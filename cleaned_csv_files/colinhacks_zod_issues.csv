issue_id,issue_number,issue_title,issue_body,comment_id,comment_body
2671814233,3860,RFC/Feature Request: Add a type-safe convert/input output mapper method for compile time input validation,"**RFC/Feature Request**: Add a type-safe `convert`/`input output mapper` method for compile time input validation

**Summary**

Introduce a new method, ie. `convert`, for Zod schemas that provides type-safe input validation and transformation. This method would enforce that the provided input matches the schema’s defined input type (`T[""_input""]`) at compile time, ensuring a stricter contract compared to `parse`.

**Motivation**

Zod’s `parse` and `safeParse` methods currently accept `unknown` as input. While this is intentional for unstructured or untrusted data validation, there are common use cases where input data is already structured (e.g., from a typed API response, database query, or other controlled sources). For such cases, allowing type-safe input validation without relying on runtime type checking enhances both safety and developer experience.

The proposed method aligns with Zod’s TypeScript-first philosophy by:

1. Enforcing input types at compile time, reducing reliance on runtime checks.
2. Providing a clear distinction between structured and unstructured input handling.
3. Supporting scenarios where transformations (via `.transform()`) are applied, while maintaining type safety.

**Proposed API**

Add a method `convert` to Zod schemas with the following behavior:

```typescript
schema.convert(input: T[""_input""]): T[""_output""];
```

- **Input Type (`T[""_input""]`)**: Enforces that the input matches the schema's input type at compile time.
- **Output Type (`T[""_output""]`)**: Returns the validated and transformed data, adhering to the schema's transformation logic.

  **Example Usage**

https://github.com/colinhacks/zod/blob/dad88200ec45b673d33eae442dff40d805d8add9/src/__tests__/convert.test-d.ts#L21-L59

**Comparison with Existing Methods**

1. **`parse`**:

   - Accepts `unknown` input and validates it.
   - Use case: General-purpose validation of unstructured data.

2. **`convert`** (Proposed):
   - Enforces that the input matches the schema’s input type at compile time.
   - Use case:
     - Validating already-structured data with guaranteed input types, while benefiting from transformations and Zod’s validation.
     - Using zod as typesafe converter ie. between well defined input and output types.

**Potential Concerns**

- **Confusion with Existing Methods**:
  - I am uncertain about how to name the method in order to clearly differentiate itself from `parse`, `safeParse`, `transform`,... to avoid ambiguity. Suggested name: `convert`, `inputToOutput`, `parseConvert`?

**Example implementation**

https://github.com/colinhacks/zod/pull/3861

https://github.com/colinhacks/zod/blob/dad88200ec45b673d33eae442dff40d805d8add9/src/types.ts#L521-L541",,
2669276740,3858,Export enumUtil types,"Similar to `z.objectUtil` and `z.util`, It'd be great if we had access to the types defined by the `enumUtil` namespace.

Is it possible to export these types? Thanks a ton.",,
2668454170,3856,Error Handling: differentiating .errors and .issues on ZodError,"Whenever working with zod errors/issues I find out that `issues` and `errors` have exactly the same content, like below:

<img width=""581"" alt=""image"" src=""https://github.com/user-attachments/assets/45baf9ea-1fcb-4316-b1bc-35f755f04cc4"">

sample code below:

```ts
try {
Schema.parse(something);
} catch (e) {
  if (e instanceof z.ZodError) {
    for (const zodIssue of e.issues) { // A
    for (const zodIssue of e.errors) { // B
      console.error(zodIssue.code);
      console.error(zodIssue.message);
      console.error(zodIssue.path);
    }
  }
}
```

and inside internal TS zod types, both properties relate to the same `ZodIssue` type:

```ts
export declare class ZodError<T = any> extends Error {
    issues: ZodIssue[];
    get errors(): ZodIssue[];
```

My question is: what's the difference between them? Why are they separate? I see docs relate to issues (and methods such as `addIssue`/`addIssues` exist). **What's the point of `errors` anyway?**

I've read [error handling](https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md) but it doesn't answer this question.

",,
2667797030,3855,Unexpected 'optional' in input type when using generic function,"I've been trying to write a generic function to generate schemas for a corresponding generic interface but keep getting errors related to some fields supposedly being optional when validating the types. I have no optionals anywhere.

## Steps to reproduce
Execute the following code:
```ts
import z from 'zod';

export interface PathParameter<T> {
  pathParameter: T;
}

export const PathParameterSchema = <T extends z.ZodTypeAny>(pathParamSchema: T) => {
  return z.object({
    pathParameter: pathParamSchema,
  }) satisfies z.ZodSchema<PathParameter<z.input<T>>, z.ZodTypeDef, PathParameter<z.output<T>>>;
};
```
### Output (Error)
```error
test.ts:10:6 - error TS1360: Type 'ZodObject<{ pathParameter: T; }, ""strip"", ZodTypeAny, { [k in keyof addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>]: addQuestionMarks<...>[k]; }, { [k_1 in keyof baseObjectInputType<...>]: baseObjectInputType<...>[k_1]; }>' does not satisfy the expected type 'ZodType<PathParameter<input<T>>, ZodTypeDef, PathParameter<output<T>>>'.
  Types of property '_type' are incompatible.
    Type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>]: addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>[k]; }' is not assignable to type 'PathParameter<input<T>>'.
      Property 'pathParameter' is optional in type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>]: addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>[k]; }' but required in type 'PathParameter<input<T>>'.

10   }) satisfies z.ZodSchema<PathParameter<z.input<T>>, z.ZodTypeDef, PathParameter<z.output<T>>>;
        ~~~~~~~~~
```
### Expected output
I expect there not to be an error, just like with the code below doesn't throw an error
```ts
const testInterfaceSchema = z.object({ str: z.string() });

const testSchema = z.object({ pathParameter: testInterfaceSchema }) satisfies z.ZodSchema<
  PathParameter<z.input<typeof testInterfaceSchema>>,
  z.ZodTypeDef,
  PathParameter<z.output<typeof testInterfaceSchema>>
>;
```",2482449908,"I found my own answer in #153, basically, this is impossible due to the typescript type interference. A solution like
```ts
export const PathParameterSchema = <T extends z.ZodTypeAny>(pathParamSchema: T): z.ZodObject<{ pathParameters: T }> => {
  return z
    .object({
      pathParameters: pathParamSchema,
    });
};
```
is recommended, but this doesn't guarantee that the types are in sync anymore."
2667247063,3854,Zod Custom Type Assertion with .pipe() Does Not Propagate Type Inference Correctly,"I'm experiencing an issue where Zod doesn't automatically propagate the custom type (CustomDate) when using .pipe() with a custom schema. Specifically, when trying to apply a .pipe(zod.custom<CustomDate>()) after defining a schema with .refine(), Zod continues to treat the output as a general string type instead of the expected CustomDate type. This causes type errors when passing the schema to the constructor.

**Steps to Reproduce:**
1. Define a custom schema using .refine() to validate a time string.
2. Use .pipe(zod.custom<CustomDate>()) to assert the type as CustomDate.
3. Try passing the schema to a constructor or other Zod-related validation flow.
4. Observe that Zod infers the type as a string instead of CustomDate, resulting in a type error.

**Code Example:**
```javascript
const zodCustomDateSchema = zod.string().refine((value) => moment(value, customFormat, true).isValid(), {
  message: ""Invalid time format. Must be in format: "" + customFormat + ""."",
  path: [""invalidCustomFormat""],
}).pipe(zod.custom<CustomDate>());
```

**Error:**
```
Type 'ZodObject<{ category: ZodEnum<[""PRODUCT_A"", ""PRODUCT_B"", ""PRODUCT_C""]>; productId: ZodString; userId: ZodString; purchaseDate: ZodPipeline<...>; shippingDate: ZodPipeline<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<{ category: ""PRODUCT_A"" | ""PRODUCT_B"" | ""PRODUCT_C""; productId: string; userId: string; purchaseDate: CustomDate; shippingDate: CustomDate; }, ZodTypeDef, { ...; }>'.
  The types of '_input.purchaseDate' are incompatible between these types.
    Type 'string' is not assignable to type 'CustomDate'.
```

Expected Behavior:
The type should be correctly inferred as CustomDateafter applying .pipe(zod.custom<CustomDate>()), and no type errors should occur when using the schema in other validation or constructor contexts.

Actual Behavior:
Zod does not propagate the custom type assertion correctly, and the type remains string, leading to type errors in downstream code (e.g., passing the schema to the constructor).

It would be great if Zod could propagate custom types properly, ensuring that inferred types are consistent throughout validation and type assertions.
",,
2663739970,3852,Can't verify that a number is in a list,"Using enum (or any other validator provided by zod), it is not possible to verify that a number belongs in a list.

With an enum, I can verify whether the string ""1"" belongs to, say:

[""2"", ""7"", ""1""]

However, if the data to be parsed is 1, instead of ""1"", zod does not provide the necessary resources to verify whether the number 1, when converted to string, belongs or not to that list of strings.

This is a very basic requirement, but the documentation does not mention how to accomplish this. Ideally, it should be possible to coerce the fields to a string and then compare to the enum.

The only way I could do this was using a ""refine"" after coerce.string(). Then the ""enum"" logic is completely custom (comparison to an array in a regular javascript function). Is this how it was designed?",,
2655668017,3849,z.discriminatedUnion requires literal array,"not sure why by discriminateUnion cannot use an array defined elsewhere.  Is this by design or fixable?
thanks

```typescript
const state1 = z.object({
    state: z.literal(""on""),
    text: z.string()
})
const state2 = z.object({
    state: z.literal(""off""),
    number: z.number()
})
const states = [state1,state2]

const dUnion1 = z.discriminatedUnion('state', states) // errors ; see image
const dUnion2 = z.discriminatedUnion('state', [state1,state2]) //works
```

![image](https://github.com/user-attachments/assets/6c031cc0-27c3-4ced-bfd8-cfe4379bdbdd)
",2478604552,"Hi @JaeTLDR, that’s a good question! This behavior actually makes sense because `z.discriminatedUnion` expects a tuple rather than a general array. When you define `const states = [state1, state2]`, TypeScript infers it as an array, which is incompatible with the tuple type requirement.

To fix this, you can adjust states to be explicitly typed as a tuple:

```typescript
const states: [typeof state1, typeof state2] = [state1, state2];
```
This way, TypeScript treats states as a tuple, making it compatible with `z.discriminatedUnion`. Hope this helps!"
2655668017,3849,z.discriminatedUnion requires literal array,"not sure why by discriminateUnion cannot use an array defined elsewhere.  Is this by design or fixable?
thanks

```typescript
const state1 = z.object({
    state: z.literal(""on""),
    text: z.string()
})
const state2 = z.object({
    state: z.literal(""off""),
    number: z.number()
})
const states = [state1,state2]

const dUnion1 = z.discriminatedUnion('state', states) // errors ; see image
const dUnion2 = z.discriminatedUnion('state', [state1,state2]) //works
```

![image](https://github.com/user-attachments/assets/6c031cc0-27c3-4ced-bfd8-cfe4379bdbdd)
",2481917752,"It's easier to type it as `const states = [state1,state2] as const` - `as const` will automatically infer the tightest type."
2655668017,3849,z.discriminatedUnion requires literal array,"not sure why by discriminateUnion cannot use an array defined elsewhere.  Is this by design or fixable?
thanks

```typescript
const state1 = z.object({
    state: z.literal(""on""),
    text: z.string()
})
const state2 = z.object({
    state: z.literal(""off""),
    number: z.number()
})
const states = [state1,state2]

const dUnion1 = z.discriminatedUnion('state', states) // errors ; see image
const dUnion2 = z.discriminatedUnion('state', [state1,state2]) //works
```

![image](https://github.com/user-attachments/assets/6c031cc0-27c3-4ced-bfd8-cfe4379bdbdd)
",2488618917,"Thanks @AlexChadwickP  that makes a lot more sense, would there be an advantage to Zod using a tuple rather than an array ? I wanted a way to 'register' various schemas (this would include other functionality as well) and use a discriminated union array as part of that, however adding a dynamic tuple has been its own rabbit hole that doesnt feel pheasable.

thanks @mitchell-merry  i did see that in my experiments and research after Alex's answer, it does seem cleaner and for now i am using it to keep my schemas together in a more relevant file than where the union lives"
2652974048,3847,Error trying to reuse inferred type,"I'm trying to use a type inferred from a zod schema, but when I need to reuse the inferred type in other generic function I just couldn't find a way of doing it.

Considering the following code:

```typescript
import { z } from 'zod';

const Schema = z.object({
  id: z.number(),
  name: z.string(),
  nickname: z.string().optional().default('')
});

export type SchemaDto = z.infer<typeof Schema>;

const parsedSchema: z.Schema<SchemaDto> = Schema;
```

I got the following error:

```
Type 'ZodObject<{ id: ZodNumber; name: ZodString; nickname: ZodDefault<ZodOptional<ZodString>>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<{ name: string; id: number; nickname: string; }, ZodTypeDef, { name: string; id: number; nickname: string; }>'.
  The types of '_input.nickname' are incompatible between these types.
    Type 'string | undefined' is not assignable to type 'string'.
      Type 'undefined' is not assignable to type 'string'.ts(2322)
```

I can understand that the inferred type assumed that, once I have the default `''` the field wouldn't be undefined in the generated type:

```typescript
type SchemaDto = {
    name: string;
    id: number;
    nickname: string;
}
```

But, if I need to use the generated type to force the usage of a Schema that is compatible with a type, I cannot use the inferred type to accomplish my goal.

In the documentation there's no information on how to infer a type without considering the `default`  to be able to reuse the inferred type in other generic functions. Is this a relevant functionality to the package?


",2478630568,"Hi @mauroviniciussilva that's correct, I looked into the documentation and found `.input`.

To work around this and get the input type (before defaults are applied), you can use `z.input<typeof Schema>` instead of `z.infer`. This will preserve the optionality of nickname, so it’s typed as `string | undefined`, matching what you need for your generic function.

This is what your code would look like:

```typescript
import { z } from 'zod';

const Schema = z.object({
  id: z.number(),
  name: z.string(),
  nickname: z.string().optional().default('')
});

type SchemaInput = z.input<typeof Schema>;  //  nickname will be string | undefined

const parsedSchema: z.ZodType<SchemaInput> = Schema;
```"
2634288956,3836,feat: copy (clone) any schema,"I'm using zod with zod-to-openapi.

If I define the constant:

```typescript
export const userDataZodSchemas = {
  account: z.string().describe('account').optional(),
  avatar: z.string().describe('avatar url or path'),
  birthday: commonZodValidatorSchemas.iso8601DateString.describe('birthday (ISO 8601 format)').optional(),
  nickname: z.string().describe('nickname')
  // More...
};
```

Now I'm going to use this entire constant in a number of places, such as in the user information API document.

But I also use it when updating user data, if I only want to use the nickname field and it's optional when updating user data.

But when I use `userDataZodSchemas.nickname.optional()`, it makes that field in the API on the user info side non-required as well, I should say it makes userDataZodSchemas.nickname directly optional!

Is there a way to copy the entire schema?",2456149192,"It looks like I'm misreading the code, but there's no such problem."
2634085714,3834,[suggestion] regex validation errors should include the pattern,"If I have a schema with a .regex(), and attempt to parse an invalid value:

```ts
const SomeSchema = z.string().regex(/^[a-z]+$/);
SomeSchema.parse('abc3');
```

The error I get looks like this:
```
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

It would be very nice if this error included a way to get the pattern which failed, like so:
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""pattern"": /^[a-z]+$/,
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

or something like that - maybe errors can start including the zod schema it relates to, so that I can infer these things myself.
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": [],
    ""schema"": ...
  }
]
```

I can currently get around this like so:
```ts
const regexRefine = (regex: RegExp) =>
  [
    (data: string) => regex.test(data),
    `String does not match regex ${regex}`,
  ] as const;
const SomeSchema = z.string().refine(...regexRefine(/^[a-z]+$/));
```",2460952489,"Actually, this is way better:
```ts
const regexWithPatternInError = (regex: RegExp): [RegExp, string] =>
  [regex, `String does not match pattern ""${regex}""`] as const;
```

```ts
const SomeSchema = z.string().regex(...regexWithPatternInError(/^[a-z]+$/));
```

but the issue still stands"
2634085714,3834,[suggestion] regex validation errors should include the pattern,"If I have a schema with a .regex(), and attempt to parse an invalid value:

```ts
const SomeSchema = z.string().regex(/^[a-z]+$/);
SomeSchema.parse('abc3');
```

The error I get looks like this:
```
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

It would be very nice if this error included a way to get the pattern which failed, like so:
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""pattern"": /^[a-z]+$/,
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

or something like that - maybe errors can start including the zod schema it relates to, so that I can infer these things myself.
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": [],
    ""schema"": ...
  }
]
```

I can currently get around this like so:
```ts
const regexRefine = (regex: RegExp) =>
  [
    (data: string) => regex.test(data),
    `String does not match regex ${regex}`,
  ] as const;
const SomeSchema = z.string().refine(...regexRefine(/^[a-z]+$/));
```",2484259002,"There's another way to get the regex which might be useful for some cases:

```typescript
declare const stringSchema: z.ZodString;

const regex = stringSchema._def.checks.find(c => c.kind === ""regex"")?.regex;
```"
2634085714,3834,[suggestion] regex validation errors should include the pattern,"If I have a schema with a .regex(), and attempt to parse an invalid value:

```ts
const SomeSchema = z.string().regex(/^[a-z]+$/);
SomeSchema.parse('abc3');
```

The error I get looks like this:
```
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

It would be very nice if this error included a way to get the pattern which failed, like so:
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""pattern"": /^[a-z]+$/,
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

or something like that - maybe errors can start including the zod schema it relates to, so that I can infer these things myself.
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": [],
    ""schema"": ...
  }
]
```

I can currently get around this like so:
```ts
const regexRefine = (regex: RegExp) =>
  [
    (data: string) => regex.test(data),
    `String does not match regex ${regex}`,
  ] as const;
const SomeSchema = z.string().refine(...regexRefine(/^[a-z]+$/));
```",2484475878,"Right, but unfortunately the ZodError doesn't include the schema that failed, so I'm unable to even inspect the schema"
2632744965,3833,".describe() is not wrapping, but creates a ""new"" _def","Hey there 👋 

I've regularly hoped for some kind of ""metadata"" in zod, but read a lot of discussion about  why it's not needed.

In my case, I just need to be able to identify some of my own schemas.
I do this by comparing `someSchema._def` with `mySchema._def`, unwrapping optional et al.

Now I noticed that it does not work with descriptions. Digging into the zod code, I found this:
https://github.com/colinhacks/zod/blob/086273160e5952ee661a7b9db82fc757f0e68eab/src/types.ts#L499-L505

My feeling is that this means that the ._def will not point to my schema anymore.
What do you think about adding something like `unwrap` or `innerType` to describe, too?
Or am I doing something wrong?",2465574094,"Hi, this pattern is very common in zod, the general def type name will be available, might not be what you need but that could be a pointer in the right direction."
2632744905,3832,".describe() is not wrapping, but creates a ""new"" _def","Hey there 👋 

I've regularly hoped for some kind of ""metadata"" in zod, but read a lot of discussion about  why it's not needed.

In my case, I just need to be able to identify some of my own schemas.
I do this by comparing `someSchema._def` with `mySchema._def`, unwrapping optional et al.

Now I noticed that it does not work with descriptions. Digging into the zod code, I found this:
https://github.com/colinhacks/zod/blob/086273160e5952ee661a7b9db82fc757f0e68eab/src/types.ts#L499-L505

My feeling is that this means that the ._def will not point to my schema anymore.
What do you think about adding something like `unwrap` or `innerType` to describe, too?
Or am I doing something wrong?",,
2626417424,3826,generic Omit function breaks type inferance ,"When using a function to omit shared keys among many schemas z.infer nolonger exports the underlying types correctly 

```typescript 
import { z } from ""zod"";

const metaKeys = {
    _rid: z.string(),
    _self: z.string(),
    _etag: z.string(),
    _attachments: z.string(),
    _ts: z.string(),
};

function omitMetaKeys(schema: z.AnyZodObject): z.AnyZodObject {
    return schema.merge(z.object({...metaKeys})).omit(Object.keys(metaKeys).reduce((prev, curr) => { return { [curr]: true, ...prev } }, {}));
}

export const mySchema = z.object({
    id: z.string(),
});
export interface myType extends z.infer<typeof mySchema> {}
// works correctly complaining about the missing id property
const eg:myType ={}

export const myOmitSchema = omitMetaKeys(z.object({
    id: z.string(),
}));
export interface myOmitType extends z.infer<typeof myOmitSchema> {}
//does not complain, whihc is incorrect behaviour
const egOmit:myOmitType ={} 
```
<img width=""701"" alt=""image"" src=""https://github.com/user-attachments/assets/ce816280-0263-42e5-8893-e48a9caa590c"">



if  we use the same schema and remove the call to omitMetaKeys, we gain typing within vscode

<img width=""720"" alt=""image"" src=""https://github.com/user-attachments/assets/8b8e3e3d-f13b-4598-88b6-6f23c00f31d7"">
",2453454729,"Hi,
My first thought is that it 'breaks' because you are returning z.AnyZodObject, and not a generic T extends AnyZodObject.

if you would change it into:

```ts

function omitMetaKeys<T extends z.AnyZodObject>(schema: T): Omit<z.infer<T>, 'key_a' | 'key_b'> {
    return schema.merge(z.object({...metaKeys})).omit(Object.keys(metaKeys).reduce((prev, curr) => { return { [curr]: true, ...prev } }, {}));
}

```

Then I believe it should work.

Try to extract the keys from your metadata, then you can use that in the Omit TS generic type.
"
2626417424,3826,generic Omit function breaks type inferance ,"When using a function to omit shared keys among many schemas z.infer nolonger exports the underlying types correctly 

```typescript 
import { z } from ""zod"";

const metaKeys = {
    _rid: z.string(),
    _self: z.string(),
    _etag: z.string(),
    _attachments: z.string(),
    _ts: z.string(),
};

function omitMetaKeys(schema: z.AnyZodObject): z.AnyZodObject {
    return schema.merge(z.object({...metaKeys})).omit(Object.keys(metaKeys).reduce((prev, curr) => { return { [curr]: true, ...prev } }, {}));
}

export const mySchema = z.object({
    id: z.string(),
});
export interface myType extends z.infer<typeof mySchema> {}
// works correctly complaining about the missing id property
const eg:myType ={}

export const myOmitSchema = omitMetaKeys(z.object({
    id: z.string(),
}));
export interface myOmitType extends z.infer<typeof myOmitSchema> {}
//does not complain, whihc is incorrect behaviour
const egOmit:myOmitType ={} 
```
<img width=""701"" alt=""image"" src=""https://github.com/user-attachments/assets/ce816280-0263-42e5-8893-e48a9caa590c"">



if  we use the same schema and remove the call to omitMetaKeys, we gain typing within vscode

<img width=""720"" alt=""image"" src=""https://github.com/user-attachments/assets/8b8e3e3d-f13b-4598-88b6-6f23c00f31d7"">
",2458782713,"Thanks this seems to be much closer, your code didn't seem to work for me, but the below did, however i am not sure how 'good' it is in comparison in terms of typescript correctness.
```typescript
function omitMetaKeys<T extends z.AnyZodObject>(schema: T): T {
    return schema.merge(z.object({...metaKeys})).omit(Object.keys(metaKeys).reduce((prev, curr) => { return { [curr]: true, ...prev } }, {})) as T;
}
```

further suggestions are very welcome,

Thanks again 
"
2626197019,3825,Type inference issue with extending/narrowing enum types in generic schemas,"I'm encountering a TypeScript error when trying to extend/narrow an enum type in a generic schema context. While TypeScript normally allows narrowing of enum types, this doesn't seem to work properly with Zod's type system.

```ts
import { z } from 'zod';

// Base schema with broader enum
const baseSchema = z.object({
gender: z.enum([""Rüde"", ""Hündin"", ""männlich"", ""weiblich""]).nullable(),
// ... other fields
});
// Trying to create a more specific schema with narrower enum
const dogSchema = z.object({
gender: z.enum([""Rüde"", ""Hündin""]).nullable(),
// ... other fields
});
// Generic interface that should accept both schemas
interface MyInterface<T extends typeof baseSchema> {
schema: T;
// ... other properties
}
// This fails with type error even though dogSchema's enum is a subset of baseSchema's enum
const implementation: MyInterface<typeof dogSchema> = {
schema: dogSchema
};
```


the type error probobly happens since zod is saying that 

` Type 'ZodEnum<[""Rüde"", ""Hündin""]>' is not assignable to type 'ZodEnum<[""Rüde"", ""Hündin"", ""männlich"", ""weiblich""]>`


### Expected Behavior
Since the enum in `dogSchema` is a subset of the enum in `baseSchema`, and TypeScript normally allows this kind of type narrowing, the implementation should type-check successfully.

### Actual Behavior
TypeScript produces an error indicating that the narrower enum type is not assignable to the broader enum type when used in this generic context with Zod schemas.

### Possible Solutions
One potential solution might be to add a utility type or method to Zod that explicitly handles enum narrowing in generic contexts, similar to how TypeScript handles normal enum type narrowing.

",2453455720,"Hi, zod does not actually know that the values are the same, does it?

Have you tried with .extend or .merge?"
2619668368,3821,Bigint with coerce throws exception in safeParse and safeParseAsync,"Hi,

I noticed a bug while using safeParse and safeParseAsync. Those methods IMO shouldn't throw any errors. Instead, they should hold error in returned object. However, currently this does not work in case of coerced big integers.

Here's an example snippet:
```
const { z } = require(""zod"");
const schema = z.object({
  data: z.coerce.bigint(),
});
const example = { data: undefined };
try {
  const result = schema.safeParse(example);
  console.log(""RESULT ok?: "", result.success);
} catch (err) {
  console.error(""Catched: "", err);
}
```

Excepted output
`RESULT ok?: false`

**Actual output**

```
Catched:  TypeError: Cannot convert undefined to a BigInt
    at BigInt (<anonymous>)
    at ZodBigInt._parse (/home/aleksander/projects/zod-bigint-error/node_modules/zod/lib/types.js:1205:26)
    at ZodObject._parse (/home/aleksander/projects/zod-bigint-error/node_modules/zod/lib/types.js:1864:37)
    at ZodObject._parseSync (/home/aleksander/projects/zod-bigint-error/node_modules/zod/lib/types.js:146:29)
    at ZodObject.safeParse (/home/aleksander/projects/zod-bigint-error/node_modules/zod/lib/types.js:176:29)
    at Object.<anonymous> (/home/aleksander/projects/zod-bigint-error/index.js:10:25)
    at Module._compile (node:internal/modules/cjs/loader:1469:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1548:10)
    at Module.load (node:internal/modules/cjs/loader:1288:32)
    at Module._load (node:internal/modules/cjs/loader:1104:12)
```
 ",,
2612647831,3816,Strip conditions from a schema,"I would like to be able to achieve this

```
const myZodSchema = z.object({
  property: z.integer().min(5).max(10)
  property2: z.integer().min(5).max(10)
})

const myZodSchemaOnlyCheckType = z.stripKeywords(myZodSchema, ['min', 'max'])

// Should return 
z.object({
  property: z.integer()
   property2: z.integer()
})
```

Is there any way to do that?

### Some context
I am building an app which uses Drizzle, Zod and Open AI.

On my app, I defined a Drizzle schema and generate a zod schema from it.
```
import { createInsertSchema } from 'drizzle-zod';

export const profiles = pgTable(
  'profiles',
  {
    headline: varchar('headline', { length: 255 }).notNull(),
  },
);

export const insertProfileSchema = createInsertSchema(profiles);
```


then send the schema over to Open AI to get [Structured output](https://platform.openai.com/docs/guides/structured-outputs/supported-schemas?context=ex1). 

The generated Zod schema would include the `length` check. However, [OpenAI doesn't support some keyword at the moment](https://platform.openai.com/docs/guides/structured-outputs/some-type-specific-keywords-are-not-yet-supported), including maxLength. So that's why I am trying to work around this.

I've tried with `createSelectSchema` from `drizzle-zod` without luck.

Any other more elegant solutions are welcomed. :)",,
2602135013,3813,The inferred type of <SchemaName> references an inaccessible this type. A type annotation is necessary.,"I'm using Zod with NestJS and facing an issue when trying to declare properties as .nullish() or .nullable().

An example
```ts
import { z } from 'zod';

export const partnerSchema = z.object({
  projectName: z.string(),
  startDate: z.coerce.date(),
  projectDuration: z.number().nullish(),
});
```
This yields a TS2527 error.

![image](https://github.com/user-attachments/assets/5ee647e8-501b-46eb-853b-ce29622ffb4c)
",2428394387,"I used this code snippet, but it didn’t raise any exceptions. This might be related to the TypeScript configuration or other factors. Could you provide a minimal reproduction?"
2600957698,3812,ZodUnion options type bound causes unwanted errors,"This shouldn't happen:

```ts
z.union(
  ([1, 2, 3, 5, 8, 11] as const).map((value) => z.literal(value)),
  // ERROR: Argument of type 'ZodLiteral<number>[]' is not assignable to parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
  //   Source provides no match for required element at position 0 in target.ts(2345)
)
```

I get that `[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]` is supposed to catch cases where someone accidentally makes a zero or one-option union, since that might be a mistake, though it's not technically invalid and zero/one-element unions have well-defined behavior.  But it's annoying to break a valid use case for the sake of this.

What's especially bad about this is *I can't just suppress the error*, because Zod doesn't even infer the correct input/output types here.  I'm forced to write out an explicit array literal to get Zod to infer the correct type:

```ts
z.union([
  z.literal(1),
  z.literal(2),
  // Could spread a .map after this point, but it's still an unnecessary waste of bytes
  z.literal(3),
  z.literal(5),
  z.literal(8),
  z.literal(11),
])
```

Which situation should take precedence?
1. Errors on potential mistakes that doesn't cause undefined behavior
2. No errors on clearly valid use cases

I would argue No. 2 should win here.  The type is overwrought.

Accepting just `ZodTypeAny[]` would work fine; the type of `[][number]` is `never`, the same as `z.union([])` accepts at runtime, hence any code that parses a value or operates on parse output will get a compile error if it expects a type other than `never`.  This will allow users who accidentally made a zero-option union to catch their mistake.  Some users may be generating the union options dynamically and have cases where it's intentional to end up with no options.  In those cases the type parameter inferred from their code will probably be an array type instead of a tuple type, which seems fine to me for a case where you're generating options dynamically.",,
2594916725,3806,Allow nativeEnum() after coerce,"Currently a string like ""1"" cant be casted to a number enum:

```ts
enum Animals {
   Dog, // 0
   Cat, // 1
}

const param = '1'; // From query params, always comes as a string

// This throws error, which is correct because param is a string:
const animal = z.nativeEnum(Animals).parse(param);

// This should work, but is not supported by zod, error: ""Property nativeEnum does not exist on type ZodNumber""
const animal = z.coerce.number().nativeEnum(Animals).parse(param);

// This would be cool, too, error: ""Property nativeEnum does not exist on type""
const animal = z.coerce.nativeEnum(Animals).parse(param);
```

### Motivation
Query params always come as a string, e.g.

```ts
GET /animals/2
```

Will be `""2""` instead of `2` and therefor cant be casted to an enum with zod


### Workaround
```ts
const animal = z.coerce.number().pipe(z.nativeEnum(Animal)).parse(param);
```",,
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419209053,`bananaSchema` and `orangeSchema` has the same `type`.
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419226109,"> `bananaSchema` and `orangeSchema` has the same `type`.

Yes, that's intended, as both are of type `fruit`. It's their subtypes ('banana' and 'orange') that differ. So I basically want something like:
```
               type: fruit/vegetable DU
                         |
     orange/banana DU        vegetable schema
          |
  subType: banana/orange
                 |
  orange schema     banana schema
   ```
    "
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419274928,"If you combine all of them, you can't use type alone to distinguish between them. What you need is something like this:

```ts
z.discriminatedUnion(z.union(['type', 'subType']), [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```
However, currently, it only supports a single string as the discriminator."
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419388990,"Yeah, I'm guessing nested discriminated unions with different discriminators aren't currently supported? "
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419400840,Yes.
2589320941,3799,Branded record keys break generics when used in an object with other branded types,"## Versions ##
Zod: 3.23.8
Typescript: 5.6.3

## Observations ##
```ts
import { z } from 'zod';

function testFn<T>(zodType: z.ZodType<T>) {
  return zodType;
}

const branded_1 = z.string().brand('type1');
const branded_2 = z.string().brand('type2');
const bad_record = z.record(branded_1, z.string());

const good_1 = z.object({
  branded_1,
});
testFn(good_1); // No type errors, a branded_1 in an object is fine

const good_2 = z.object({
  branded_2,
});
testFn(good_2); // No type errors, branded_2 in an object is fine

const good_3 = z.object({
  branded_1,
  branded_2,
  record_1: z.record(branded_1, z.any()),
  record_2: z.record(branded_1, z.unknown()),
  record_3: z.record(branded_1, z.undefined()),
});
testFn(good_3); // No type errors, we can have branded records where the value is potentially undefined

const good_4 = z.object({
  bad_record,
});
testFn(good_4); // No type errors, bad_record is not bad by itself

const good_5 = z.object({
  x: z.number(),
  bad_record,
});
testFn(good_5); // No type errors, bad_record is not bad with some other non-branded types

const bad_1 = z.object({
  branded_1,
  bad_record,
});
testFn(bad_1); // Type error!, bad_record cannot be put with another branded type here

const bad_2 = z.object({
  branded_2,
  bad_record,
});
testFn(bad_2); // Type error! it doesn't matter if it's mixed with the branded type it uses, any other branded type will cause the issue

const bad_3 = z.object({
  a: z.object({
    branded_2,
  }),
  b: z.object({
    bad_record,
  }),
});
testFn(bad_3); // Type error! Issue still occurs when separately nested
```

Errors are:
```log
mre.ts(45,8): error TS2345: Argument of type 'ZodObject<{ branded_1: ZodBranded<ZodString, ""type1"">; bad_record: ZodRecord<ZodBranded<ZodString, ""type1"">, ZodString>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodType<{ branded_1: string & BRAND<""type1"">; bad_record: Partial<Record<string & BRAND<""type1"">, string>>; }, ZodTypeDef, { branded_1: string & BRAND<...>; bad_record: Partial<...>; }>'.
  The types of '_input.branded_1' are incompatible between these types.
    Type 'string' is not assignable to type 'string & BRAND<""type1"">'.
      Type 'string' is not assignable to type 'BRAND<""type1"">'.
mre.ts(51,8): error TS2345: Argument of type 'ZodObject<{ branded_2: ZodBranded<ZodString, ""type2"">; bad_record: ZodRecord<ZodBranded<ZodString, ""type1"">, ZodString>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodType<{ branded_2: string & BRAND<""type2"">; bad_record: Partial<Record<string & BRAND<""type1"">, string>>; }, ZodTypeDef, { branded_2: string & BRAND<...>; bad_record: Partial<...>; }>'.
  The types of '_input.branded_2' are incompatible between these types.
    Type 'string' is not assignable to type 'string & BRAND<""type2"">'.
      Type 'string' is not assignable to type 'BRAND<""type2"">'.
mre.ts(61,8): error TS2345: Argument of type 'ZodObject<{ a: ZodObject<{ branded_2: ZodBranded<ZodString, ""type2"">; }, ""strip"", ZodTypeAny, { branded_2: string & BRAND<""type2"">; }, { branded_2: string; }>; b: ZodObject<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodType<{ a: { branded_2: string & BRAND<""type2"">; }; b: { bad_record: Partial<Record<string & BRAND<""type1"">, string>>; }; }, ZodTypeDef, { ...; }>'.
  The types of '_input.a.branded_2' are incompatible between these types.
    Type 'string' is not assignable to type 'string & BRAND<""type2"">'.
```

## Expected ##

`testFn` should take any instance of `ZodType`, which `ZodObject` extends, without error.",,
2589138304,3798,Email Regex not respecting RFC,"In our project we validate email addresses using `z.string().email()`, a user reported that he couldn't signup since his email was containing an `&` (`user&user@company.com`).

According to the email RFC (section [3.4.1][local-part-rfc] and [3.2.4][atom-rfc]) it should allow the following special characters:

```
atext           =       ALPHA / DIGIT / ; Any character except controls,
                        ""!"" / ""#"" /     ;  SP, and specials.
                        ""$"" / ""%"" /     ;  Used for atoms
                        ""&"" / ""'"" /
                        ""*"" / ""+"" /
                        ""-"" / ""/"" /
                        ""="" / ""?"" /
                        ""^"" / ""_"" /
                        ""`"" / ""{"" /
                        ""|"" / ""}"" /
                        ""~""
```

but in the current regex the `&` is not included: 
https://github.com/colinhacks/zod/blob/3032e240a0c227692bb96eedf240ed493c53f54c/src/types.ts#L600

[atom-rfc]: https://datatracker.ietf.org/doc/html/rfc2822#section-3.2.4
[local-part-rfc]: https://datatracker.ietf.org/doc/html/rfc2822#section-3.4.1",,
2583490246,3795,ZodType is not contravariant to the input,"## Background

[Contravariance](https://www.typescriptlang.org/docs/handbook/2/generics.html#variance-annotations) is a property associated of generic types on their type parameters where the generic type `G<A>` extends `G<B>` if `B` extends `A`. It is usually associated with type parameters used as inputs.

Each `ZodType` is composed of an input and an output type. Consider, for instance, the following Zod schema:

```ts
const s = z.object({
    a: z.string().default(""foo"")
});
```

Its input type has `a` as an optional field, but it is required on the output type:

```ts
type A = z.input<typeof s>; // { a?: string | undefined; }
type B = z.output<typeof s>; // {a: string}
```

## Description

Given that the input and output types are type parameters to `ZodType`, one might expect `ZodType` to be covariant on the output type and contravariant on the input type. While the former is true, the latter, unfortunately, is not.

## Example
```ts
function f<S extends z.ZodType<string, any, any>>(_: S) {}
f(z.literal(""a"")); // Works fine

function g<S extends z.ZodType<any, any, ""a"">>(_: S) {}
g(z.string()); // Errors out :(
```

## Expected behaviour

`ZodType` should be contravariant with respect to the input type

## Actual behaviour

`ZodType` is not contravariant with respect to the input type",,
2581581665,3794,Unable to chain min & max method on string,"I have created a custom zod Instance to check any string if it contains ""undefined"" or ""null"" as string.

```ts
import { z } from 'zod'

export const cZ = {
    ...z,
    string: () =>
        z
            .string()
            .refine((val) => val !== 'undefined' && val !== 'null', {
                message: 'string cannot be ""undefined"" or ""null""',
            })
}
```

Now when i tried to use this custom zod instance i am unable to chain min and max methods on strings.

```ts
import { cZ } from '..utils/custom-zod.js'

const user = cZ.object({
    name : cZ.string().min(2).max(20)
})

```
",,
2580779281,3793,"Does not infer the types correctly, forcing me to cast the typing","When using safeParse with SelectOption and SelectOptionDto, TypeScript does not infer the types correctly, forcing me to cast parseResult.data manually as { id: T; label: string }.

```TypeScript
const { id, label } = parseResult.data as { id: T; label: string };

const maybeSelectOption = SelectOption(valueSchema).safeParse({
    value: id,
    label,
});
```
However, parseResult comes from:
```TypeScript
const parseResult = SelectOptionDto(valueSchema).safeParse(selectOptionDto);
```
```TypeScript
export const SelectOption = <T extends z.ZodTypeAny = z.ZodNumber>(
    valueSchema: T = z.number() as z.infer<T>,
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
) =>
    z
        .object({
            value: valueSchema,
            label: z.string(),
        })
        .strict()
        .brand(""SelectOption"");

export type SelectOptionInputProps<T extends z.ZodTypeAny = z.ZodNumber> =
    z.input<ReturnType<typeof SelectOption<T>>>;

export type SelectOption<T extends z.ZodTypeAny = z.ZodNumber> = z.infer<
    ReturnType<typeof SelectOption<T>>
```

```TypeScript
export const SelectOptionDto = <T extends z.ZodTypeAny = z.ZodNumber>(
    valueSchema: T = z.number() as z.infer<T>,
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
) =>
    z
        .object({
            id: valueSchema,
            label: z.string(),
        })
        .strict()
        .readonly();

export type SelectOptionDto<T extends z.ZodTypeAny = z.ZodNumber> = z.infer<
    ReturnType<typeof SelectOptionDto<T>>
>;
```

Question:
Is this a known typing issue with zod or could it be a problem with how I’m using generics?
Should this work without manual casting?
Additional info:
zod version: 3.23.8
TypeScript version: 5.5.3",,
2577068952,3791,"SourceType fully unrolls nested refinements, but TypeScript types don't reflect this.","In attempting to utilize `sourceType` on a ZodEffect to get to the underlying ZodObject, I discovered that in a situation where I have two refinements chained the types are inconsistent with the behaviour.

In a situation where you have two refinements chained, such as:
``` typescript
const nestedRefinementSchema = z.object({
  number: z.number(),
}).refine(data => {
  return data.number > 5;
}).refine(data => {
  return data.number < 10;
});
```

Calling .sourceType() on the returned schema will return a ZodObject, but the types expect it to be ZodEffect.

``` typescript
nestedRefinementSchema.sourceType(); // Returns a ZodObject, but the Types still believe it is a ZodEffect wrapping a ZodObject.
```

Here's a larger example demonstrating this:
``` typescript
import * as z from ""zod"";

const baseSchema = z.object({
  number: z.number(),
});

const firstRefinement = baseSchema.refine((data) => {
  return data.number > 5;
});
/**
 * const firstRefinementSourceType: z.ZodObject<{
    number: z.ZodNumber;
}, ""strip"", z.ZodTypeAny, {
    number: number;
}, {
    number: number;
}>
 */
const firstRefinementSourceType = firstRefinement.sourceType();

const secondRefinement = firstRefinement.refine((data) => {
  return data.number < 10;
});
/**
 * const secondRefinementSourceType: z.ZodEffects<z.ZodObject<{
    number: z.ZodNumber;
}, ""strip"", z.ZodTypeAny, {
    number: number;
}, {
    number: number;
}>, {
    number: number;
}, {
    number: number;
}>
 */
const secondRefinementSourceType = secondRefinement.sourceType();


console.log(""Base"", baseSchema._def.typeName); // Base ZodObject
console.log(
  ""First"",
  firstRefinement._def.typeName,
  firstRefinementSourceType._def.typeName
); // First ZodEffects ZodObject
console.log(
  ""Second"",
  secondRefinement._def.typeName,
  secondRefinementSourceType._def.typeName
); // Second ZodEffects ZodObject
```

Zod version: 3.23.8
TypeScript version: 4.9.5",,
2575258623,3787,Request: make BRAND<T> readonly to support @typescript-eslint/prefer-readonly-parameter-types,"Currently, BRAND is defined as follows:

```ts
export type BRAND<T extends string | number | symbol> = {
  [BRAND]: { [k in T]: true };
};
```

https://github.com/LumaKernel/zod/blob/3032e240a0c227692bb96eedf240ed493c53f54c/src/types.ts#L4904-L4906

Here is the suggestion to update this to following readonly added type.

```ts
export type BRAND<T extends string | number | symbol> = {
  readonly [BRAND]: { readonly [k in T]: true };
};
```

This can support the [`@typescript-eslint/prefer-readonly-parameter-types`](https://typescript-eslint.io/rules/prefer-readonly-parameter-types/https://typescript-eslint.io/rules/prefer-readonly-parameter-types/) rule.

This can be now confirmed as following with the repository: https://github.com/LumaKernel/zod-issue-3787

```sh
npx eslint .

/<proj>/int.ts
  8:22  error  Parameter should be a read only type  @typescript-eslint/prefer-readonly-parameter-types

/<proj>/span.ts
  15:23  error  Parameter should be a read only type  @typescript-eslint/prefer-readonly-parameter-types

✖ 2 problems (2 errors, 0 warnings)

```

And I already confirmed that, if I replace the `BRAND` definition in `node_modules/` as above, this lint error is resolved for `span.ts` (using `z.object()` base).

Unfortunately, for the limitation of the eslint rule, the branded types for literal types like `number & { readonly some: null }` is not treated as readonly by the rule. That's why, `int.ts` (using `z.number()` base) in the repo cannot be resolved by this change, but it's still happy for the pattern of `span.ts`, it's mainly used in my project.
",,
2567618700,3785,Typescript doesn't realize record can return undefined,"Hey there. Just ran into an issue where typescript didn't realize that a key can not exist in a record. It assumes no matter what key you use, it will return the defined type.

```ts
import { z } from ""zod""

const testContract = z.record(z.string(), z.number())

type TestType = z.infer<typeof testContract>

const testObject: TestType = {
  hello: 1,
  world: 2,
}

// Typescript has no problem with this, but I'd expect it to 
// complain about the potential for it to be undefined
const x: number = testObject[""not in object""]

```

Is this expected behavior?",,
2566124059,3783,Proposal: Include received value in union discriminator error messages,"Currently, when a union discriminator validation fails, the error message only includes the expected values but not the actual received value.

My proposition is to change:
`src/types.ts`:
```typescript
const discriminator = this.discriminator;

const discriminatorValue: string = ctx.data[discriminator];

const option = this.optionsMap.get(discriminatorValue);

if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator],
+        received: discriminatorValue,
   });
      return INVALID;
    }
```
and `src/locales/en.ts`:
```typescript
case ZodIssueCode.invalid_union_discriminator:
-      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
+      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
```

If there are reasons for the current implementation, I'd appreciate any insights.",,
2552286203,3776,Wrong export types (CJS vs ESM modules),"The `package.json` export field seems to be misconfigured for the ESM export. I've run into the issues importing zod in one of my projects. 

The publint is giving following warning (https://publint.dev/zod@3.23.8). 

> **The types is interpreted as CJS when resolving with the ""import"" condition.** This causes the types to be ambiguous when default importing the package due to its implied interop. Consider splitting out two ""types"" conditions for ""import"" and ""require"", and use the .mts extension, e.g. pkg.exports["".""].import.types: ""./index.d.mts"" ([More info](https://publint.dev/rules.html#export_types_invalid_format))

Fixing that should solve the problem. Would you accept a PR?

---

Possibly related https://github.com/colinhacks/zod/issues/2557
",,
2549417550,3773,Bug: Zod function types not inferred correctly,"# Detail
Zod types generate function always carry a unknown[] args.
But it's a difference from `(...args: unknown[]) => string;` between `() => string;`

# Code 
```ts
import { z } from ""zod"";

const myFunction = z.function().returns(z.string());

// MyFunction1 type is (...args: unknown[]) => string;
type MyFunction1 = z.infer<typeof myFunction>;

const f1: MyFunction1 = (x1: string) => """";

// Expect type is () => string;
type MyFunction2 = () => string;

const f2: MyFunction2 = () => """";

```",,
2547541784,3772,No index signature with a parameter of type 'string' was found on type with union of array and key-ed object,"Hi,

I have the following schema:
```typescript
const TeamRadio = z.object({
    Utc: z.string(),
    RacingNumber: z.string(),
    Path: z.string(),
}).strict();

type TeamRadio = z.infer<typeof TeamRadio>;

const TeamRadios = z.object({
    Captures: z.union([
        z.array(TeamRadio),
        z.record(z.string(), TeamRadio),
    ]),
}).strict();

type TeamRadios = z.infer<typeof TeamRadios>;
```

So basically the `Captures` property of TeamRadios is either an array of TeamRadio OR an object with a string key (sequence number and a single  TeamRadio object.

I then want to process all TeamRadio objects into a large array using the following code:
```typescript
const test = async (filepath: string) => {
    const file = await Deno.open(filepath, { read: true, write: false });
    const lines = readLines(file);
    const radios: TeamRadio[] = [];
    for await (const line of lines) {
        console.log(line);
        const [_timestamp, obj] = [line.slice(0, 12), line.slice(12)];
        const json = JSON.parse(obj) as TeamRadios;
        if (Array.isArray(json.Captures)) {
            json.Captures.forEach((c) => radios.push(c));
        } else {
            const keys = Object.keys(json.Captures);
            keys.forEach((c) => radios.push(json.Captures[c])); <--------------------------------------
        }
        // const parsed = TeamRadios.safeParse(json);
        // if (parsed.error) console.log(""error"", parsed.error.stack);
    }
    console.log(radios.length);
};

const filepath = ""../2024-09-22_Singapore_Grand_Prix/2024-09-22_Race/TeamRadio.jsonStream"";
await test(filepath);
```
At the arrow I get the following error:
```
Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ Utc: string; RacingNumber: string; Path: string; }[] | Record<string, { Utc: string; RacingNumber: string; Path: string; }>'.
  No index signature with a parameter of type 'string' was found on type '{ Utc: string; RacingNumber: string; Path: string; }[] | Record<string, { Utc: string; RacingNumber: string; Path: string; }>'.
```

Data:
```
00:13:11.872{""Captures"":[{""Utc"":""2024-09-22T11:20:10.75Z"",""RacingNumber"":""44"",""Path"":""TeamRadio/LEWHAM01_44_20240922_192005.mp3""}]}
00:15:24.940{""Captures"":{""1"":{""Utc"":""2024-09-22T11:22:22.852Z"",""RacingNumber"":""43"",""Path"":""TeamRadio/FRACOL01_43_20240922_192211.mp3""}}}
00:15:57.207{""Captures"":{""2"":{""Utc"":""2024-09-22T11:30:07.5758076Z"",""RacingNumber"":""18"",""Path"":""TeamRadio/LANSTR01_18_20240922_192927.mp3""}}}
00:49:01.425{""Captures"":{""11"":{""Utc"":""2024-09-22T11:56:01.865Z"",""RacingNumber"":""24"",""Path"":""TeamRadio/GUAZHO01_24_20240922_195530.mp3""},""12"":{""Utc"":""2024-09-22T11:56:01.865Z"",""RacingNumber"":""10"",""Path"":""TeamRadio/PIEGAS01_10_20240922_195544.mp3""}}}
```
How to get rid of it?  tried a lot of `keyof` / `typeof` combinations, but doing that didn't get rid of the errors;
Scratching my head as `c` is a string, and so is `z.record(z.string(), TeamRadio)`

",,
2543081219,3769,Proposal : make `coerce` more generic,"Hi!

I've been thinking about how to make `coerce` something more powerful and generic than what it is right now and I think I found an elegant solution. Not knowing `zod` codebase perfectly (I read a big part of it though) I might be missing things that would make this impossible. But I think it should work.

1st, add to every zod schema a `schema.constructWith(inputSchema)` method (that name can obviously be changed, I'm not sure it is good) that would satisfy the followings:

- `inputSchema` **REQUIRES** a compatible `OutputType` type with the schema's `InputType`
- That method would return a similarly typed `ZodSchema` except for its `InputType` that would be changed to the same one as the one of `inputSchema`
- The returned schema would basically be the same `schema` but constructed with the `inputSchema` in its def object
- Change the parse method to run it on `inputSchema.parse(val)` instead of `val` directly when there is one

2nd add a `schema.coerce(transformFn, outputSchema)` method to every zod schema that would basically just return `outputSchema.constructWith(schema.transform(transformFn))`.

Those changes would allow to implement existing coerce tooling more easily:

```ts
zod.coerce.number = z.string()
  .or(z.number())
  // that might not be enough to put Number only there, but it keeps things simple
  .coerce(Number, z.number());

// or:
zod.coerce.number = z.number()
  .constructWith(
    z.number()
      .or(z.string().transform(Number))
  );

// ZodNumber would need to be parameterized with its input type now
// eg: ZodNumber<Input = number> extends ZodType<number, ZodNumberDef, Input> {}

// zod.coerce.number would be defined as a ZodNumber<string | number>
```

If we want to keep very broad coercing tooling, it could be defined as:
```ts
zod.coerce.number = z.unknown()
  .coerce(Number, z.number()); // ZodNumber<unknown>
```

I think that would also allow to completely deprecate `z.preprocess()` that would be better served by using `.coerce()` or `.constructWith()` (it could always be simulated using `z.unknown().coerce()`, the only difference being that the resulting schema would be ""better"" typed).

Some very cool uses for this would be to create some generic schemas representing more complex things that can still be used in a very intuitive way after that:

```ts
// duration.ts
import parseDuration from ""parse-duration"";

export const duration = z.string()
  .min(1)
  .or(z.number())
  .coerce(
    (val: string | number) => typeof val === ""string"" ? parseDuration(val) : val,
    z.number()
  ) // another ZodNumber<string | number>

// example.ts
import { duration } from ""./duration.js"";

const requestTimeout = duration
  .int(""do not support µs"")
  .min(1_000, ""1s minimum timeout"")
 ;
 
 // ...
requestTimeout.parse(""20s""); // OK => 20_000
requestTimeout.parse(""200ms""); // fails with ""1s minimum timeout""
requestTimeout.parse(10_000); // OK => 10_000
requestTimout.parse(10_000.25); // fails with ""do not support µs""",,
2539159566,3767,Bug: z.output makes all properties optional,"Using `z.output`, ALL properties optional. E.g. the following should throw a TypeScript error that `count` is required but it does not:

```
export const myMsgSchema = z.object({
  message: z.string(),
  count: z.number().positive(),
});

export type MyMsg = z.output<typeof myMsgschema>;

const msg: MyMsg = {
  message: 'hello';
}
```",,
2533811458,3759,values of type number are not accepted when key of NativeEnum is specified as a number type,"version: v3.23.8

```ts
const STRING_KEY_ENUM = {
  ten: 10,
  twenty: 20,
} as const
z.nativeEnum(STRING_KEY_ENUM) // OK

const NUMBER_KEY_ENUM = {
  10: 10,
  20: 20,
} as const
z.nativeEnum(NUMBER_KEY_ENUM) // Error: Argument of type '{ readonly 10: 10; readonly 20: 20; }' is not assignable to parameter of type 'EnumLike'.

const NUMBER_WITH_QUOTE_KEY_ENUM = {
  '10': 10,
  '20': 20,
} as const
z.nativeEnum(NUMBER_WITH_QUOTE_KEY_ENUM) // Error: Argument of type '{ readonly '10': 10; readonly '20': 20; }' is not assignable to parameter of type 'EnumLike'.
```

While using numbers as keys might not be a common pattern, I would expect consistent behavior regardless of the key type. However, it appears that enums with number keys and stringified number keys lead to different results, which seems unintuitive. ",,
2524395296,3753,"Although `z.string().date()` check fails, yet the callback to `.superRefine()` is executed.","Consider the following schema.

```typescript
import { z } from ""zod"";

export const dateRangeSchema = z.object({
    minimum: z.string().date(),
    maximum: z.string().date(),
}).superRefine(({ minimum, maximum }, context) => {
    console.log({ minimum, maximum }); // for debugging

    if (new Date(minimum) > new Date(maximum)) {
        context.addIssue({
            code: z.ZodIssueCode.too_big,
            type: ""date"",
            maximum,
            inclusive: true,
            path: [""minimum""],
            message: ""minimum must not be greater than maximum"",
        });

        context.addIssue({
            code: z.ZodIssueCode.too_small,
            type: ""date"",
            minimum,
            inclusive: true,
            path: [""maximum""],
            message: ""maximum must not be lesser than minimum"",
        });
    }
});
```

I expect when `minimum` or `maximum` are invalid date strings, then the callback to `.superRefine()` won't be executed. However, this is not the case. Consider the following example.

```typescript
console.log(dateRangeSchema.safeParse({ minimum: ""1"", maximum: ""0"" }).error.issues);
```

The above example prints out the following output to the console.

```typescript
{ minimum: '1', maximum: '0' }
[
  {
    code: 'invalid_string',
    validation: 'date',
    message: 'Invalid date',
    path: [ 'minimum' ]
  },
  {
    code: 'invalid_string',
    validation: 'date',
    message: 'Invalid date',
    path: [ 'maximum' ]
  },
  {
    code: 'too_big',
    type: 'date',
    maximum: '0',
    inclusive: true,
    path: [ 'minimum' ],
    message: 'minimum must not be greater than maximum'
  },
  {
    code: 'too_small',
    type: 'date',
    minimum: '1',
    inclusive: true,
    path: [ 'maximum' ],
    message: 'maximum must not be lesser than minimum'
  }
]
```

As you can see, although `""1""` and `""0""` fail the `z.string().date()` check, yet the callback to `.superRefine()` is executed. This is unintuitive behavior. At the very least, it violates the [principle of least astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment). The callback to `.superRefine()` should only be executed when the input is parsed without any issue.",,
2521773407,3752,Problem with validation of identical fields in the schema,"Currently, there is an issue in the schema where, if identical fields are present in the user's schemas, Zod incorrectly validates the second testProperty field. Is there a way to fix this? At the moment, the only solution I've found is to change the field name (testProperty) to a unique one.

[https://codesandbox.io/p/sandbox/zodschemas-forked-76tlcr?file=%2Fsrc%2FApp.tsx
![Снимок экрана 2024-09-12 115322](https://github.com/user-attachments/assets/cf91d4f4-25a7-4871-a04f-c3e078e56620)
](url)

`import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import { z } from ""zod"";

const stringSchema = z.string().min(1, { message: ""fieldIsRequired"" });

const firstUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema,
});

const secondUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema.or(z.string().length(0)),
  testPropertySecond: stringSchema.or(z.string().length(0)),
});

const UserSchema = z.union([firstUser, secondUser]);

const usersSchema = z.object({
  users: UserSchema.array(),
});

type UsersForm = z.infer<typeof usersSchema>;

export const App: VFC = () => {
  const { register, handleSubmit, formState, control } = useForm<UsersForm>({
    resolver: zodResolver(usersSchema),
    defaultValues: {
      users: [
        {
          firstName: """",
          lastName: """",
          testProperty: """",
        },
        {
          firstName: """",
          lastName: """",
          testProperty: """",
          testPropertySecond: """",
        },
      ],
    },
  });

  const errors = formState.errors;

  console.log(errors, formState, control);

  const onSubmit: SubmitHandler<UsersForm> = useCallback(async (value) => {},
  []);

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      style={{
        display: ""flex"",
        flexDirection: ""column"",
        width: 512,
        margin: ""0 auto"",
      }}
    >
      <label>
        <span>First name first user</span>
        <input {...register(""users.0.firstName"")} />
        <span>{errors?.users?.[0]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name first user</span>
        <input {...register(""users.0.lastName"")} />
        <span>{errors?.users?.[0]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property first user</span>
        <input {...register(""users.0.testProperty"")} />
        <span>{errors?.users?.[0]?.testProperty?.message}</span>
      </label>

      <label style={{ marginTop: ""40px"" }}>
        <span>First name second user</span>
        <input {...register(""users.1.firstName"")} />
        <span>{errors?.users?.[1]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name second user</span>
        <input {...register(""users.1.lastName"")} />
        <span>{errors?.users?.[1]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property second user</span>
        <input {...register(""users.1.testProperty"")} />
        <span>{errors?.users?.[1]?.testProperty?.message}</span>
      </label>
      <label>
        <span>Second test property second user</span>
        <input {...register(""users.1.testPropertySecond"")} />
        <span>{errors?.users?.[1]?.testPropertySecond?.message}</span>
      </label>
      <button type=""submit"">Submit</button>
    </form>
  );
};
`",2346221877,"You can switch `firstUser` and `secondUser` position in union.

```ts
const UserSchema = z.union([secondUser, firstUser]);
```

Zod will iterate through all the options in a union array. If any of the options pass validation, the entire result is considered valid. However, if any of the options fail validation, it will return the result of the first invalid option and ignore the rest.

For example, if you use `z.union([firstUser, secondUser])` to parse `{ firstName: """", lastName: """", testProperty: """" }`, the `firstUser` schema will raise 3 errors, so that becomes the result. Even if you try parsing `{ firstName: """", lastName: """", testProperty: """", testPropertySecond: """" }`, the outcome remains the same. This happens because `firstUser` is the first option evaluated, and Zod will return its result, ignoring the `secondUser` schema."
2521773407,3752,Problem with validation of identical fields in the schema,"Currently, there is an issue in the schema where, if identical fields are present in the user's schemas, Zod incorrectly validates the second testProperty field. Is there a way to fix this? At the moment, the only solution I've found is to change the field name (testProperty) to a unique one.

[https://codesandbox.io/p/sandbox/zodschemas-forked-76tlcr?file=%2Fsrc%2FApp.tsx
![Снимок экрана 2024-09-12 115322](https://github.com/user-attachments/assets/cf91d4f4-25a7-4871-a04f-c3e078e56620)
](url)

`import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import { z } from ""zod"";

const stringSchema = z.string().min(1, { message: ""fieldIsRequired"" });

const firstUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema,
});

const secondUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema.or(z.string().length(0)),
  testPropertySecond: stringSchema.or(z.string().length(0)),
});

const UserSchema = z.union([firstUser, secondUser]);

const usersSchema = z.object({
  users: UserSchema.array(),
});

type UsersForm = z.infer<typeof usersSchema>;

export const App: VFC = () => {
  const { register, handleSubmit, formState, control } = useForm<UsersForm>({
    resolver: zodResolver(usersSchema),
    defaultValues: {
      users: [
        {
          firstName: """",
          lastName: """",
          testProperty: """",
        },
        {
          firstName: """",
          lastName: """",
          testProperty: """",
          testPropertySecond: """",
        },
      ],
    },
  });

  const errors = formState.errors;

  console.log(errors, formState, control);

  const onSubmit: SubmitHandler<UsersForm> = useCallback(async (value) => {},
  []);

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      style={{
        display: ""flex"",
        flexDirection: ""column"",
        width: 512,
        margin: ""0 auto"",
      }}
    >
      <label>
        <span>First name first user</span>
        <input {...register(""users.0.firstName"")} />
        <span>{errors?.users?.[0]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name first user</span>
        <input {...register(""users.0.lastName"")} />
        <span>{errors?.users?.[0]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property first user</span>
        <input {...register(""users.0.testProperty"")} />
        <span>{errors?.users?.[0]?.testProperty?.message}</span>
      </label>

      <label style={{ marginTop: ""40px"" }}>
        <span>First name second user</span>
        <input {...register(""users.1.firstName"")} />
        <span>{errors?.users?.[1]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name second user</span>
        <input {...register(""users.1.lastName"")} />
        <span>{errors?.users?.[1]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property second user</span>
        <input {...register(""users.1.testProperty"")} />
        <span>{errors?.users?.[1]?.testProperty?.message}</span>
      </label>
      <label>
        <span>Second test property second user</span>
        <input {...register(""users.1.testPropertySecond"")} />
        <span>{errors?.users?.[1]?.testPropertySecond?.message}</span>
      </label>
      <button type=""submit"">Submit</button>
    </form>
  );
};
`",2348141746,"@sunnylost it could be a working solution, but if we change the order of zod schemas in the array and then decide to add a property with the same key but with different validation schema, validation will raise error in the `testPropertySecond` property. Take a look at this example below: 
![image](https://github.com/user-attachments/assets/a92f42c2-0689-4a24-9921-cebefeb3617f)
"
2521773407,3752,Problem with validation of identical fields in the schema,"Currently, there is an issue in the schema where, if identical fields are present in the user's schemas, Zod incorrectly validates the second testProperty field. Is there a way to fix this? At the moment, the only solution I've found is to change the field name (testProperty) to a unique one.

[https://codesandbox.io/p/sandbox/zodschemas-forked-76tlcr?file=%2Fsrc%2FApp.tsx
![Снимок экрана 2024-09-12 115322](https://github.com/user-attachments/assets/cf91d4f4-25a7-4871-a04f-c3e078e56620)
](url)

`import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import { z } from ""zod"";

const stringSchema = z.string().min(1, { message: ""fieldIsRequired"" });

const firstUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema,
});

const secondUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema.or(z.string().length(0)),
  testPropertySecond: stringSchema.or(z.string().length(0)),
});

const UserSchema = z.union([firstUser, secondUser]);

const usersSchema = z.object({
  users: UserSchema.array(),
});

type UsersForm = z.infer<typeof usersSchema>;

export const App: VFC = () => {
  const { register, handleSubmit, formState, control } = useForm<UsersForm>({
    resolver: zodResolver(usersSchema),
    defaultValues: {
      users: [
        {
          firstName: """",
          lastName: """",
          testProperty: """",
        },
        {
          firstName: """",
          lastName: """",
          testProperty: """",
          testPropertySecond: """",
        },
      ],
    },
  });

  const errors = formState.errors;

  console.log(errors, formState, control);

  const onSubmit: SubmitHandler<UsersForm> = useCallback(async (value) => {},
  []);

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      style={{
        display: ""flex"",
        flexDirection: ""column"",
        width: 512,
        margin: ""0 auto"",
      }}
    >
      <label>
        <span>First name first user</span>
        <input {...register(""users.0.firstName"")} />
        <span>{errors?.users?.[0]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name first user</span>
        <input {...register(""users.0.lastName"")} />
        <span>{errors?.users?.[0]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property first user</span>
        <input {...register(""users.0.testProperty"")} />
        <span>{errors?.users?.[0]?.testProperty?.message}</span>
      </label>

      <label style={{ marginTop: ""40px"" }}>
        <span>First name second user</span>
        <input {...register(""users.1.firstName"")} />
        <span>{errors?.users?.[1]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name second user</span>
        <input {...register(""users.1.lastName"")} />
        <span>{errors?.users?.[1]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property second user</span>
        <input {...register(""users.1.testProperty"")} />
        <span>{errors?.users?.[1]?.testProperty?.message}</span>
      </label>
      <label>
        <span>Second test property second user</span>
        <input {...register(""users.1.testPropertySecond"")} />
        <span>{errors?.users?.[1]?.testPropertySecond?.message}</span>
      </label>
      <button type=""submit"">Submit</button>
    </form>
  );
};
`",2348166718,"So the issue is that you want to use the `firstUser` schema to parse the first user and the `secondUser` schema for the second, but since both users have the same structure, there's no way to determine which schema to apply. In my opinion, each user should have a property to distinguish them, allowing you to use a discriminated union for validation."
2521773407,3752,Problem with validation of identical fields in the schema,"Currently, there is an issue in the schema where, if identical fields are present in the user's schemas, Zod incorrectly validates the second testProperty field. Is there a way to fix this? At the moment, the only solution I've found is to change the field name (testProperty) to a unique one.

[https://codesandbox.io/p/sandbox/zodschemas-forked-76tlcr?file=%2Fsrc%2FApp.tsx
![Снимок экрана 2024-09-12 115322](https://github.com/user-attachments/assets/cf91d4f4-25a7-4871-a04f-c3e078e56620)
](url)

`import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import { z } from ""zod"";

const stringSchema = z.string().min(1, { message: ""fieldIsRequired"" });

const firstUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema,
});

const secondUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema.or(z.string().length(0)),
  testPropertySecond: stringSchema.or(z.string().length(0)),
});

const UserSchema = z.union([firstUser, secondUser]);

const usersSchema = z.object({
  users: UserSchema.array(),
});

type UsersForm = z.infer<typeof usersSchema>;

export const App: VFC = () => {
  const { register, handleSubmit, formState, control } = useForm<UsersForm>({
    resolver: zodResolver(usersSchema),
    defaultValues: {
      users: [
        {
          firstName: """",
          lastName: """",
          testProperty: """",
        },
        {
          firstName: """",
          lastName: """",
          testProperty: """",
          testPropertySecond: """",
        },
      ],
    },
  });

  const errors = formState.errors;

  console.log(errors, formState, control);

  const onSubmit: SubmitHandler<UsersForm> = useCallback(async (value) => {},
  []);

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      style={{
        display: ""flex"",
        flexDirection: ""column"",
        width: 512,
        margin: ""0 auto"",
      }}
    >
      <label>
        <span>First name first user</span>
        <input {...register(""users.0.firstName"")} />
        <span>{errors?.users?.[0]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name first user</span>
        <input {...register(""users.0.lastName"")} />
        <span>{errors?.users?.[0]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property first user</span>
        <input {...register(""users.0.testProperty"")} />
        <span>{errors?.users?.[0]?.testProperty?.message}</span>
      </label>

      <label style={{ marginTop: ""40px"" }}>
        <span>First name second user</span>
        <input {...register(""users.1.firstName"")} />
        <span>{errors?.users?.[1]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name second user</span>
        <input {...register(""users.1.lastName"")} />
        <span>{errors?.users?.[1]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property second user</span>
        <input {...register(""users.1.testProperty"")} />
        <span>{errors?.users?.[1]?.testProperty?.message}</span>
      </label>
      <label>
        <span>Second test property second user</span>
        <input {...register(""users.1.testPropertySecond"")} />
        <span>{errors?.users?.[1]?.testPropertySecond?.message}</span>
      </label>
      <button type=""submit"">Submit</button>
    </form>
  );
};
`",2348183280,"> So the issue is that you want to use the `firstUser` schema to parse the first user and the `secondUser` schema for the second, but since both users have the same structure, there's no way to determine which schema to apply. In my opinion, each user should have a property to distinguish them, allowing you to use a discriminated union for validation.

Yes, you are right! We want to apply the schema to object depends on some key (for example, id from enum). Unfortunately, zod union do not support the determination of validation schema according to key property and its value. We have `z.discriminatedUnion` which could help if it could work with transformed zod schemas."
2520708502,3751,Question: TypeScript Isolated Declarations,"Hi folks,

Firstly, thanks for all the work you've done building such a great project.
We're wondering what you have plan for making a lighter type annotations for projects using isolated declarations. We tried Zod with the current version, and explicitly type annotating the module exports are not easy to maintain.

What are you thoughts?",2386569864,"I'm also interested in this, although I don't see a good way of reconciling Zod with isolated declarations since the whole point of Zod is that it will automatically keep the type in sync with the schema."
2512395540,3747,Allow `.extract`/`.exclude` for `nativeEnum`s,"Hey there! We're swapping to zod in our library for validation and we have the following use case:

```ts
// some-dependency
enum Something {
  X,
  Y,
  Z
}
```

We're using this numeric enum from our dependency (which has more like 14 available members), and we happen to want, say, 6 of them as allowed values to a record field.

My instinct was to use `z.nativeEnum(Something).extract(...)`, but I was surprised to learn it doesn't exist. My next idea was to do what I thought was the next most-correct thing, which is `z.enum([Something.X, Something.Y, ...])`, but I was quickly reminded it only supports strings (fair).

Which leaves me with using literals. https://github.com/colinhacks/zod/issues/2686#issuecomment-2073511939 would be of big help already, since I ended up having to do something like this: https://github.com/discordjs/discord.js/blob/6d44a77180fc52e6b87278b8054c54cb3a501600/packages/builders/src/interactions/slashCommands/Assertions.ts#L61-L75

I think ultimately though, it'd be ideal if ""native enums"" supported extract & exclude. I'd be willing to try to implement this, just figured I'd make an issue first in case there's a clear-cut sort of blocker for something like this.
",,
2512061178,3746,Type narrowing not working with generic zod type,"If we use `zod` to parse an API response:

```typescript
function foo(subSchema: z.ZodTypeAny) {
  fetch('example/api')
    .then(res => res.json())
    .then(json => {

      const resSchema = z.union([
        z.object({
          passed: z.literal(true),
          value: subSchema
        }),
        z.object({
          passed: z.literal(false),
          msg: z.string()
        })
      ])

      const parsed = resSchema.safeParse(json);

      if (parsed.success) {
        if (parsed.data.passed) {
          console.log(parsed.data.value);
        }
      }
    })
}
```

We see that when we specify a conditional for when the parse is successful, the type of `parsed` is narrowed. We specify another conditional inside of that for when the API result `passed === true`, and the type is narrowed further to one where the `value` key is present.

Let's say we want to make `foo` generic so that we can potentially return the parsed API response value.

```typescript
function foo<TSubSchema extends z.ZodTypeAny>(subSchema: TSubSchema) {
  fetch('example/api')
    .then(res => res.json())
    .then(json => {

      const resSchema = z.union([
        z.object({
          passed: z.literal(true),
          value: subSchema
        }),
        z.object({
          passed: z.literal(false),
          msg: z.string()
        })
      ])

      const parsed = resSchema.safeParse(json);

      if (parsed.success) {
        if (parsed.data.passed) {
          console.log(parsed.data.value);
        }
      }
    })
}
```

Now we have specified that subSchema is of a type `TSubSchema`, which is an extension of `ZodTypeAny`.

But we get an error on the line
```typescript
console.log(parsed.data.value);
```
indicating that 
```
Property 'value' does not exist on type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ passed: ZodLiteral<true>; value: TSubSchema; }>, any>]: addQuestionMarks<baseObjectOutputType<{ passed: ZodLiteral<...>; value: TSubSchema; }>, any>[k]; } | { ...; }'.
  Property 'value' does not exist on type '{ passed: false; msg: string; }'.ts(2339)
```

This tells that us that the type narrowing is not working, as it the type checker is complaining about `value` potentially not being a key of `parsed.data`.
",2345999371,Stuck in the same issue. No solution so far
2511202410,3745,How to union or merge two or more z.record schemas,"Thanks for the great library, really finding it useful.

Is there a recommended way to define a union of two or more record schemas, that would successfully parse an object with a mix of key/values from each record? Here's a minimal example outlining my unsuccessful attempt:

```ts
import { z } from 'zod';

// Define the schemas for the individual records
const record1Schema = z.record(z.enum(['a', 'b']), z.union([z.number(), z.string()]));

const record2Schema = z.record(z.enum(['c', 'd']), z.union([z.boolean(), z.string()]));

// Define the merged schema
const mergedSchema = z.union([record1Schema, record2Schema]);

// Example usage
const example1 = { a: 42, b: 'hello' }; // Valid according to record1Schema
const example2 = { c: true, d: 'world' }; // Valid according to record2Schema
const example3 = { a: 42, c: true }; // Valid according to mergedSchema

console.log(record1Schema.safeParse(example1)); // Success
console.log(record2Schema.safeParse(example2)); // Success
console.log(mergedSchema.safeParse(example3)); // Error
```

The last parse fails with invalid_union errors that includes invalid_enun_values errors like this:

```
{                                                                                                                
              ""received"": ""c"",               
              ""code"": ""invalid_enum_value"",      
              ""options"": [                                                                                                   
                ""a"",            
                ""b""                                                                                                          
              ],                                                                                                             
              ""path"": [                                                                                                      
                ""c""                                                                                                          
              ],                                                                                                             
              ""message"": ""Invalid enum value. Expected 'a' | 'b', received 'c'""                   
            }
```

I would expect it to work (and it does type check), but it seems like it expects it to conform to one of the record schemas only, and won't accept the other. Is there a better way to do this?
",2363174342,I suggest using `superRefine()` to gain more custom control.
2510856015,3744,Idea: `.meta(...)` method on ZodType,"I've considered asking this for a bit, for the sake of [trpc-cli](https://github.com/mmkal/trpc-cli). So far, it takes advantage of `.describe('...')` to allow adding CLI docs for zod input parameters, but it would be nice to add richer metadata.

How I think it could work:

1. Define a new `ZodMeta` interface (maybe make it generic with the same typeargs as `ZodType`)
2. Only add a `description` property to it
3. Add a `metadata: ZodMeta` prop to `ZodType`
4. Have `.describe('foo')` update the metadata to `{ description: 'foo' }` (maybe shallow-merging the old value?)
5. Update the description property of ZodType to `get description() { return this.metadata.description }` for backwards-compatibility

The fun part would be: end users could then use module augmentation to add to `ZodMeta` however they like, e.g. I in trpc-cli could do:

```ts
import {z} from 'zod'

declare module 'zod' {
  export interface ZodMeta {
    alias: string
  }
}

const router = t.router({
  test: t.input(
    z.object({
      glob: z.string().meta({
        description: 'Glob pattern for test files',
        alias: 'g',
      })
    })
  ).mutation(...)
)
```

Looking at the issues, I think this would cover a few requests zod has got:

https://github.com/colinhacks/zod/issues/3734
https://github.com/colinhacks/zod/issues/3732
https://github.com/colinhacks/zod/issues/3736 (maybe)
https://github.com/colinhacks/zod/issues/3673
https://github.com/colinhacks/zod/issues/1439

Possible more but I didn't go that far back in the issues. In general, with trpc and OpenAI adopting zod, there will be more cases where people use zod as a user-facing part of their libraries and applications, so there might be more and more requests for the ability to attach metadat to types

Alternatively, these fields could somehow be dumped onto `ZodDef`, which is where `description` lives now but that doesn't feel quite right to me.",2348288500,"i like the idea of removing all the non entity related stuff to a meta field, it would make it more consistent across types"
2510856015,3744,Idea: `.meta(...)` method on ZodType,"I've considered asking this for a bit, for the sake of [trpc-cli](https://github.com/mmkal/trpc-cli). So far, it takes advantage of `.describe('...')` to allow adding CLI docs for zod input parameters, but it would be nice to add richer metadata.

How I think it could work:

1. Define a new `ZodMeta` interface (maybe make it generic with the same typeargs as `ZodType`)
2. Only add a `description` property to it
3. Add a `metadata: ZodMeta` prop to `ZodType`
4. Have `.describe('foo')` update the metadata to `{ description: 'foo' }` (maybe shallow-merging the old value?)
5. Update the description property of ZodType to `get description() { return this.metadata.description }` for backwards-compatibility

The fun part would be: end users could then use module augmentation to add to `ZodMeta` however they like, e.g. I in trpc-cli could do:

```ts
import {z} from 'zod'

declare module 'zod' {
  export interface ZodMeta {
    alias: string
  }
}

const router = t.router({
  test: t.input(
    z.object({
      glob: z.string().meta({
        description: 'Glob pattern for test files',
        alias: 'g',
      })
    })
  ).mutation(...)
)
```

Looking at the issues, I think this would cover a few requests zod has got:

https://github.com/colinhacks/zod/issues/3734
https://github.com/colinhacks/zod/issues/3732
https://github.com/colinhacks/zod/issues/3736 (maybe)
https://github.com/colinhacks/zod/issues/3673
https://github.com/colinhacks/zod/issues/1439

Possible more but I didn't go that far back in the issues. In general, with trpc and OpenAI adopting zod, there will be more cases where people use zod as a user-facing part of their libraries and applications, so there might be more and more requests for the ability to attach metadat to types

Alternatively, these fields could somehow be dumped onto `ZodDef`, which is where `description` lives now but that doesn't feel quite right to me.",2403836753,"I am a long time zod user and had wanted something similar. There is this library [zod-to-openapi](https://github.com/asteasolutions/zod-to-openapi) that introspects metadata, but that has intimate knowledge of zod internals.

I'd like to share a zod compatible library I recently published. It is built with extensibility (like in this issue) in mind. I started it initially wanting to customize some zod error messages, and it kind of grew into something bigger.

https://github.com/ajaishankar/pukka?tab=readme-ov-file#extension-introspection

I apologize for the plug, but thought you'd find it interesting.

"
2510856015,3744,Idea: `.meta(...)` method on ZodType,"I've considered asking this for a bit, for the sake of [trpc-cli](https://github.com/mmkal/trpc-cli). So far, it takes advantage of `.describe('...')` to allow adding CLI docs for zod input parameters, but it would be nice to add richer metadata.

How I think it could work:

1. Define a new `ZodMeta` interface (maybe make it generic with the same typeargs as `ZodType`)
2. Only add a `description` property to it
3. Add a `metadata: ZodMeta` prop to `ZodType`
4. Have `.describe('foo')` update the metadata to `{ description: 'foo' }` (maybe shallow-merging the old value?)
5. Update the description property of ZodType to `get description() { return this.metadata.description }` for backwards-compatibility

The fun part would be: end users could then use module augmentation to add to `ZodMeta` however they like, e.g. I in trpc-cli could do:

```ts
import {z} from 'zod'

declare module 'zod' {
  export interface ZodMeta {
    alias: string
  }
}

const router = t.router({
  test: t.input(
    z.object({
      glob: z.string().meta({
        description: 'Glob pattern for test files',
        alias: 'g',
      })
    })
  ).mutation(...)
)
```

Looking at the issues, I think this would cover a few requests zod has got:

https://github.com/colinhacks/zod/issues/3734
https://github.com/colinhacks/zod/issues/3732
https://github.com/colinhacks/zod/issues/3736 (maybe)
https://github.com/colinhacks/zod/issues/3673
https://github.com/colinhacks/zod/issues/1439

Possible more but I didn't go that far back in the issues. In general, with trpc and OpenAI adopting zod, there will be more cases where people use zod as a user-facing part of their libraries and applications, so there might be more and more requests for the ability to attach metadat to types

Alternatively, these fields could somehow be dumped onto `ZodDef`, which is where `description` lives now but that doesn't feel quite right to me.",2405794802,"I like it
"
2510856015,3744,Idea: `.meta(...)` method on ZodType,"I've considered asking this for a bit, for the sake of [trpc-cli](https://github.com/mmkal/trpc-cli). So far, it takes advantage of `.describe('...')` to allow adding CLI docs for zod input parameters, but it would be nice to add richer metadata.

How I think it could work:

1. Define a new `ZodMeta` interface (maybe make it generic with the same typeargs as `ZodType`)
2. Only add a `description` property to it
3. Add a `metadata: ZodMeta` prop to `ZodType`
4. Have `.describe('foo')` update the metadata to `{ description: 'foo' }` (maybe shallow-merging the old value?)
5. Update the description property of ZodType to `get description() { return this.metadata.description }` for backwards-compatibility

The fun part would be: end users could then use module augmentation to add to `ZodMeta` however they like, e.g. I in trpc-cli could do:

```ts
import {z} from 'zod'

declare module 'zod' {
  export interface ZodMeta {
    alias: string
  }
}

const router = t.router({
  test: t.input(
    z.object({
      glob: z.string().meta({
        description: 'Glob pattern for test files',
        alias: 'g',
      })
    })
  ).mutation(...)
)
```

Looking at the issues, I think this would cover a few requests zod has got:

https://github.com/colinhacks/zod/issues/3734
https://github.com/colinhacks/zod/issues/3732
https://github.com/colinhacks/zod/issues/3736 (maybe)
https://github.com/colinhacks/zod/issues/3673
https://github.com/colinhacks/zod/issues/1439

Possible more but I didn't go that far back in the issues. In general, with trpc and OpenAI adopting zod, there will be more cases where people use zod as a user-facing part of their libraries and applications, so there might be more and more requests for the ability to attach metadat to types

Alternatively, these fields could somehow be dumped onto `ZodDef`, which is where `description` lives now but that doesn't feel quite right to me.",2457991537,"that'd be really awesome, I use zod schemas to generate forms in react and need to attach a lot of extra data to a ZodType. Currently I have to hack it a bit like so:

```typescript
type ZodTypeEnhanced<
	O = any,
	D extends ZodTypeDef = ZodTypeDef,
	I = O
> = ZodType<O, D, I> & {
	meta: FieldMeta
	original: ZodType<O, D, I>
}

export const isEnhanced = <O, D extends ZodTypeDef, I>(
	type: any
): type is ZodTypeEnhanced<O, D, I> =>
	type._def !== undefined && type.meta !== undefined

// Create a proxy to delegate method calls
export const asField = <
	M extends FieldMeta,
	O = any,
	D extends ZodTypeDef = ZodTypeDef,
	I = O
>(
	schema: ZodType<O, D, I>,
	meta: M
): ZodTypeEnhanced<O, D, I> => {
	return new Proxy(schema, {
		get(target: any, prop: string) {
			if (prop === 'meta') {
				return meta
			}
			if (prop === 'original') {
				return schema
			}
			if (typeof target[prop] === 'function') {
				return (...args: any[]) => target[prop](...args)
			}
			return target[prop]
		}
	})
}
```

then all I need to do is wrap the codecs with asField like so:

```typescript
object({
	...
	parent_id: asField(number().optional(), {
		label: 'Parent',
		placeholder: 'No parent',
		description: 'From which tag should values be inherited from?',
		editor: EditorType.Select,
		options: ....
	})
})
```
I'm pretty sure this would spark a ton of plugins for zod if it were natively supported."
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2344638164,Can you provide `tsconfig.json`
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2344777936,"```json
{
  ""compilerOptions"": {
    /* Base Options: */
    ""esModuleInterop"": true,
    ""skipLibCheck"": true,
    ""target"": ""ESNext"",
    ""allowJs"": true,
    ""resolveJsonModule"": true,
    ""moduleDetection"": ""force"",
    ""isolatedModules"": true,

    /* Strictness */
    ""strict"": true,
    ""noUncheckedIndexedAccess"": true,
    ""checkJs"": true,

    /* Bundled projects */
    ""lib"": [""dom"", ""dom.iterable"", ""ESNext""],
    ""noEmit"": true,
    ""module"": ""ESNext"",
    ""moduleResolution"": ""Bundler"",
    ""jsx"": ""preserve"",
    ""plugins"": [{ ""name"": ""next"" }],
    ""incremental"": true,

    /* Path Aliases */
    ""baseUrl"": ""."",
    ""paths"": {
      ""~/*"": [""./src/*""]
    },
    ""types"": [""cypress""]
  },
  ""include"": [
    "".eslintrc.cjs"",
    ""next-env.d.ts"",
    ""**/*.ts"",
    ""**/*.tsx"",
    ""**/*.cjs"",
    ""**/*.js"",
    "".next/types/**/*.ts""
  ],
  ""exclude"": [""node_modules""]
}
```"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2345716279,I got the same error
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2346050907,"> ```json
> {
>   ""compilerOptions"": {
>     /* Base Options: */
>     ""esModuleInterop"": true,
>     ""skipLibCheck"": true,
>     ""target"": ""ESNext"",
>     ""allowJs"": true,
>     ""resolveJsonModule"": true,
>     ""moduleDetection"": ""force"",
>     ""isolatedModules"": true,
> 
>     /* Strictness */
>     ""strict"": true,
>     ""noUncheckedIndexedAccess"": true,
>     ""checkJs"": true,
> 
>     /* Bundled projects */
>     ""lib"": [""dom"", ""dom.iterable"", ""ESNext""],
>     ""noEmit"": true,
>     ""module"": ""ESNext"",
>     ""moduleResolution"": ""Bundler"",
>     ""jsx"": ""preserve"",
>     ""plugins"": [{ ""name"": ""next"" }],
>     ""incremental"": true,
> 
>     /* Path Aliases */
>     ""baseUrl"": ""."",
>     ""paths"": {
>       ""~/*"": [""./src/*""]
>     },
>     ""types"": [""cypress""]
>   },
>   ""include"": [
>     "".eslintrc.cjs"",
>     ""next-env.d.ts"",
>     ""**/*.ts"",
>     ""**/*.tsx"",
>     ""**/*.cjs"",
>     ""**/*.js"",
>     "".next/types/**/*.ts""
>   ],
>   ""exclude"": [""node_modules""]
> }
> ```

Can you try these settings?

{ ""compilerOptions"": { ""target"": ""ESNext"", ""module"": ""ESNext"", ""allowImportingTsExtensions"": true, ""moduleResolution"": ""Bundler"", ""noEmit"": true, ""esModuleInterop"": true, ""strict"": true } }"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2346394127,"I am getting the same error from many days in the vs code.
"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2346398711,"when did you start getting it?- JacobOn Sep 12, 2024, at 09:03, Taksh Chanana ***@***.***> wrote:﻿
I am getting the same error from many days in the vs code.

—Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you authored the thread.Message ID: ***@***.***>"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2346400076,"![Screenshot from 2024-09-12 19-35-11](https://github.com/user-attachments/assets/bdebb3fe-873e-429f-9c7c-d75bef4cbd42)
"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2356777215,"> allowImportingTsExtensions

same"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2356867870,"This fixes it for me:

in `eslint.config.mjs`, add the zod plugin:

```js
import typescriptEslint from ""@typescript-eslint/eslint-plugin"";
import drizzle from ""eslint-plugin-drizzle"";
import zod from ""eslint-plugin-zod"";
import tsParser from ""@typescript-eslint/parser"";
import path from ""node:path"";
import { fileURLToPath } from ""node:url"";
import js from ""@eslint/js"";
import { FlatCompat } from ""@eslint/eslintrc"";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all
});

export default [...compat.extends(
  ""next/core-web-vitals"",
  ""plugin:@typescript-eslint/recommended-type-checked"",
  ""plugin:@typescript-eslint/stylistic-type-checked"",
), {
  plugins: {
    ""@typescript-eslint"": typescriptEslint,
    drizzle,
    zod,
  },

  languageOptions: {
    parser: tsParser,
    ecmaVersion: 5,
    sourceType: ""script"",

    parserOptions: {
      project: true,
    },
  },

  rules: {
    ""zod/prefer-enum"": 2,
    ""zod/require-strict"": 2,

    ""@typescript-eslint/array-type"": ""off"",
    ""@typescript-eslint/consistent-type-definitions"": ""off"",

    ""@next/next/no-duplicate-head"": ""off"",
    ""import/no-anonymous-default-export"": ""off"",

    ""@typescript-eslint/consistent-type-imports"": [""warn"", {
      prefer: ""type-imports"",
      fixStyle: ""inline-type-imports"",
    }],

    ""@typescript-eslint/no-unused-vars"": [""warn"", {
      argsIgnorePattern: ""^_"",
    }],

    ""@typescript-eslint/require-await"": ""off"",

    ""@typescript-eslint/no-misused-promises"": [""error"", {
      checksVoidReturn: {
        attributes: false,
      },
    }],

    ""@typescript-eslint/no-empty-object-type"": ""off"",

    ""drizzle/enforce-delete-with-where"": [""error"", {
      drizzleObjectName: [""db"", ""ctx.db""],
    }],

    ""drizzle/enforce-update-with-where"": [""error"", {
      drizzleObjectName: [""db"", ""ctx.db""],
    }],

    ""@typescript-eslint/no-unsafe-member-access"": ""off"",
    ""@typescript-eslint/no-unsafe-call"": ""off"",
    ""@typescript-eslint/no-unsafe-assignment"": ""off"",
    ""@typescript-eslint/no-unsafe-argument"": ""off"",
  },
}];
```

Then install the dependencies:

```bash
bun add @eslint/js @eslint/eslintrc @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint eslint-plugin-react eslint-plugin-jsx-a11y eslint-plugin-import eslint-plugin-drizzle eslint-plugin-zod 
```

For reference, here's my `package.json`:

```json
{
  ""name"": ""aii"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""build"": ""next build"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""dev"": ""next dev"",
    ""lint"": ""next lint"",
    ""start"": ""next start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@fullcalendar/daygrid"": ""^6.1.15"",
    ""@fullcalendar/interaction"": ""^6.1.15"",
    ""@fullcalendar/react"": ""^6.1.15"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-alert-dialog"": ""^1.1.1"",
    ""@radix-ui/react-collapsible"": ""^1.1.0"",
    ""@radix-ui/react-context-menu"": ""^2.2.1"",
    ""@radix-ui/react-dialog"": ""^1.1.1"",
    ""@radix-ui/react-hover-card"": ""^1.1.1"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@radix-ui/react-label"": ""^2.1.0"",
    ""@radix-ui/react-menubar"": ""^1.1.1"",
    ""@radix-ui/react-progress"": ""^1.1.0"",
    ""@radix-ui/react-select"": ""^2.1.1"",
    ""@radix-ui/react-separator"": ""^1.1.0"",
    ""@radix-ui/react-slider"": ""^1.2.0"",
    ""@radix-ui/react-slot"": ""^1.1.0"",
    ""@radix-ui/react-switch"": ""^1.1.0"",
    ""@radix-ui/react-tabs"": ""^1.1.0"",
    ""@radix-ui/react-toggle"": ""^1.1.0"",
    ""@radix-ui/react-toggle-group"": ""^1.1.0"",
    ""@radix-ui/react-tooltip"": ""^1.1.2"",
    ""@sendgrid/mail"": ""^8.1.3"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""eslint-plugin-import"": ""^2.30.0"",
    ""eslint-plugin-jsx-a11y"": ""^6.10.0"",
    ""eslint-plugin-react"": ""^7.36.1"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.441.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""node-cron"": ""^3.0.3"",
    ""nodemailer"": ""^6.9.15"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""react-hook-form"": ""^7.53.0"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""zod"": ""^3.23.8""
  },
  ""devDependencies"": {
    ""@eslint/eslintrc"": ""^3.1.0"",
    ""@eslint/js"": ""^9.10.0"",
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.6.0"",
    ""@typescript-eslint/parser"": ""^8.6.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^9.10.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""eslint-plugin-zod"": ""^1.4.0"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2372878644,"Okay so for those of us who don't have any linting rules and have this stupid error, what the heck is it"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2373071115,"yeah linting configuration didn’t actually fix it for me either- JacobOn Sep 24, 2024, at 23:13, ZachHandley ***@***.***> wrote:﻿
Okay so for those of us who don't have any linting rules and have this stupid error, what the heck is it

—Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you authored the thread.Message ID: ***@***.***>"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2374314654,"@colinhacks can you please fix this or look at this, something got effed

```bash
❯ bun install
bun install v1.1.30-canary.34 (17d719fa)

+ vite-tsconfig-paths@5.0.1
+ @astrojs/check@0.9.3
+ @astrojs/cloudflare@11.1.0
+ @astrojs/partytown@2.1.2
+ @astrojs/sitemap@3.1.6
+ @astrojs/tailwind@5.1.1
+ @astrojs/vue@4.5.1
+ @directus/sdk@17.0.1
+ @iconify/vue@4.1.2
+ @inox-tools/astro-when@0.2.3
+ @nanostores/persistent@0.10.2
+ @nanostores/vue@0.10.0
+ @vueuse/core@11.1.0
+ astro@4.15.9
+ nanostores@0.11.3
+ sweetalert2@11.14.1
+ tailwindcss@3.4.13
+ typescript@5.6.2
+ vue@3.5.8
+ zastro-service-worker@0.0.3
+ zod@3.23.8

865 packages installed [164.71s]
```

okay great, so it's installed right? and I can use it right?
![image](https://github.com/user-attachments/assets/b34feb42-fbb3-4729-8c02-a4351ccb0a9c)

okay............................................. idk what the hell to do here. No package manager properly resolves it and it's broken now on multiple projects."
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2374347897,i should clarify that this is not a eslint error. because even if i get eslint to shut up next build still fails
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2374365014,^ correct. Something got effed.
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2395468058,"I have the same issue with Typescript 5.6, but it works fine with Typescript 5.5.

I suspect the problem is related to [this change](https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/#respecting-file-extensions-and-package.json-from-within-node_modules) ([related Typescript pull request](https://github.com/microsoft/TypeScript/pull/58825)). This change was already in the typescript@5.5.1-rc prerelease, and I'm also encountering the issue when using this version."
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2395495126,"I fixed above issue by putting the following inside the tsconfig.json for your front end project **NOT** Amplify file:

```
{
  ""compilerOptions"": {
    ...
    ""esModuleInterop"": true
    ...
  }
}
```
"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2403559062,"1. Add this to your package.json dependency (^ is the problem)
```
""zod"": ""3.22.4""
```

2. Remove node_modules(`sudo rm -rf node_modules`)
3. Re-install npm modules (`npm i`)"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2407877765,"careful with the sudo rm- JacobOn Oct 9, 2024, at 15:52, Taksh Chanana ***@***.***> wrote:﻿

Add this to your package.json dependency (^ is the problem)

""zod"": ""3.22.4""


Remove node_modules(sudo rm -rf node_modules)
Re-install npm modules (npm i)


—Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you authored the thread.Message ID: ***@***.***>"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2439704006,"> 1. Add this to your package.json dependency (^ is the problem)

^ is not the problem. ^ merely allows to get the newest 3.x.x version out there. The real problem is the specific version ^3 gets you and since I just installed zod in my new project my version looks like this `""zod"":""^3.23.8`. Removing the ^ does literally nothing in my case.

But sure, I installed v3.22.4 and it worked, so then I kept upgrading zod until it broke. v3.23.7 works and v3.23.8 doesnt.

Also, v3.23.8 works with commonjs. It's just the ESM part that's broken."
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2470270575,any update on the issue ? using pnpm instead of bun seems to resolve the issue.
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2471796532,"hmm thank u ill stick with pnpm then- JacobOn Nov 12, 2024, at 03:22, catinrage ***@***.***> wrote:﻿
any update on the issue ? using pnpm instead of bun seems to resolve the issue.

—Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you authored the thread.Message ID: ***@***.***>"
2502927180,3737,zod import triggers an error in typescript,"tsx v4.19.0
node v22.7.0
zod version: ""^3.23.8""

tsconfig:

```json
{
  ""compilerOptions"": {
    ""target"": ""ESNext"",
    ""module"": ""NodeNext"",
    ""allowImportingTsExtensions"": true,
    ""moduleResolution"": ""NodeNext"",
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""strict"": true
  }
}
```


code:

```ts
import { z } from ""zod"";
```

yields in vscode

```txt
Cannot find module 'zod' or its corresponding type declarations.ts(2307)
```

but running it works",2344624486,"Can you try it like this?

`{
  ""compilerOptions"": {
    ""target"": ""ESNext"",
    ""module"": ""ESNext"",
    ""allowImportingTsExtensions"": true,
    ""moduleResolution"": ""Bundler"",
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""strict"": true
  }
}`"
2502927180,3737,zod import triggers an error in typescript,"tsx v4.19.0
node v22.7.0
zod version: ""^3.23.8""

tsconfig:

```json
{
  ""compilerOptions"": {
    ""target"": ""ESNext"",
    ""module"": ""NodeNext"",
    ""allowImportingTsExtensions"": true,
    ""moduleResolution"": ""NodeNext"",
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""strict"": true
  }
}
```


code:

```ts
import { z } from ""zod"";
```

yields in vscode

```txt
Cannot find module 'zod' or its corresponding type declarations.ts(2307)
```

but running it works",2344950121,actually now it works. weird.
2501486499,3735,Incorrect type derivation when using z.array() with z.transform(),"In a much bigger project, I have a compile error where it complains that a type ""string | boolean"" can't be assigned to ""boolean.""
I want to define a boolean field that can coerce from string.
Unfortunately, ""coerce"" doesn't work, because the string ""false"" is coerced to true, because it's JavaScript truthy.
Thus, I tried using transform() instead.

Here is the small reproduction case:

```
import { z } from ""zod"";

export const ZInner = z.strictObject({
        a_string: z.string(),
        a_boolean: z.boolean().or(
                z.string().transform((v, ctx) => {
                        if (v === ""true"") return true;
                        if (v === ""false"" || v === """") return false;
                        ctx.addIssue({ code: z.ZodIssueCode.custom, message: ""invalid boolean value: "" + v });
                        return false;
                })
        ),
});
export type IInner = z.infer<typeof ZInner>;

export const ZOuterList: z.ZodType<IInner[]> = z.lazy(() => z.array(ZInner));
export type IOuterList = z.infer<typeof ZOuterList>;
```

This gives the following error:

```
> tsc --build --pretty

src/index.ts:16:14 - error TS2322: Type 'ZodLazy<ZodArray<ZodObject<{ a_string: ZodString; a_boolean: ZodUnion<[ZodBoolean, ZodEffects<ZodString, boolean, string>]>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, ""many"">>' is not assignable to type 'ZodType<{ a_string?: string; a_boolean?: boolean; }[], ZodTypeDef, { a_string?: string; a_boolean?: boolean; }[]>'.
  Types of property '_input' are incompatible.
    Type '{ a_string?: string; a_boolean?: string | boolean; }[]' is not assignable to type '{ a_string?: string; a_boolean?: boolean; }[]'.
      Type '{ a_string?: string; a_boolean?: string | boolean; }' is not assignable to type '{ a_string?: string; a_boolean?: boolean; }'.
        Types of property 'a_boolean' are incompatible.
          Type 'string | boolean' is not assignable to type 'boolean'.
            Type 'string' is not assignable to type 'boolean'.

16 export const ZOuterList: z.ZodType<IInner[]> = z.lazy(() => z.array(ZInner));
```

It is my assumption that, if `IInner` is boolean-only, then `z.array(ZInner)` should also be.
However, this doesn't seem to hold true.
",2325226657,"Also, the `lazy()` doesn't matter (happens without it,) and trying to tack on `.pipe(z.coerce.boolean())` doesn't work, same error."
2501486499,3735,Incorrect type derivation when using z.array() with z.transform(),"In a much bigger project, I have a compile error where it complains that a type ""string | boolean"" can't be assigned to ""boolean.""
I want to define a boolean field that can coerce from string.
Unfortunately, ""coerce"" doesn't work, because the string ""false"" is coerced to true, because it's JavaScript truthy.
Thus, I tried using transform() instead.

Here is the small reproduction case:

```
import { z } from ""zod"";

export const ZInner = z.strictObject({
        a_string: z.string(),
        a_boolean: z.boolean().or(
                z.string().transform((v, ctx) => {
                        if (v === ""true"") return true;
                        if (v === ""false"" || v === """") return false;
                        ctx.addIssue({ code: z.ZodIssueCode.custom, message: ""invalid boolean value: "" + v });
                        return false;
                })
        ),
});
export type IInner = z.infer<typeof ZInner>;

export const ZOuterList: z.ZodType<IInner[]> = z.lazy(() => z.array(ZInner));
export type IOuterList = z.infer<typeof ZOuterList>;
```

This gives the following error:

```
> tsc --build --pretty

src/index.ts:16:14 - error TS2322: Type 'ZodLazy<ZodArray<ZodObject<{ a_string: ZodString; a_boolean: ZodUnion<[ZodBoolean, ZodEffects<ZodString, boolean, string>]>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, ""many"">>' is not assignable to type 'ZodType<{ a_string?: string; a_boolean?: boolean; }[], ZodTypeDef, { a_string?: string; a_boolean?: boolean; }[]>'.
  Types of property '_input' are incompatible.
    Type '{ a_string?: string; a_boolean?: string | boolean; }[]' is not assignable to type '{ a_string?: string; a_boolean?: boolean; }[]'.
      Type '{ a_string?: string; a_boolean?: string | boolean; }' is not assignable to type '{ a_string?: string; a_boolean?: boolean; }'.
        Types of property 'a_boolean' are incompatible.
          Type 'string | boolean' is not assignable to type 'boolean'.
            Type 'string' is not assignable to type 'boolean'.

16 export const ZOuterList: z.ZodType<IInner[]> = z.lazy(() => z.array(ZInner));
```

It is my assumption that, if `IInner` is boolean-only, then `z.array(ZInner)` should also be.
However, this doesn't seem to hold true.
",2325426709,"Looking at this some more, the problem here is that the `z.ZodType<Output, Def, Input>` typedef defaults `Input` to `Output` and in this case, `Input` is something else.
So, I have to indirect another type for the `z.input<typeof ZInner>` and pass that to the `ZodType` definition, and then it works.
"
2499245240,3734,Add Optional Descriptions to Enums in Zod for Enhanced Schema Clarity,"Enums are widely used to represent a fixed set of values but cannot currently carry additional metadata such as descriptions. Adding optional descriptions would make schemas more informative and easier to understand, especially in complex applications where context is key.

``` ts

import { z } from ""zod"";

// Current approach without descriptions
export const ProductCategorySchema = z.enum([""electronics"", ""clothing"", ""furniture""]);

// Descriptions would be managed separately
const categoryDescriptions = {
    electronics: ""Devices and gadgets such as smartphones, laptops, and cameras."",
    clothing: ""Apparel including shirts, pants, dresses, and accessories."",
    furniture: ""Home and office furnishings like chairs, tables, and sofas.""
};

// Usage example
const selectedCategory = ""electronics"";
const description = categoryDescriptions[selectedCategory] || ""No description available"";
console.log(`Category: ${selectedCategory}`);
console.log(`Description: ${description}`);

```

### Proposed Implementation
**Extend Zod’s Enum Schema:** Add optional description support directly within Zod’s enum definitions, allowing for cleaner and more integrated schema management.

``` ts
import { z } from ""zod"";

// Define a schema with optional descriptions
export const ProductCategorySchema = z.enum([
    { value: ""electronics"", description: ""Devices and gadgets such as smartphones, laptops, and cameras."" },
    { value: ""clothing"", description: ""Apparel including shirts, pants, dresses, and accessories."" },
    { value: ""furniture"", description: ""Home and office furnishings like chairs, tables, and sofas."" }
]);

// Accessing descriptions directly
const category = ProductCategorySchema.enumValues.find(v => v.value === ""electronics"");
console.log(`Category: ${category.value}`);
console.log(`Description: ${category.description}`);

```
**Backward Compatibility**
**Non-Disruptive Change:** This feature introduces descriptions as an optional addition to enums. Existing code using enums without descriptions will remain unaffected.
**Optional Descriptions:** The feature will be available but not required, allowing developers to adopt it at their own pace.",,
2494077055,3731,Help about zod arrays and strings,"i am working on a simple project and i got stuck in working with zod arrays:
currently i am pushing a zod string into the array then it works with the input element but the form won't submit bcz of the field and the field isn't validated.

```
export const formSchema = z.object({
        origins: z.array(z.string().min(1).max(256)
//      origins: z.string().array().min(1).max(256)
});
```

```
<script lang=""ts"">
	import { zodClient } from ""sveltekit-superforms/adapters"";
	import { superForm } from ""sveltekit-superforms"";
	import { formSchema } from ""./schema.js"";
	import { loadStore } from ""$lib/store"";
	import { z } from ""zod"";
	export let data;

	// HERE IS THE ISSUE SO PLS HLP
	function addOrigin() {
		if ($formData.origins.length >= 5) {
			toast.error(""Reached the origins limit."", {
				action: {
					label: ""Close"",
					onClick: () => { return; }
				}
			})
			return;
		}

		$formData.origins.push(z.string().min(1).max(256)) // ONCE PUSHED THE FIELD SHOWS '[object Object]'
		$formData.origins = [...$formData.origins]
	}

	const form = superForm(data.form, {
		validators: zodClient(formSchema),
	});
	const { form: formData, message, enhance } = form;
	$: if ($message) toast.error($message)

	addOrigin()
	$: for (let i = 0; i < $formData.origins.length; i += 1) {
		console.log($formData.origins[i])
	}
</script>

<form method=""POST"" use:enhance>
		<label>Origin</label>
		{#each $formData.origins as origin, index}
			<div class=""flex w-full flex-row"">
				<input type=""text"" placeholder=""Http Origins"" autofocus=""1""bind:value={$formData.origins[index]} />
				<button on:click={remOrigin}>
					Remove a Field
				</button>
			</div>
		{/each}
		<button on:click={addOrigin}>
			Add a Field
		</button>
		<button type=""submit"">Continue</button>
</form>
```",2317967417,"Uh, If I understand correctly, there seems to be a misunderstanding. Zod is used to generate schemas. The `$formData.origins` requires actual data, while a schema is used to validate that data. A schema itself cannot be treated as data, so it's important not to mix these two concepts together."
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2318204702,"I found the relevant code, and since they used `undefined extends T`, if they had used `assertEqual<undefined, T>`, the optional situation wouldn't have occurred. So I believe this was intentional.

https://github.com/colinhacks/zod/blob/8552233c77426f77d3586cc877f7aec1aa0aa45b/src/helpers/util.ts#L107-L109"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2337744535,I have the same issue
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2380631058,ran into the same issue ... i partially agree with it being optional but would need something like a `.required()` then?! are there any workarounds? 
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381138080,The feature [existed](#494) but was [rolled back](#519).  😅
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381274856,Workaround from another thread https://github.com/colinhacks/zod/issues/1628#issuecomment-1338136697
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381331254,"> Workaround from another thread [#1628 (comment)](https://github.com/colinhacks/zod/issues/1628#issuecomment-1338136697)

this does not seem to resolve the problem:

<img width=""338"" alt=""image"" src=""https://github.com/user-attachments/assets/cc3eb868-8f35-4b93-8d1f-d90b054d093e"">
"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381338776,`z.custom<someTypeHere>(x => x !== undefined)`
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381341798,"nope

<img width=""482"" alt=""image"" src=""https://github.com/user-attachments/assets/c6714646-9d73-49eb-a931-c0048287a3ba"">
"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381344755,"@schwarmco You can try any type, except for `unknown` and `any`."
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381345200,"> @schwarmco You can try any type, except for `unknown` and `any`.

of course! but the whole topic on this issue is to have non-optional any and unknown!?"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381346676,`z.custom<object>(x => x !== undefined)` works
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381346968,":sob: Oops, I lost track of the topic."
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381351702,"`z.custom<Required<unknown>>(x => x !== undefined)`
`z.custom<Required<any>>(x => x !== undefined)`

Maybe ☝️ is ok"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"Hello👋,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381355840,"> `z.custom<Required<any>>(x => x !== undefined)`

this is actually a valid workaround - really appreciate your efforts @darky and @sunnylost :) really think, there should be a zod-way of doing that though.
"
2486967236,3726,Question: How to extend/copy array schema but only change the containing type,"Hello

I have a question regarding arrays.

Given following simple example

```typescript
const myObjSchema = z.object({
  name: z.string(),
});

const arrayOfMyObj = z.array(myObjSchema).min(1).max(2);
```

What i wanna do is kind of changing the containing type of the array like this.

```typescript
const arrayOfMyObjExt = arrayOfMyObj.changeType(myObjSchema.extend({ foo:z.string()}));
```

but i want to keep the constraints of **min** and **max** of the original array.

Why do i need this?

I want to extend and existing schema with some OpenAPI documentation and i **do not have access to the original
schema definitions**. I want to keep as much from the original schema as possible to not run out of sync.
For **z.object** i can use **extends** but there is nothing like this for **z.array**.

Any hints?

Thank you so much for help.

",2315363586,"Maybe you can try something like this:

```ts
const arrayOfMyObj = z.array(myObjSchema).min(1).max(2);

const newSchema = arrayOfMyObj.and(
  z.array(
    z.object({
      foo: z.string(),
    })
  )
);
```

Transforms original schema into an Intersection type."
2486452258,3725,Unable to Chain .min() and Other Validation Methods After .refine() on z.string(),"Zod version: 3.23.8

When writing the following Zod schema:
```typescript
z.string()
  .refine((val) => val === ""John"", {
    message: ""String must be equal to 'John'"",
  })
  .min(1)
```
I expected this validation code to be valid and check whether the string has a minimum length of 1. However, instead of that, I get an error stating that `.min()` is not a function. This error suggests that chaining `.min()` or other validation methods after `.refine()` is not supported.

**Expected Behavior:**

I expect to still be able to use `.min()` and other validation methods (such as `.max()`, etc.) after using `.refine()`. This would allow me to build more complex validation rules without running into method chaining issues.

**Current Behavior:**

Currently, attempting to chain `.min()` (or similar validation methods) after `.refine()` on `z.string()` results in an error: `TypeError: .min is not a function`. This behavior limits the flexibility of combining custom validation logic with built-in methods.

**Use Case:**

In my codebase, I rely on the ability to combine custom validation logic using `.refine()` with built-in methods such as `.min()`. Being able to chain these methods makes the code more concise and maintainable.

**Proposed Solution:**

It would be helpful if `.min()`, `.max()`, and similar validation methods were still accessible after using `.refine()`, or if there were an alternative approach to achieve the same result.

**Request for Feedback:**

I would appreciate feedback on whether this behavior is intentional, and if so, whether there are recommended workarounds or plans to support this kind of chaining in the future.",2309955424,"I've come up with a temporary workaround using an `if` statement to check whether the `.min()` method is available:
```javascript
import z from ""zod"";

let schema = z.string();

schema = schema.refine((val) => val === ""John"", {
  message: ""String must be equal to 'John'"",
});

if (schema.min) {
  console.log(""min is available to use"");
  schema = schema.min(1);
} else {
  console.log(""min is NOT available to use"");
  schema = schema.refine((val) => val.length >= 1);
}

console.log(schema.safeParse(""John""));
```
While this approach works, it adds unnecessary complexity and feels a bit messy. It would be much more straightforward if chaining methods like `.min()` after `.refine()` were supported natively in Zod."
2486452258,3725,Unable to Chain .min() and Other Validation Methods After .refine() on z.string(),"Zod version: 3.23.8

When writing the following Zod schema:
```typescript
z.string()
  .refine((val) => val === ""John"", {
    message: ""String must be equal to 'John'"",
  })
  .min(1)
```
I expected this validation code to be valid and check whether the string has a minimum length of 1. However, instead of that, I get an error stating that `.min()` is not a function. This error suggests that chaining `.min()` or other validation methods after `.refine()` is not supported.

**Expected Behavior:**

I expect to still be able to use `.min()` and other validation methods (such as `.max()`, etc.) after using `.refine()`. This would allow me to build more complex validation rules without running into method chaining issues.

**Current Behavior:**

Currently, attempting to chain `.min()` (or similar validation methods) after `.refine()` on `z.string()` results in an error: `TypeError: .min is not a function`. This behavior limits the flexibility of combining custom validation logic with built-in methods.

**Use Case:**

In my codebase, I rely on the ability to combine custom validation logic using `.refine()` with built-in methods such as `.min()`. Being able to chain these methods makes the code more concise and maintainable.

**Proposed Solution:**

It would be helpful if `.min()`, `.max()`, and similar validation methods were still accessible after using `.refine()`, or if there were an alternative approach to achieve the same result.

**Request for Feedback:**

I would appreciate feedback on whether this behavior is intentional, and if so, whether there are recommended workarounds or plans to support this kind of chaining in the future.",2321241066,"After you use something like refine() or transform(), the return value will be a `ZodEffect`, not a `ZodType` anymore. While you can use pipe() to chain another schema, it can seem verbose in this scenario.

```ts
z
  .string()
  .refine((val) => val === ""John"", {
    message: ""String must be equal to 'John'"",
  })
  .pipe(z.string().min(10));
```"
2485647700,3724,Bug: Defining schema shape causes a TS error when it shouldn't,"### Description
When defining the schema shape using a type (`const Schema: z.ZodType<MyType> = ...`) Typescript is raises an error when using a schema and the pipe method.

I believe it to be a bug as the correct type is inferred from the schema.

### Example
Zod Version 3.23.8

```
import { z } from ""zod"";

export const StringListSchema = z.string().transform((input) => input?.split("",""));

export type InputType = {
  strings?: string[];
};

const Schema: z.ZodType<InputType> = z.object({
  strings: StringListSchema.pipe(z.array(z.string())).optional(),
});
// Type Error: Type 'string | undefined' is not assignable to type 'string[] | undefined'.

export type OutputType = z.infer<typeof Schema>;
// Infered Type: type OutputType = { strings?: string[] | undefined; }

console.log(Schema.parse({ strings: ""one,two"" }));
// Output: { strings: [ 'one', 'two' ] }
```",,
2476531764,3719,Workarounds for TS 7056?,"Hi guys. I'm pretty new to Zod. I have a project with some large schemas and I am frequently running into this error:
```
TS7056: The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.
```

It seems that it has to do mainly with typescript hitting a hard maximum for schemas of a certain size, as I can trigger it just by adding or removing one property on a schema. Splitting the big schema into multiple variables or files does not help.

Would like to know if there are any good workarounds to this. There has been a [past issue](https://github.com/colinhacks/zod/issues/1040) but none of the solutions in that thread have helped for me. The only thing I haven't tried is to monkey-patch tsc, but I would like to avoid that.

Thanks!",,
2472196141,3716,Improve regex DX by adding babel-plugin-transform-regex as dev dependency,"What do you think about adding the [regex](https://github.com/slevithan/regex) package's [Babel plugin](https://github.com/slevithan/babel-plugin-transform-regex) to devDependencies? Since Zod uses a lot of complex regexes, this would allow writing them it a readable and maintainable way that gets transpiled away into native JS regex literals.

From `regex`'s [readme](https://github.com/slevithan/regex#readme):

> `regex` is a template tag that extends JavaScript regular expressions with features from other leading regex libraries that make regexes more powerful and dramatically more readable. It returns native `RegExp` instances that run with native performance, and can exceed the performance of regex literals you'd write yourself. It's also lightweight, has no dependencies, supports all ES2025 regex features, has built-in TypeScript declarations, and can be used as a [Babel plugin](https://github.com/slevithan/babel-plugin-transform-regex) to avoid any runtime dependencies or user runtime cost.
>
> Highlights include support for free spacing and comments, atomic groups via `(?>…)` and possessive quantifiers (e.g. `++`) that can help you avoid [ReDoS](https://en.wikipedia.org/wiki/ReDoS), subroutines via `\g<name>` and subroutine definition groups via `(?(DEFINE)…)` that enable powerful subpattern composition, and context-aware interpolation of regexes, escaped strings, and partial patterns.
>
> With the `regex` library, JavaScript steps up as one of the best regex flavors alongside PCRE and Perl, possibly surpassing C++, Java, .NET, Python, and Ruby.

Note that all of `regex`'s syntax is a strict superset of JS, and its syntax extensions work identically in PCRE (the regex library used by PHP and many others), so there is nothing magical or surprising.

This would allow changing e.g. the unreadable/unmaintainable `ipv4Regex` from `src/types.ts`:

```js
/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
```

To the much nicer:

```js
regex`^
  (?<byte> 25[0-5] | 2[0-4]\d | 1\d\d | [1-9]?\d)
  (\. \g<byte>){3}
$`
```

That would then get transpiled into a native regex literal (you can try it [here](https://slevithan.github.io/babel-plugin-transform-regex/demo/)), without any added runtime dependency or run-time cost for users.

Some of the other regexes in `src/types.ts` would benefit more significantly. To give one more example, here's the `ipv6Regex` regex that's currently used:

`/^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/`

And here is the same regex refactored using `regex`, taking advantage of subroutines and a subroutine definition group:

```js
regex`
  ^ \g<ipv6> $

  (?(DEFINE)
    (?<ipv6>
      ( \g<part>{7}
      | :: \g<part>{0,6}
      | \g<part>    : \g<part>{0,5}
      | \g<part>{2} : \g<part>{0,4}
      | \g<part>{3} : \g<part>{0,3}
      | \g<part>{4} : \g<part>{0,2}
      | \g<part>{5} : \g<part>?
      )
      (\g<segment> | \g<ipv4>)
    )
    (?<part>    \g<segment> :)
    (?<segment> [a-f\d]{1,4})
    (?<ipv4>    \g<byte> (\. \g<byte>){3})
    (?<byte>    25[0-5] | 2[0-4]\d | 1\d\d | [1-9]?\d)
  )
`
```

Written like this, mortals can understand it, spot bugs, and maintain it (e.g. if you wanted to add support for IPv6 zone identifiers), and other mortals can review those changes. The regex literal emitted for this by `regex` also runs faster, because it avoids all the unnecessary capturing groups in the original (by default, `regex` implicitly uses flag `n` or ""named capture only"" mode).

To demonstrate that regex readability matters, after rewriting it like this I easily spotted several errors. For example, it doesn't match the following valid addresses:

- 2001:db8:3:4:5:6:1.2.3.4
- 2001:db8::
- ::

Also, it thinks the following addresses are valid (they aren't since there should be 6 IPv6 segments rather than 7 in mixed addresses):

- 1:2:3:4:5:6:7:1.2.3.4
- ::2:3:4:5:6:7:1.2.3.4

Good luck to anyone who wants to fix these bugs in the original version of the regex. Personally, I don't want to touch it. 😖 And I'm in the 99th percentile of developers comfortable with reading and editing complex regexes. Perhaps these issues could have been caught with more tests, but tests are no substitute for readability since being able to understand the regexes helps people know where the gaps might be that need testing, and it allows far more people to spot issues.

If you think this could be helpful, I'd be happy to submit a PR that that adds the dev dependency and updates all of the regexes (at least those that would benefit) for readability. My recommendation would be to extract the regexes out of `src/types.ts` into `src/regex.ts`, which `types.ts` would import. Then the Babel plugin would run only on `regex.ts`.",,
2465327140,3710,Inferred type imported from library has all fields as optional,"I've got a schema and inferred type in a library:
```ts
const schema = z.object({
  name: z.string(),
  address: z.string(),
});

type SchemaType = z.infer<typeof schema>;
```
I'm importing this inferred type into a project, and for some reason all of the fields are showing as potentially undefined. It's got an enum in there and it also shows undefined.

The type signature for the schema in the library looks like this:

```ts
const schema = z.ZodObject<{
  name: z.ZodString;
  addresss: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
  name: string;
  address: string;
}, {
  ...;
}>
```

The type signature for the schema when imported into the project looks like this:

```ts
const schema = z.ZodObject<{
  name: z.ZodString;
  addresss: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
  name?: string | undefined;
  address?: string | undefined;
}, {
  ...;
}>
```

I've got `strict: true` in both `tsconfig.json` files (the library and the project). `strictNullChecks` is not set in either.

Library: 
  Zod 3.23.8
  TS 5.4.5

Project:
  Zod 3.23.8
  TS 4.9.5

Where am I going wrong?
",,
2464729078,3708,variadic rest in the tuple with min & max capability,"I have a scenario, where I need to define the schema in the form of a tuple with certain restrictions in length of min, and max on the variadic rest.

```
const TypeOneSchema = z.object({
  name: z.string(),
  value: z.number(),
});

const TypeTwoSchema = z.object({
  title: z.string(),
  amount: z.number(),
});


const TupleSchema = z.tuple([
  TypeOneSchema, **// First element: TypeOneSchema**
  z.array(TypeTwoSchema).min(1).max(3) **// Rest elements: 1 to 3 TypeTwoSchema**
]);
Note: The above syntax of the tuple isn't supported, adding it here for a better understanding of the use case.
```

Say something like this:
**For example:** the scenario is that a tuple can be a minimum of 2 items & at max, it can have 4 items in the array.

**// Example usage** 
### Valid
const validTuple1 = [
  { name: 'John', value: 20 },
  { title: 'Title 1', amount: 100 }
];

const validTuple2 = [
  { name: 'John', value: 20 },
  { title: 'Title 1', amount: 100 },
  { title: 'Title 2', amount: 150 }
];

### Invalid
const invalidTuple1 = [
  {name: 'John', value: 20 }
];

const invalidTuple2 = [
  { name: 'John', value: 20 },
  { title: 'Title 1', amount: 100 },
  { title: 'Title 2', amount: 150 },
  { title: 'Title 3', amount: 200 },
];

Please suggest how to achieve this using tuple, because it also gives the benefit of auto-suggestion in the code-editor. ",,
2460221017,3704,Using generic schemas from generic functions makes enum fields optional,"Reopen https://github.com/colinhacks/zod/issues/995.

```typescript
import { z } from 'zod';

function makeSchema<T extends string>(values: readonly [T, ...T[]]) {
  return z.object({
    e: z.enum(values),
    s: z.string(),
  });
}

function useSchema<T extends string>(values: readonly [T, ...T[]], input: unknown): void {
  const schema = makeSchema(values);
  const result = schema.parse(input);
  let { e, s } = result;
  s = e;
}
```

`e` is a string enum. `s` is a string. `e` should be assignable to `s`, but TypeScript disagrees:
```
zod.ts:14:3 - error TS2322: Type 'addQuestionMarks<baseObjectOutputType<{ e: ZodEnum<[T, ...T[]]>; s: ZodString; }>, any>[""e""] | undefined' is not assignable to type 'string'.
  Type 'undefined' is not assignable to type 'string'.

14   s = e;
     ~
```

`e` is declared as a required field. It can't be undefined.",,
2459789379,3703,z.infer<> fails to infer nested union type.,"Hey everyone, I seem to have run into an issue but I'm unsure if this is by design or there's a way around this.
z.infer<exampleSchema> seems to skip an entire schema and only shows a schema of shared fields only for a nested field with a union type. 

```
field: z
        .union([zod1Schema, zod2Schema])
        .nullable()
        .optional(),
```
The result is a type that only shows what's shared between the two schemas and ignores fields from zod2Schema.",,
2459479748,3702,"The above code how to verify whether newPwd and confirmPwd are consistent, and can get a custom message when the verification fails, just like two passwords are inconsistent; Just like if this check doesn't pass, it gets it in errors.message","`export const zr_colorsize_reset_pwd_FormScheme = z
    .object({
        oldPwd: z.string().min(8, { message: ""8+ characters required"" }).trim(),
        newPwd: z.string().min(8, { message: ""1+ characters required"" }).trim(),
        confirmPwd: z
            .string()
            .min(8, { message: ""4+ characters required"" })
            .trim()
    })
`
The above code how to verify whether newPwd and confirmPwd are consistent, and can get a custom message when the verification fails, just like two passwords are inconsistent; Just like if this check doesn't pass, it gets it in errors.message
`.min(8, { message: ""4+ characters required"" })`
",,
2459268498,3701,File zod/index.d.ts is not a module.,"When using zod@3.23.8 on importing I receive the following error:

![image](https://github.com/user-attachments/assets/93c9d570-e03b-4dad-8d18-1f2f9946d517)

3.23.7 works with no errors",,
2457937139,3698,Creating a large schema from a subset,"Hello, how correct this approach is for creating a large schema from a subset?

```
export const createCampaignSchema = z.object({
    ...campaignSetupSchema.shape,
    ...campaignTargetingSchema.shape,
    ...budgetBiddingSchema.shape
});
```",,
2446860887,3687,"Misleading Error: ""Property 'infer' Does Not Exist"" When Using const Instead of type in Zod","I got the Typescript error:

Property 'infer' does not exist on type 'typeof import(.../node_modules/zod/lib/external)

`const CampaignForm = z.infer<typeof CampaignSchema>;`

Looking at the docs and node_modules the property is there.

The issue was using const instead of type.

Expected:
` type CampaignForm = z.infer<typeof CampaignSchema>;`

Actual:
 `const CampaignForm = z.infer<typeof CampaignSchema>`;

The error is misleading.

although i have this issue but for sake of clearity i have copy pasted from stack overflow 
here is the link
[stack overflow question on this issue](https://stackoverflow.com/questions/76111305/zod-property-infer-does-not-exist-on-type-typeof-import-node-modules-zo)
",,
2439778828,3685,Proper inference of a string to typeof keyof Object,"Hello,

I'm starting using Zod and I haven't figure out how  to proper infer string union type from key of an object without using a type guard.

Here is a sample Zod schema : 
```ts
const obj = z.object({
  foo: z.optional(z.boolean()),
  bar: z.optional(z.boolean()),
})
```

And then I have a function that take a string in parameter and I would like to validate it's a key of the object and infer it.

```ts
function checkKey(key: string) {
  if (key in obj.keyof()) {
    // key is still of type 'string', should be 'foo' | 'bar'
}
```

Example stackblitz : https://stackblitz.com/edit/stackblitz-starters-qfu3yi?file=index.ts

Is this something possible without using type guard right now ? Maybe a potential feature ?",,
2434012542,3680,z.string().base64() validation matches non-base64 strings,"**Actual behavior:**
The `z.string().base64()` validation matches non-base64 strings even when a string is empty.

**Expected behavior:**
The `z.string().base64()` validation matches only valid base64 strings.

**Environment:**
- windows 10 22H2;
- node 20.9.0;
- pnpm 8.6.0;
- zod 3.23.8;

**Reproduction:** https://zod-playground.vercel.app?appdata=N4IgzgxgFgpgtgQxALhALwHRgC4CcCWAdgOYAUAlBgEYJgwBsALBQNwgA0IAbggDYCuMMCgDaIAOTiOEwgjgwpncfkTFFEmnSkBdTlxi4w%2BAPaEUIAMwYATFYAcIAL5A

UPD:
According to the [spec](https://datatracker.ietf.org/doc/html/rfc4648#section-10) I see the empty string is valid base64. Additionally, I see it's [tested](https://github.com/colinhacks/zod/blob/821d45b9ed1f3376f3912de15933c92dc926ccbd/src/__tests__/string.test.ts#L167) with the empty string as well, but I think the rest of values in my repro are still non-valid base64 strings.",,
2432939403,3676,Extending zod schema with branded type produces typescript error,"I have a brand in a base schema, which I extend to add additional data, like so:
```ts
import { z } from ""zod"";

const agentBaseSchema = z.object({
  id: z.string().uuid().brand(""Uuid""),
})

enum AgentType {
  CODE_FREE = ""CODE_FREE"",
  MACHINE_CODE = ""MACHINE_CODE"",
}

type AgentBase = z.infer<typeof agentBaseSchema> & {
  type: AgentType 
}

const codeFreeAgentSchema = agentBaseSchema.extend({
  type: z.literal(AgentType.CODE_FREE),
  // Other specific things
})

const machineCodeAgentSchema = agentBaseSchema.extend({
  type: z.literal(AgentType.MACHINE_CODE),
  // Other specific things
})

// ERROR! Type 'string' is not assignable to type string & 'BRAND<""Uuid"">'
const agentSchema = z.union([codeFreeAgentSchema, machineCodeAgentSchema]) satisfies z.ZodSchema<AgentBase>

type Agent = z.infer<typeof agentSchema>
```

[TS playground](https://www.typescriptlang.org/play/?ts=5.4.5&ssl=28&ssc=41&pln=1&pc=1#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8AhgOYCmdMAQsw+wGVqAC3YhmcALwoAdBABGAK3bUYACgQU4cYMQBcsplGB1WagJQyArld0WZ8qMzrE1+AKq3S5gDQU05lScVngAghxcACoAnmDsiFpwAMIA8gAiAKIA+gBiAEoZGVIEqZm5BRn4ftoAsqFJABIAkgBy2aVF0vh1ja3t6ZV+aFQwsfHhnDx88dLIMiaY7FAAPKNxEJhwbJO8-EKi4gB8cABkCdpr7AYTUWNw-lS0jPC0xOw5UOzsNzD7YhLSbZcXaCET-GTsAAeME4rk0FzGBjmABtgDCnMi1D8YnEZB1yoVfIkAPTEuApGCiKBwBhxajATDAahwSkmVgMfyBGj0JhwcQiEzsJIkb4RX5g8TFIFTPYS5gQ6GwjSJS5ImSo9HMTHYsYyHrNNpZDpE7Sk8mUpY0ukMpks4RsjkBR48lhiv6S2bWOjAehqADar3en1Fk3dzB8fOYAroQpFPzDAF1zDTmDBgAxGewGLIAFokMPLH4gw4jO4-YpzBZLVZjDZbN1yktAA)

The `agents` are consumed as a discriminated union on the `type`, as you can see. I'm doing the `satisfies` bit to ensure that new schemas are created properly by other people in the team.

Is there a way to do this? Should I not be doing this?

It seems to be the same idea as https://github.com/colinhacks/zod/issues/2076, but I don't really understand how to apply the solution to my use case since I don't have input/output schemas.",,
2431066838,3675,z.union() ignores custom error message,"```typescript
import { z } from 'zod';

const schema = z.union([z.boolean(), z.number()], { message: 'custom error message' });

const result = schema.safeParse('hello');

if (!result.success) {
    console.log(result.error.errors);
}
```

In this code, I expect that `result.error.errors` emit my custom error message. But I got

```
[
  {
    code: 'invalid_union',
    unionErrors: [ [ZodError], [ZodError] ],
    path: [],
    message: 'Invalid input' // <- this should be 'custom error message'
  }
]
```

Is this specification or bug?",,
2430043008,3673,Support `enumDescriptions`,"The VSCode JSON schema integration supports a custom field [`enumDescriptions`](https://github.com/microsoft/vscode-json-languageservice/blob/fe686d59243664c413654dd6778878c7e0e0ce69/src/jsonSchema.ts#L81) to describe each enum value individually. This is used by various other editors as well. It would be neat if Zod supports this field too, for example:

```js
const kin = z
  .enum([
    'elf',
    'dwarf',
    'human'
  ])
  .describe('Your character lineage', [
    'Elves are a magical people of otherworldly grace',
    'Bold and hardy, dwarves are known as skilled warriors, miners, and workers of stone and metal',
    'Humans are the most adaptable and ambitious people among the common kin'
  ])

console.log(kin.enumDescriptions)
// [
//   'Elves are a magical people of otherworldly grace',
//   'Bold and hardy, dwarves are known as skilled warriors, miners, and workers of stone and metal',
//   'Humans are the most adaptable and ambitious people among the common kin'
// ]
```",,
2426026554,3669,Using nullable() or nullish() alone,"For a specific use case involving a custom type with a complex type union, I need to ensure that a key is defined, but its value can sometimes be undefined or null. I attempted to create a dummy type like this:

```typescript
const myZodObject = z.object({ test: z.nullish() });
// or
const myZodObject = z.object({ test: z.nullable().optional() });
```
However, in both cases, I encountered an error stating that the functions nullable or nullish do not exist.

I can work around this issue by adding a primitive type as shown below, but this solution isn't entirely satisfactory. I am curious to understand why this occurs. Is it due to a technical constraint, such as TypeScript inference, or is it a bug that can be fixed?

If it is a bug, I am willing to investigate further and potentially open a PR to address it. However, I wanted to ask for clarification before proceeding.

Thank you for your help and for this great library, which has already saved me hundreds of hours of work.",,
2425407404,3668,Infer new schema from parsed output,"I have a schema something like this:

```js
UserPost = z.object({
  username: z.string(),
  password: z.string().min(8).transform(val => hash(val))
})
```

What I'd like to do is create a new schema based on the output of `UserPost.parse()`.

Something like this:

```js
UserRecord = UserPost.output()
```

so that when I read the data again at a later time, I can parse it to be confident that it has not been corrupted.

I am aware that a _type_ can be inferred this way:

```js
type output = z.output<typeof UserPost>
```

But is it possible to infer a new Zod schema in a similar way?

(This is just an example by the way, it doesn't really represent my auth strategy!)",,
2423103153,3665,[BUG] Generic Function with Object Extend/Merge not treating optional properties as optional and expecting them anyways.,"The following is my code, where in the `createParser` function, where on the return it wants all properties in the schema from the `ResultCreator`/`createResult` function even though the omitted properties are optional and shouldn't be required.

The two Errors look the following in order of lines:
![Code_WxPNisx1AF](https://github.com/user-attachments/assets/ef461556-9971-4cad-9986-d641e9252842)

![Code_CtU0jRz4W8](https://github.com/user-attachments/assets/87b5066a-8dde-4cad-8cdc-deeb8cd51344)


`Result.ts`:
```ts
import { z } from ""zod"";

export const VResultOptions = z.object({
  success: z.boolean(),
  message: z.string().optional(),
  errors: z.array(z.any()).optional(),
});

export type ResultOptions = z.infer<typeof VResultOptions>;

export function ResultCreator<T extends z.ZodTypeAny>(data_schema: T) {
  let merged = VResultOptions.extend({ data: data_schema.optional() });
  return function (options: z.input<typeof merged>) {
    let res = merged.safeParse(options);
    if (!res.success) throw res.error;
    return res.data;
  };
}
```

`Parser.ts`
```ts
import { ResultCreator } from ""./Result"";
import { fromError } from ""zod-validation-error"";
import { z } from ""zod"";

export function createParser<T extends z.ZodTypeAny>(schema: T) {
  const createResult = ResultCreator(schema);
  return function (item: z.input<typeof schema>) {
    const parsed = schema.safeParse(item);
    if (!parsed.success) return createResult({ success: false, message: `${fromError(parsed.error).toString()}` }); //EXPECTS DATA AND ERROR PROPERTY ANYWAYS
    return createResult({ success: true, message: ""Parsed without problems"", data: parsed.data }); //EXPECTS THE ERROR PROPERTY ANYWAYS
  };
}
```

I believe this is not the expected behavior, since the properties should be optional as defined and not required. Also I hope I am not a big dumb dumb, and this behavior is normal.

> *Side note I did try setting every property even as undefined and then it worked, so it really does want all the properties even though some are optional*",,
2421317465,3661,[Feature Request]  take regular expressions to support progressive improvement,"Well, it would be nice to add a function that could pull a regular expression from the validation scheme, at least for strings, so that if js is disabled, the pattern in input can work:

![image](https://github.com/user-attachments/assets/1239893b-d0b7-4025-972d-e226bee4dab4)

To somehow unify verification on the client (even if there is no js) and validation on the server

```jsx
const regExp = z.string().email()
...

return (
<input 
   pattern={regExp}
/>
)
```
",,
2421278487,3660,CI lint checks can be simplified,"Hi,

I was looking through the v4 branch and I noticed in your GitHub workflow that you run these two script as part of your [`lint` job](https://github.com/colinhacks/zod/blob/5a3b5f3d966f4ae654f2f18076aa6b0ccc51f18a/.github/workflows/test.yml#L34-L48):

https://github.com/colinhacks/zod/blob/5a3b5f3d966f4ae654f2f18076aa6b0ccc51f18a/.github/workflows/test.yml#L47-L48

The scripts are defined like this:

https://github.com/colinhacks/zod/blob/5a3b5f3d966f4ae654f2f18076aa6b0ccc51f18a/package.json#L49-L52

The `biome check` command actually combines `lint` and `format`:
> [biome check](https://biomejs.dev/reference/cli/#biome-check)
Runs formatter, linter and import sorting to the requested files.
> Usage: biome check [--write] [--unsafe] [--staged] [--changed] [--since=REF] [PATH]…

https://biomejs.dev/reference/cli/#biome-check

So `lint:check` could actually be removed from the `lint` job.

Furthermore, there is also a `biome ci` command:
> [biome ci](https://biomejs.dev/reference/cli/#biome-ci)
Command to use in CI environments. Runs formatter, linter and import sorting to the requested files. 
> Files won’t be modified, the command is a read-only operation.
>Usage: biome ci [--formatter-enabled=<true|false>] [--linter-enabled=<true|false>] [--organize-imports-enabled=<true|false>] [--changed] [--since=REF] [PATH]…

So if you have the `*:check` scripts are only needed for CI, they could be replaced by using `biome ci`.",,
2417622283,3654,Support custom discriminators in `z.discriminatedUnion`,"Currently `z.discriminatedUnion` only supports a restricted range of types for the discriminator field – mostly literal values.

There are use-cases for wanting to use other possible values (e.g. a union of values), or even custom types.

For example, an object might have different fields depending on the value of the `type` property, but we might also need a fallback case for any unknown value (i.e. any value other than the known values), e.g.:
```typescript
enum Species {
  Cat = 'cat',
  Dog = 'dog',
}

const zPet = z.discriminatedUnion('species', [
  z.object({ species: z.literal(Species.Cat), lives: z.number() }),
  z.object({ species: z.literal(Species.Dog), breed: z.string() }),
  z.object({
    species: z.custom<string>(val => typeof val === 'string' && Object.values(Species).indexOf(val) < 0),
  }),
})
```

",,
2416424709,3651,Use arrays to create unions,"Trying to something like this, just to reduce noise of lots of potential literal values:

```
const unionSchema = z.union(([0,2,5,7]).map(i =>z.literal(i)))
type UnionType = z.infer<typeof unionSchema>
```

but right now, `UnionType` resolves to `any`",,
2415490151,3649,IP Validation + optional is behaving unexpectedly,"Hello,

I've encountered an issue a couple of days ago and did not find any related topics or issues to that. Maybe my assumption is wrong but I've created a simple example to show what is currently not working as (I) intended it will do:

[Sandbox](https://codesandbox.io/s/vigilant-bogdan-vdr7rn?file=/src/index.ts)

It is possible to chain ip() with optional() - however the validation will fail for an empty string. I've also checked the docs on any exceptions for the usage of optional() but did not find any limitations to that.

Is this a bug or expected behaviour and if so, how can others be made aware of this behaviour?

",,
2414072384,3645,"Property 'pick' does not exist on type 'ZodType<Output, ZodTypeDef, Input>'.","Found a related issue here: https://github.com/colinhacks/zod/issues/2403 - but it doesn't provide a proper solution

I have a zod schema that uses `.lazy` and needs explicit typing with `z.ZodType<Output, z.ZodTypeDef, Input>`. All is well in that regard and that works, but considering that the schema is an object, I'm losing some typing here when I try to `.pick` from my explicitly typed schema.

Is there an alternative to `z.ZodType` that can be used on object schemas, such that pick and omit remain available and no types are lost?

Example code:

```
const nested = z.object({
  bar: z.string(),
}).transform((data) => {
  // transform...
});

const base = z.object({
  foo: z.string(),
}).transform((data) => {
  // transform...
});

type Input = z.input<typeof base> & { nestedObj: z.input<typeof nested> }
type Output = z.output<typeof base> & { nestedObj: z.infer<typeof nested> }

const extendedBase: z.ZodType<Output, z.ZodTypeDef, Input> = base.extend({
  nestedObj: z.lazy(() => nested.optional())
});

const derivedFromExtendedBase = extendedBase.pick({
  foo: true
});

// ^ Property 'pick' does not exist on type 'ZodType<Output, ZodTypeDef, Input>'.
```

Essentially, I'm looking for an alternative to `z.ZodType`. Perhaps `z.ZodObjectType<TOutput, TTypeDef, TInput>`? ",,
2412959414,3644,z.instanceOf error with class with private constructor,"Hi guys,

I'm starting to use ZOD on DDD-oriented classes, and I'm struggling to use the z.instanceof method to type my schema; here is an example

```tsx 
const userSchema = z.object({
    id: z.number().int().positive(),
    firstName: z.string(),
    lastName: z.string(),
});

export type UserInputProps = z.input<typeof userSchema>;
export type UserProps = z.infer<typeof userSchema>;

export class User {
    public readonly __brand = ""User"" as const;

    get id(): number {
        return this.props.id;
    }

    get firstName(): string {
        return this.props.firstName;
    }

    get lastName(): string {
        return this.props.lastName;
    }

    get fullName(): string {
        return `${this.props.firstName.trim()} ${this.props.lastName.trim()}`;
    }

    private constructor(private readonly props: Readonly<UserProps>) {}

    static validate(
        props: UserInputProps,
    ): null | UserProps {
        const result = userSchema.safeParse(props);

        if (result.success) {
            result.data;
        }

        return null
    }

    static create(
        props: Readonly<UserInputProps>,
    ): null |  User {
        const validateResult = User.validate(props);
        if(!validateResult) return null;

        return new User(validateResult );
    }
}
```

Then if I try to use this class on another schema for a list of paginated related data: 

```tsx
export const usersSchema = z.object({
    items: z.array(z.instanceof(User)),
    count: z.number().int().positive(),
});
```

I got this error message

![image](https://github.com/user-attachments/assets/71f8ed80-2c9a-42f8-8f76-e8b50ece4461)

The problem seems to come from here 

![image](https://github.com/user-attachments/assets/29901c0b-e239-47cc-9441-a82d348c3b68)

My private constructor approach comes from the idea of preventing invalid instances and handling it on my create static method that acts as my constructor

Thank you for your time",,
2411671154,3643,z.date({ coerce: 'iso' }),"hi - I find `z.date({ coerce: true })` very useful when using with trpc or another tool that uses JSON to cross an i/o boundary. Because, it forces the client to use a `Date` value - which is then serialized via its `toJSON` method into an ISO string and correctly converted back to a `Date` on the other side. So you get nice `Date` types on either side of the boundary.

But a not-ideal effect of using that trick is that it will also accept values like `null` and `0` which both parse to `1970-01-01T00:00:00.000Z`, so it's a bit dangerous.

So suggestion here is to change `coerce: boolean` to `coerce: boolean | 'iso'`, then update this block: https://github.com/colinhacks/zod/blob/9257ab78eec366c04331a3c2d59deb344a02d9f6/src/types.ts#L1798-L1800

An easy change to that block which should give the right results:

```ts
if (this._def.coerce === 'iso') {
  const coerced = typeof input.data === 'string' ? new Date(input.data) : null;
  if (coerced && coerced.toISOString() === input.data) {
    input.data = coerced;
  }
} else if (this._def.coerce) {
  input.data = new Date(input.data);
}
```

This just makes sure that the ISO string exactly matches the parsed `Date`'s ISO string, but it could also use a regex or some other ISO string validation technique.",,
2405951501,3638,z.union() inside of z.array repeats the same issue multiple times,"Let's say I have a schema like this

```ts
const questionsSchema = z.array(
  z.union([
    z.object({
      code: z.string(),
      value: z.enum(['Yes', 'No']),
    }),
    z.object({
      code: z.string(),
      value: z.enum(['Yes', 'No']),
      meta: z.object({
        something: z.number(),
      }),
    }),
    z.object({
      code: z.string(),
      value: z.enum(['Yes', 'No']),
      meta: z.object({
        somethingElse: z.boolean(),
      }),
    }),
  ]),
);
```

And the following array which I try to validate:
```ts
const questions = [
  {
    code: 'Q1',
    value: 'No',
    meta: {
      something: 123,
    },
  },
  {
    code: 'Q2',
    value: 'Yes',
    meta: {
      somethingElse: false,
    },
  },
  { code: 'Q3', value: 'No' },
];
```

If there are no errors, as in the example above, it all looks good. But if I mess up one of the values, e.g. 'No' -> 'Nooo' for Q1, I'd expect to get a single issue, instead of the issue being repeated multiple times and wrongly interpreting the type of one of the items.

```json
[
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""received"": ""Nooo"",
            ""code"": ""invalid_enum_value"",
            ""options"": [""Yes"", ""No""],
            ""path"": [0, ""value""],
            ""message"": ""Invalid enum value. Expected 'Yes' | 'No', received 'Nooo'""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""received"": ""Nooo"",
            ""code"": ""invalid_enum_value"",
            ""options"": [""Yes"", ""No""],
            ""path"": [0, ""value""],
            ""message"": ""Invalid enum value. Expected 'Yes' | 'No', received 'Nooo'""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""received"": ""Nooo"",
            ""code"": ""invalid_enum_value"",
            ""options"": [""Yes"", ""No""],
            ""path"": [0, ""value""],
            ""message"": ""Invalid enum value. Expected 'Yes' | 'No', received 'Nooo'""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""boolean"",
            ""received"": ""undefined"",
            ""path"": [0, ""meta"", ""somethingElse""],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [0],
    ""message"": ""Invalid input""
  }
]
```",,
2400498373,3632,Create an error map in pt-br,"First, I would separate the translation texts into a json, which would be passed as a parameter to the errorMap function.

I would move the errorMap function that is in the en.ts file to the root, or we could even create a folder called errors, to place the files that deal with errors.

Then, I would create a pt-br file within the locales, with the translation of the error content.

This would initially make it easier for Brazilians to use, but it would also be easier to implement in other languages ​​as well.",,
2398205335,3630,required not work,"```
const User = z
  .object({
    username: z.string(),
  })
  .required();

User.parse({ username: ""Ludwig"" });

type User = z.infer<typeof User>;
// actual { username?: string }
// expected  { username: string }
```
typescript version: Version 5.5.3
zod version: 3.23.8",,
2396523524,3628,Recursive schema with lazy() doesn't seem to work,"**reproduction** https://github.com/dearlordylord/zod-recursive-problem

**similar problems** exist https://github.com/colinhacks/zod/issues/3560 , https://github.com/colinhacks/zod/issues/3331

but they seem to yield different errors and have different reasons

**Context**

I have a file system-like structure where a node is a discriminated union of a leaf (file) or a node with n leaves (directory)

(**the type signature** goes further in the code example and in the repo )

I tried another parser library https://github.com/effect-ts/effect/tree/main/packages/schema and can pull it off with both compile time and runtime

however, Zod doesn't seem to compile this correctly, but it does run and validate correctly runtime:

(the same code is in counter.tsx of https://github.com/dearlordylord/zod-recursive-problem )

```ts

import { z } from 'zod';

type FileSystem = (
  | {
  readonly type: 'directory';
  readonly children: readonly FileSystem[];
}
  | {
  readonly type: 'file';
}
  ) & {
  readonly name: FileSystemName;
};

const fileSystemNameSchema = z.string().min(1).max(255).brand('fileSystemName');
type FileSystemName = z.infer<typeof fileSystemNameSchema>;

const fileSystemBaseSchema = z.object({
  name: fileSystemNameSchema
});

const fileSystemDirectoryBaseSchema = fileSystemBaseSchema.extend({
  type: z.literal('directory')
});

type FileSystemDirectory = z.infer<typeof fileSystemDirectoryBaseSchema> & {
  readonly children: readonly FileSystem[];
}

const fileSystemDirectorySchema: z.ZodType<FileSystemDirectory> = fileSystemDirectoryBaseSchema.extend({
  children: z.lazy(() => z.array(fileSystemSchema))
});

const fileSystemFileSchema = fileSystemBaseSchema.extend({
  type: z.literal('file')
});

export const fileSystemSchema = z.discriminatedUnion('type', [
  fileSystemDirectorySchema,
  fileSystemFileSchema
]);

```

the error is 

```
src/counter.ts:30:7 - error TS2322: Type 'ZodObject<extendShape<extendShape<{ name: ZodBranded<ZodString, ""fileSystemName"">; }, { type: ZodLiteral<""directory"">; }>, { children: ZodLazy<ZodArray<ZodDiscriminatedUnion<""type"", [...]>, ""many"">>; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<FileSystemDirectory, ZodTypeDef, FileSystemDirectory>'.
  Types of property '_type' are incompatible.
    Type '{ type: ""directory""; name: string & BRAND<""fileSystemName"">; children: { [x: string]: any; type?: unknown; }[]; }' is not assignable to type 'FileSystemDirectory'.
      Type '{ type: ""directory""; name: string & BRAND<""fileSystemName"">; children: { [x: string]: any; type?: unknown; }[]; }' is not assignable to type '{ readonly children: readonly FileSystem[]; }'.
        Types of property 'children' are incompatible.
          Type '{ [x: string]: any; type?: unknown; }[]' is not assignable to type 'readonly FileSystem[]'.
            Type '{ [x: string]: any; type?: unknown; }' is not assignable to type 'FileSystem'.
              Type '{ [x: string]: any; type?: unknown; }' is not assignable to type '{ readonly type: ""directory""; readonly children: readonly FileSystem[]; } & { readonly name: string & BRAND<""fileSystemName"">; }'.
                Property 'children' is missing in type '{ [x: string]: any; type?: unknown; }' but required in type '{ readonly type: ""directory""; readonly children: readonly FileSystem[]; }'.
```

zod `^3.23.8`



",,
2392897150,3623,idea: leverage module augmentation to reduce bundle size,"I like how Zod has great auto-completion, but it currently results in unused code being loaded which increases bundle sizes (e.g. see #2596).

[Module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) could be a great way to reduce the core Zod size and allow developers to optionally load additional schema methods. Zod can still be a large library. In fact, it can grow as much as wanted with lots of methods. Consumers will still only load what they want. Their bundle sizes will remain small and only grow as they opt-into more methods. This results in faster loading web pages, cloud function (e.g. AWS Lambda), etc.

This could be a breaking change or Zod could continue to export everything together but provide alternative import paths for this module augmentation leveraging approach.

Here is an oversimplified example that only loads desired methods:

```ts
import { z } from ""./zod"";
import ""./zod/string"";
import ""./zod/string/max"";

console.log(z.string().max(12).parse(""abc"")); // => ""abc""

// cannot use .number() unless it is loaded by importing ./zod/number""
// console.log(z.number().parse(42));
//               ^^^^^^ error TS2339: Property 'number' does not exist on type 'Zod'.

```

<details>
<summary>zod/index.ts</summary>

```ts
export class Zod {}

export const z = new Zod();

type ZodCheck<T> = (value: T) => void;

export abstract class ZodSchema<T> {
  #checks: ZodCheck<T>[];

  constructor(checks: ZodCheck<T>[] = []) {
    this.#checks = checks;
  }

  protected abstract typeCheck(value: unknown): asserts value is T;

  parse(value: unknown) {
    this.typeCheck(value);
    for (const check of this.#checks) check(value);
    return value;
  }

  refinement(check: ZodCheck<T>): this {
    type Self = this;
    return new (this.constructor as { new (checks: ZodCheck<T>[]): Self })([
      ...this.#checks,
      check,
    ]);
  }
}

```

</details>

<details>
<summary>zod/number.ts</summary>

```ts
import type { Zod } from ""."";
import { z, ZodSchema } from ""."";

export class ZodNumber extends ZodSchema<number> {
  protected typeCheck(value: unknown): asserts value is number {
    if (typeof value === ""number"") return;
    throw new Error(""value is not a number"");
  }
}

declare module ""."" {
  interface Zod {
    number(): ZodNumber;
  }
}

z.number = function (this: Zod) {
  return new ZodNumber();
};

```

</details>

<details>
<summary>zod/string.ts</summary>

```ts
import type { Zod } from ""."";
import { z, ZodSchema } from ""."";

export class ZodString extends ZodSchema<string> {
  protected typeCheck(value: unknown): asserts value is string {
    if (typeof value === ""string"") return;
    throw new Error(""value is not a string"");
  }
}

declare module ""."" {
  interface Zod {
    string(): ZodString;
  }
}

z.string = function (this: Zod) {
  return new ZodString();
};

```

</details>

<details>
<summary>zod/string/max.ts</summary>

```ts
import { ZodString } from ""../string"";

declare module ""../string"" {
  interface ZodString {
    max(maxLength: number): ZodString;
  }
}

Object.defineProperty(ZodString.prototype, ""max"", {
  value(this: ZodString, maxLength: number) {
    return this.refinement((value) => {
      if (value.length <= maxLength) return;
      throw new RangeError(""max length exceeded"");
    });
  },
});

```

</details>
",,
2388920360,3617,Using the key of string enum using nativeEnum?,"So I have been using this Country enum and wondering if we can validate the keys instead of the value?

https://gist.github.com/evolkmann/740d24889c509c08484a8ff72af5dd64

Currently, the nativeEnum validates the value and could not find an option to make it validate the key instead.",,
2385010658,3611,Enum parsing error: TypeError: Cannot read private member from an object whose class did not declare it (codesandbox repro included),"Reproduction: https://codesandbox.io/p/sandbox/zod-test-d6y6ts

I recently upgraded to 3.23.x from 3.22.4 and starting getting this error: 
```
TypeError: Cannot read private member from an object whose class did not declare it.
``` 

After some digging, I narrowed it down to ZodEnums parsing under specific circumstances. It happens when a ZodEnum has been deep cloned (in this case with lodash) and is then added as value of a ZodObject.

See the reproduction for details and some cases that do and don't work.  It's the parsing on the last line that causes the error. Comment it out, and the error goes away.

Edit the package.json to 3.22.4 and the error also disappears. 

I think this might be a related issue: https://github.com/colinhacks/zod/issues/3520

Thanks!",,
2384128345,3608,zod parsing bug ,"This is my complex object zod definition

```
import { z } from 'zod'
import { FieldDataType } from '../../enums/filed-data-type'
import { FieldDataChromoShow } from '../../enums/field-data-chromo-show'
import { EventCategory } from '../../enums/event-category'

const genericAlarmEventFieldDataPayloadSchema = z.object({
    NtpError: z.coerce.boolean(),
    DeviceNotFound: z.coerce.boolean(),
    MasterNotFound: z.coerce.boolean(),
})

const hammamAlarmEventFieldDataPayloadSchema = z.object({
    BoilerFullTooSoon: z.coerce.boolean(),
    EvLoad: z.coerce.boolean(),
    EvDrain: z.coerce.boolean(),
    VinBus: z.coerce.boolean(),
    Ntc: z.coerce.boolean(),
    Fan: z.coerce.boolean(),
    Slave: z.coerce.boolean(),
    HeaterFail: z.coerce.boolean(),
    Capacitive: z.coerce.boolean(),
    CabTemp: z.coerce.boolean(),
    Door: z.coerce.boolean(),
})

const saunaAlarmEventFieldDataPayloadSchema = z.object({
    StoveTemp: z.coerce.boolean(),
    VinBus: z.coerce.boolean(),
    Ntc: z.coerce.boolean(),
    ThermalProtection: z.coerce.boolean(),
    CabTemp: z.coerce.boolean(),
    Potentiometer: z.coerce.boolean(),
})

const eccIotInfoSchema = z.object({
    Id: z.string(),
    Ts: z.coerce.date(),
    Type: z.nativeEnum(FieldDataType),
    HostId: z.string(),
    Payload: saunaAlarmEventFieldDataPayloadSchema
       .or(genericAlarmEventFieldDataPayloadSchema)
       .or(hammamAlarmEventFieldDataPayloadSchema),
})

export const rawEventFieldDataSchema = z.object({
    App: z.string(),
    Cat: z.nativeEnum(EventCategory),
    EccIOTEvent: eccIotInfoSchema,
})

export type RawEventFieldData = z.infer<typeof rawEventFieldDataSchema>
```

When I use this definition, in my code, zod parses it wrongly

```
 const body = { 
                ""App"": ""EccIOT"", 
                ""Cat"": ""Event"", 
                ""EccIOTEvent"":  
                    {  
                    ""Id"": ""ecc-D8E39657C"", 
                    ""Ts"": ""2020/02/28 10:14:10"", 
                    ""Type"":""HAlarm"", 
                    ""HostId"":""0A229332"",
                    ""Payload"":{ 
                        ""BoilerFullTooSoon"" : 0, 
                        ""EvLoad"": 0, 
                        ""EvDrain"": 0, 
                        ""VinBus"": 0, 
                        ""Ntc"": 0, 
                        ""Fan"": 0, 
                        ""Slave"": 0, 
                        ""HeaterFail"": 0, 
                        ""Capacitive"": 0, 
                        ""CabTemp"": 0, 
                        ""Door"": 0 
                    } 
                }  
            }

const rawData: RawEventFieldData = rawEventFieldDataSchema.parse(body)

console.log(rawData);

```

In the console I found this:

```
{
  App: 'EccIOT',
  Cat: 'Event',
  EccIOTEvent: {
    Id: 'ecc-D8E39657C',
    Ts: 2020-02-28T10:14:10.000Z,
    Type: 'HAlarm',
    HostId: '0A229332',
    Payload: {
      StoveTemp: false,
      VinBus: false,
      Ntc: false,
      ThermalProtection: false,
      CabTemp: false,
      Potentiometer: false
    }
  }
}
```

What am I doing wrong ?

> Zod version is 3.23.8 

> Compiler options already includes 
> ```
>""compilerOptions"": {
>        ""strict"": true   
>    }
> ```
",,
2383517975,3607,ZodObject with generic key (i.e. [key: string]: xx) and specific key (i.e. {debug: xx}) don't _seem_ to work as expected,"Hey, I'm trying to take type that is defined like:

```
type A = {
  [x: string]: AllowedZodType;
  debug: z.ZodDefault<z.ZodBoolean>; // One of the allowed zod types
};
```

And convert it to a ZodObject, which I can later use `z.infer` on to get a native type out. I'm having some problems though. First this is how my `AllowedZodType` is defined (it's for defining command arguments schemas for a CLI)

```
type BaseZodType =
  | z.ZodString
  | z.ZodNumber
  | z.ZodBoolean
  | z.ZodEnum<[string, ...string[]]>
  | z.ZodRecord<z.ZodString, z.ZodString | z.ZodNumber>
  | z.ZodArray<z.ZodString | z.ZodNumber, 'many'>;

type NativeType = z.infer<BaseZodType> | undefined;

type WrappedZodType = z.ZodDefault<BaseZodType> | z.ZodOptional<BaseZodType>;

type AllowedZodType = BaseZodType | WrappedZodType | z.ZodEffects<WrappedZodType | BaseZodType, unknown, NativeType>;
```

So what I would like to do is is take type `A` defined above, and:
```
type X = z.ZodObject<A>
type Y = z.infer<X>

// Where Y ends up looking like:
type Y = {
  [x: string]: NativeType;
  debug: boolean;
}
```

But what I actually get is:
```
type X = z.ZodObject<aaa, z.UnknownKeysParam, z.ZodTypeAny, {
    [x: string]: unknown;
    debug?: unknown;
}, {
    [x: string]: NativeType;
    debug?: unknown;
}>

type Y = {
    [x: string]: unknown;
    debug?: unknown;
}
```

I'm thinking there might be something I can use or do, or is this just being interpreted incorrectly by zod's utility types or am I doing something totally dumb?

Thank you!

",,
2383516902,3606,Support for curly braces around UUID/GUID,"Curly braces around UUID's are very common in Microsoft applications also interchangeably referred to as GUIDs it would be great if these could also be validated, maybe a separate GUID validator or some options?

As far as I can see the PR by @jeansibelius merged in v4 for GUIDs also does not cater for the curly braces https://github.com/colinhacks/zod/pull/2872

> PostgreSQL also accepts the following alternative forms for input: use of upper-case digits, the standard format surrounded by braces, omitting some or all hyphens, adding a hyphen after any group of four digits. Examples are:
> 
> A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
> {a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
> a0eebc999c0b4ef8bb6d6bb9bd380a11
> a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
> {a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
> 

https://www.postgresql.org/docs/current/datatype-uuid.html

Microsoft refer to this here https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-

> 4d64-a93b-2f5c833d7d92#gt_b753d3f3-f3b7-4fee-bf4d-63085e108ec9): 
> curly braced GUID string: The string representation of a 128-bit globally unique identifier ([GUID](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-4d64-a93b-2f5c833d7d92#gt_f49694cc-c350-462d-ab8e-816f0103c6c1)) using the form {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}, where X denotes a hexadecimal digit. The string representation between the enclosing braces is the standard representation of a GUID as described in [[RFC4122]](https://go.microsoft.com/fwlink/?LinkId=90460) section 3. Unlike a GUIDString, a curly braced GUID string includes enclosing braces.

and here https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/222af2d3-5c00-4899-bc87-ed4c6515e80d

> 2.3.4.3 GUID--Curly Braced String Representation
> 
> The curly braced GUID string representation is a format commonly used for a string representation of the [GUID](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-4d64-a93b-2f5c833d7d92#gt_f49694cc-c350-462d-ab8e-816f0103c6c1) type (as specified in section [2.3.4.1](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/49e490b8-f972-45d6-a3a4-99f924998d97)) is described by the following ABNF syntax, as specified in [[RFC5234]](https://go.microsoft.com/fwlink/?LinkId=123096).
> 
>  CurlyBraceGuidString  =  ""{"" UUID ""}""
>  Where [UUID](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-4d64-a93b-2f5c833d7d92#gt_c4813fc3-b2e5-4aa3-bde7-421d950d68d3) represents the string form of a UUID, as specified in [[RFC4122]](https://go.microsoft.com/fwlink/?LinkId=90460) section 3. The non-terminal symbol CurlyBraceGuidString represents (that is, generates) strings that satisfy the definition of [curly braced GUID string](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-4d64-a93b-2f5c833d7d92#gt_b753d3f3-f3b7-4fee-bf4d-63085e108ec9).
> 
> By way of illustration, the UUID string specified in [RFC4122] section 3 as an example would have the following representation as a curly braced GUID string.
> 
>  {f81d4fae-7dec-11d0-a765-00a0c91e6bf6}

",,
2381767809,3604,Schema evolutions using zod?,"I'm trying to achieve schema versioning / schema evolution / schema migration using zod. I guess zod isn't meant to be used this way, however I got a simple working prototype and wanted to get an opinion if this approach works, scales or if I should drop it and try to use different zod APIs or a completely different library. I would like to stick with zod though as its works quite nice and we already use it for our schema validations.

Basically, what I try to achieve is having different versions of a schema, which would be able to map all versions to the ""latest"" type - allowing me to modify types and schemas over time and still be able to parse ""old"" objects from a previous version of the schema.

For example, imagine a User type with only one string property `id`. Objects of type User are written to some persistence layer.  Over time, Users are extended by another string property `name`. Again after some time, the `name` field is renamed to `userName`. There are possibly three different versions of type User in the persistence layer and I am not able to do database migrations. So we end up with these versions:

v1: { id: string }
v2: { id: string, name: string }
v3 (latest): { id: string, userName: string }

In my application, I only want to deal with latest User type
```ts
type User = {
  id: string,
  userName: string,
}
```

Parsing objects conforming the ""latest"" schema obviously works, but will break for older objects

```ts
const userSchema: z.ZodType<User> = z.object({ id: z.string(), userName: z.string() })

userSchema.parse({ id: '1' }) // fails
userSchema.parse({ id: '2', name: 'alice' }) // fails
userSchema.parse({ id: '3', userName: 'alice' }) // works
```

So my idea was to use a combination of `.transform()`, `.or()` and `.pipe()` to basically create ""schema migrations"", which would be able to lift v1 to v2, v2 to v3, and so on. In the end, I came up with the following solution:

```ts
export const createSchemaEvolution = <T, S>(
  oldSchema: z.ZodType<T>,
  _: z.ZodType<S>,
  mapper: (value: T) => S,
): z.ZodEffects<z.ZodType<T>, S> => oldSchema.transform(mapper)

export const createSchema = <T>(
  latest: z.ZodType<T>,
  evolutions: z.ZodTypeAny[],
): z.ZodType<T> => {
  let schemaEvolutionPipeline = latest
  for (let i = evolutions.length - 1; i >= 0; i--) {
    let currentPipeline = evolutions[i]
    for (let j = i + 1; j < evolutions.length; j++) {
      currentPipeline = currentPipeline.pipe(evolutions[j])
    }
    schemaEvolutionPipeline = schemaEvolutionPipeline.or(currentPipeline)
  }
  return schemaEvolutionPipeline
}
```

Concrete solution for the different versions of User:

```ts
const userSchemaV1 = z.object({ id: z.string() })
const userSchemaV2 = userSchemaV1.extend({ name: z.string() })
const userSchemaV3 = userSchemaV2.omit({ name: true }).extend({ userName: z.string() })

const V1toV2 = createSchemaEvolution(userSchemaV1, userSchemaV2, v1 => ({
  ...v1,
  name: `${v1.id}-defaultName`,
}))
const V2toV3 = createSchemaEvolution(userSchemaV2, userSchemaV3, v2 => ({
  id: v2.id,
  userName: v2.name,
}))

const userSchema = createSchema<User>(userSchemaV3, [V1toV2, V2toV3]) // userSchemaV3.or(V2toV3).or(V1toV2.pipe(V2toV3)) as z.ZodType<User>

userSchema.parse({ id: '1' }) // result: { id: '1', userName: '1-defaultName' }
userSchema.parse({ id: '2', name: 'alice' }) // result: { id: '2', userName: 'alice' }
userSchema.parse({ id: '3', userName: 'alice' }) // result: { id: '3', userName: 'alice' }
```

One can already see, that this approach might be prone to errors and mistakes, `createSchema` is not really typesafe, especially regarding the `evolutions` array and also the order is really important.

Is there a better approach using zod?",,
2381001824,3602,Add `invalid_literal` ZodIssueCode to documentation,"Hello there, new to zod and super happy with it, thank you so much for your work!

As I was playing around with implementing zod into my ts projects I realized I was getting some `invalid_literal` error codes in my zod issues array (mostly in union validation errors). I tried looking up the `invalid_literal` code in the general project gh docs as well as your [error handling docs](https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#zodissuecode) to see what extra fields I can expect and it seems to be missing from those docs. I do see this error code in the [source code](https://github.com/colinhacks/zod/blob/main/src/ZodError.ts) so I'm assuming I didn't find a bug, just possibly some missing docs.

Figured I'd bring it up in case you weren't aware or in the case I'm missing/confused about how the `invalid_literal` code is supposed to be used.",,
2374844934,3597,Refine removes null from schema,"Hello. I don't quite understand what happens but when I use typescript 5.5 (does not happen with 5.2)the refine removes null from union in my schema. 
Proof:
![image](https://github.com/colinhacks/zod/assets/67366321/d55703f8-7933-4e2e-822b-b0f3c5ca8cc9)


If I remove the refine segment, now _null_ is added to the type union and the error is gone.
![image](https://github.com/colinhacks/zod/assets/67366321/d496ada0-5f5e-425d-a2f6-5b61a0710f5d)

If I switch the refine function arguement with a boolean constructor,then the error is gone, but that is because typescript does not use Boolean as a type predicate, so perhaps this further proves that ts's 5.5 inferred predicates work on refine now too.
![image](https://github.com/colinhacks/zod/assets/67366321/fff86e67-4a8b-4f0a-a20f-ff8e8a4f1bd6)

So obviously refine is doing something here...
**But**, I am unable to duplicate this error when I upload it on stackblitz, here -
https://stackblitz.com/edit/typescript-ebur5x?file=index.ts


I am not sure what is going on... Why is refine suddenly removing nulls from the union? it doesn't do it in older typescript versions, and I can't seem to replicate this in stackblitz so maybe it's just me? I guess the question is why is refine removing the null from my union and how can I make it stop... I am using strict mode.",,
2366175406,3592,Overloaded function return schema with z.union,"We are using zod with  ts-rest and node express. 

I created and endpoint that uses a function which can return 3 different types based on one argument. 
The function is `getFile` and the argument is `serveAs: 'stream' | 'url' | 'data'`. The way I coded it is function overload statements.

```
export async function getFile(serveAs: 'data'): Promise<File>;
export async function getFile(serveAs: 'stream'): Promise<{ file: File, fileStream: SdkStream<IncomingMessage> }>;
export async function getFile(serveAs: 'url'): Promise<{ url: string }>;
export async function getFile(serveAs: 'data' | 'file' | 'url' = 'file' ) { ... }
```

Because we are using sequelize v6, the model is still ""in js code"" and lacks proper and robust typing. The model is simply the `File` returned from the topmost overload, and at that point is a JSON object (calling `toJSON` after getting the response from the db).

The contract for this endpoint is declared as a `z.union`

```typescript
z.union([
  // For serveAs: url
  z.object({ url: z.string() }),
  // For serveAs: file
  z.instanceof(Stream),
  // For serveAs: data
  FileDto
])
```
where FileDto is the schema reflecting the db model `z.object({ ... })`.

Localy it runs fine. No problems whatsoever. But once I pushed the code for a PR our github action for testing failed complaining.

```
Error: Jest: Got error running globalSetup - /codebuild ... testSetup.js, reason: [TSError: app/controllers/emi/files.controller.ts:32:14 - error TS2322: Type '({ params, res, query }: { params: { id: string; }; query: { serveAs?: ""data"" | ""file"" | ""presigned-url"" | undefined; expiresIn?: number | undefined; }; headers: { [x: string]: string | string[] | undefined; [x: number]: string | ... 1 more ... | undefined; authorization?: string | undefined; ""x-product-name""?: stri...' is not assignable to type 'AppRouteQueryImplementation<{ metadata: { 'x-audience': Audience; tags: string[]; operationId: string; }; method: ""GET""; description: ""Get file by id""; query: ZodObject<{ serveAs: ZodOptional<ZodEnum<[""file"", ""presigned-url"", ""data""]>>; expiresIn: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; ... 4 ...'.
  Type 'Promise<{ status: 200; body: Stream; } | { status: 200; body: string; } | { status: 200; body: File; }>' is not assignable to type 'Promise<Prettify<AppRouteResponses<{ metadata: { 'x-audience': Audience; tags: string[]; operationId: string; }; method: ""GET""; description: ""Get file by id""; query: ZodObject<{ serveAs: ZodOptional<ZodEnum<[""file"", ""presigned-url"", ""data""]>>; expiresIn: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>;...'.
    Type '{ status: 200; body: Stream; } | { status: 200; body: { url: string }; } | { status: 200; body: File; }' is not assignable to type 'Prettify<AppRouteResponses<{ metadata: { 'x-audience': Audience; tags: string[]; operationId: string; }; method: ""GET""; description: ""Get file by id""; query: ZodObject<{ serveAs: ZodOptional<ZodEnum<[""file"", ""presigned-url"", ""data""]>>; expiresIn: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; ... 4 m...'.
      Type '{ status: 200; body: File; }' is not assignable to type 'Prettify<AppRouteResponses<{ metadata: { 'x-audience': Audience; tags: string[]; operationId: string; }; method: ""GET""; description: ""Get file by id""; query: ZodObject<{ serveAs: ZodOptional<ZodEnum<[""file"", ""presigned-url"", ""data""]>>; expiresIn: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; ... 4 m...'.
        Type '{ status: 200; body: File; }' is not assignable to type '{ status: 200; body: string | Stream | { key: string; location: string; id: string; metadata: { key: string; value: string; }[]; path: string; size: number; createdAt: Date; updatedAt: Date; ... 5 more ...; cdnLing?: string | undefined; }; }'.
          Types of property 'body' are incompatible.
            Type 'File' is not assignable to type '{ url: string } | Stream | { key: string; location: string; id: string; metadata: { key: string; value: string; }[]; path: string; size: number; createdAt: Date; updatedAt: Date; bucket: string; ... 4 more ...; cdnLing?: string | undefined; }'.
              Type 'File' is missing the following properties from type '{ key: string; location: string; id: string; metadata: { key: string; value: string; }[]; path: string; size: number; createdAt: Date; updatedAt: Date; bucket: string; mimeType: string; originalName: string; extension: string; version?: string | undefined; cdnLing?: string | undefined; }': metadata, extension

32 export const findFileById: AppRouteImplementation<
                ~~~~~~~~~~~~]
    at runGlobalHook
```
If I were to give up, I would just split the endpoint into three separate endpoints for each type. Just not sure if the problem wont be the same in the one that returns `FileDto/File`

Can anyone tell me what am I doing wrong here?

PS: 
I can't fix the typo `cdnLing` - it does not appear in code anymore but pops up in the log on github...",,
2360831074,3584,Valid union-of-partials data does not parse even though it conforms to one (or more) of the union members,"Consider this example:
```ts
import { z } from ""zod"";

const FooASchema = z.object({
  type: z.literal(""A""),
  a: z.number(),
});

const FooBSchema = z.object({
  type: z.literal(""B""),
  b: z.number(),
});

// const FooSchema = z.union([FooASchema, FooBSchema]);
const PartialFooSchema = z.union([FooASchema.partial(), FooBSchema.partial()]);

const input: unknown = { b: 12 };

const typed = PartialFooSchema.safeParse(input);

console.log(""Input:"", input);
console.log(""Error:"", typed.error);
console.log(""Data:"", typed.data);
```

Here I would expect that `typed.data` would be `{ b: 12 }` since `input` should validate against `FooBSchema.partial()`. However, the actual behavior is (1) no error; and (2) `typed.data` is `{}`.
",,
2357553169,3579,Generic type function converting property with a default value to optional,"I have written a helper function that allows me to validate FormData objects using Zod. Since this can be used for various schemas, I have used a generic type.

The problem I'm having is, when using the helper function it seems to be turning the properties with default values set in the schemas to optional:

```typescript
export const createUserSchema = z.object({
    name: fullName(),
    email: email(),
    sendEmail: z.boolean().default(true)
});
``` 
![Screenshot 2024-06-17 at 15 39 38](https://github.com/colinhacks/zod/assets/40760694/b6dfeff5-813c-43d8-a5f5-1ee5f281c761)

Here is the code for the validate helper function:
```typescript
export function validate<T>(
    formData: FormData,
    schema: z.ZodSchema<T>
): { validatedData: T; errors: null } | { validatedData: null; errors: ActionErrors<T> } {
    const body = parseFormData(formData);
    const validated = schema.safeParse(body);

    if (!validated.success) {
        return {
            validatedData: null,
            errors: formatZodErrors<T>(validated.error),
        };
    }

    return { validatedData: validated.data, errors: null };
}
``` 

The fact this is being returned with an optional property just doesn't make any sense to me. Any explanation or help would be much appreciated 😊.

Worth noting that if I don't run this through the helper function and parse it directly in the action, it isn't returning as optional which you would expect.",,
2355278508,3577,ZodReadonly missing methods to manipulate schema shape,"Several methods for manipulating the shape of a schema are conspicuously missing just by marking a schema as read-only:

```typescript
import { z } from ""zod"";

export const EDITION = z.enum([""bedrock"", ""java""]);

export const VERSION = z.object({
	id: z.string().uuid(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
	edition: EDITION,
	version: z.string(),
	cycle: z.tuple([z.number().nonnegative(), z.number().nonnegative()]),
	releasedOn: z.coerce.date(),
	releaseNotesUrl: z.string().url(),
	isPublished: z.boolean().default(false).optional()
});

export const LATEST_VERSION = VERSION.extend({
	isLatest: z.boolean(),
	isLatestInCycle: z.boolean()
}).readonly();

export const RARITY = z.enum([""common"", ""uncommon"", ""rare"", ""epic""]);

export const ITEM = z.object({
	id: z.string().uuid(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
	identity: z.string(),
	wikiUrl: z.string().url(),
	rarity: RARITY.default(""common"").optional(),
	stackSize: z.number().positive().default(64).optional(),
	isRenewable: z.boolean()
});

export const VERSIONED_ITEM = ITEM.and(
	z.object({
		// unrelated, but if there's a better way to rename a property, i'd like to know
		versionId: LATEST_VERSION.shape.id // .shape isn't available because LATEST_VERSION is read-only
	})
)
	.and(
		LATEST_VERSION.pick({ // .pick() isn't available because LATEST_VERSION is read-only
			edition: true,
			version: true,
			cycle: true,
			isLatest: true,
			isLatestInCycle: true
		})
	)
	.readonly();
```

Everything is fine if I remove `.readonly()` from `LATEST_VERSION` and `VERSIONED_ITEM`. However these schemas represent views in the database, so they are inherently read-only. Shouldn't we be able to mark schemas as read-only and still be able to use helpers like `.pick()`, `.omit()` and `.shape`?

---

Edit: formatting",,
2352812477,3573,"If object with nested refine fails, it doesn't apply transform before superRefine, causing superRefine to not be typesafe","Object with nested define doesn't apply transform before superRefine, causing superRefine to not be typesafe.

```typescript
  const res = z
    .object({
      name: z.string(),
      age: z.number().refine((data) => {
        return data > 18;
      }), // Fails refine
    })
    .transform((data) => {
      return {
        userName: data.name,
        userAge: data.age,
      };
    })
    .superRefine((data) => {
      // Data here is { ""name"": ""John"", ""age"": 6 }, Expected { ""userName"": ""John"", ""userAge"":  6} after transformation
      console.log(""superRefine"", JSON.stringify(data, null, 2));
    })
    .safeParse({
      name: ""John"",
      age: 6,
    });
  console.log(res);
```

This parsing should abort early or perform the transformation anyway. Transform isn't applied here.",,
2350572411,3570,safeParse not working server sider with z.union() : Error: Attempted to call indexOf() from the server but indexOf is on the client.,"I am working on a next js app with the directory page system.
I have a folder called [[...options]], which enable to get url segments in the url, more details about that [here](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-segments)

I would like parse the string[] containing the segments with zod server side.

```ts
export const VIEW_OPTIONS = ['day', 'week', 'month', 'year'] as const;

type ViewOption = (typeof VIEW_OPTIONS)[number];
type Segments = ['booking', ViewOption, number, number, number] | [ViewOption, number, number, number];

const calendarOptionsSchema = z.union([
    z.tuple([z.literal('booking'), z.enum(VIEW_OPTIONS), z.number(), z.number(), z.number()]),
    z.tuple([z.enum(VIEW_OPTIONS), z.number(), z.number(), z.number()]),
    z.undefined(),
]);

const extractSegments = (options: Segments) => {
    if (!calendarOptionsSchema.safeParse(options).success) {
        // redirect to 404 page
        notFound();

    }
    // other stuff here
}
```

I get this issue : 

<img width=""983"" alt=""Screenshot 2024-06-13 at 10 48 38"" src=""https://github.com/colinhacks/zod/assets/96651063/6fbb66e0-196e-4679-9375-4f2bf82fbd68"">

I looked on the internet, I have see nothing about this issue.
If you have an idea/an explanation, you are welcome. :)",,
2349068575,3565,[Bug]: ZodFormattedError type breaks for ReadonlyArrays.,"The following TypeScript code gives a compiler error:

```ts
    type Foo = {
      ids: ReadonlyArray<string>;
    };

    const error: ZodFormattedError<Foo> = {
      _errors: [],
      ids: { _errors: [] },
    };
```

The error:

```
[Filename]: error TS2322: Type '{ _errors: never[]; }' is not assignable to type 'ZodFormattedError<readonly string[], string>'.
  Type '{ _errors: never[]; }' is missing the following properties from type 'readonly ({ _errors: string[]; } | undefined)[]': length, concat, join, slice, and 26 more.

85       ids: { _errors: [] },
         ~~~

[Filename]:
    80       ids: ReadonlyArray<string>;
             ~~~
    The expected type comes from property 'ids' which is declared here on type 'ZodFormattedError<Foo>'
```

The weird thing is if I change my type `Foo` to use an `Array` instead of a `ReadonlyArray` the error goes away. This works:

```ts
    type Foo = {
      ids: Array<string>;
    };

    const error: ZodFormattedError<Foo> = {
      _errors: [],
      ids: { _errors: [] },
    };
```",,
2348136656,3564,How to use discriminatedUnion with multiple conditions?,"I need to create a model to apply schema with multiple conditions. For example

Parent type

- event
- webinar

Sub event type

- group
- round_robin

But I am unable to merge it in add it in `discriminatedUnion[]` and getting TS error. Any suggestion?

```
const eventSchema = z.discriminatedUnion('event_type', [
  oneOnOneSchema,
  groupEventSchema,
]);

export const mainSchema = z.discriminatedUnion('type', [
  eventSchema,
  webniarSchema,
]);

```


![image](https://github.com/colinhacks/zod/assets/6106479/c620d75b-5cd5-4aa9-8c04-83f7f122fb80)


TS error - 

![image](https://github.com/colinhacks/zod/assets/6106479/70ee1b43-73e1-4fe6-95a4-beab86e82627)

",,
2344597909,3562,[Bug ?] Zod union ignoring zod object when fields are z.optional(),"Hi,

Basically, when doing zod objects and doing an union on that, when the second object of the union has optional fields, parsing just ignore it ! Is that normal ? I can't find any information about that. I've came with a solution using discriminatedUnion but that feels a little bit dirty ...

I've created a reproduction environment for replaying the issue  
https://stackblitz.com/edit/typescript-f8ppcz?file=schemas%2FschemaWithDefaultType.ts
```js
import { z } from 'zod';

const say = console.info;

function zod_optional_union_ignored() {
  // ! when one and two are optional,
  const type2 = z.object({
    one: z.number().optional(),
    two: z.number().optional(),
  });

  const type1 = z.object({
    three: z.number().optional(),
  });

  const type2or1 = z.union([type1, type2]);

  const test_data = {
    one: 1,
    two: 2,
  };

  const validatedTestData = type2or1.parse(test_data);

  // ! type2 is ignored, why is that ??
  say('zod optional type2 object ignored', { validatedTestData });

  const test_data2 = {
    three: 3,
  };

  // type1 is parsed correctly
  const validatedTestData2 = type2or1.parse(test_data2);
  say('zod optional type1 object not ignored', { validatedTestData2 });
}

function zod_union_not_ignored() {
  const type2 = z.object({
    one: z.number(),
    two: z.number(),
  });

  const type1 = z.object({
    three: z.number(),
  });

  const type2or1 = z.union([type1, type2]);

  const test_data = {
    one: 3,
    two: 2,
  };

  const validatedTestData = type2or1.parse(test_data);

  // type2 is parsed correctly here, certainly because there is no optional
  say('zod optional ingored', { validatedTestData });
}

zod_optional_union_ignored();
zod_union_not_ignored();

```
![image](https://github.com/colinhacks/zod/assets/77932724/e6490799-8d58-459e-94ff-1343ecf7d2bf)




",,
2342463351,3560,Documentation example for recursive types gives type error,"# Issue
Type hints made for recursive types `z.lazy( ... )` make all properties optional. I made a minimal reproducible example repo with the example of recursive types given [in the documentation](https://zod.dev/?id=recursive-types) and this error is present.

## Error Output
```
Type 'ZodObject<extendShape<{ name: ZodString; }, { subcategories: ZodLazy<ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">>; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'.
  Types of property '_type' are incompatible.
    Type '{ name?: string; subcategories?: Category[]; }' is not assignable to type 'Category'.
      Type '{ name?: string; subcategories?: Category[]; }' is not assignable to type '{ subcategories: Category[]; }'.
        Property 'subcategories' is optional in type '{ name?: string; subcategories?: Category[]; }' but required in type '{ subcategories: Category[]; }'. ts(2322)
```
## tsconfig.json
```json
{
	""compilerOptions"": {
		""outDir"": ""dist"",
		""declaration"": true,
		""target"": ""ES6"",
		""module"": ""CommonJS"",
		""moduleResolution"": ""Node10""
	}
}
```
## Example
https://github.com/alligatorjazz/recursive-error",,
2341785499,3559,Feature Request: Autoscroll to Input Field on Validation Error,"#### Description

I would like to propose a new feature for the Zod library: autoscrolling to the input field when a validation error occurs. This enhancement aims to improve user experience by automatically directing users to the specific form field that has failed validation, thereby reducing confusion and enhancing usability.

#### Motivation

When a form submission fails due to validation errors, especially in lengthy forms, users often find it challenging to identify which specific field contains the error. Implementing an autoscroll feature would address this issue by smoothly scrolling the user to the erroneous input field and focusing on it. This makes the error more visible and the form more user-friendly.

#### Proposed Implementation

1. **Modify the `ZodError` class**: Add a new method to handle the autoscroll functionality.
2. **Scroll to First Error**: On validation failure, scroll to the first erroneous input field and focus on it.
3. **Integration with Form Libraries**: Ensure compatibility with popular form handling libraries like `react-hook-form`.

Here is a conceptual example of how the method might look:

```typescript
export class ZodError<T = any> extends Error {
  issues: ZodIssue[] = [];

  // Existing methods...

  // New method to scroll to the first error
  scrollToError(form: HTMLFormElement) {
    if (this.issues.length === 0) return;

    const firstIssue = this.issues[0];
    const fieldName = firstIssue.path.join(""."");
    const input = form.querySelector(`[name=""${fieldName}""]`);

    if (input) {
      input.scrollIntoView({ behavior: ""smooth"" });
      (input as HTMLInputElement).focus();
    }
  }

  // Existing methods...
}
```

#### Request for Guidance and Authorization
I am very interested in contributing this feature to the Zod library. I would appreciate any guidance or suggestions on how to best implement this feature according to the project's standards. Additionally, I would like to request authorization to proceed with developing this feature.",,
2341530420,3558,Recursive types losing types and get `any`,"Hi everyone,

I'm trying to represent some HTML tags and the `div` can contain children tags, but `div` loses its type and becomes `any`.

The types I want with Typescript:

```ts
type H1 = { _tag: ""h1"", id: string }
type H2 = { _tag: ""h2"", id: string }
type H3 = { _tag: ""h3"", id: string }
type Div = { _tag: ""div"", id: string, children: Tag[] }

type Tag = H1 | H2 | H3 | Div
```

The types with Zod:

```ts
const h1 = z.object({ _tag: z.literal(""h1""), id: z.string() })
const h2 = z.object({ _tag: z.literal(""h2""), id: z.string() })
const h3 = z.object({ _tag: z.literal(""h3""), id: z.string() })
const div = z.object({ 
  _tag: z.literal(""div""), 
  id: z.string(), 
  children: z.lazy(() => z.array(tag)) 
})

const tag = z.lazy(() => z.union([h1, h2, h3, div]))
type Tag = z.infer<typeof tag>
```

😬 **The errors:**

on `const div` and `const tag`:
```ts
'div' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.ts(7022)

'tag' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.ts(7022)
```

🌐 **The code:**

[Stackblitz](https://stackblitz.com/edit/html-tags-with-zod?file=src%2Fmain.ts) 

🔎 **Some links:**

- [Zod.dev docs about recursive types (using ZodType and not ZobObject 😢)](https://zod.dev/?id=recursive-types)
- [Stack Overflow about recursive types (using DiscriminatedUnion)](https://stackoverflow.com/questions/74706608/zod-recursive-type-with-discriminated-union)
- [GitHub issue about recursive types (using ZobObject)](https://github.com/colinhacks/zod/discussions/3004)
",,
2339288784,3551,Type Inference not working ,"I am trying to create a simple form schema using zod, and wants to infer the type so that I can get some helpers and autocomplete. However, the process of doing so resulted in this. 

**My Code**
![image](https://github.com/colinhacks/zod/assets/145012063/9d84c4cd-e0ae-460a-a385-a01f7a9619d7)

** Inferred Type** 
![image](https://github.com/colinhacks/zod/assets/145012063/79b5ad71-80a7-4d3c-9450-b708270cd6e1)


Any advice as to why this is happening? I am using 3.23.8
",,
2336253905,3546,Required key inferred as optional in mutually recursive tree structure,"Hello! We're working on a project that involves modeling something akin to a generic mutually recursive expression tree with Zod. Here's a simplified example:

```typescript
import { z } from 'zod';


export type AndNode<TBase> = {
  type: 'and',
  children: Tree<TBase>[],
};

export type OrNode<TBase> = {
  type: 'or',
  children: Tree<TBase>[],
};

export type NotNode<TBase> = {
  type: 'not',
  child: Tree<TBase>,
};


export type Tree<TBase> =
  | TBase
  | AndNode<TBase>
  | OrNode<TBase>
  | NotNode<TBase>;

function treeOf<
  TBaseSchema extends z.ZodTypeAny,
>(
  baseSchema: TBaseSchema,
): {
  AndNode: z.ZodType<AndNode<z.infer<TBaseSchema>>>,
  OrNode: z.ZodType<OrNode<z.infer<TBaseSchema>>>,
  NotNode: z.ZodType<NotNode<z.infer<TBaseSchema>>>,
  Tree: z.ZodType<Tree<z.infer<TBaseSchema>>>,
} {
  let Tree: z.ZodType<Tree<z.infer<TBaseSchema>>>;

  const AndNode = z.object({
    type: z.literal('and'),
    children: z.lazy(() => Tree.array()),
  });

  const OrNode = z.object({
    type: z.literal('or'),
    children: z.lazy(() => Tree.array()),
  });


  const NotNode = z.object({
    type: z.literal('not'),
    child: z.lazy(() => Tree),
  });

  Tree = z.union([
    baseSchema,
    AndNode,
    OrNode,
    NotNode,
  ]);

  return {
    AndNode,
    OrNode,
    NotNode,
    Tree,
  };
}
```

This example fails to type check because `NotNode` doesn't satisfy the return type:
```
Type 'ZodObject<{ type: ZodLiteral<""not"">; child: ZodLazy<ZodType<Tree<TypeOf<TBaseSchema>>, ZodTypeDef, Tree<TypeOf<TBaseSchema>>>>; }, ""strip"", ZodTypeAny, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }, { [k_1 in keyof baseObjectInputType<...>]: baseObjectInputType<...>[k_1]; }>' is not assignable to type 'ZodType<NotNode<TypeOf<TBaseSchema>>, ZodTypeDef, NotNode<TypeOf<TBaseSchema>>>'.
  Types of property '_type' are incompatible.
    Type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ type: ZodLiteral<""not"">; child: ZodLazy<ZodType<Tree<TypeOf<TBaseSchema>>, ZodTypeDef, Tree<TypeOf<TBaseSchema>>>>; }>, any>]: addQuestionMarks<...>[k]; }' is not assignable to type 'NotNode<TypeOf<TBaseSchema>>'.
      Property 'child' is optional in type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ type: ZodLiteral<""not"">; child: ZodLazy<ZodType<Tree<TypeOf<TBaseSchema>>, ZodTypeDef, Tree<TypeOf<TBaseSchema>>>>; }>, any>]: addQuestionMarks<...>[k]; }' but required in type 'NotNode<TypeOf<TBaseSchema>>'.ts(2322)
test.ts(33, 3): The expected type comes from property 'NotNode' which is declared here on type '{ AndNode: ZodType<AndNode<TypeOf<TBaseSchema>>, ZodTypeDef, AndNode<TypeOf<TBaseSchema>>>; OrNode: ZodType<...>; NotNode: ZodType<...>; Tree: ZodType<...>; }'
```

It seems like the inferred type for `NotNode` types `child` as optional, which it should not be. I've seen issues similar to this reported here before and for the most part, they've been solved by enabling strict mode, but that doesn't seem to work here.
Here's the `tsconfig.json` I'm using for this example:

```json
{
    ""compilerOptions"": {
        ""strict"": true,
    }
}
```

and the `package.json`:
```json
{
    ""dependencies"": {
        ""zod"": ""^3.23.8""
    },
    ""devDependencies"": {
        ""typescript"": ""^4.8.4""
    }
}
```

I've also tried constraining `TBaseSchema`, e.g `TBaseSchema extends z.ZodType<object>`. This doesn't seem to affect anything.

Is there something incorrect about the way this is being modeled?",,
2334796390,3544,"object.props ""required"" but z.infer<T> returns  ""optional"" type?","deps:
typescript@4.9.4
zod@3.23.8

code:
<img width=""466"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/14211764/228e391b-1a1f-4018-b1a7-30aec76826fa"">

ps: the ""parse"" & ""safeParse"" method works well",,
2325439267,3537,Zod Preprocess returning unknown type,"The type returned from [z.preprocess](https://zod.dev/?id=preprocess) is giving out type `unknown`

```
export const string_validation = z.preprocess(
  (value) => {
    if (typeof value !== 'string') return value;
    return value.trim().replace(/\s\s+/g, ' ');
  },
  z.string().min(1)
);

export const boolean_validation = z.preprocess((bool) => {
  if (typeof bool === 'boolean') return bool;
  return bool === 'true';
}, z.boolean());

export const number_validation = z.preprocess(
  (num) => (!num && num !== 0 ? num : Number(num)),
  z.number()
);
```

It's annoying but don't use preprocess in too many places so for now fixing by setting the type explicitly

```
// Before
export const string_validation: .ZodEffects<z.ZodString, string, unknown>
export const boolean_validation: z.ZodEffects<z.ZodBoolean, boolean, unknown>
export const number_validation: z.ZodEffects<z.ZodNumber, number, unknown>

// After
export const string_validation: .ZodEffects<z.ZodString, string, string>
export const boolean_validation: z.ZodEffects<z.ZodBoolean, boolean, boolean>
export const number_validation: z.ZodEffects<z.ZodNumber, number, number>
```",,
2324674610,3536,Importing `infer` type makes all props `unknown`?,"I'm having an issue where I have one package to define Zod schemas and types, and I import those types in other packages. The issue I'm having is that the exported `type` drops all property types and makes them unknown.

```ts
// refresh.ts - exported package
import { GrantType } from '@/types/GrantType';
import z from 'zod';

export const refreshTokenParams = z.object({
  refresh_token: z.string(),
  scope: z.string().optional(),
  client_id: z.string(),
  grant_type: z.literal(GrantType.RefreshToken),
});
export type RefreshTokenParams = z.infer<typeof refreshTokenParams>;
```

Importing the type where is its needed results in all property types being wiped away:
![image](https://github.com/colinhacks/zod/assets/17836372/d5b14aea-aa1d-4d6a-9b9e-33465da0ea99)

If I take the exact same Zod schema and type and declare them in the package where I am importing them, the type information is persisted. I feel like this is something to do more with TS typings than Zod, but I've hit a wall with how to move forward.

*edit*
It appears my issue is due to using a an `enum` type within `z.literal`. Changing this to a regular string fixes type-inference, but then I lose the ability to reference my source enum for the value. This is further complicated because I'm using these types as part of a discriminatedUnion, with the enum values being used as the discriminator.",,
2319031009,3534,Is it possible to create a zod enum from a string literal type,"What zod fn should I use to make the BarSchema valid?

```ts
type Foo = 'foo' | 'bar'; // generated

interface Bar {
 foo: Foo,
 id: string,
}

export const BarSchema = z.object({
  foo: z.enum(Foo), // what should this be?
  id: z.string()
}) satisfies z.ZodSchema<Bar>;

```

I know I can redefine the Foo type like:
```
foo: z.enum(['foo', 'bar'])
```

But the point is not to redefine the generated types.
",,
2316587607,3529,Descriptions from root schema carry over to schemas created with a chained `.array()`,"Related to changes made in #1756.

The above PR addresses an issue where descriptions would not carry over to schemas created using the chaining helper methods, like `.optional()`.

```typescript
// Before the above changes
z.string().describe(""a description"").description // ""a description""
z.string().describe(""a description"").optional().description // undefined

// After
z.string().describe(""a description"").description // ""a description""
z.string().describe(""a description"").optional().description // ""a description""
```

The changes to fix this issue were also applied to `.array()`, which results in some unexpected behavior.

```typescript
// With this bug,
z.string().describe(""a description"").array()
// is equivalent to:
z.string().describe(""a description"").array().describe(""a description"")
// but this works as expected
z.array(z.string().describe(""a description""))
```

The fix was super simple, I'll open a PR shortly!",,
2315753434,3527,zod safeparse not working with nextjs server action useFormState hok,"Im using zod for velidation, the form doesnt send correct data to server action function. it always returns **invalid fields**

This is form component:

```ts
'use client';

import * as z from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import {
	Form,
	FormControl,
	FormField,
	FormItem,
	FormLabel,
	FormMessage,
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { loginFormInput } from '@/constants/form';
import Link from 'next/link';
import { loginSchema } from '@/validators/auth.schema';
import FormError from '../feedback/FormError';
import FormSuccess from '../feedback/FormSuccess';
import { loginAction } from '@/actions/auth/login.action';
import { useSearchParams } from 'next/navigation';
import { FaArrowLeft } from 'react-icons/fa';
import Submit from '../buttons/submit';
import { useFormState } from 'react-dom';

const LoginForm = () => {
  const [formState, formAction] = useFormState(loginAction, {
    error: '',
    success: '',
  });

  const searchParams = useSearchParams();
  const urlError =
    searchParams.get('error') === 'OAuthAccountNotLinked' &&
    'Please sign in with the same account you used originally.';

  const form = useForm<z.infer<typeof loginSchema>>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  });

  return (
    <>
      <Form {...form}>
        <Link href={'/login'}>
          <FaArrowLeft size={20} />
        </Link>

        <form action={formAction} className=""flex flex-col gap-4"">
          {loginFormInput.map((data) => (
            <FormField
              key={data.id}
              control={form.control}
              name={data.name}
              render={({ field }) => (
                <FormItem>
                  <FormLabel>{data.label}</FormLabel>
                  <FormControl>
                    <Input
                      className=""border-none bg-slate-100 py-6 shadow-none""
                      type={data.type}
                      placeholder={data.placeholder}
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          ))}
          <Link
            className=""text-right text-sm font-semibold text-slate-500 hover:underline""
            href={'/forgot-password'}
          >
            Forgot Password?
          </Link>
          <FormError message={formState.error || urlError} />
          <FormSuccess message={formState.success} />
          <Submit title=""Login"" loadingTitle=""Logging In..."" />
        </form>
      </Form>
    </>
  );
};

export default LoginForm;
```

This is server action

```ts
'use server';
import { signIn } from '@/auth';
import { getUserByEmail } from '@/data/user';
import { sendVerificationMail } from '@/lib/mail';
import { generateVerificationToken } from '@/lib/tokens';
import { DEFAULT_LOGIN_REDIRECT } from '@/routes';
import { loginSchema } from '@/validators/auth.schema';
import { AuthError } from 'next-auth';
import * as z from 'zod';

interface LoginFormState {
  error?: {};
  success?: {};
}

export const loginAction = async (
  formState: LoginFormState,
  formData: z.infer<typeof loginSchema>,
): Promise<LoginFormState> => {
  const validateFields = loginSchema.safeParse(formData);
  if (!validateFields.success) return { error: 'Invalid Fields!' };

  const { email, password } = validateFields.data;

  const existingUser = await getUserByEmail(email);

  if (!existingUser || !existingUser.email || !existingUser.password) {
    return { error: 'Email doesnt exist!' };
  }

  if (!existingUser.emailVerified) {
    const verificationToken = await generateVerificationToken(
      existingUser.email,
    );
    await sendVerificationMail(
      verificationToken.token,
      verificationToken.email,
      existingUser?.name as string,
    );
    return { success: 'Confirmation email sent' };
  }

  try {
    await signIn('credentials', {
      email,
      password,
      redirectTo: DEFAULT_LOGIN_REDIRECT,
    });
  } catch (error) {
    if (error instanceof AuthError) {
      switch (error.type) {
        case 'CredentialsSignin':
          return { error: 'Invalid credentials' };

        default:
          return { error: 'Something went wrong' };
      }
    }
    throw error;
  }
  return { success: 'Email sent successfully!' };
};

```


This is schema
```ts
export const loginSchema = z.object({
	email: z.string().email({ message: 'Must be a valid email' }),
	password: z.string().min(3, {
		message: 'Password is required',
	}),
});

```",,
2315651266,3525,infer literal in discriminatedUnion fails typecheck but not parse,"I want to typecheck the object before parsing it to validate it.
But the type generated from a discriminatedUnion does not seem to match the zod parse() result.

```TypeScript
const myUnion = z.discriminatedUnion(""status"", [
  z.object({ status: z.literal(""success""), data: z.string() }),
  z.object({ status: z.literal(""failed""), error: z.instanceof(Error) }),
]);

const data = { status: ""success"", data: ""yippie ki yay"" };

type TypeFromSchema<T> = T extends ZodType<infer U> ? U : never;

function test<T extends ZodType>(data: TypeFromSchema<T>, schema: T) {
  return myUnion.safeParse(data); // works
}

const result = test(data, myUnion);  // typecheck fails
```
Result:
```
Argument of type '{ status: string; data: string; }' is not assignable to parameter of type '{ status?: ""success""; data?: string; } | { status?: ""failed""; error?: Error; }'.
  Type '{ status: string; data: string; }' is not assignable to type '{ status?: ""success""; data?: string; }'.
    Types of property 'status' are incompatible.
      Type 'string' is not assignable to type '""success""'.
```
Expected result:

I'm probably wrong here but I would expect no type errors. Having the type of status be a literal too and not a string.

[codesandbox.io](https://codesandbox.io/p/devbox/zod-playground-forked-z6v6np?workspaceId=1308f168-9fd5-4b3a-895b-efe2385373cb&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cln3s5wur00073b6hpvdyzdd7%2522%252C%2522sizes%2522%253A%255B51.07255520504731%252C48.92744479495269%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cln3s5wur00033b6h80ute5zp%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cln3s5wur00053b6h90wtxxns%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cln3s5wur00063b6h1y81405t%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B61.68772109412797%252C38.31227890587203%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cln3s5wur00033b6h80ute5zp%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00033b6h80ute5zp%2522%252C%2522tabs%2522%253A%255B%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522cln3s60zq002v3b6hm2cfn9qk%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fpackage.json%2522%252C%2522id%2522%253A%2522cln3sh8u0007x3b6g1r8nttu6%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%252C%2522activeTabId%2522%253A%2522cln3s60zq002v3b6hm2cfn9qk%2522%257D%252C%2522cln3s5wur00063b6h1y81405t%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00063b6h1y81405t%2522%252C%2522activeTabId%2522%253A%2522clwkqp34l004a2e68qnlkq5vd%2522%252C%2522tabs%2522%253A%255B%257B%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A2222%252C%2522id%2522%253A%2522clwkqp34l004a2e68qnlkq5vd%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522path%2522%253A%2522%252F%2522%257D%255D%257D%252C%2522cln3s5wur00053b6h90wtxxns%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00053b6h90wtxxns%2522%252C%2522activeTabId%2522%253A%2522clwkrgaeu00ng2e68yf4b5xw9%2522%252C%2522tabs%2522%253A%255B%257B%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%252C%2522id%2522%253A%2522clwkrgaeu00ng2e68yf4b5xw9%2522%252C%2522mode%2522%253A%2522permanent%2522%257D%252C%257B%2522id%2522%253A%2522clwkssdtf00wx2e68yyub9301%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TERMINAL%2522%252C%2522shellId%2522%253A%2522clwkssdvq000xdkey8fsnbbjm%2522%257D%255D%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)",,
2314548228,3521,"literal uses `\""` in error message","It seems a bit strange to me that the error message for a literal contains `\""` rather than using a single quote, or another option

```typescript
const testSchema = z.object({
  foo: z.literal('bar'),
});

const testData = { foo: 'badval' };
testSchema.parse(testData);
```
![image](https://github.com/colinhacks/zod/assets/93682696/28982910-2a6b-4184-aefa-52c9a40c65c8)
its especially ugly in api responses (at least imo) 
![image](https://github.com/colinhacks/zod/assets/93682696/4247beea-615c-4c2a-a79c-2a04f16fcc2c)

also compared to enums, which use `'`
```typescript
const testSchema = z.object({
  foo: z.enum(['bar', 'baf']),
});

const testData = { foo: 'badval' };
testSchema.parse(testData);
```
![image](https://github.com/colinhacks/zod/assets/93682696/766fdd3a-a221-44bb-9798-dc6bfad1710a)
",,
2313903548,3520,`#cache` private field in ZodEnum makes it incompatible with Proxy,"Hi,

first I want to emphasize, that I am no expert in JS/TS land and very new to Zod too - I just learned about those private fields today, lol!

In https://github.com/colinhacks/zod/pull/2659, the private field `#cache` was added to ZodEnum.

I am using Vue 3, which uses Proxies to implement [reactivity](https://vuejs.org/guide/extras/reactivity-in-depth.html).
On top, I am using `vee-validate` library, that has [zod support](https://vee-validate.logaretm.com/v4/integrations/zod-schema-validation/) to validate form fields based on Zod schemas.

Just bumped from `3.22.5` to `3.23.X` and noticed some of our form views got broken. 

Seems it is the combination of having ""dynamic schema"" and using `z.enum` - dynamic schema here being that we change the format of zod schema based on conditions X, and using the Vue's reactivity system that new schema is updated to `vee-validate`, which basically does `parse` calls with the form values against the full schema.

The error we are seeing is:
```
 index.mjs:531 Uncaught (in promise) TypeError: Cannot read private member from an object whose class did not declare it
     at __classPrivateFieldGet (index.mjs:531:1)
     at Proxy._parse (index.mjs:3481:1)
     ...
```

So it blows when it tries to access the `#cache` field. 

I _think_ in this case the schema is somehow wrapped as Proxy and thats why we are seeing this error - will try to dig a little deeper in upcoming days... It might be that we are Doing Something Wrong and there is a way to avoid the Proxy behavior, but that needs little bit more understanding atm 😃 

There seems to be more depth discussion about private fields vs Proxies [here](https://github.com/tc39/proposal-class-fields/issues/106), with some [workaround examples](https://es.discourse.group/t/a-simple-way-to-implement-protected/1110) on managing `this`.

Nevertheless, maybe I just wanted to make sure, if using the private field was a weighed decision, or if use case like this Vue example might lead to some improvements so that Proxy cases might be supported...? I was trying to checkout the `src/types.ts`, but did not find any other usages of private fields.

Thanks for any inputs, that might help me to learn more about these topics! 🙂 Props for your efforts so far!",,
2313856208,3519,Zod Async Refine always returning false,"Hello,

I am trying to validate a form with an async request to a server route that works fine when tested on its own, however, in the zod validation always returns false.

I am trying to prevent user from attempting to register with an email that has already been taken, and so validating email inside a nuxtui form by calling this async server route. 

testing the server route  works just fine and return expected true or false
`http://localhost:3000/user/is_email_available?email=er.ttt@gmail.com` returns true or false as expected
but for some reason always returns false in the zod schema validation. 


```
const schema = z.object({
  tenant_name: z.string({ required_error: ""Business Name is required"" }).
    min(2, { message: ""Must be at least 2 characters"" }).
    refine(async (val) => await tenantSlugAvailable(slugify(val)), (val) => ({ message: `${val} is not available` })),
  email: z.string({ required_error: ""Business Email is required"" }).email({ message: ""Invalid email address"" }).
    refine(async (val) => { await useFetch('user/is_email_available', { query: { email: val } }) }, (val) => ({ message: `${val} is not available` })),
  password: z.string({ required_error: ""Password is required"" }).min(8, { message: 'Must be at least 8 characters' }),
  confirmPassword: z.string({ required_error: ""Password Confirmation is required"" }).min(8, { message: 'Must be at least 8 characters' })
}).refine((values) => values.password === values.confirmPassword,
  {
    message: ""Passwords must match!"",
    path: [""confirmPassword""],
  }
);
```

Please can someone take a look and show me what I am doing wrong? have spent a day on this already and not making any headway.

Thanks",,
2311873985,3517,ZodFormattedType does not include the fields in TypeScript,"## Description
The `zodError.format()` method is of type `ZodFormattedError`. The `ZodFormattedError` seems to be:
```TypeScript
{
  _errors: string[]
}
```
even though it has types for all the particular fields in the object:
```TypeScript
{
  name: { _errors: string[]; };
  iso2: { _errors: string[]; };
  iso3: { _errors: string[]; };
  _errors: string[]
}
```
which should be reflected in TypeScript.

## Code snippet
```TypeScript
try {
    newCountry = CountryCreateSchema.parse(await request.formData());
} catch (e) {
    logger.info('[database-example] Invalid form data: ', e);
    return fail(400, {
        message: 'Invalid form data',
        errors: e instanceof ZodError ? e.format() : null
    });
}
```

## Potential workaround
Create a custom generic type:
```TypeScript
type ZodErrorObject<T> = {
	[P in keyof T]: {
		_errors: string[];
	};
} & { _errors: string[] };
```
and cast your formatted error:
```TypeScript
(e.format() as ZodErrorObject<CountryCreateSchema>)
```

or, use `error.flatten()` which seems to work as expected: https://zod.dev/ERROR_HANDLING?id=flattening-errors

## Version
- TypeScript: 5.0.0
- Zod: 3.23.8",,
2310791562,3512,IPv6 validation error,"IPv6 validation fails when the last two parts of the IPv6 are compressed, both when one or both are omitted. It does not happen if it is any other part. I have checked the regex you use in https://github.com/colinhacks/zod/blob/1247caf58d1c189155bd04c068be1c758ab77c1c/src/types.ts#L613 and I have also checked it in external tools and the zod behavior is reproduced.

```ts
const ip = '2001:4888:50:ff00:500:d::';
const schema = z.string().ip();
const { success } = schema.safeParse(ip); // false
```

```ts
const ip = '2001:4888:50:ff00:500:d:0:0';
const schema = z.string().ip();
const { success } = schema.safeParse(ip); // true
```

```ts
const ip = '2001:4888:50:ff00::d:0:0';
const schema = z.string().ip();
const { success } = schema.safeParse(ip); // true
```",,
2310445555,3510,Unable to pass `z.ZodType` as argument to `merge`,"Hi all,

Following the advice for circular references, I've built this schema for a table-of-contents in the sphinx-external-toc Python package:
```typescript
import { z } from 'zod';

const TOCTreeOptions = z
  .object({
    caption: z.string(),
    hidden: z.boolean(),
    maxdepth: z.number(),
    numberted: z.boolean(),
    reversed: z.boolean(),
    titlesonly: z.boolean(),
  })
  .partial();

const FileEntry = z.object({
  file: z.string(),
  title: z.string().optional(),
});

const URLEntry = z.object({
  url: z.string(),
  title: z.string().optional(),
});

const GlobEntry = z.object({
  glob: z.string(),
});

/** Basic TOC Trees **/
type NoFormatSubtreeType = z.infer<typeof TOCTreeOptions> & {
  entries: z.infer<typeof NoFormatEntry>[];
};
const NoFormatSubtree: z.ZodType<NoFormatSubtreeType> = TOCTreeOptions.extend({
  entries: z.lazy(() => NoFormatEntry.array()),
});

type NoFormatShorthandSubtreeType = {
  entries: z.infer<typeof NoFormatEntry>[];
  options?: z.infer<typeof TOCTreeOptions>;
}
const NoFormatShorthandSubtree: z.ZodType<NoFormatShorthandSubtreeType> = z.object({
  entries: z.lazy(() => NoFormatEntry.array()),
  options: TOCTreeOptions.optional(),
});

const NoFormatHasSubtrees = z.object({
  subtrees: NoFormatSubtree.array(),
});

const NoFormatEntry = z.union([
  FileEntry.merge(NoFormatShorthandSubtree),
  FileEntry.merge(NoFormatHasSubtrees),
  FileEntry,
  URLEntry,
  GlobEntry,
]);

const NoFormatTOCBase = z.object({
  root: z.string(),
  defaults: TOCTreeOptions.optional(),
});

const NoFormatTOC = z.union([
  NoFormatTOCBase.merge(NoFormatShorthandSubtree).strict(),
  NoFormatTOCBase.merge(NoFormatHasSubtrees).strict(),
  NoFormatTOCBase.strict(),
]);
```

This fails on the calls to `merge` that pass `NoFormatShorthandSubtree` as an argument. 

I can understand why this fails (`ZodType` _isn't_ `ZodObject`), but is there a way to solve this using `merge`?

In my specific case, I can probably drop the `strict` requirement, and thus use `and` instead of `merge`, but it's not ideal!",,
2305120639,3504,is not assignable to parameter of type 'AnyZodObject'.   Types have separate declarations of a private property '_cached',"We have this custom function

```ts
import type { Handler, NextFunction, Request, Response } from 'express';
import type { AnyZodObject, ZodError, ZodIssue } from 'zod';

import type { Logger } from '../logger/logger';

export interface ZodErrorResponse {
  success: false;
  error: {
    code: number;
    message: 'Invalid body, query or params';
    zodError: ZodIssue[];
  };
}

/**
 * Returns a function to validate request against Zod-defined schema
 * @param schema - Zod-defined schema
 * @param logInstance - Instance of Logger class
 * @param handler - Name of handler for logging purposes
 * @returns A middleware handler to validate requests
 */
export const validate =
  (schema: AnyZodObject, logInstance: Logger, handler: string): Handler =>
  async (req: Request, res: Response<ZodErrorResponse>, next: NextFunction) => {
    try {
      await schema.parseAsync({
        body: req.body as unknown,
        query: req.query,
        params: req.params,
      });
      next();
    } catch (error) {
      logInstance.errorRequest(handler, error, req, 400);

      const zodError = error as ZodError;
      res.status(400).send({
        success: false,
        error: {
          code: 400,
          message: 'Invalid body, query or params',
          zodError: zodError.issues,
        },
      });
    }
  };
```

However when I try to use it it says

```bash
Argument of type 'ZodObject<{ query: ZodObject<{ roleId: ZodOptional<ZodNumber>; hirerId: ZodOptional<ZodNumber>; page: ZodOptional<ZodNumber>; pageSize: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'AnyZodObject'.
  Types have separate declarations of a private property '_cached'

```

I'm not sure what does _cached mean?",,
2299428307,3495,Can't chain transform then default,"I have the following code:

```typescript
const schema = z.unknown().transform(() => {
    return undefined
}).default(1);

const value = schema.parse(undefined);

if (value !== 1) {
    throw new Error(`Expected value to be 1, got ${ value }`)
}
```

This gives me the error:

```typescript
Uncaught Error: Expected value to be 1, got undefined
```

Shouldn't the default() catch the unknown value here?",,
2297407746,3491,lazy doesn't compile when used with default,"here is example from tutorial, but with added field with default:
```
const baseCategorySchema = z.object({
  name: z.string(),
  val: z.number().default(0),
});

type Category = z.infer<typeof baseCategorySchema> & {
  subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
  subcategories: z.lazy(() => categorySchema.array()),
});
```
Compiler complains
```
Type 'ZodObject<extendShape<{ name: ZodString; val: ZodDefault<ZodNumber>; }, { subcategories: ZodLazy<ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">>; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'.
  Types of property '_input' are incompatible.
    Type '{ name: string; subcategories: Category[]; val?: number | undefined; }' is not assignable to type 'Category'.
      Type '{ name: string; subcategories: Category[]; val?: number | undefined; }' is not assignable to type '{ name: string; val: number; }'.
        Types of property 'val' are incompatible.
          Type 'number | undefined' is not assignable to type 'number'.
            Type 'undefined' is not assignable to type 'number'.ts(2322)
```
I believe this is valid case",,
2294797767,3489,"[FEAT] add ""afterRefine"" method","Let's say i have schema like this:

```typescript
const validationSchema = z.object({
  name: z.string().min(1),
  lowerBound: z.number(),
  upperBound: z.number(),
});
```

i want to check if ""upperBound"" is greaterThan ""lowerBound""

current solution (as far as i understood from searching) is to do something like this:
```typescript
const baseSchema = z.object({
  name: z.string().min(1),
});
const extendedSchema = baseSchema.extend({
  lowerBound: z.number(),
  upperBound: z.number(),
}).refine((item) => baseSchema.safeParse(item) && item.upperBound > item.lowerBound);
```

i want to have method which will do ""current checks"" and will allow me to add my own on top, like this:
```typescript
const validationSchema = z.object({
  name: z.string().min(1),
  lowerBound: z.number(),
  upperBound: z.number(),
}).afterRefine((item, result) => result && item.upperBound > item.lowerBound);
```",,
2290641546,3485,Intersection of object and record fails if function is used as a value for both,"I want to replicate the following type in zod:
```typescript
{
  foobar: () => {},
  [key: string]: () => {} | string
}
```

I believe something like the following should do it:
```typescript
z.object({
  foobar: z.function(),
}).and(
  z.record( z.union([ z.function(), z.string() ]) )
)
```

And indeed that pattern does work fine if you replaced `z.function()` with something like `z.number()`:
```typescript
const schema = z.object({
  foobar: z.number(),
}).and(
  z.record( z.union([ z.number(), z.string() ]) )
)

// Succeeds!
schema.parse({ foobar: 100, test: 42 })
```

But unfortunately this does not work with `z.function()`:
 ```typescript
const schema = z.object({
  foobar: z.function(),
}).and(
  z.record( z.union([ z.function(), z.string() ]) )
)

// Fails with error ""invalid_intersection_types: Intersection results could not be merged"" :(
schema.parse({ foobar: () => {}, test: () => {} })
```

**My understanding/best guess of why it's failing:**
When ZodIntersection is passed it calls the [mergeValues function](https://github.com/colinhacks/zod/blob/ca42965df46b2f7e2747db29c40a26bcb32a51d5/src/types.ts#L3245C10-L3245C21) which determines that `foobar` is a key shared in both `a` and `b`. Because of this it will then [recursively call mergeValues on the values of the `foobar` property from both `a` and `b`](https://github.com/colinhacks/zod/blob/ca42965df46b2f7e2747db29c40a26bcb32a51d5/src/types.ts#L3262). In the case above where `z.number()` is used this will succeed because the number `100` from both `a` and `b` will `===` each other and thus [the merge will be marked as valid](https://github.com/colinhacks/zod/blob/ca42965df46b2f7e2747db29c40a26bcb32a51d5/src/types.ts#L3252). But in the case of `z.function()` both `a.foobar` and `b.foobar` are considered different objects (since it looks like zod creates a different object wrapped around the original `() => {}` object or something like that, I'm not really sure) and thus they are not consided equal and will fail.

Thanks for reading and for such an extremely useful library!",,
2290160738,3484,New Restriction in .pick()/.omit() restrict using of dynamic property in the object,"Here I am trying to pick only the necessary schema field inside the zod object, and parse it.
```typescript
  const { watch,  } = useForm<FormSchemaType>({
    resolver: zodResolver(formSchema),
  });

React.useEffect(() => {
    const subscription = watch((value, { name }) => {
      if (name) {
        const newValue = value[name as keyof FormSchemaType] as string;
        const validate = formSchema
          .pick({ [name]: true })
          .safeParse({ [name]: newValue }).success;

        if (validate) {
          // The required field is validated
        }
      }
    });
    return () => subscription.unsubscribe();
  }, [watch]);
``` 

This was working fine for me in ```v3.22.x``` but not in ```v3.23.x```.
```typescript
 .pick({ [name]: true })
``` 
This particular line is now throwing me error that ```Argument of type '{ [x: string]: boolean; }' is not assignable to parameter of type 'Exactly<{ field1?: true | undefined;.....}>```

I'm guessing this has to do with the changes made in https://github.com/colinhacks/zod/pull/3255.",,
2289888683,3481,Looking for a way to reuse the same schema with `.merge`,"Hi,
Hope you're fine!

I would like some guidance here, because I did not find any answer through multiple researches, and it is maybe a bug. I would like to know if I'm doing wrong or if a bug is  likely to be suspected here or inside nestjs/swagger

Here are my schemas:

```typescript
// Some utils I would like to reuse

export const stringToDateString = z
	.string()
	.refine(val => !Number.isNaN(Date.parse(val)), {
		message: 'Invalid datetime string',
	})
	.transform(val => new Date(val).toISOString());

export const dateToDateString = z.date().transform(date => date.toISOString());

export const dateToDatelike = z.union([stringToDateString, dateToDateString]);

export const startAndEndDates = z
	.object({
		start_date: dateToDatelike,
		end_date: dateToDatelike,
	})
	.refine(
		({ start_date, end_date }) =>
			isBefore(new Date(start_date), new Date(end_date)),
		{
			message: 'La date de début dépasse la date de fin',
		}
	);
	
// ##### Phase schema #####

const base = z.object({
	// Some properties
});

export const PhaseSchema = base.merge(startAndEndDates.innerType());

// ##### Cycle Schema #####

const base = z.object({
	// Some properties
});

export const CycleSchema = base.merge(startAndEndDates.innerType());
```

If I'm doing this, I'm getting this error:

`Error: A circular dependency has been detected (property key: ""start_date""). Please, make sure that each side of a bidirectional relationships are using lazy resolvers (""type: () => ClassType"").`

This error is generated by `@nestjs/swagger`, but I'm not sure this is related, and I think the root cause is my schema.

It's worth noting that I also tried using `z.lazy()`, according to the mentionned error, in many ways but **without success**.

Is anyone can help here ? It could be interesting to have this kind of usecase directly in the documentation 😄 

Have a nice day",,
2289811109,3480,z.merge not inferring types properly,"The `CombinedType` in this code:

```ts
import { z, ZodObject } from 'zod'

const schema1 =  z.object({ providerId: z.string() })
const schema2 = z.object({ serviceId: z.string() })
const schema3 =  z.object({ date: z.date() })

function combineSchemas<
	T extends ZodObject<any, any, any>,
	U extends ZodObject<any, any, any>,
	V extends ZodObject<any, any, any>,
>(s1: T, s2: U, s3: V) {
	return s1.merge(s2).merge(s3)
}
const CombinedSchema = combineSchemas(schema1, schema2, schema3)
type CombinedType = z.infer<typeof CombinedSchema>
```

is not properly inferring the type. It should be 

```ts
{
  providerId: string;
  serviceId: string;
  date: Date
}
```

But the inferred type is:

```
type CombinedType = {
    [x: string]: any;
    serviceId?: unknown;
    date?: unknown;
}
```

[See Playground](https://www.typescriptlang.org/play/?#code/JYWwDg9gTgLgBAbzgLwDRwFoQCYHkBGAVgKYDG8AvnAGZQQhwDkyOjAUG6RAHYDO8vUgAtiIAIYBGOAF44KAHQQiZGAAokYOgDdg2YlACS2AFwL+UYNwDmqgJRwKtzj35xBI8QCYZCpSXLqbvo6pMRGpsjy5pY29o7OfALComIAzD6+ygFI2GIwxBHyufl2Dk5s1ACu3OTAPHBcIPiWxADKyeK8ADxsAJAAKnDEAB753Ni8mDgE-jBdYtwAnugLy3CrAHyofQCqQ6PE45NYeFlzqytLl4tbfQBq+2MTU6ez81frH5vbG6q8EqZ+uheJ5TDtgalTHd7Ag+lBiDBKlBuG4JPIQPorMQ-p5bOjMdjeKknBQEq4AML0ZrcYjYdoeMQ+RrUtodMS8P5siTAtmeHkM4lsGCLMDEOCUpotbD9EVi2SRSzUfRdYWiiDUcVUqX0lIbNhAA)",,
2286136336,3474,Passing `RawCreateParams` to `z.tuple()` doesn't apply to all errors generated by `z.tuple()`.,"Example: 

```example.ts
const schema = z.tuple([z.string(), z.number()], { message: 'this doesnt look right' });
schema.parse([]); 
```
This will throw with a ZodIssue of `{ too_short, 'Array must contain at least 2 elements' }` instead of the supplied message.",,
2285303800,3473,Can not use branded enum options,"Hi team,

Thanks for a great amount of work delivered!

_Not sure if it makes sense to use branded enums at all, but here is my case._

I have met an issue with my types: I am unable to use branded enum's options in TypeScript.

Minimal example:
```
export const AgentStatus = z.enum([""offline"", ""online""]);

console.log(AgentStatus.enum.offline);

export const AgentStatusBrand = z
	.enum([""offline"", ""online""] as const)
	.brand<""AgentStatus"">();

console.log(AgentStatusBrand.enum.offline);
```

The last line gives the error:
```
src/domain/servers.ts:51:30 - error TS2339: Property 'enum' does not exist on type 'ZodBranded<ZodEnum<[""offline"", ""online""]>, ""AgentStatus"">'.

51 console.log(AgentStatusBrand.enum.offline);
```",,
2284324447,3472,Large declaration files for flattened zod schema,"[luluNextData.txt](https://github.com/colinhacks/zod/files/15241501/luluNextData.txt)

When emitting declaration files for a complex nested json the resulting declaration file can end up being quite large. I've shared a schema above generated from a large json (next data from a lululemon page) using https://transform.tools/typescript-to-zod. This results in a 17mb declaration file (.d.ts).

 A quick look at the .d.ts file shows very large const declaraions of the the zod objects. Anything I can do to reduce this file size? If naively doing this as a human I could just modify the zod schema into an interface/type and avoid declaring the large consts, as the declaration files for inferred types don't need the zod context. 

This is in a typescript project with the following tsconfig settings

```
{
  ""compileOnSave"": true,
  ""compilerOptions"": {
    ""declaration"": true,
    ""declarationMap"": true,
    ""composite"": true,
    ""downlevelIteration"": true,
    ""experimentalDecorators"": true,
    ""incremental"": true,
    ""lib"": [""esnext""],
    ""module"": ""commonjs"",
    ""moduleResolution"": ""node"",
    ""noErrorTruncation"": true,
    ""noImplicitReturns"": true,
    ""noUnusedLocals"": true,
    ""skipLibCheck"": true,
    ""sourceMap"": true,
    ""strict"": true,
    ""target"": ""esnext""
  }
}
```",,
2282741076,3468,Inability to retrieve keys from z.nativeEnum type,"Hello,

I am using zod to work with TypeScript enums and have encountered an issue when trying to retrieve the keys from an enum using `z.nativeEnum`. The `z.nativeEnum` function does not seem to provide a method to retrieve the keys of the enum, unlike the standard TypeScript keyof type operator.

Here's an example illustrating the issue:
```ts
// Definition of SomeEnum using TypeScript
enum SomeEnum {
    PNG = 1,
    APNG = 2,
    Lottie = 3,
    GIF = 4,
};

// Attempt to use keyof on SomeEnum directly
type SomeEnumKeyof = keyof typeof SomeEnum;  // This works as expected

// Using z.nativeEnum with SomeEnum
const SomeEnumSchema = z.nativeEnum(SomeEnum);

// Attempting to use keyof on z.nativeEnum result
// The following line throws an error because .keyof() method does not exist
const keySomeEnum = SomeEnumSchema.keyof(); // This does not work
```

Could you provide guidance on how to properly retrieve the keys from an enum defined with `z.nativeEnum`? Is there a workaround or a method that I might be missing?

Thank you for your assistance, and apologies for any confusion caused by my language skills.",,
2277970603,3461,Issue with inferring types from pipes.,"Using code that is almost verbatim lifted from docs:
```typescript
const forceNumber = z.union([z.string(), z.number()]).pipe(z.coerce.number())
```
Idea being to accept a number or string, and coerse to string or fail. The function works, unit tests are all fine, but type inference falls over like so:

```typescript
const forceNumber = z.union([z.string(), z.number()]).pipe(z.coerce.number())

const dataSchema = z.object({
  numberOrString: forceNumber,
})

type Data = z.infer<typeof dataSchema>

// parse any data into schema or fail
const parseSchema = <U>(data: any, schema: z.ZodType<U>): U => {
  return schema.parse(data)
}

// log Data
const logSchemaData = (data: Data) => {
  console.log(data)
}

function processDataAndLog(data: any) {
  const parsedData = parseSchema(data, dataSchema)
  logSchemaData(parsedData)
}

```

this gives us the following error:

![image](https://github.com/colinhacks/zod/assets/196705/a29b0833-870e-4ead-98fd-5ab677c77b6a)
",,
2276642067,3459,zod  a field whose type is jsonLogic.RulesLogic. From type to zod,"Hi.
What the best `zod` function to check for a type `jsonLogic.RulesLogic` [https://github.com/jwadhams/json-logic-js/](https://github.com/jwadhams/json-logic-js/)

I use `type` and would like to derive the `zod` schema from iit.

```ts
export type Permission = {
  actions: string[];
  resources: string[];
  condition: jsonLogic.RulesLogic;
}
```
what should be a schema for this type.

Thanks ",,
2275327844,3456,feat: single method to comine `.unwrap().unwrap()`,"Currently, if you have a schema with both optional and nullable, you have to call unwrap twice in order to get the base type. It would be nice to get it immediately.

I propose adding something like `.nonnullable()` (to match TypeScript's `NonNullable<T>` type) that does this in one shot:

Sandbox: https://stackblitz.com/edit/vitejs-vite-ursctp?file=src%2Fmain.ts",,
2266834921,3448,Override safeParse and parse behavior at a given key,"I'm looking to implement a Zod schema that supports ""hard"" and ""soft"" type definitions in the same schema with little boilerplate. What I mean by that is combining the behaviors of parse and safeParse in the same schema. 

For example, given a schema 
```
export const simpleSchema = z.object({
  errorIfNotString: z.string(),
  warnIfNotString: z.string(),
});
```

If the parsed object doesn't have a string value for `errorIfNotString` I want to throw an error. If `warnIfNotString` is undefined, number type etc. I want to follow safeParse behavior and return an error message, but not throw. I understand this would be possible right now, I could define two separate schemas and call safeParse for one & parse with the other. However this can get complex for large objects, so I'd prefer an API that is something like the below:

```
export const simpleSchema = z.object({
  errorIfNotString: z.string().assert(),
  warnIfNotString: z.string().warn(),
});
```

The expected behavior would be an override of the called parse method. I.e. if I call parse() on simpleSchema, zod should still not throw an error in the event of mismatch on warnIfNotString. And if I call safeParse zod should still error if errorIfNotString ends up being a mismatch.

Happy to look into this and come back with a PR too, just wanted to get the discussion started!

Some quick things to note:
- the response type likely should always match safe parse if using this approach. It might be simplest to add a third .parse type, i.e. .multiParse that behaves like parse + ",,
2265825455,3446,Huge memory and performance gap between `parse` and `parseAsync`,"Running `parseAsync` instead of `parse` seems to have massive differences in resource consumption for larger objects.

I'd expect some overhead of async operations for sure, however in our production env. and in the benchmark as well the difference is 100x in time consumption and 10x in memory consumption.
Larger objects even OOM the entire node app with `parseAsync` whereas `parse` hovers at around 300mb.

The reproduction of a minimal bench setup can be found here: https://github.com/warflash/zod-async-perf

Tested on 2 machines with node 18 and 20.

Logs:
```
Benchmarking with 1000 elements
Validation time sync: 17.801ms
Validation time async: 36.208ms

Benchmarking with 10000 elements
Validation time sync: 63.467ms
Validation time async: 216.365ms

Benchmarking with 50000 elements
Validation time sync: 305.788ms
Validation time async: 1.778s

Benchmarking with 100000 elements
Validation time sync: 665.208ms
Validation time async: 4.917s

Benchmarking with 150000 elements
Validation time sync: 1.164s
Validation time async: 8.275s

Benchmarking with 200000 elements
Validation time sync: 1.273s
Validation time async: 22.556s

Benchmarking with 250000 elements
Validation time sync: 1.746s
Validation time async: 1:51.280 (m:ss.mmm)
```
",,
2263438517,3442,"Password match validation don't hide error, when input name not mentioned in refine() 'path' has changed","```
export const PasswordSchema = z.object({
  password: z.string(),
  password_confirmation: z.string(),
}).refine(
  (values) => values.password === values.password_confirmation,
  {
    message: 'Error',
    path: ['password_confirmation'],
  }
);```

This scheme is used like an example in docs. But if you: 
1. validate form
2. got error that passwords does not match
3. change ""password_confirmation"" field to valid
Everything is ok, error is gone now.

This scheme is used like an example in docs. But if you: 
1. validate form
2. got error that passwords does not match
3. change ""password"" field to valid
Error remains!",,
2263191309,3441,Zod dealing with image object,"I'm working with react-file-base64 which gives metadata of files such as name, type of files, size, base64 encoding, i registered the zod validation, even though i uploaded the image, zod throws ""image required error"". I cross verified, zod isn't accepting any image object to verify, How to deal with this error.

```ts
interface featured_image_types {
    name: string;
    type: string;
    size: string;
    base64: string
}

 const schema = z.object({
        blog: z.any({ required_error: ""Please enter a blog content, it cannot be empty!!!"" }),
        title: z.string().min(5, { message: ""Title should be atleast minimum 5 characters"" }).refine((val) => console.log(val)),
        reading_time: z.string({ required_error: ""Reading Time required"" }),
        featured_image:  z
        .any()
        // Custom refinement function to log files
        .refine((files) => {
        console.log(files, ""this not rertriviing files here"");
          // Return null to ensure the validation continues
        return true;
        })
        // To not allow empty files
        .refine((files) => files?.length >= 1, { message: 'Image is required.' })
        // To not allow files other than images
        .refine((files) => ACCEPTED_IMAGE_TYPES.includes(files?.[0]?.type), {
        message: '.jpg, .jpeg, .png and .webp files are accepted.',
        })
        // To not allow files larger than 5MB
        .refine((files) => files?.[0]?.size <= MAX_FILE_SIZE, {
        message: `Max file size is 5MB.`,
        }),
        blog_cat: z.string({ required_error: ""Please select one of blog cateogry"" }).min(6, { message: ""Please select one of blog cateogry"" }),
        tags: z.any()
    })
    
<div>
<label className=""block mb-2 text-sm font-bold"" htmlFor=""file_input"">Featured Image</label>

 <FileBase
     type = 'file'
     {...register('featured_image')}
     multiple={false}
     onDone={(file: featured_image_types) => setSomething({ ...something, featured_image: file })}
                            />

    {errors.featured_image && <p className=""text-red-500"">{errors?.featured_image?.message?.toString()}</p>}

                        </div>
                        
                        
// This part return undefined
.refine((files) => {
        console.log(files, ""this not rertriviing files here"");
          // Return true to ensure the validation continues
        })
```
",,
2262720261,3439,Default enum generic,"If you have existing string union types, enum requires both generics to be defined in order to type guard against the input. Example:

```ts
import { z } from 'zod';

type TColors = 'Red' | 'Green' | 'Blue';

// Type error
z.enum<TColors>([""Red"", ""Green"", ""Blue""]);

// Success
z.enum<TColors, [TColors, ...TColors[]]>([""Red"", ""Green"", ""Blue""]);
```

To get around this, the  `createZodEnum`  overrides need a default generic for the second parameter
```ts
function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]> = Readonly<[U, ...U[]]>>(
  values: T,
  params?: RawCreateParams
): ZodEnum<Writeable<T>>;
function createZodEnum<U extends string, T extends [U, ...U[]] = [U, ...U[]]>(
  values: T,
  params?: RawCreateParams
): ZodEnum<T>;
```",,
2260464124,3437,JSDoc hints are lost after using `.extend`,"Once you use `.extend`, any JSDoc hints are lost.

```ts
import { z } from 'zod';

const v1 = z.object({
    /** this works */
    userId: z.string(),
});

const v2 = z.object({
    /** this doesn't */
    itemId: z.string(),
}).extend(v1.shape);

const instance1: z.infer<typeof v1> = {
    userId: '2' // has hint on hover
}

const instance2: z.infer<typeof v2> = {
    itemId: '1',
    userId: '2'
}

```

Playground - https://tsplay.dev/w2oKzN",,
2258017923,3434,Type changes in 3.23 breaks some code,"We have a code base, where we've used branded strings for a long time. (before ZodBranded was added).
And to make that work, I believe the recommended way at the time was for them to be cast as `ZodSchema<BrandedStringType>`

We also have a function requiring a ZodObject with a defined Input and Output. (we need the .shape property)
After upgrading to 3.23, what's the best workaround for this, here's an example where the type checking is getting angry:

Exemple:
```typescript
type BrandedString = Branded<string, ""BrandedString"">;
const aBrandedString = z.string() as unknown as z.ZodSchema<BrandedString>;

const helloSchema = z.object({
    name: aBrandedString,
});
type Hello = z.infer<typeof helloSchema>;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const func = (hello: z.ZodObject<any, any, any, Hello, Partial<Hello>>) => {
    // ...
}

const funcResult = func(helloSchema); // this type errors out
```

The call to func doesn't like the helloSchema since 3.23 because it now thinks name of hello could be `{ name?: unknown }`
```typescript
Argument of type 'ZodObject<{ name: ZodType<BrandedString, ZodTypeDef, unknown>; }, ""strip"", ZodTypeAny, { name: string & _BrandedTagged<""BrandedString"">; }, { ...; }>' is not assignable to parameter of type 'ZodObject<any, any, any, { name: string & _BrandedTagged<""BrandedString"">; }, Partial<{ name: string & _BrandedTagged<""BrandedString"">; }>>'.
   Type '{ name?: unknown; }' is not assignable to type 'Partial<{ name: string & _BrandedTagged<""BrandedString"">; }>'.
     Types of property 'name' are incompatible.
       Type 'unknown' is not assignable to type '(string & _BrandedTagged<""BrandedString"">) | undefined'.ts(2345)
``` 


We could get around this by doing something like (to mimic zodtypes/zodschema old behavior (Input = Output):

```typescript
const aBrandedString = z.string() as unknown as z.ZodSchema<BrandedString, ZodTypeDef, BrandedString>;
```

or maybe for convenience:
```typescript
type ZodSchemaOf<T> = ZodSchema<T, ZodTypeDef, T>
const aBrandedString = z.string() as unknown as ZodSchemaOf<BrandedString>;
```

So my question is, what is the recommended way of getting around and solving these new type issues when upgrading to 3.23? (I should perhaps add that the real `func` is generic, and the `Hello` type is passed as a generic type). Is it reverting back to setting Input = Output manually like it was before the best way, or is there a better way to solve this for the future? Maybe there is a better way to accept a type safe ZodObject as a parameter? We could of course switch to AnyZodObject but then we would loose the type safety of the func hello parameter in the example. 🤔 ",,
2255858017,3431,Type changes in 3.23 ,"Hi Colin,

@t3-oss/t3-env has started failing in zod@3.23: https://github.com/t3-oss/t3-env/issues/222

We're not using any internal types which made me think you've unintentionally broken semver for this release?

See the source, we're basically just using ZodType: 
- https://github.com/t3-oss/t3-env/blob/main/packages/core/src/index.ts
- https://github.com/t3-oss/t3-env/blob/main/packages/nextjs/src/index.ts

We're also not really using the ZodType generics, so I don't think that change is relevant here. We're only using ZodType as a constraint",,
2255840310,3430,[Feature Request] store validator function for z.refine,"Hi, thank you for building this powerful validation library~

## Feature Request

Could we store the user-defined validator in somewhere like `schema._def.effect`:

https://github.com/colinhacks/zod/blob/890556e/src/types.ts#L322

## Use case

I'm implementing a [zod-schema-faker](https://github.com/iendeavor/zod-schema-faker) library to generate fake data for zod.

Recently I am trying to support fake data generation for **custom schema (`.custom`)** and **custom validation logic (`.refine`)**, the strategy is to identify the schema/validator and execute user-defined faker to achieve the goal.

For example:

```ts
// user may have this validator:
const validator = (val: string) => val.length <= 255
const schema = z.string().refine(validator, {
  message: ""String can't be more than 255 characters"",
})

// they could generate data by register a custom validator:
function validatorFaker(fakeVal: string): string {
  return fakeVal.slice(0, 255)
}
installRefine(validator, validatorFaker)
const fakeData = fake(schema)
```

Further info about how custom schema to be supported:

```ts
import * as z from 'zod'
import { fake, installCustom, ZodTypeFaker, runFake, install } from 'zod-schema-faker'

const pxSchema = z.custom<`${number}px`>(val => {
  return typeof val === 'string' ? /^\d+px$/.test(val) : false
})

class pxFaker extends ZodTypeFaker<typeof pxSchema> {
  fake(): `${number}px` {
    return `${runFake(faker => faker.number.int({ min: 0 }))}px`
  }
}
install()
installCustom(pxSchema, pxFaker)
const data = fake(pxSchema)
// > '10px'
```

Thank you 😄 
",,
2253316314,3423,Zod validation for fields that are rendered optionally to DOM,"I am using ZOD, react-hook-form, axios in a next js form. I am facing difficulty regarding how to add validation logic to a password, confirm-password field in my form

- they are initially hidden by a boolean state value (this state can be toggled thus adding/removing the 2 password field to DOM)
- if rendered, then they are first required && secondly they should be same naturally
- if not rendered then they are not required


```tsx
type EditProfile = z.infer<typeof editProfileSchema>;


  const {
    control,
    register,
    handleSubmit,
    formState: { errors },
    setValue,
  } = useForm<EditProfile>({
    resolver: zodResolver(editProfileSchema),
  });


  const profileDetailsQuery = useQuery({
    queryKey: [""profile_details""],
    queryFn: getProfileData,
    refetchOnWindowFocus: false,
  });

  const editProfileMutation = useMutation({
    mutationFn: updateProfileData,
    onSuccess: () => {
      toast.success(""Profile edited successfully"", {
        duration: 1800,
      });
      router.replace(""/welcome"");
    },
  });


  const handleFormSubmit = (data: any) => {
    const { [""confirmPassword""]: excluded, ...actual } = data;
    const obj = { ...actual };
    if (croppedImage) {
      obj.profile_image = croppedImage;
    }
    editProfileMutation.mutate({
      profile: {
        ...obj,
      },
    });
  };

  return (
    <>
      <form  onSubmit={handleSubmit(handleFormSubmit)}>
         //...
         <AnimatePresence>
                        {pwdChange && (
                          <motion.div
                            className=""grow""
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0 }}
                            transition={{ duration: 0.3 }}
                          >
                            {/* pwd */}
                            <InputWrapper
                              backgroundColor=""#FECB46""
                              className=""mb-5""
                            >
                              <input
                                type=""password""
                                placeholder=""placeholder""
                                id=""password""
                                className=""input-primary peer h-14 w-full text-sm""
                                {...register(""password"")}
                              />
                              {errors.password && (
                                <p className=""mt-2 text-sm text-red-400"">
                                  {errors.password.message}
                                </p>
                              )}
                              <label
                                htmlFor=""password""
                                className=""label-primary""
                              >
                                password
                              </label>
                            </InputWrapper>
                            {/* confirm pwd */}
                            <InputWrapper backgroundColor=""#FECB46"">
                              <input
                                type=""password""
                                placeholder=""placeholder""
                                id=""confirmPassword""
                                className=""input-primary peer h-14 w-full text-sm""
                                {...register(""confirmPassword"")}
                              />
                              {errors.confirmPassword && (
                                <p className=""mt-2 text-sm text-red-400"">
                                  {errors.confirmPassword.message}
                                </p>
                              )}
                              <label
                                htmlFor=""confirmPassword""
                                className=""label-primary""
                              >
                                confirm password
                              </label>
                            </InputWrapper>
                          </motion.div>
                        )}
                      </AnimatePresence>
         //...
      </form>
    </>
  )

```

ZOD schema:


```ts
const editProfileSchema = z
  .object({
  //...

    password: z
      .string()
      .min(8, { message: ""min 8 chars required"" })
      .optional()
      .or(z.literal("""")),
    confirmPassword: z.string().optional().or(z.literal("""")),

   //...
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: ""password do not match"",
    path: [""confirmPassword""],
  });
```




What I did :

- I made them optinal or string, then checked they are equal or not with refine.

But I still think why should ZOD validation be applied something that is not in DOM?


My problems: 

- if i am not making those fields optional, ZOD is not letting me submit the form (I wonder why ? I mean these two inputs  not in DOM, so why validation applied to them ?)
",,
2252888571,3422,ZodError#message cannot deal with circular data structures in its `issues`,"# Example

A Mocha test that shows the issue:

```javascript
/* eslint-env mocha */

const { z, ZodError } = require('zod')

describe('zod', function () {
  it('cannot deal with circular data structures', function () {
    const AnObjectSchema = z.object({ someLiteralProperty: z.literal(1) })

    const cicrularObject = {
      aProperty: 'a property',
      anotherProperty: 137,
      anObjectProperty: { anObjectPropertyProperty: 'an object property property' },
      anArrayProperty: [{ anArrayObjectPropertyProperty: 'an object property property' }]
    }
    cicrularObject.anObjectProperty.cicrularObject = cicrularObject
    cicrularObject.anArrayProperty.push(cicrularObject.anObjectProperty)
    const violatingObject = { someLiteralProperty: cicrularObject }

    const { success, error } = AnObjectSchema.safeParse(violatingObject)

    success.should.be.false()
    error.should.be.an.instanceof(ZodError)
    error.message.should.be.a.String()
  })
})
```

This test fails with

```
TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'Object'
    |     property 'anObjectProperty' -> object with constructor 'Object'
    --- property 'cicrularObject' closes the circle
    at JSON.stringify (<anonymous>)
    at get message [as message] (node_modules/zod/lib/ZodError.js:105:21)
    at Context.<anonymous> (test/00.zodIssue.js:23:11)
    at process.processImmediate (node:internal/timers:478:21)
```

# Analysis

[ZodError.ts](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts), line 283:

```typescript
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
```

`JSON.stringify` is called on `this.issues`. `JSON.stringify` cannot cope with circular data structures. In the example, the circular data structure appears in the  `received` property of the issue.

`jsonStringifyReplacer` does not deal with this either:

[helpers/util.ts#jsonStringifyReplacer](https://github.com/colinhacks/zod/blob/master/src/helpers/util.ts), line 91:

```typescript
  export const jsonStringifyReplacer = (_: string, value: any): any => {
    if (typeof value === ""bigint"") {
      return value.toString();
    }
    return value;
  };
```",,
2250912296,3418,Feature Request: Runtime introspection of the output type of a zod schema,"Hi! 

Absolutely love zod, it's the first package I add to any TS project I'm working on.

I'm curious if zod has support / docs / examples of other projects that read schema types at runtime? Is depending on the internals of zod to do this a bad idea?

I'm the maintainer of the [`ERA` relational algebra library](https://newera.dev/). It ships with a runtime relational algebra type checker for type checking queries. I'd like to build a feature in `ERA` that roughly looks like this

```
class Relation {
  /* .. */
   
  compile<T extends z.ZodTypeAny>(zodSchema: T): () => Promise<z.infer<T>[]> {
      // at runtime, the relation class runs ERA typechecker and knows the type of the 
      // output of this sql query. Lets say the query returns rows of the form `{ foo: string | null, bar: number }`
      // I'd like to use `zodSchema` at runtime and make sure it can accept values of that form before
      // actually running the query.
      
      // Conceptual pseudo code
     for (const zodField of zodSchema.something) {
        assert(compatible(zodField, eraTypeCheck[zodField.name]))
     } 
  }
} 
```

Another way this could be accomplished is generating a zod schema from the era types and some sort of `z.implementsOutputOf` 

```
schemaA.implementsOutputOf(schemaB)
``` ",,
2250585258,3417,expose zod schema for parsing errors,"When using zod it can return [various errors](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts) when parsing.

I would be nice if the zod library itself would expose a zod schema for these errors (dogfooding).

This could be very useful when e.g. using zod-openapi to use it as error response schema in a 400/422.

```
import * as z from ""zod"";

..

    responses: {
      200: {
        description: 'OK',
        content: {
          'application/json': {
            schema: PetSchema,
          },
        },
      },
      400: {
        description: 'Invalid request',
        content: {
          'application/json': {
            schema: z
              .object({
                errors: z.array(z.errorSchema), // <-- what is proposed to be exposed by zod
              }),
          },
        },
      },
```",,
2250536631,3416,The 'error' property does not exist in the type 'SafeParseReturnType,"I am trying to make a validator for my Config module  like this:

import { z as zod } from 'zod';

const validationSchema = zod.object({
  NODE_ENV: zod.string(),
  APP_PORT: zod.coerce.number().default(3000),
  DB_HOST: zod.string().min(4),
  DB_PORT: zod.coerce.number(),
  DB_NAME: zod.string(),
  DB_USER: zod.string(),
  DB_PASSWORD: zod.string(),
});

export type EnvVariables = zod.infer<typeof validationSchema>;

export const validate = (config: unknown) => {
  const result = validationSchema.safeParse(config);

  if (!result.success)
    return {
      error: result.error,
    };

  return { value: result.data };
};



![Captura de pantalla 2024-04-18 a las 14 11 53](https://github.com/colinhacks/zod/assets/55498983/6dfaf2e8-c84c-4ac8-90d2-4d6d972a57e6)




But I am getting this error:   Error' property does not exist in type 'SafeParseSuccess<{ NODE_ENV?: string; APP_PORT?: number; DB_HOST?: string; DB_PORT?: number; DB_NAME?: string; DB_USER?: string; DB_PASSWORD?: string; }>'.



Node Version: 20.11.0
Typescript Version: 5.4.5
Zod Version:  3.22.4",,
2247115698,3410,Match only true,"There should be way to match true or false not both with z.boolean(). Example is field that can be a string or the value true. Some examples how it can look

```
z.union([
  z.string(),
  z.enum([true])
])

z.union([
  z.string(),
  z.boolean(true)
])

z.union([
  z.string(),
  true
])
```",,
2247036251,3408,Better errors for wrong schema,"If you use `{}` instead of `z.object({})` you get `TypeError: keyValidator._parse is not a function` which is not clear. There should be understandable error message that says you need `z.object({})` instead of plain object.

Same thing on `z.enum('value', 'value')` there is error `TypeError: array.map is not a function` instead of telling you to wrap it in array like `z.enum(['value', 'value'])`.",,
2246798280,3407,RFC: Faster unions (vs `z.switch()`),"> This is a followup discussion to https://github.com/colinhacks/zod/issues/2106

Okay, I'm glad I didn't rush a `z.switch()` implementation, because I now think there's a better way forward. This is definitely *my own brilliant idea* and not something @gcanti suggested in a Twitter DM.

It's pretty simple, we just...make `z.union()` better. Here's the case for sticking with plain `z.union()`: 

- It's introspectable, unlike `z.switch()`. Code generation tools need a way to enumerate all elements of a union, and that isn't possible with `z.switch()`.
- It hews more closely to TypeScript conceptually (remember, TypeScript has no special concept of a ""discriminated union"")
- Implemented well, it can approach the performance of `z.discriminatedUnion` 

How? The idea is for Zod to do some ""pre-computation"" at the *schema creation time* to make parsing faster. 

- All Zod schemas will implement a `.getLiterals(): Set<Primitive>` method that returns the set of *known literal values* that will pass validation. For something like `z.string()`, this will be undefined (there are infinitely many valid inputs). For something like a ZodEnum or ZodLiteral, this will be a finite set of values. 
  - This method can also be implemented by user-defined subclasses, so this doesn't break extensibility!
- When you create a `z.union()`, Zod uses `getLiterals()` to extract a set of ""fast checks"" for each union element in the form `{[k: string]: Set<Primitive>`. 
- During parsing, Zod will do use these ""fast checks"" to quickly determine if the input has any chance of parsing properly against the schema.
- Ideally in most cases, only one schema will remain after the fast checks. Zod will use that schema to validate the input.
- If multiple union items pass the ""fast check"", the input will be validated against each one in succession (like a regular union). 
- Relatedly: Zod will implement a much-requested `abortEarly` mode to bail out ASAP in the event of validation errors. This mode will speed up ZodUnion performance even if there's no discrimination to be done. This was already on the Zod 4 roadmap but is made even more relevant now.

The API could also accept a ""discriminator hint"" to point the parser in the right direction. 

```ts
z.union([ ... ], {
  discriminator: ""someKey""
})
```

In retrospect, this is what the API always should have been. Discriminated unions are not a type unto themselves, just an optimization over unions, and the API should have reflected that. 


",,
2246246537,3406,how to validate external types,"is there a way in zod to validate external types not directly managed within my project?

in the example below I use a langgraph type to generate my own type. What I would like to do is create a zod schema to validate MyType.

```typescript
import { RunnableLike } from ""@langchain/core/runnables"";

export MyType = RunnableLike<string, number>
```",,
2246191167,3405,Error using .time(),"I'm trying to validate the date and time, but when I use .time() I get this error. Is there any alternative to using .time() to validate the time?

```js
export const appointmentSchema = z.object({
  clientHashId: z.string({ required_error: 'Client ID is required' }),
  employeeHashId: z.string({
    required_error: 'Employer ID is required',
  }),
  appointmentDate: z.coerce.date(),
  appointmentTime: z.string().time(),
})
```

**Error:** _The 'time' property does not exist in the 'ZodString' type._

To validate the date/time I'm using date-fns in the form submit, but could it be validated in zod as well or not necessarily?

Thank you in advance for your help.",,
2245476816,3404,How to merge a ZodEffect with a ZodObject,"I receive a type error saying that the first schema is of type ZodEffects, is there a way to infer the underlying object?

",,
2241768683,3396,Issue in making required field optional in ZOD? would you please tell me where is the issue in below code?,"const schema = z.object({
  workType: z.string().min(1, { message: ""Please select work type"" }),
  workSubType: z.string().min(1, { message: ""Please select work sub type"" }),
  workTypeDescriptions: z.string().min(1, { message: ""Please select description"" }),
  radioButtonSelection: z.enum([""Yes"", ""No""], {errorMap: () => ({ message: ""Please select an option"" })}),
  policyNumber: z.string().refine((value , data) => {
      if (data.radioButtonSelection === ""Yes"") {
        return  typeof value === 'string' && value.length >= 7;
      }
      return true;
    }, {message: 'please enter policy number', path:['policyNumber']}).optional(),
});",,
2235770246,3394,parameters and return type validation for functions,"Is there a way in zod to validate a function's parameters and its return type?
In the following example I have defined an object schema.
In the object there is a function that takes two parameters as numbers and returns void.
Then I defined an object in which there is a function that accepts a string and returns a boolean.
As you can see the output of the safeParse is success:true but in reality it is not correct as a result.

```typescript

import * as z from ""zod"";

const obj = {
    fn: (n: string) => { return true; }
}

const schema = z.object({
    fn: z.function(
            z.tuple(
                [
                    z.number(),
                    z.number()
                ]
            ),
            z.void()
        )
})

 // expected {success:false, error: ...}
let result = schema.safeParse(obj);

console.log(result); // received {success:true, data: ...}
```

![image](https://github.com/colinhacks/zod/assets/28861452/f62f9b32-7c26-49f7-8618-bbcb72ffa64a)",,
2231287818,3389,z.string().email() allows invalid emails with a comma,"It seems that the zod validation for email is allowing commas through which does not match the RFC 5322 standards. 

I'm on version `3.22.4`

To reproduce ([playground link](https://stackblitz.com/edit/typescript-k85yrc?file=index.ts)):
```typescript
import { z } from 'zod';

const myschmea = z.object({
  email: z.string().email(),
});

const test = {
  email: 'test,dumb@company.com',
};

const parse = myschmea.safeParse(test);

console.log(parse);

const appDiv: HTMLElement = document.getElementById('app');
appDiv.innerHTML =
  `<h1>TypeScript Zod Playground<br>` + JSON.stringify(parse) + `</h1>`;
```

Workaround - Disable typing of commas into input fields",,
2229878299,3387,`z.string().date` is not a function,"I just installed zod version `3.22.4`. 

I'm trying to create a validator for an ISO8061 date string (`YYYY-MM-DD`). According to [the docs](https://zod.dev/?id=iso-date-time-amp-datetime-validation), this can be done as follows:

> The `z.string().date()` method validates strings in the format `YYYY-MM-DD`.

However, the date() method doesn't seem to exist on the object returned by `z.string()`.

## Steps to reproduce

```typescript
const { z } = require(""zod"")
const dateSchema = z.string().date();
```

My IDE yields a TypeScript error on the above code:

> TS2339: Property `date` does not exist on type `ZodString`

Also, when I run the code, an error is thrown:

> TypeError: z.string(...).date is not a function

This can be verified on runkit: https://runkit.com/embed/ph6clqi91sj2

Screenshot below for reference.

![image](https://github.com/colinhacks/zod/assets/3456755/c92ca6e6-4fe5-4e5b-ae69-ac42ec6b771e)

## Workaround

I'm using the `refine` method as a workaround

```typescript
z.string().refine((str: string) => {
  return (
    /^\d{4}-\d{2}-\d{2}$/.test(str) &&
    new Date(str).toISOString().startsWith(str)
  );
});
```",,
2228416001,3383,z.union allow ZodType array spread as argument,"I am attempting to use a dynamically generated array of strings to define a `z.union()` that validates that a string is included within said dynamic array.

To do this I am mapping each element of my dynamic array of strings to `z.literal()`, and then spreading this mapped array of literals to the union type.

```typescript
import { z } from ""zod""
const TILES = [""a1"",""a2"",""a3"",""b1"",""b2"",""b3""]

// ERROR:
// Argument of type 'ZodLiteral<string>[]' is not assignable to parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
// Source provides no match for required element at position 0 in target.ts(2345)
const myUnion = z.union([
    ...TILES.map(tile => z.literal(tile))
])
```

This implementation results in typescript kicking up a fuss, as it is not sure that union has been provided any values. This is because zod's `union` type is hardcoded to have *atleast 2* ZodTypes provided to it. 
```typescript
declare const unionType: <T extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T, params?: RawCreateParams) => ZodUnion<T>;
```

This means to prevent typescript from complaining, *2* literals must be hardcoded before we spread our array of literals into the union.
```typescript
const myUnion = z.union([
    z.literal(""a1""),
    z.literal(""a2""),
    ...TILES.map(tile => z.literal(tile))
])
```
This is evidently not ideal as we may not have two values which we always wish to be included in our union type.

Is there any way `z.union()` could be re-typed / changed in some way to better support spreading of ZodType arrays? ",,
2223057428,3376,`.parse()` and `z.output` does make `.optional().default()` undefined even tho it is always defined,"Consider the following:

```
export const catSchema = z.object({
  name: z.string().default('cat').optional(),
});

export type Cat = z.output<typeof catSchema>;
```

The name is `string | undefined` when using the schema but in the output of `.parse()` or when using `z.output` it is still `string | undefined` even tho it will always be `string` and cant possibly be undefined.",,
2222565160,3374,Alternatives to using strict mode?,"Zod changes its behavior depending on if Typescript is using strict mode.

For example:

```
const User = z.object({
  username: z.string(),
});

type User = z.infer<typeof User>;
```

Non-strict:

```
type User  {
   username?: string
}
```

Strict:

```
type User {
   username: string
}
```

I can't help feel this is unexpected behavior, since field optionality has nothing to do with what mode typescript is running in.


I'm trying to add zod to an existing typescript codebase that doesn't use strict mode. Porting the whole codebase right now would be infeasible.

Is there any way to get the strict type output without having to port my entire codebase over?",,
2215030567,3368,Not able to change state inside refine ,"When i try to submit the form at first, the **firstField** doesnot get updated but when i submit the form again, the firstField gets updated. Can i know why i have to resend the form again to get updated state.

```typescript
const formSchema = z.object({
    email_phone: z.string().refine(
      (value) => {
        if (emailRegex.test(value)) {
          setFirstField(""email"");
          return true;
        } else if (phoneRegex.test(value)) {
          setFirstField(""mobile_no"");
          return true;
        } else {
          setFirstField(""email"");
          return false;
        }
      },
      {
        message: ""Please enter a valid email or phone number"",
      }
    ),
  });
``` 
  
  ",,
2210123705,3364,z.union has no `_parseSync` method with bare literals,"I'm getting an error when trying to call parse on a union with primitive literals:

```
const schema = z.union(['a', 'b'])
schema.parse('a') // Throws Error: option._parseSync is not a function
```

Using numbers or booleans gives the same results.

Changing the `union` to an enum or wrapping the literals in `z.literal` fixes the issue.

Zod version 3.22.4",,
2209558506,3363,Branded types inferred improperly by function when inside `ZodObject` passed as `ZodSchema`,"# Description

When passing a `ZodObject` containing a branded type to a function as a `ZodSchema`, the function infers the type of the branded field without the brand(IE turning `foo: string & z.BRAND<'brand'>` into `foo: string`). This means functions which seek to validate using Zod schemas generically are effectively unable to work with branded types.
# Example

```ts
// Should return exactly what it's passed
const schemaId = <T>(schema: ZodSchema<T>) => schema;

const myObject = z.object({ foo: z.string().brand('brand') });
const shouldEqualMyObject = schemaId(myObject); // T inferred as { foo: string } instead of { foo: string & z.BRAND<'brand'> }

type MyObject = z.infer<typeof myObject>; // { foo: string & z.BRAND<'brand'> }
type ShouldEqualMyObject = z.infer<typeof shouldEqualMyObject>; // { foo: string }
```

# Workarounds

Notably, this does *not* occur when `schemaId` takes a `ZodObject` like so
```ts
const schemaId = <T extends ZodRawShape>(schema: ZodObject<T>) => schema;
// ...
type ShouldEqualMyObject = z.infer<typeof shouldEqualMyObject>; // { foo: string & z.BRAND<'brand'> }
```
or when the generic `T` is for the whole `ZodSchema`
```ts
const schemaId = <U extends ZodSchema>(schema: U) => schema;
// ...
type ShouldEqualMyObject = z.infer<typeof shouldEqualMyObject>; // { foo: string & z.BRAND<'brand'> }
```

",,
2209009103,3362,Safeparse doesn't give back the expected data,"### Discussed in https://github.com/colinhacks/zod/discussions/3361

<div type='discussions-op-text'>

<sup>Originally posted by **kapsule-studio** March 26, 2024</sup>
I have a `product` schema, that never returns the `secondaryImages` after the parsing. It gives an empty array whereas it is clear that it isn't empty before parsing. Any help would be greatly appreciated, thanks!

Here is my schema
```typescript
export const ZodProduct = z.object({
  name: z.string().min(1),
  slug: z.string(),
  collections: z.array(
    z.object({
      name: z.string(),
      parent: z.string().nullable(),
      products: z.array(z.string())
    })
  ),
  variants: z.array(
    z.object({
      id: z.string(),
      name: z.string().min(1),
      images: z.object({
        mainImage: z.string(),
        secondaryImages: z.array(z.string())
      }),
      price: z.number().min(0),
      comparedAt: z.number().min(0).optional(),
      weight: z.number().min(0).optional(),
      width: z.number().min(0).optional(),
      height: z.number().min(0).optional(),
      length: z.number().min(0).optional(),
      sku: z.string().min(1).optional()
    })
  )
})
```

Here is my implementation
```typescript 
const product = {
  name: name,
  slug: toSlugFormat(name),
  collections: prodCollections,
  variants: formattedVariants
}

console.log('before', product)

const productValidation = ZodProduct.safeParse(product)
if (productValidation.success) {
  console.log('valid', productValidation.data)
  createProduct(productValidation.data)
}
```

And here are the results

![image](https://github.com/colinhacks/zod/assets/77295465/d4dfb5a2-f895-41c2-9393-f9027fa77e22)

</div>",,
2202627121,3351,Question: superRefine on nested objects,"Hi, I tried to play around with`.superRefine` to add some custom issues. I found that zod only supports these on the first level of an object schema. Could someone confirm with me that this is true? Or am i missing something?

```
export const AnotherSchema = z.object({
    id: z.string(),
    clientId: z.string(),
});

export const BaseSchema = z.object({
    key1: z.string().superRefine((val, ctx) => {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: 'trouble looking'
        });
    }),
    key2: AnotherSchema,
});
```

if I add 
```
export const BaseSchema = z.object({
    key1: z.string().superRefine((val, ctx) => {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: 'trouble looking'
        });
    }),
    key2: AnotherSchema,
});
```
This works fine. I can see:
```
ZodError: [
      {
        ""code"": ""custom"",
        ""message"": ""trouble looking"",
        ""path"": [
          ""key1""
        ]
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""key2"",
          ""clientId""
        ],
        ""message"": ""Required""
      }
    ]
```
However moving the superRefine to key2's schema won't print out any issues like above.

If this is expected behaviour, how can I make zod to throw a custom issue or error on nested objects then?

Thank you.
",,
2201475244,3349,Broken overload in `z.record()`.,"There's a bug in the overloads for `z.record()` that lets you to pass in an arbitrary schema as the key schema into `z.record()`...whoops. 

```ts
const schema = z.record(z.object({ name: z.number() }), z.number());
// no TS errors
```

The expected behavior is that the first argument should conform to `type KeySchema = ZodType<string | number | symbol, any, any>;` but it currently doesn't. 

In order to fix it I need to remove the ""single argument"" shorthand: `z.record(z.number)`, which will land in Zod 4.",2014679823,"Did you write it backwards?

<img width=""1551"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/32638462/a51f270f-e07b-41f8-a717-01a51df82c96"">


```js
const User = z.object({ name: z.string() });

const UserStore = z.record(z.string(), User);
```
"
2201475244,3349,Broken overload in `z.record()`.,"There's a bug in the overloads for `z.record()` that lets you to pass in an arbitrary schema as the key schema into `z.record()`...whoops. 

```ts
const schema = z.record(z.object({ name: z.number() }), z.number());
// no TS errors
```

The expected behavior is that the first argument should conform to `type KeySchema = ZodType<string | number | symbol, any, any>;` but it currently doesn't. 

In order to fix it I need to remove the ""single argument"" shorthand: `z.record(z.number)`, which will land in Zod 4.",2016057090,"I did not. The point is that this code should throw an error when I try to pass a `ZodObject` as the key, but it doesn't. 
"
2201475244,3349,Broken overload in `z.record()`.,"There's a bug in the overloads for `z.record()` that lets you to pass in an arbitrary schema as the key schema into `z.record()`...whoops. 

```ts
const schema = z.record(z.object({ name: z.number() }), z.number());
// no TS errors
```

The expected behavior is that the first argument should conform to `type KeySchema = ZodType<string | number | symbol, any, any>;` but it currently doesn't. 

In order to fix it I need to remove the ""single argument"" shorthand: `z.record(z.number)`, which will land in Zod 4.",2080774566,"@colinhacks looks like this could be fixed like this:
```ts
static create<Value extends ZodTypeAny, Params extends RawCreateParams>(
  valueType: Value,
  params?: Params extends ZodTypeAny ? never : Params
): ZodRecord<ZodString, Value>;
```

Not super ideal but it will complain about it will `never` if the 2nd param is a `ZodTypeAny` forcing TS to choose the other overload.

Though if you're removing the single arg variant this would be moot"
2201398114,3348,mark bound methods with `this: void`,hello is it possible to mark the bound methods of `ZodType` and others with `this: void`? maybe with declaration merging or something i'm not sure. linter rules like [this one](https://typescript-eslint.io/rules/unbound-method/) make it cumbersome to pass references to those methods around because they're designed to detect situations where methods get detached from their instance,,
2198136607,3343,Using discriminatedUnion with nativeEnum,"There is an issue when using `discriminatedUnion` in combination with `nativeEnum`s. (`enum`s work fine.)

I created a playground to reproduce this: https://stackblitz.com/edit/zod-discriminated-union-enums?file=schemas%2FschemaTests.ts

The native enums look like this:
```ts
enum Type1 {
  FirstType = 'firstType',
}
enum Type2 {
  SecondType = 'secondType',
  ThirdType = 'secondType',
}
```
The error message when using them to parse an object with `type: 'firstType'` is:
```
Invalid discriminator value. Expected 'FirstType' | 'SecondType' | 'ThirdType'
```

zod seems to use the enum **keys** instead of the values here, which is wrong from my perspective. When using a `nativeEnum` in simpler schemas, it takes the value (`firstType` etc.) as expected.

As a workaround, we now use `enum([Type1.FirstType])` etc., but that is not really a clean solution IMO.

Can you confirm this is a bug in zod?



---
<details><summary>Playground Code</summary>
<p>

```typescript
import { z } from 'zod';

const testData = { type: 'firstType', data: { something: 'test' } };

/**
 * NON-NATIVE ENUMS
 */

const schema1 = z
  .object({
    type: z.enum(['firstType']),
    data: z.object({ something: z.string() }),
  })
  .strict();

const schema2 = z
  .object({
    type: z.enum(['secondType', 'thirdType']),
    data: z.object({ somethingElse: z.string() }),
  })
  .strict();

export const schemaUnion = z.discriminatedUnion('type', [schema1, schema2]);

const validatedTestData = schemaUnion.safeParse(testData);

console.info('Validated non-native enums (success)', validatedTestData);

/**
 * NATIVE ENUMS
 *
 * It seems to take the enum key (left side) instead of the value (right side).
 */

enum Type1 {
  FirstType = 'firstType',
}
enum Type2 {
  SecondType = 'secondType',
  ThirdType = 'secondType',
}

const schema1Native = z
  .object({
    type: z.nativeEnum(Type1),
    data: z.object({ something: z.string() }),
  })
  .strict();

const schema2Native = z
  .object({
    type: z.nativeEnum(Type2),
    data: z.object({ somethingElse: z.string() }),
  })
  .strict();

export const schemaUnionNative = z.discriminatedUnion('type', [
  schema1Native,
  schema2Native,
]);

const validatedTestDataNative = schemaUnionNative.safeParse(testData);

console.info('Validated native enums (fails)', validatedTestDataNative);

``` 

</p>
</details> ",,
2197443274,3341,z.infer<T> infers dynamic fields are required even if required prop is false.,"Environment:
- zod v. 3.22.4
- TypeScript v. 4.9.5

I have this props

```js
interface Props {
  additional_questions?: Question[]
}
```

Question is this type

```js
type TextQuestion = {
  id: number;
  title: string;
  type: ""text"";
  value: string;
  required?: boolean;
};
```

The property additional_questions is 

```js
[
 {
  id: 1, 
  title: ""Idade"", 
  value: """", 
  type: ""text"", 
  required: false 
 }
]
```

I have this zod form scheme

```js
const formSchema = z.object({
    email: z.string().email(""E-mail inválido""),
    names: z.string().min(1, ""Campo obrigatório""),
    surnames: z.string().min(1, ""Campo obrigatório""),
    phonenumber: z.string(),
    attendance: z.enum([""yes"", ""no""], {
      required_error: ""Precisa de selecionar se aceita ou não o convite."",
    }),
    message: z.string(),
    additional_questions: z.array(
      z.object({
        id: z.number(),
        answer: z.string().min(1),
        title: z.string(),
        type: z.string(),
        required: z.boolean()
      })
    ),
  });
```

and this is the form:

```js
const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: """",
      names: """",
      surnames: """",
      phonenumber: """",
      attendance: ""yes"",
      message: """",
      additional_questions: props.additional_questions
    },
  });
```

And this is the render section:
```js
{props.additional_questions && props.additional_questions?.map((question, index) => (
  <FormField
    key={question.id}
    control={form.control}
    name={`additional_questions.${question.id}.id`}
    render={({ field }) => (
      <FormItem>
        <FormLabel>{question.title}:</FormLabel>
        <FormControl>
          {
            question.type == ""text"" ? <Input disabled={loading} {...field} /> :
              question.type == ""textarea"" ? <TextArea rows={5} disabled={loading}  {...field} /> :
                <div></div>
          }

        </FormControl>
        <FormMessage />
      </FormItem>
    )}
  />
))}
```

I don't know why when I try to submit the form all the additional questions are required even if the props.additional_questions has questions with required a false. 

<img width=""566"" alt=""Screenshot 2024-03-20 at 12 37 24"" src=""https://github.com/colinhacks/zod/assets/48591110/a0984a22-83c2-404e-b588-e1879413735c"">


Can you help me?",,
2192329083,3334,Object with Generic Properties makes the properties optional,"In the following code, if I use generic parameters to create some validators, as in `ValidatorFactory`, this makes all the non static properties optional. Is this a limitation on Typescript or Zod?

```ts
import { AnyZodObject, ZodType, z } from ""zod"";

type allowedStandardStringEnum=Record<string, string>
type EnumValues<Enum extends allowedStandardStringEnum> = Enum[keyof Enum]

function stringEnumValidator<Enum extends allowedStandardStringEnum>(enumParam:Enum):ZodType<EnumValues<Enum>>{
	return z.nativeEnum(enumParam);
}

function ValidatorFactory<StateEnum extends allowedStandardStringEnum, ZodDataObject extends AnyZodObject>(
	states:StateEnum,
	validator:ZodDataObject,
){
	return z.object({
    staticProp: z.string(),
		currentState    : stringEnumValidator(states),
		dataForFunction : z.unknown(),
		stateData       : validator,
	})
}

type FactoryReturn<StateEnum extends allowedStandardStringEnum, ZodDataObject extends AnyZodObject>=z.infer<ReturnType<typeof ValidatorFactory<StateEnum,ZodDataObject>>>


function execution<StateEnum extends allowedStandardStringEnum, ZodDataObject extends AnyZodObject>(instance:FactoryReturn<StateEnum, ZodDataObject>){
  let staticProp=instance.staticProp                // Correct
  let currentState=instance.currentState            // Incorrect
  let dataForFunction=instance.dataForFunction      // Incorrect
  let stateData=instance.stateData                  // Incorrect
}
```

I believe it may also be similar to https://github.com/colinhacks/zod/issues/2077


Also believing that it may be caused by https://github.com/colinhacks/zod/issues/3330, I can verify that `""strict"":true` has been set in tsconfig.json

Thanks in Advance for any help",,
2190927779,3332,z.undefined() behaves weird,"I was trying to create a schema verifier for one pre-existing interface and stumbled into a weird problem.

This works:
![image](https://github.com/colinhacks/zod/assets/50925676/325c2dd6-a210-4bd5-994b-cdc3f7055bb7)

But these aren't:
![image](https://github.com/colinhacks/zod/assets/50925676/418fd9af-12a4-480e-af0d-1738413cf0e8)
![image](https://github.com/colinhacks/zod/assets/50925676/bb22da54-3e40-4b4e-8f6f-fd9e6951ab8a)
![image](https://github.com/colinhacks/zod/assets/50925676/e387d084-7e9b-4fa5-8a9c-14e36ae683cb)

I find this behavior to be weird. I understand where it might come from, but describing some project types with this library becomes impossible. Also, I would like to point out that in the real project, I have no control over the interface, so this example is from the wild.",,
2190236795,3331,Recursive schema,"Hello,

I'm currently experiencing a problem that I can't solve.

I have a recursion problem between two schemas and I don't understand how to do it.

My first schema OrderResponseSchema:

```ts
export const OrderSchema = z.object({
  [...]
  account: CustomerSchema,
  [...]
});

export type OrderResponse = z.infer<typeof OrderResponseSchema>

export const OrderResponseSchema = z.object({
  count: z.number(),
  page_count: z.number(),
  page: z.number(),
  results: z.array(OrderSchema)
})
```

And my second CustomerSchema which extends the OrderResponseSchema in the orders object:

```ts
import { OrderResponseSchema } from ""./Order"";
import { z } from 'zod';

export type Customer = z.infer<typeof CustomerSchema>

export const CustomerSchema = z.object({
  [...]
  orders: z.optional(OrderResponseSchema),
});
```

This is the error I'm encountering:


```ts
'CustomerSchema' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.ts(7022)
const CustomerSchema: any
```

This error disappears if I comment out the orders object.

Thanks for your help

Versions:

```js
""typescript"": ""5.1.3"",
""zod"": ""^3.22.4""
```",,
2189273325,3330,z.infer<T> infers optional fields even though no .optional() is specified,"Environment:
- zod v. 3.22.4
- TypeScript v. 5.2.2

Reproduction: https://stackblitz.com/edit/react-ts-awcdlz?file=App.tsx

If I specify a Zod schema like this:
```ts
const RequiredNameSchema = z.object({
  requiredName: z.string(), // should infer required field
  optionalName: z.string().optional(),  // should infer optional field
});

type RequiredNameType = z.infer<typeof RequiredNameSchema>;
```

The inferred type of `RequiredNameType` is (note that both fields are optional):
```ts
type RequiredNameType = {
  requiredName?: string; // PROBLEM: infers optional field
  optionalName?: string;
}
```

Expected inferred type (e.g. as found in the example here: https://zod.dev/?id=basic-usage):
```ts
type RequiredNameType = {
  requiredName: string;
  optionalName?: string;
}
```

Or am I missing something?",,
2188352346,3328,coerce.boolean incorrect,"```js
import { z } from 'zod';

const schema = z.object({
	something: z.coerce.boolean(),
});

console.log(schema.parse({ something: 'false' }));
```

expected:
```
{ something: false }
```

got:
```
{ something: true }
```",,
2187158970,3326,[Generic Types] zod doesn't extend zod? Does not return correct?,"Hello, please.
Shouldn't this work?

Shouldn't parse() return an object that extends zod?

![image](https://github.com/colinhacks/zod/assets/1591772/a276dd30-a195-4ad8-a0ce-13f25553fee0)



```typescript
import { z } from 'zod';

const zData = z.object({
  name: z.string(),
});
type zData = z.infer<typeof zData>;

const zTypeInParameters = <T>(params: z.ZodType<T>) => {
  return z.object({
    data: params,
  });
};
type zTypeInParameters<T> = z.infer<ReturnType<typeof zTypeInParameters<T>>>;

const zTypeInExtends = <T extends z.ZodType>(params: T) => {
  return z.object({
    data: params,
  });
};
type zTypeInExtends<T extends z.ZodType> = z.infer<ReturnType<typeof zTypeInExtends<T>>>;

const zTypeInExtendsTypeAny = <T extends z.ZodTypeAny>(params: T) => {
  return z.object({
    data: params,
  });
};
type zTypeInExtendsTypeAny<T extends z.ZodTypeAny> = z.infer<ReturnType<typeof zTypeInExtendsTypeAny<T>>>;

const zDataInst = zData.parse({ name: 'abc' });
const zTypeInParametersInst: zTypeInParameters<zData> = zTypeInParameters<zData>(zDataInst);
const zTypeInExtendsInst: zTypeInExtends<zData> = zTypeInExtends<zData>(zDataInst);
const zTypeInExtendsTypeAnyInst: zTypeInExtendsTypeAny<zData> = zTypeInExtendsTypeAny<zData>(zDataInst);

console.log(zTypeInParametersInst, zTypeInExtendsInst, zTypeInExtendsTypeAnyInst);

```",,
2186979941,3325,Allow `data` and `error` to be accessed on `SafeParseReturnType` even when they may not be present,"When using zod in react applications, the error property is often unused. Instead, the primary focus is on either getting back parsed data or `undefined` (which can then be overwritten with some default value). Currently this involves a pointless intermediate variable.

```typescript
import {MyThingParser} from '../parsers'

const useMyThing = () => {
	const myThingResult = MyThingParser.safeParse(localStorage.get('myThingKey'))
	const myThing = myThingResult.success ? myThingResult.data : defaultMyThing
	// ... further transformations, defaulting, etc.
}
```

These sorts of patterns also come up frequently in tests, where it is usually solved with very broad casting.

```typescript
test('myThing is parsed correctly', () => {
  const myThingResult = MyThingParser.safeParse(testData)
  expect((myThingResult as any).data).toEqual(testData)
})
```

Both of these would be unneccessary if we made a slight change to the safe parse output type, while keeping the discriminated union structure.

```typescript
type SafeParseSuccessOutput<Output> = { 
    success: true; 
    data: output; 
    error? : never
}

type SafeParseError<Input> = { 
    success: false; 
    error: ZodError<Input>; 
    data? : never
}
```

This was initially discussed in #3266 , but that was closed because the original suggestion in that thread involved removing the discriminated union structure. There is a PR for this work already (#3295 ).",,
2184677260,3324,url validation does not work as expected,"``` typescript
import { z } from ""zod"";
import isUrl from ""is-url"";

console.log(""zod"", z.string().url().safeParse(""javascript:void();""));
console.log(""is-url"", isUrl(""javascript:void();""));
```
that gave output like

```
zod {
  success: true,
  data: ""javascript:void();"",
}
is-url false
```

*zod@3.22.4*, *is-url@1.2.4*
",,
2176914787,3313,Having `undefined` as a function that can be imported is a package design issue,"Hi everyone,

  First of all, we like `zod` a lot, it is an excellent tool for its job. However I feel that having an `undefined` function that can be imported separately (see example below) is a metaphorical rake lying in the grass that I am stepping on _way too frequently_. After a while my subjective opinion is that there should be no separately importable `undefined` variables in `zod`, because it just creates much confusion.

```typescript
// This just happens and then 💥 
import { undefined } from 'zod';
```

Any postfix/prefix could fix it, in my opinion.

If it's only me who is stepping on this rake, then just close this.",,
2176498552,3310,unable to catch errors,"I use promise, but I can't get the error in catch.

```ts
zod.number({
  required_error: 'title is required',
}).promise().parse(title).catch(() => {});
```

<img width=""680"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/10768858/777fb37d-086d-4f38-94db-130976a655c0"">
",,
2176472001,3309,Type inference is too loose in combination with generic functions,"## Motivation

I am trying to use Zod to validate and transform data received from an external API. It's shape nests lots of information in objects with a single key called `data`. For example, instead of

```js
[""a"", ""b"", ""c""]
```

we might receive
```js
[{data: ""a""}, {data: ""b""}, {data: ""c""}]
```

Transforming `{data: ""a""}` to `""a""` works as expected via the schema

```ts
z.object({ data: z.string() }).transform((a) => a.data)
```

## Problem

Since this pattern is so common, I want to extract this into a function:

``` typescript
function dataObj<T extends z.ZodTypeAny>(schema: T) {
  return z.object({ data: schema }).transform((a) => a.data);
}
```
According to [the documentation](https://zod.dev/?id=writing-generic-functions), I understand this to be the correct usage of generic parameters.

Unfortunately, the type inferring capabilities of TypeScript seem to fail, as the resulting type (determined by hovering over it in VS Code) always contains an unwanted `undefined`:

``` typescript
const test = dataObj(z.string())
z.infer<typeof test> // string|undefined, should be string
```

## Workaround
I can work around the problem by adding a type assertion in `transform`. But I assume, it should also work without this, since it works if the function is inlined.

``` typescript
function otherDataObj<T extends z.ZodTypeAny>(schema: T) {
  return z.object({ data: schema }).transform((a) => a.data as z.infer<T>);
}

const test = otherDataObj(z.string())
z.infer<typeof test> // string, ok
```

## Additional information
I am using TypeScript 5.4.2 and Zod 3.22.4.

I have prepared the example on [codesandbox.io](https://codesandbox.io/p/devbox/relaxed-framework-7npypx?file=%2Fsrc%2Findex.ts%3A5%2C2&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cltiwcgn200062v6gnc7vbsj4%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cltiwcgn200022v6gurks998r%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cltiwcgn200042v6gw08vynab%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cltiwcgn200052v6g57l4b0yw%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cltiwcgn200022v6gurks998r%2522%253A%257B%2522id%2522%253A%2522cltiwcgn200022v6gurks998r%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cltiwcgn200052v6g57l4b0yw%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522cltiwcgn200052v6g57l4b0yw%2522%257D%252C%2522cltiwcgn200042v6gw08vynab%2522%253A%257B%2522id%2522%253A%2522cltiwcgn200042v6gw08vynab%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltiwcgn200032v6gjgx0efpb%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%257D%252C%257B%2522id%2522%253A%2522cltiwkjon00cx2v6geowrneo7%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TERMINAL%2522%252C%2522shellId%2522%253A%2522cltiwkjpl00q2dag63pig2dci%2522%257D%255D%252C%2522activeTabId%2522%253A%2522cltiwkjon00cx2v6geowrneo7%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D).

I hope, you can help me with this problem. Thanks for investing your time.",,
2176430047,3308,Show discriminatorValue in discriminatedUnion error message,"Could we get the [discriminatorValue](https://github.com/colinhacks/zod/blob/master/src/types.ts#L2950) in the error message as well?

Please take a look at the following example:

```typescript
const schema = z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""apple"") }),
  z.object({ type: z.literal(""orange"") }),
]);

schema.parse({ type: ""banana"" });
```

Current error message (version 3.22.4):
```
​ Uncaught ZodError: [
  {
    ""code"": ""invalid_union_discriminator"",
    ""options"": [
      ""apple"",
      ""orange""
    ],
    ""path"": [
      ""type""
    ],
    ""message"": ""Invalid discriminator value. Expected 'apple' | 'orange'""
  }
]
```

Expected:
```
...
    ""message"": ""Invalid discriminator value. Expected 'apple' | 'orange', got 'banana'.""
...
```

https://playground.solidjs.com/anonymous/230fe5d4-25b0-41dd-b854-8b1b8f99b029
(PS. would love a zod playground, but did not find one suitable)",,
2164553824,3293,Property 'x' is optional in z.ZodType but required in TypeScript type?,"I have this [CodeSandbox](https://codesandbox.io/p/devbox/zod-playground-forked-g9t87m?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cln3s5wur00073b6hpvdyzdd7%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cln3s5wur00033b6h80ute5zp%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cln3s5wur00053b6h90wtxxns%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cln3s5wur00063b6h1y81405t%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cln3s5wur00033b6h80ute5zp%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00033b6h80ute5zp%2522%252C%2522tabs%2522%253A%255B%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522cln3s60zq002v3b6hm2cfn9qk%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fpackage.json%2522%252C%2522id%2522%253A%2522cln3sh8u0007x3b6g1r8nttu6%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%252C%2522activeTabId%2522%253A%2522cln3s60zq002v3b6hm2cfn9qk%2522%257D%252C%2522cln3s5wur00063b6h1y81405t%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00063b6h1y81405t%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cln3s5wur00053b6h90wtxxns%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cln3s5wur00043b6h3lhgss80%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%257D%255D%252C%2522id%2522%253A%2522cln3s5wur00053b6h90wtxxns%2522%252C%2522activeTabId%2522%253A%2522cln3s5wur00043b6h3lhgss80%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D), which has the following code. Notice that both in the TypeScript type, and the zod type, all properties are required. I am getting an error (shown below the code) which says that zod type is optional, which it shouldn't be.

```ts
import * as z from ""zod"";

export const FFMPEG_AUDIO_CODEC = [""foo"", ""bar""] as const;

export type FfmpegAudioCodec = (typeof FFMPEG_AUDIO_CODEC)[number];

export const FFMPEG_SUBTITLE_CODEC = [""foo"", ""bar""] as const;

export type FfmpegSubtitleCodec = (typeof FFMPEG_SUBTITLE_CODEC)[number];

export const FFMPEG_VIDEO_CODEC = [""foo"", ""bar""] as const;

export type FfmpegVideoCodec = (typeof FFMPEG_VIDEO_CODEC)[number];

export type ConvertVideoWithFfmpeg = {
  input: ArrayBuffer;
  output: ArrayBuffer;
  audioBitRate: number;
  audioChannels: number;
  audioCodec: FfmpegAudioCodec;
  audioSamplingFrequency: number;
  duration: number;
  endTime: number | string;
  frameRate: number;
  rotation: number;
  scaleHeight: number;
  scaleWidth: number;
  startTime: number;
  strict: boolean;
  subtitleCodec: FfmpegSubtitleCodec;
  videoBitRate: number;
  videoCodec: FfmpegVideoCodec;
};

export const FfmpegAudioCodecModel: z.ZodType<FfmpegAudioCodec> =
  z.enum(FFMPEG_AUDIO_CODEC);

export const FfmpegSubtitleCodecModel: z.ZodType<FfmpegSubtitleCodec> = z.enum(
  FFMPEG_SUBTITLE_CODEC,
);

export const FfmpegVideoCodecModel: z.ZodType<FfmpegVideoCodec> =
  z.enum(FFMPEG_VIDEO_CODEC);

export const ConvertVideoWithFfmpegModel: z.ZodType<ConvertVideoWithFfmpeg> =
  z.object({
    input: z.instanceof(ArrayBuffer),
    output: z.instanceof(ArrayBuffer),
    audioBitRate: z.number().int(),
    audioChannels: z.number().int(),
    audioCodec: z.lazy(() => FfmpegAudioCodecModel),
    audioSamplingFrequency: z.number(),
    duration: z.number().int(),
    endTime: z.union([z.number(), z.string()]),
    frameRate: z.number().int(),
    rotation: z.number(),
    scaleHeight: z.number().int(),
    scaleWidth: z.number().int(),
    startTime: z.number().int(),
    strict: z.boolean(),
    subtitleCodec: z.lazy(() => FfmpegSubtitleCodecModel),
    videoBitRate: z.number().int(),
    videoCodec: z.lazy(() => FfmpegVideoCodecModel),
  });
```

The last `export const ConvertVideoWithFfmpegModel` is throwing a TypeScript error:

```
Type 'ZodObject<{ input: ZodType<ArrayBuffer, ZodTypeDef, ArrayBuffer>; output: ZodType<ArrayBuffer, ZodTypeDef, ArrayBuffer>; ... 14 more ...; videoCodec: ZodLazy<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<ConvertVideoWithFfmpeg, ZodTypeDef, ConvertVideoWithFfmpeg>'.
  Types of property '_type' are incompatible.
    Type '{ input?: ArrayBuffer; output?: ArrayBuffer; audioBitRate?: number; audioChannels?: number; audioCodec?: ""foo"" | ""bar""; audioSamplingFrequency?: number; duration?: number; ... 9 more ...; videoCodec?: ""foo"" | ""bar""; }' is not assignable to type 'ConvertVideoWithFfmpeg'.
      Property 'input' is optional in type '{ input?: ArrayBuffer; output?: ArrayBuffer; audioBitRate?: number; audioChannels?: number; audioCodec?: ""foo"" | ""bar""; audioSamplingFrequency?: number; duration?: number; ... 9 more ...; videoCodec?: ""foo"" | ""bar""; }' but required in type 'ConvertVideoWithFfmpeg'.typescript(2322)
```

I follow this pattern everywhere in my large codebase of doing:

```ts
export const MyModel: z.ZodType<MyType> = z.object(...)
```

Because I use `z.lazy` in many many places, so I ned to use `z.ZodType`. But for some reason it is saying the type is not required in the zode type, even though it is required in the TypeScript type. How do I fix this? Is this a bug, or what am I doing wrong?

Thanks for the help! Please let me know how to make the properties all required, _while still specifying the `z.ZodType<T>`.

Note, I get a different but similar error locally (it errors on a different property):

<img width=""724"" alt=""Screenshot 2024-03-01 at 7 25 41 PM"" src=""https://github.com/colinhacks/zod/assets/28718/1c3968a2-52d4-46d9-bfdc-5643478e7e53"">
",,
2163621896,3291,How to have .optional() survive during transform(),"How would I keep a property as truly optional (`{ a?:..}`) in my resulting object after doing a `.transform()`. 

Take the example below, the property is correctly inferred as optional (`a?:...`) **after** parsing **but before** transforming. 
However, after transforming, it no longer is optional.


```
const objectA = z.object({ a: z.number().optional() })

type A = z.infer<typeof objectA>;
// { a?: number  | undefined } <-- optional


const objectB = z.object({ a: z.number().optional() }).transform((x) => {
  return { a: x.a?.toString() };
});


type B = z.infer<typeof objectB>;
// { a: string  | undefined } <-- no longer optional

```

",,
2162810343,3290,superRefine don't work,"`console.log('superRefine',values) `  doesn't even occur

```
export const getBaseManagementGateFormSchema = () =>
  z
    .object({
      name: z.string().min(1, _translate('message_required_name')),
      gateModeId: z.nativeEnum(TerminalClientMods),
      gatePeriodTimeMinutes: z.coerce.number(),
      gatePeriodPrice: z.coerce.number(),
      gatePeriodFreeTimeMinutes: z.coerce.number(),
      coords: z.string().min(1, _translate('message_required_coords')),
      latitude: z.number().optional(),
      longitude: z.number().optional(),
      externalId: z.number().refine((v) => Boolean(v), _translate('message_required_external_gate')),
      terminals: z.array(
        z.object({
          name: z.string().min(1, _translate('message_required_terminal_name')),
          externalId: z.number().refine((v) => Boolean(v), _translate('message_required_external_terminal')),
          typeId: z.number().refine((v) => Boolean(v), _translate('message_required_terminal_type')),
          terminalPeriodTimeMinutes: z.coerce.number().optional(),
          terminalPeriodPrice: z.coerce.number().optional(),
          terminalPeriodFreeTimeMinutes: z.coerce.number().optional(),
          terminalMode: z.number().optional(),
        }),
      ),
    })
    .superRefine((values, ctx) => {
      console.log('superRefine', values)
      console.log(
        'values.gateModeId === TerminalClientMods.PARKING_PREPAYMENT ||' +
          'values.gateModeId === TerminalClientMods.PARKING_POSTPAID',
        values.gateModeId === TerminalClientMods.PARKING_PREPAYMENT ||
          values.gateModeId === TerminalClientMods.PARKING_POSTPAID,
      )
      if (
        values.gateModeId === TerminalClientMods.PARKING_PREPAYMENT ||
        values.gateModeId === TerminalClientMods.PARKING_POSTPAID
      ) {
        if (values.gatePeriodTimeMinutes < 0 || (!values.gatePeriodPrice && values.gatePeriodTimeMinutes !== 0)) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: _translate('message_required_periodTimeMinutes'),
            path: ['gatePeriodTimeMinutes'],
          })
        }
        if (values.gatePeriodPrice < 0 || (!values.gatePeriodPrice && values.gatePeriodPrice !== 0)) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: _translate('message_required_periodPrice'),
            path: ['gatePeriodPrice'],
          })
        }
        if (
          values.gatePeriodFreeTimeMinutes < 0 ||
          (!values.gatePeriodFreeTimeMinutes && values.gatePeriodFreeTimeMinutes !== 0)
        ) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: _translate('message_required_periodFreeTimeMinutes'),
            path: ['gatePeriodFreeTimeMinutes'],
          })
        }
      }
      if (values.gateModeId === TerminalClientMods.MANUAL) {
        values.terminals.forEach((terminal, index) => {
          if (
            terminal.terminalPeriodTimeMinutes < 0 ||
            (!terminal.terminalPeriodPrice && terminal.terminalPeriodTimeMinutes !== 0)
          ) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: _translate('message_required_periodTimeMinutes'),
              path: [`terminal[${index}].terminalPeriodFreeTimeMinutes`],
            })
          }
          if (
            terminal.terminalPeriodPrice < 0 ||
            (!terminal.terminalPeriodPrice && terminal.terminalPeriodPrice !== 0)
          ) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: _translate('message_required_periodPrice'),
              path: [`terminal[${index}].terminalPeriodPrice`],
            })
          }
          if (
            terminal.terminalPeriodFreeTimeMinutes < 0 ||
            (!terminal.terminalPeriodFreeTimeMinutes && terminal.terminalPeriodFreeTimeMinutes !== 0)
          ) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: _translate('message_required_periodFreeTimeMinutes'),
              path: [`terminal[${index}].terminalPeriodFreeTimeMinutes`],
            })
          }
          if (!terminal.terminalMode) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: _translate('message_required_terminal_mode'),
              path: [`terminal[${index}].terminalMode`],
            })
          }
        })
      }
    })
```",,
2160481243,3284,feat: `z.valueof`,"Zod already has [`Objects.keyof`](https://zod.dev/?id=keyof), but is missing `Objects.valueof`.

One example [adapted from discussions](https://github.com/colinhacks/zod/discussions/839#discussioncomment-8142768) is:

```ts
function valueof<
  T extends Record<string, string>,
  V extends string = T extends Record<string, infer V> ? V : never,
>(input: T): z.ZodEnum<[V, ...V[]]> {
  const [firstKey, ...otherKeys] = Object.values(input) as [V, ...V[]];
  return z.enum([firstKey, ...otherKeys]);
}
```

It is important to note that this function only works with objects of shape `Record<string, string>` as the [docs](https://zod.dev/?id=basic-usage) say:

> `z.enum` is a Zod-native way to declare a schema with a fixed set of allowable string values.",,
2156898047,3279,Is it possible to make Zod throw custom errors rather than a ZodError?,"I have a predefined error that occurs when there is a bad arg in an API call. Trying to move validation over to use zod. Could I instead make it so zod throws a custom error?

```typescript
export class BadApiArgumentException extends OttException {
	name = ""BadApiArgumentException"";
	arg: string;
	reason: string;

	constructor(arg: string, reason: string) {
		super(`Bad argument: ${arg}: ${reason}`);
		this.arg = arg;
		this.reason = reason;
	}
}
```",,
2156242631,3277,Request to add Typescript 5.3 to test matrix,Testing the latest Typescript since that is what most people use when starting a new project.,,
2152767988,3271,How to set any zod schema as the attribute in z.object,"i am trying to create a zod object schema for generic REST api request def.  this schema is generated by codegen.
```
const apiRequestSchema = z.object({
  apiConfig: apiConfigSchema, // another zod schema that specifies url, body etc.
  outputSchema: z.zodAny() // schema that will be used to parse the response. it can be any zod schema
})

type APIRequest = z.infer<typeof apiRequestSchema>
```

APIRequest typescript sets `outputSchema` as any zod schema that can be used to parse the response.

is there a zod method e.g. `z.zodAny` to specity zod schema as the value of `outputSchema`?",,
2152258188,3267,How to make a schema from dynamic and static fields,"Hi everyone. I have a form that creates a product for an online store. The product has certain fields, such as - title, description, photo. There is also a field that assigns the product to a certain category, and depending on which category the product is assigned to, the product has additional, dynamic fields based on options that come from the server. For example, if I select category 1 in the form, the product will have an option for color where I can select a specific color, and if I select category 2, the form should have a size field where I can select a size. Here is how it looks like in the code
Schema(these are the fields that the product always has)
```
export const productFormSchema = z.object({
  name: z
    .string()
    .min(3)
    .max(30)
    .transform((name) => name.trim()),
  description: z.string(),
  about: z.string(),
  img: z.array(z.string()),
  categoryList: z.array(
    z.object({
      id: z.string(),
    }),
  ),
});

export type ProductFormValues = z.infer<typeof productFormSchema>;
```
Here is the base component of the form
```
const getDefaultValues = (product?: ProductRelation) => ({
  name: product?.name ?? """",
  description: product?.description ?? """",
  about: product?.about ?? """",
  img: product?.img ?? [],
  categoryList: product?.categoryList ?? [],
});

export const ProductForm: FC<ProductFormProps> = (props) => {
  const {
    product,
    handleSubmit: onSubmit,
    submitText,
    isPending,
    categorySelectOptionList,
    categotySelectOptionListActive,
    optionSelectOptionList,
    handleCategorySelectOption,
  } = props;

  const form = useForm<ProductFormValues>({
    resolver: zodResolver(productFormSchema),
    defaultValues: getDefaultValues(product),
  });

  useEffect(() => {
    form.reset(getDefaultValues(product));
  }, [product, form, optionSelectOptionList]);

  const handleSubmit = form.handleSubmit(async (data) => {
    onSubmit?.(data);
  });

  const handleDeleteimg = (path: string) => {
    const list = form.getValues(""img"");
    const result = list.filter((item) => item !== path);
    form.setValue(""img"", result);
  };

  const isPendingAppearance = useAppearanceDelay(isPending);

  const handleSelect = useCallback((value: MultiSelectOptionItem[]) => {
    form.setValue(""categoryList"", handleCategorySelectOption(value));
  }, []);

  return (
    <Form {...form}>
      <form onSubmit={handleSubmit} className=""space-y-8"">
        <FormField
          control={form.control}
          name=""categoryList""
          render={({ field }) => {
            return (
              <FormItem>
                <FormLabel>Category list</FormLabel>
                <FormControl>
                  <MultiSelect
                    optionList={categorySelectOptionList}
                    optionActiveList={categotySelectOptionListActive}
                    onSelected={handleSelect}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            );
          }}
        />
        <FormField
          control={form.control}
          name=""name""
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input placeholder=""Enter product name..."" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name=""description""
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Input placeholder=""Enter product description..."" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name=""about""
          render={({ field }) => (
            <FormItem>
              <FormLabel>About</FormLabel>
              <FormControl>
                <Textarea placeholder=""Enter product about..."" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name=""img""
          render={({ field }) => (
            <FormItem>
              <FormLabel>Avatar</FormLabel>
              <FormControl>
                <ImgField
                  value={field.value}
                  onChange={field.onChange}
                  onDelete={handleDeleteimg}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type=""submit"" disabled={isPendingAppearance}>
          {isPendingAppearance && (
            <Spinner
              className=""mr-2 h-4 w-4 animate-spin""
              aria-label=""Profile updating...""
            />
          )}
          {submitText}
        </Button>
      </form>
    </Form>
  );
};
```
Now I want to add fields to it based on which categories are selected in categoryList
For this purpose the optionSelectOptionList props come to the form and based on it I add fields to the form, here is a simplified version with only select, but in the actual code there are also multiselect, checkbox and radio
```
        {optionSelectOptionList &&
          optionSelectOptionList.map((option) => {
            const { datatype } = option;
            if (datatype === OptionDataTypeEnum.SELECT) {
              return (
                <FormField
                  key={option.name}
                  control={form.control}
                  name={option.name}
                  render={({ field }) => {
                    console.log(""name"", option.name);
                    return (
                      <FormItem>
                        <FormLabel>{option.name}</FormLabel>
                        <Select onValueChange={field.onChange}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder=""placeholder"" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {option.optionList.map((row) => (
                              <SelectItem key={row.value} value={row.value}>
                                {row.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                     
                        <FormMessage />
                      </FormItem>
                    );
                  }}
                />
              );
            }
          })}

```
But the problem is that my original schema doesn't know anything about dynamic fields and I don't understand how to implement what I described. Here is an example of how optionSelectOptionList looks like
```
[
    {
        ""id"": ""option_eeesddfew789855"",
        ""name"": ""New"",
        ""datatype"": ""radio"",
        ""optionList"": [
            {
                ""value"": ""optionItem_77da558waew77YES"",
                ""label"": ""yes"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_ew5da558waew22NO"",
                ""label"": ""no"",
                ""active"": false
            }
        ]
    },
    {
        ""id"": ""option_585fsddfew7898dd"",
        ""name"": ""Size"",
        ""datatype"": ""select"",
        ""optionList"": [
            {
                ""value"": ""optionItem_58ddtwaew7897dfeXS"",
                ""label"": ""XS"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_d33ddtwaew68deS"",
                ""label"": ""S"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_M68ddtwaew65687M"",
                ""label"": ""M"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_L58ddtwaew65622L"",
                ""label"": ""L"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_XL33ddtwaew65dd2eeXL"",
                ""label"": ""XL"",
                ""active"": false
            }
        ]
    },
    {
        ""id"": ""option_11fsddfew7898186"",
        ""name"": ""Color"",
        ""datatype"": ""mult"",
        ""optionList"": [
            {
                ""value"": ""optionItem_8fsddfew7898d857"",
                ""label"": ""Red"",
                ""active"": true
            },
            {
                ""value"": ""optionItem_d555fsddfew78981fe"",
                ""label"": ""Blue"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_rs5fsd55846fptes"",
                ""label"": ""Yellow"",
                ""active"": false
            }
        ]
    }
]
```
",,
2152005827,3266,Different typing for SafeParseReturnType<T>,"## Behavior description

Nowadays, the **safeParse** and **safeParseAsync** - functions for parsing Zod schemas - return types are based on **SafeParseReturnType<T>**, this type is an union containing the following types:

- **SafeParseSuccess\<Output\>**

  ```ts
  export declare type SafeParseSuccessOutput<Output> = {
    success: true;
    data: output;
  }
  ```

- **SafeParseError\<Input\>**

  ```ts
  export declare type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
  }
  ```

## Behavior problem

This kind of behavior, besids applying bad practices by design - here I'm talking about having const values true and false for success instead of a boolean - also needs an explicit declaration on what type it should be. This situation causes more complexity in the user code - complexity that should be handled by the library itself and it's against the TypeScript idea of good inference and usability.

![307189632-6373aa6c-aa30-47f2-b511-56b028f866c8](https://github.com/colinhacks/zod/assets/70824102/19410396-b002-4ea5-b398-787810eb5960)

## Solution suggestion

My solution, for that case, would be implementing a single typing for **SafeParseReturnType<T>** without unions - in a way that will not break existing code and will correctly adapt to any situation that the previously implemented unions covered. 

Code:

```ts
export declare type SafeParseResult<InputOrOutput> = {
  success: boolean,
  data?: InputOrOutput,
  error?: ZodError<InputOrOutput>
}
```",,
2150146802,3263,Type for safeParseAsync not coming correctly,"The return type for safeParseAsync is not coming correctly, I can retrieve only the success item but not the error itself. I checked the typescript declarations and it contains some union (unnecessary because error or data could be added as optional fields - I mean, nullable ones). Is that the correct behavior? I'm kind of confused but I'm sure it is not.

![image](https://github.com/colinhacks/zod/assets/70824102/6373aa6c-aa30-47f2-b511-56b028f866c8)

![image](https://github.com/colinhacks/zod/assets/70824102/9cfef0a2-2e1e-45e8-8326-6b17816f3806)

They could just be like that:

![image](https://github.com/colinhacks/zod/assets/70824102/c133735d-e13e-40cb-9007-cf1c9ec45960)

",,
2145328507,3260,"Zod throws ""ReferenceError: x is not defined"" instead of ZodError with unions","I would expect z.union to throw a ZodError with a readable error message, instead I get `ReferenceError: x is not defined`

Created a small example to show and reproduce the error:

```typescript
import { describe, test, expect } from ""vitest"";
import { z, ZodError } from ""zod"";

const SchemaOne = z.object({
    foo: z.literal(""One""),
    bar: z.string(),
});

const SchemaTwo = z.object({
    other: z.literal(""Two""),
    hello: z.string(),
});

const BadTestSchema = z.union([SchemaOne, SchemaTwo]);

describe(""Test"", () => {
    test(""test"", () => {
        expect(() =>
            SchemaOne.parse({
                foo: ""One"",
                bar: ""Hello"",
            }),
        ).to.not.throw(); // Succeeds, does not throw

        expect(() =>
            SchemaOne.parse({
                foo: ""One"",
            }),
        ).toThrow(ZodError); // Succeeds, throws a ZodError

        expect(() =>
            BadTestSchema.parse({
                foo: ""One"",
            }),
        ).toThrow(ZodError); // Fails, throws ""ReferenceError: x is not defined""
    });
});
```

Error:
```
AssertionError: expected error to be instance of ZodError
Expected :[Function ZodError]
Actual   :[ReferenceError: x is not defined]
```

EDIT: I just discovered this issue existing on even the simplest unions, `z.string().or(z.number())`. I found that I do not have this issue when running directly in `node` but I do have the issue with vitest. 🤔 I will see if I have the same issue with jest.",,
2142574612,3257,Map ZodEffects back to ZodObject,"I may be missing something, but there appears to be no way to assert that a `.preprocess`'d schema to a ZodObject again.

As a quick example:

```
// Preprocess so any usage of zWage first rounds to 4 decimal places
export const zWage = z.preprocess(x => isNumber(x) ? Math.round(x * 10000) / 10000 : x, z.number());

// Knowing that the schema is in actuality a z.number(), extend it using a .min()
zWage.min(34.345345).parse(myNumber);       // Property 'min' does not exist on type 'ZodEffects<ZodNumber, number, unknown>'.

```

Is there any way around this?",,
2142081166,3256,Custom error message shape,"Consider the following schema:
```ts
export const FileToUpload = z
  .instanceof(File)
  .refine((file) => file.size < FILE_SIZE_LIMIT, {
    message: `File size should be less than ${FILE_SIZE_LIMIT_MB} MB`,
  });
```
I'm using react-intl package from [FormatJS](https://github.com/formatjs/formatjs) for providing i18n and would like to be able to return a translation object instead of instead of a string, like:
```ts
export const FileToUpload = z
  .instanceof(File)
  .refine((file) => file.size < FILE_SIZE_LIMIT, {
    message: {
      id: 'uploaded_file_size',
      defaultMessage: `File size should be less than {max} MB`,
      values: { max: FILE_SIZE_LIMIT_MB },
    },
  });

```
The first solution that naturally comes to mind is this:
```ts
const useFileTuUploadSchema = () => {
  const intl = useIntl();

  return z.instanceof(File).refine((file) => file.size < FILE_SIZE_LIMIT, {
    message: intl.formatMessage({
      id: 'uploaded_file_size',
      defaultMessage: `File size should be less than {max} MB`,
      values: { max: FILE_SIZE_LIMIT_MB },
    }),
  });
};
```
Unfortunately, it doesn't solve my issue, because I need access to the actual translation object, not a formatted string (I render all translations in a custom component that allows admins to edit translations on the frontend)


Interestingly enough, returning a translation object instead of a string seems to work fine, but it's a terrible hack and would require shutting typescript errors, so do you have any suggestion here? 
Thanks a lot! ",,
2139291130,3249,"'safeParse()' doesn't work in server component, complains about not being on the client-side.","Hello,
I'm getting this error, which I can't figure out.
```
Unhandled Runtime Error

Error: Attempted to call safeParse() from the server but safeParse is on the client. 
It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.
```
As far as I'm aware, safeParse is available to use on the server, please correct me if i'm wrong. I can't find any information at all about this error, nothing in GitHub issues or Google. Using parse() also returns the same error.
Here is my login.ts where I call safeParse:

```jsx
""use server"";

import * as z from ""zod"";
import { AuthError } from ""next-auth"";

import { signIn } from ""@/auth"";
import { LoginSchema } from ""../../ui/components/form/login"";
import { defaultLoginRedirect } from ""@/routes"";

export async function login(values: z.infer<typeof LoginSchema>,) {

        console.warn('Entering login function');
        console.warn('Execution context:', typeof window === 'undefined' ? 'server' : 'client');

        const validatedFields = LoginSchema.safeParse(values);    // This is where the error happens.
        console.log('Validation successful:', validatedFields);

        if ( ! validatedFields.success ) {

            return { error: ""Invalid fields!"" };

        };

        const { email, password } = validatedFields.data;

        try {

            await signIn(""credentials"", {
                email,
                password,
                redirectTo: defaultLoginRedirect,
            });

        } catch ( error ) {

            if ( error instanceof AuthError ) {
                switch ( error.type ) {
                    case ""CredentialsSignin"":
                        return { error: ""The username or password is incorrect."" }
                    case ""AdapterError"" || ""MissingAdapter"" || ""MissingAdapterMethods"":
                        return { error: ""The database is currently experiencing issues, please try again later."" }
                    case ""CallbackRouteError"":
                        return { error: ""The login failed to proceed. If you're using an external service such as GitHub, try making an account locally."" }
                    case ""InvalidCallbackUrl"":
                        return { error: ""The CallbackUrl was invalid. Make sure your browser allows cookies and doesn't change them."" }
                    case ""InvalidCheck"":
                        return { error: ""The login failed to proceed as some checks could not be performed. Make sure your browser isn't blocking cookies."" }
                    case ""InvalidEndpoints"":
                        return { error: ""Login via external providers is currently unavailable due to system issues."" }
                    case ""InvalidProvider"":
                        return { error: ""The system failed to recognise your authentication provider. Please retry the login process."" }
                }
            }

            throw error;

        };

}
```

and here is (part of) my login.tsx form, where I use login.ts: 
```jsx

    const onSubmit = (values: z.infer<typeof LoginSchema>) => {

        setError("""");
        setSuccess("""");

        startTransition(() => {
            login(values)
                .then((data) => {
                    setError(data?.error);
                    setSuccess(data?.success);
                })
        });
    };
```
Note that the form is a client component, so I wonder if that's it.",,
2138414001,3246,Type definition `ZodFirstPartySchemaTypes` is missing some first party schema types,"While trying to create an object which maps from `ZodFirstPartyTypeKind` to a function that takes the associated schema as argument, I found that `ZodReadonly` and `ZodSymbol` are missing from `ZodFirstPartySchemaTypes` union. The basic premise of the mapping is as follows.

```ts
type ZodFirstPartySchemaForType<T extends ZodFirstPartyTypeKind> = ZodFirstPartySchemaTypes extends infer Schema 
  ? Schema extends { _def: { typeName: T} } 
    ? Schema 
    : never
  : never;
type ZodSchemaMap = { [key in ZodFirstPartyTypeKind]: ZodFirstPartySchemaForType<key> };
```

Based on this mapping we could then infer which types are missing:

```ts
type MissingSchemaTypes = { [key in keyof ZodSchemaMap as ZodSchemaMap[key] extends { _def: never } ? key : never ]: true }
```

![image](https://github.com/colinhacks/zod/assets/11519728/93e7ca06-d7ce-4a0c-a4c4-662f4f4a7b69)

https://github.com/colinhacks/zod/blob/76c8ace1acd9fd713f99d3dca6a3f28320972eac/src/types.ts#L4941-L4976

Could be related to #2663",,
2137657238,3244,[Feature request] Reverse type inference,"First of all, I really love Zod! I tried a few validation libraries and Zod by far clicked with me the most. I especially love the TypeScript integration and how easy it is to create a pair of type/interface and validator (schema).

I think it would be amazing if (I'm not sure if this is implemented yet, I haven't found something similar) it would be possible to to _reverse type inference_. Something like this:

```typescript
interface MyType {
    firstName: string
    lastName: string
    age: number
    whatever?: boolean
}

const myTypeSchema = z.fromType<MyType>({
    firstName: z.string(),
    // error: lastName is missing
    age: z.string(), // error: invalid type
    extra: z.number() // error: extra
})
```

This would make using the library much easier if you already have a bunch of existing interfaces, especially if you cannot modify them. Basically, an equivalent of `z.object<T>` but instead of having an argument `schema: T` it would have an argument `schema: reverseInfer<T>`.

I currently use this pretty bad hack because I will never understand types in TypeScript, why are they even [turning complete](https://github.com/microsoft/TypeScript/issues/14833):

```typescript
({} as MyType) satisfies z.infer<typeof myTypeSchema>
({} as z.infer<typeof myTypeSchema>) satisfies MyType
```

This throws type errors if the schema isn't defined correctly.",,
2134262516,3239,"Union, can't access a field, as it does not exist in the other schema","I have this schema

```ts
const updateUserSchema = z.union([
  z.object({
    email: z.string().email().optional(),
    given_name: z.string().optional(),
    family_name: z.string().optional(),
    email_verified: z.enum(['true', 'false']).optional(),
    reset_password: z.enum(['true', 'false']).optional(),
  }),
  z.object({
    email: z.string().email().optional(),
    given_name: z.string().optional(),
    family_name: z.string().optional(),
    email_verified: z.enum(['true', 'false']).optional(),
    set_password: z.enum(['true', 'false']).optional(),
    password: z.string().optional(),
  }),
]);
```

After parsing, when I trie to check `data.reset_password`, I get the following error:

```bash
Property 'reset_password' does not exist on type '({ email?: string | undefined; given_name?: string | undefined; family_name?: string | undefined; email_verified?: ""true"" | ""false"" | undefined; reset_password?: ""true"" | ""false"" | undefined; } | { ...; }) & ({ ...; } | ... 1 more ... | undefined)'.
  Property 'reset_password' does not exist on type '{ email?: string | undefined; given_name?: string | undefined; family_name?: string | undefined; email_verified?: ""true"" | ""false"" | undefined; set_password?: ""true"" | ""false"" | undefined; password?: string | undefined; }'.ts(2339)
```

How am I supposed to check if a field exists?",,
2132907108,3235,[Feature Request] Allow preprocess even if schema validation fails,"our code has a very loose parse

```ts
const parseBasic = (data: any) => {
  const schema = z
    .object({
      name: z.string(),
      letter: z.preprocess(v => (v as string)?.toUpperCase(), z.enum(['A', 'B'])),
    })
    .describe('Basic');

  try {
    return schema.parse(data);
  } catch (error: any) {
    console.warn(schema._def.description + 'SchemaError', {
      ...error.issues,
    });

    return data;
  }
};

parseBasic({ name: 'Jay', letter: 'a' });
// { name: 'Jay', letter: 'A' }
 ```
 
 We love that it adds types to our json, and if the json schema is wrong it simply logs a warning. 
 
 
 But there is a few cases were we would like to preprocess the data prior to parsing incase the parsing fails, we would still like to have the preprocess. 
 Unfortunately there is no way to currently accomplish this. 
 
```ts
const parseBasic = (data: any) => {
  const schema = z
    .object({
      name: z.string(),
      letter: z.preprocess(v => (v as string)?.toUpperCase(), z.enum(['A', 'B'])),
      fieldThatDefDoesNotExisit: z.string(),
    })
    .describe('Basic');

  
  try {
    data = schema.preProcess(data);  // this does not currently exist
    return schema.parse(data);
  } catch (error: any) {
    console.warn(schema._def.description + 'SchemaError', {
      ...error.issues,
    });

    return data;
  }
};

parseBasic({ name: 'Jay', letter: 'a' });
// *logs warning*
// { name: 'Jay', letter: 'a' } <= ideally still would be  {name: 'Jay', letter: 'A' }'
```


   ",,
2131071555,3233,"Using ""zod.infer"" in a specific object will cause the vs code typescript intellisense stuck forever in ""Loading...""","Hello gyes!

I'm new using zod as validator for objects. I have found a very frustrating bug! When I use zod infer to create a new type of object based on a zod object my visual studio code intellisense stops working. When this happen I got eternal vs code ""Loading..."" status message and in the bottom corner of the screen says ""Loading Intellisense Status..."" and this stays forever in this status when I try to use zod infer method.

Open the file ""src\app\comp1\constructionCompany\component\test.tsx"".

If we comment z.infer line the intellisense will work:
![Untitled](https://github.com/colinhacks/zod/assets/22732718/f238855a-d5a1-4d47-8a65-7d37c2972986)

If we uncomment z.infer line the intellisense will stop working in entire project:
![Untitled2](https://github.com/colinhacks/zod/assets/22732718/46cbe3f1-e45a-4721-bd37-56ae8afc4eda)

I created a repo where we can reproduce the error with the vs code intellisense. Basically to initialize the repo you should execute ""npm install"" and ""npx prisma generate"" to generate the schemas and objects from prisma database.

_**Repo: https://github.com/ADSNB/intellisense-bug-zod-infer**_

I'm very frustrated because I have spent some days to identify what exactly was breaking the intellisence in this project that I'm working and I was unable to find a fix yet on my own. I'm using zod with trpc prisma generator to create classes with automatic validation and this worked for simple tables without relation between them. But in this specific scenario we have a table called ""ConstructionCompany"" and another table ""ConstructionCompanyProject"" and this tables have an relation one to many. I guess when I use zod infer in this type of object for some reason this doesn't work. I tried to use developer console to check the console logs and analyse TS server logs but I didn't found anything that could indicates or solve this issue.

Any help is really appreciated. If you have any questions let me know.


",,
2129871320,3229,"Minimum length check does not work for numbers starting with 0, which is a problem for decimal numbers between 0 and 1","https://codesandbox.io/p/devbox/flamboyant-newton-lqcmtc?file=%2Fsrc%2Findex.ts%3A6%2C12&workspaceId=7d1f2f4a-ef98-44cd-8b46-d234f9380aba

Please refer the code sandbox link. 

Minimum length check works for 1, 1.42.  
It fails for all values starting with 0 e.g. 0, 0.42.

```ts
import test from ""node:test"";
import assert from ""node:assert/strict"";
import { z } from ""zod"";

const obj = z.coerce
  .number()
  .min(1, { message: `Field should have minimum 1 characters` });

const valid = 1;
const valid2 = 1.42;
const invalid = 0;
const invalid2 = 0.42;

test(""valid for 1"", () => {
  const result = obj.safeParse(valid);
  assert.ok(result.success);
  assert.equal(result.data, valid);
});

test(""valid for 1.42"", () => {
  const result = obj.safeParse(valid2);
  assert.ok(result.success);
  assert.equal(result.data, valid2);
});

test(""invalid for 0"", () => {
  const result = obj.safeParse(invalid);
  assert.ok(result.success);
  assert.equal(result.data, invalid);
});

test(""invalid for 0.42"", () => {
  const result = obj.safeParse(invalid2);
  assert.ok(result.success);
  assert.equal(result.data, invalid2);
});

```",,
2129188033,3228,z.infer return types any for my schema ,"I am attempting to create types with JSDoc from z.infer in my schema, but most of them are type any.

```js
//? -------- Sub Schema ---------
const tokenSchema = stringNonEmpty().length(128, { message: ""must be a 128-character string"" }).regex(hexRegex, { message: ""must be a hexadecimal string"" });
const tokenExpireSchema = stringNonEmpty(tokenExpireErrorMap).regex(durationRegex);
const numberSchema = z.coerce.number().int({ message: ""must be integer number"" }).positive({ message: ""must be positive number"" });


/**
 * @typedef {z.infer<typeof envSchema>} Env
 */

const envSchema = z.object({
	ACCESS_TOKEN_SECRET: tokenSchema,
	REFRESH_TOKEN_SECRET: tokenSchema,
	ACCESS_TOKEN_SECRET_EXPIRE: tokenExpireSchema,
	REFRESH_TOKEN_SECRET_EXPIRE: tokenExpireSchema,
	COOKIE_MAX_AGE: z.preprocess((x) => x || undefined, numberSchema.min(60_000)),
	DATABASE_URI: stringNonEmpty().regex(mongodbUriRegex, {
		message: ""must be a valid MongoDB URI"",
	}),
	DATABASE_NAME: stringNonEmpty(),
	NODE_ENV: z.enum([""development"", ""production""]).default(""development""),
	ALLOWED_ORIGINS: arrayFromString(z.string().url()),
	PORT: z.preprocess((x) => x || undefined, numberSchema.min(1).max(65_536).default(3000)),
});


try {
	/** @type {Env} */
	const ENV = envSchema.parse(process.env);
} catch (error) {
 ....
}

```

- `ENV`
![image](https://github.com/colinhacks/zod/assets/74573675/aab627c1-d06d-4b00-8627-1e384fad8852)

- `envSchema`
![image](https://github.com/colinhacks/zod/assets/74573675/b7cbaa35-4dbd-4531-becb-60b960c1dd74)


- utils functions used in my schema : 

```js
const stringNonEmpty = (errorMap = undefined) => {
	return z.string({ errorMap: errorMap }).min(1, { message: ""cannot be empty"" });
};

const arrayFromString = (schema, defult = """") => {
	return z.preprocess((obj) => {
		if (Array.isArray(obj)) {
			return obj;
		} else if (typeof obj === ""string"") {
			return obj.split("","");
		} else {
			return [defult];
		}
	}, z.array(schema).nonempty({ message: ""array cannot be empty"" }));
};
```",,
2127506232,3225,Enum.extract() removes error messages,"If I declare an enum like

```ts
onst enumErrorMap = {
    errorMap: () => ({ invalid_type_error: ""Error Message"" }),
};

const TestEnum = z.enum(
    [
        ""value1"",
        ""value2"",
    ],
    enumErrorMap,
);
```

The error message works properly. However, if I do `const TestEnumTwo = TestEnum.exclude([""value1""]);`, the error map is lost. It looks like the code just creates a new enum and discards the `RawCreateParams` that were passed to the original enum.

https://github.com/colinhacks/zod/blob/a5a9d31018f9c27000461529c582c50ade2d3937/src/types.ts#L4065-L4076",,
2126428748,3222,Adding branded attribute in recursive type breaks compilation,"Let's take example with recursive types from README and add branded attribute:

~~~~~typescript
import { z } from 'zod'

const baseCategorySchema = z.object({
    branded: z.string().brand('Brand'),  // <--------------
    name: z.string(),
});

type Category = z.infer<typeof baseCategorySchema> & {
    subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
    subcategories: z.lazy(() => categorySchema.array()),
});
~~~~~

Now this code doesn't compile with following error:
~~~~~
.ts:12:7 - error TS2322: Type 'ZodObject<{ branded: ZodBranded<ZodString, ""Brand"">; name: ZodString; subcategories: ZodLazy<ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'.
  Types of property '_input' are incompatible.
    Type '{ branded: string; name: string; subcategories: Category[]; }' is not assignable to type 'Category'.
      Type '{ branded: string; name: string; subcategories: Category[]; }' is not assignable to type '{ branded: string & BRAND<""Brand"">; name: string; }'.
        Types of property 'branded' are incompatible.
          Type 'string' is not assignable to type 'string & BRAND<""Brand"">'.

12 const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
~~~~~

I'm using:
""zod"": ""^3.22.4""
""typescript"": ""^5.3.3""
",,
2115880627,3212,Officially support non-string error messages,"According to the typings error messages need to be strings. I'd love to use JSX here however to be more expressive (e.g. allow formatting, links, etc.). For historical reasons I'd like to not just use JSX, but actually a function that returns JSX, so I can pass some field specific meta data to the error message that is not available in the schema.

We used this pattern with yup in the past and I noticed that despite the typings this seems to actually work with zod as well:

```tsx
.refine(
  (value) => value === 17,
  () => ({
    message: (() => (
      <span>
        Cool error{' '}
        <span style={{ fontStyle: 'italic', color: 'green' }}>here</span>.
      </span>
    )) as any, // <--- any, because string is expected
  })
)
```

We use Formik currently and neither Formik or zod seem to make usage of the message. They pass it just forward and this pattern seems to work with all existing components that we have. It is just not ""officially"" supported and it would be awesome, if it could be. Thanks for all the work!

(FYI: I had the [same question](https://github.com/jquense/yup/issues/1233) some years ago with yup and they officially support this.)",,
2110060855,3204,Documentation broken link,"In page https://zod.dev/ERROR_HANDLING?id=zodissue, when clicking on here ""You can see all the possible variants defined [here](https://zod.dev/src/ZodError.ts)."" 

I get

```src"" content=""https://opengraph.githubassets.com/1cac1150838995e1f7d1643c00eee51a5d884f2054f995c9d3225b07b0eddb39/colinhacks/zod"" /> alt"" content=""TypeScript-first schema validation with static type inference"" /> width"" content=""1200"" /> height"" content=""600"" />```",,
2105271728,3199,How does it add ? in keys,"Hello, I am `Tahsin Ayman`. i was looking after solving a bug / contribute in this open source project but as i read the code i noticed something **confusing** 😕 . in the source code on line number `4464-4468`:
```ts
export class ZodOptional<T extends ZodTypeAny> extends ZodType<
  T[""_output""] | undefined,
  ZodOptionalDef<T>,
  T[""_input""] | undefined
> 
```
this is the code when i use `.optional()` class returns. here the `T[""_output""]` is the one causing the output hense it shows `undefined`
as mentioned in:
#3186 
but i'm not sure how does it even add `?` after keys when it's a object ❓ 

e.g:
```ts
const schema = z.object({
  name: z.string().optional()
});
/*
type User = {
    name?: string | undefined;
}
*/
type User = z.infer<typeof schema>;
```
but when i create just `string().optional()`
```ts
const schema = z.string().optional()
/*
type User = string | undefined
*/
type User = z.infer<typeof schema>;
```
where does it even add `?` ❔ ",,
2103642405,3196,"""Intersection results could not be merged"" does not mention the cause","### Discussed in https://github.com/colinhacks/zod/discussions/3194

<div type='discussions-op-text'>

<sup>Originally posted by **JoshuaKGoldberg** January 23, 2024</sup>
Zod is great and I'm enjoying the features around intersecting/merging objects. But for `.and`, when the intersections results can't be merged for some reason, the error message thrown at runtime doesn't provide any details.

> An error occurred.
> 
> ```plaintext
> Intersection results could not be merged
> ```
> 
> Stack Trace
> 
> ```plaintext
> ZodError: [
>   {
>     ""code"": ""invalid_intersection_types"",
>     ""path"": [],
>     ""message"": ""Intersection results could not be merged""
>   }
> ]
>     at get error [as error] (file:///Users/josh/repos/dot-com/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs:538:31)
>     at ZodIntersection.parse (file:///Users/josh/repos/dot-com/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs:638:22)
>     at /Users/josh/repos/dot-com/src/pages/rss.xml.ts:26:48
>     at Array.map (<anonymous>)

Not sure if this is a bug report or feature request, but: could the error message also include which field(s) are problematic?

Note that I'm not trying to report that the error is wrong. The error may be right - it just informative enough to explain why clearly.

Sorry that I'm not familiar enough with Zod to provide a standalone reproduction (I tried the Stackblitz Astro starter but couldn't get past TypeScript errors, amusingly). But here's how to get it on a real world project:

```plaintext
git clone https://github.com/JoshuaKGoldberg/dot-com
cd dot-com
git checkout 708081f # ncu-u-for-vite-5 branch
pnpm i
pnpm dev
open http://localhost:4321/rss.xml
```</div>",,
2103086279,3193,Proposal: Create a new schema with the types based on the describe value,"Is this possible or not?

seems the types are not showing here

```ts
export const Schema= z.object({
  __typename: z.literal('ProjectMember'),
  id: z.string(),
  attributeField: z.number().optional().nullable().describe('[attribute]'),
});
const SchemaWithAttributeOnly = Schema.pick(
  mapValues(
    Schema.shape,
    item => item.description?.startsWith('[attribute]') ? true : undefined,
  ),
);
```",,
2099564009,3187,Why is positive and negative functions uses zero as the minimum and maximum value?,"I'm reading different writings about if zero value is considered as `positive` but so far it all tells its neither positive nor negative.  Same goes with the `negative` function.  Although I can raise PR for this but just want to get the narrative first before I modify it. Thanks

```typescript
  positive(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: ""min"",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }

  negative(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: ""max"",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
```
",,
2099316369,3186,optional should not add undefined to type signature,"I'm sorry if this is a duplicate, I could not find an existing issue or discussion that seemed to be exactly about the following. It's really rather simple: the following schema infers the wrong type

```typescript
const schema = z.object({
  foo: z.string().optional()
});
```
is inferred as
```typescript
type Schema = {
  foo?: string | undefined
};
```
when it should really be
```typescript
type Schema = {
  foo?: string
}
```

Let me showcase the issue with two different typescript playgrounds. They both have the same content, but the second has `exactOptionalPropertyTypes` enabled.

[`exactOptionalPropertyTypes: false`](https://www.typescriptlang.org/play?exactOptionalPropertyTypes=false#code/CYUwxgNghgTiAEYD2A7AzgF3nNBXCGAXPAN4BmSSA-MZjAJYoDmAvgFBv1kAUARBUl7xG2EHgIBKUm3izEqNEgggAdBCRNuOfBhUCVGJABkkYKMpMB3EDADCUNCG4SJAbjYsgA)

This playground errors, because even though we know that `foo` exists on `result` the compiler adds `undefined` to the set of possible types for `result.foo`.

[`exactOptionalPropertyTypes: true`](https://www.typescriptlang.org/play?exactOptionalPropertyTypes=true#code/CYUwxgNghgTiAEYD2A7AzgF3nNBXCGAXPAN4BmSSA-MZjAJYoDmAvgFBv1kAUARBUl7xG2EHgIBKUm3izEqNEgggAdBCRNuOfBhUCVGJABkkYKMpMB3EDADCUNCG4SJAbjYsgA)

And here we eliminated the error, because the compiler knows that **if** `foo` exists on `result` it **must** be exactly a `string`.

The problem to note here is that the decision to include `undefined` should be up to the **compiler**. Zod takes that decision away and subsequently makes it impossible to truly express optional keys.",,
2098736340,3185,Question: Type flow in a generic validator function,"Hey guys! I'm pretty new to Zod, I currently have a type issue while trying to create a typed generic validator function. It's about reflecting different status codes coming from an API service. It can receive different `method`s in the request body and delivers appropriate `status` in the response. The idea is to eventually have a generic fetch function, which automatically returns the correctly typed response and an union of all possible responses. As a first step, I'd like to define a generic validator function.

```ts
export const METHOD = {
  ADDRESS_CHECK: 'addressCheck',
  PHONE_CHECK: 'phoneCheck',
  EMAIL_CHECK: 'emailCheck',
  NAME_CHECK: 'nameCheck',
  POSTCODE_AUTOCOMPLETE: 'postCodeAutocomplete',
  CITY_AUTOCOMPLETE: 'cityNameAutocomplete',
  STREET_AUTOCOMPLETE: 'streetAutocomplete',
  FINISH_SESSION: 'doAccounting',
} as const

// getValues() lists all values of METHOD
export const MethodZ = z.enum(getValues(METHOD))

export type Method = z.infer<typeof MethodZ>

// Schemas in the values defined elsewhere (not relevant)
const StatusZ = z.object({
  [METHOD.ADDRESS_CHECK]: AddressCheckStatusSchema,
  [METHOD.PHONE_CHECK]: PhoneCheckStatusSchema,
  [METHOD.EMAIL_CHECK]: EmailCheckStatusSchema,
  [METHOD.NAME_CHECK]: NameCheckStatusSchema,
  [METHOD.POSTCODE_AUTOCOMPLETE]: GeneralStatusSchema,
  [METHOD.CITY_AUTOCOMPLETE]: GeneralStatusSchema,
  [METHOD.STREET_AUTOCOMPLETE]: GeneralStatusSchema,
  [METHOD.FINISH_SESSION]: GeneralStatusSchema,
})

const createStatusObjectSchema = <T extends Method>(method: T) => z.object({
  status: z.array(StatusZ.shape[method]),
})

const NameCheckStatusObjectZ = createStatusObjectSchema(METHOD.NAME_CHECK)

type NameCheckStatusObj = z.infer<typeof NameCheckStatusObjectZ>

// has any[] instead of the appropriate NameCheckStatus[]
type InnerStatus = NameCheckStatusObj['status']
```

Now, If `status` in `createStatusObjectSchema` is just `StatusSchema.shape[method]` (no array) the types flow correctly. But the API service returns a status array, so I need to have a `z.array(StatusZ.shape[method])`. This messes up the the type and `InnerStatus` is consequently `any[]`. 

I'm pretty sure that I'm missing something here but I can't figure it out on my own.

I'd appreciate any guidance. Thank you!",,
2098497621,3182,z.string().url() validates invalid urls,"zod: 3.22.4
nodejs: 20.11.0

I've encountered a couple of validations issue with urls:

```js
import { z } from 'zod';

const schema = z.string().url();

const res = schema.safeParse(""https://example"");

console.log('success', res.success)
console.log('error', res.error?.issues ?? [])
```

will return:
```
success true
error []
```

another case is:

```js
import { z } from 'zod';

const schema = z.string().url();

const res = schema.safeParse(""https://example.com/a b"");

console.log('success', res.success)
console.log('error', res.error?.issues ?? [])
```

that again will return:
```
success true
error []
```",,
2097828690,3180,Discriminated Union inside Discriminated Union,"I am trying to write a schema for the below type

```ts

type Bill = {
  billDate: string;
  billId: number;
  name: string;
  balance: number;
};

type MonthType = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;

type InvoiceDateType =
  | { isPartial: 0; invoiceMonth: 0; invoiceYear: 0 }
  | { isPartial: 1; invoiceMonth: MonthType; invoiceYear: number };

export type InvoiceType = Bill &
  (
    | ({ type: ""Invoice""; invoices: number } & InvoiceDateType)
    | {
        type: ""Payment"";
        paymentsAndCredits: number;
        isPartial: 0 | 1;
        invoiceMonth: MonthType;
        invoiceYear: number;
      }
  );
```

I am stuck here.

```ts
const billSchema = z.object({
  billDate: z.string(),
  billId: z.number(),
  name: z.string(),
  balance: z.number(),
});

const monthSchema = z.union([
  z.literal(1),
  z.literal(2),
  z.literal(3),
  z.literal(4),
  z.literal(5),
  z.literal(6),
  z.literal(7),
  z.literal(8),
  z.literal(9),
  z.literal(10),
  z.literal(11),
  z.literal(12),
]);

const invoiceDateSchema = z.discriminatedUnion(""isPartial"", [
  z.object({
    isPartial: z.literal(0),
    invoiceMonth: z.literal(0),
    invoiceYear: z.literal(0),
  }),
  z.object({
    isPartial: z.literal(1),
    invoiceMonth: monthSchema,
    invoiceYear: z.number(),
  }),
]);

const invTypeSchema = z.intersection( // I tried .and operator also
  z.object({
    type: z.literal(""Invoice""),
    invoices: z.number(),
  }),
  invoiceDateSchema,
);

const invoiceTypeSchema = z.discriminatedUnion(""type"", [
  invTypeSchema, // this always gives me error
  z.object({
    type: z.literal(""Payment""),
    paymentsAndCredits: z.number(),
    isPartial: z.union([z.literal(0), z.literal(1)]),
    invoiceMonth: monthSchema,
    invoiceYear: z.number(),
  }),
]);

export const invoiceSchema = billSchema.extend(invoiceTypeSchema); // still gives error
```",,
2097038180,3175,"""Intersection results could not be merged"" does not mention the cause","Zod is great and I'm enjoying the features around intersecting/merging objects. But for `.and`, when the intersections results can't be merged for some reason, the error message thrown at runtime doesn't provide any details.

> An error occurred.
> 
> ```plaintext
> Intersection results could not be merged
> ```
> 
> Stack Trace
> 
> ```plaintext
> ZodError: [
>   {
>     ""code"": ""invalid_intersection_types"",
>     ""path"": [],
>     ""message"": ""Intersection results could not be merged""
>   }
> ]
>     at get error [as error] (file:///Users/josh/repos/dot-com/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs:538:31)
>     at ZodIntersection.parse (file:///Users/josh/repos/dot-com/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs:638:22)
>     at /Users/josh/repos/dot-com/src/pages/rss.xml.ts:26:48
>     at Array.map (<anonymous>)

Not sure if this is a bug report or feature request, but: could the error message also include which field(s) are problematic?

Note that I'm not trying to report that the error is wrong. The error may be right - it just informative enough to explain why clearly.

Sorry that I'm not familiar enough with Zod to provide a standalone reproduction (I tried the Stackblitz Astro starter but couldn't get past TypeScript errors, amusingly). But here's how to get it on a real world project:

```plaintext
git clone https://github.com/JoshuaKGoldberg/dot-com
cd dot-com
git checkout 708081f # ncu-u-for-vite-5 branch
pnpm i
pnpm dev
open http://localhost:4321/rss.xml
```",,
2093527416,3168,"I am getting ""Invalid email"" error with my company brand email address `<my name>@namespactit.com`.","I use `z` from zod and check my email like `z.string().email()`, but I am getting this error `Invalid email`. When I use my company email address as input `<my name>@namespaceit.com>`

#### Desc
> zod version `^3.22.4`
> nextjs version `^13.5.6`
> nodejs version `v20.10.0`
> tRPC version
>  ""@trpc/client"": `^10.38.4`,
    ""@trpc/next"": `^10.38.4`,
    ""@trpc/react-query"": `^10.38.4`,
    ""@trpc/server"": `^10.38.4`,

> error looks like

![email error](https://github.com/colinhacks/zod/assets/60110696/1d5e86d4-a4a2-4433-ba55-09201ff4084d)
![email error 2](https://github.com/colinhacks/zod/assets/60110696/e9b5d7f6-0c77-4a10-afca-47ee544583d7)



```ts
import { z } from ""zod"";


export const changeEmail = () => {
  return privateProcedure
    .input(
      z.object({
     // getting error from there---↓↓
        email: z.string().email(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const userWithTheEmail = await db.user.findFirst({
        where: { email: input.email },
      });

      if (userWithTheEmail) {
        throw new TRPCError({
          code: ""BAD_REQUEST"",
          message: ""Email already exists"",
        });
      }

      await db.user.update({
        where: {
          id: ctx.userId,
        },
        data: {
          email: input.email,
          isEmailVerify: email_verify_options === ""ON"" ? false : true,
        },
      });

      return { success: true, isEmailVerifyOption: email_verify_options };
    });
};
```

> What is the reason behind that?? How to solve the problem?",,
2092555084,3166,How to remove errors when input changed?,"the error now keeps

```
async function onSubmit(data: FormData) {
    setIsLoading(true);

    try {
      userAuthSchema.parse(data);

    } catch (error) {

    }
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // Reset errors when input value changes
   
  };

  return (
    <div className={cn(""mt-4 flex flex-col gap-4"")}>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div className=""flex flex-col gap-2.5"">
          <div>
            <Label className=""sr-only"">
              Email
            </Label>
            <Input
              id=""acc""
              placeholder=""手机号""
              disabled={isLoading || isGithubLoading}
              {...register(""phone"")}
              onChange={handleInputChange}
            />
            {errors?.phone && (
              <p className=""mt-2 text-xs text-destructive"">
                {errors.phone.message}
              </p>
            )}
          </div>
```",,
2092091250,3164,"Constraining ZodTypeAny, for generic functions that receive some schema","Hello, I'm working in a project using NextJS 14, with server actions, and am trying to make a generic helper that parses FormData automatically for me, because it is super annoying to work with FormData and schemas by hand.

Currently I already have a solution that can automatically parse objects that don't have attributes that are arrays, but I will need those types of objects in the future, so the only way I could think of doing that is by checking if schema indexed at that key is an instance of a ZodArray.

But, because ZodTypeAny is essentially, an any, on strict mode, typecript doesn't let me do that. Here's the following code for the automatic parser, and it being used in a real case in my project.

### Parser

```ts
import { ZodArray, ZodTypeAny, z } from ""zod"";

export const parseFormData = <Z extends ZodTypeAny>(
  formData: FormData,
  schema: Z
) => {
  var data: z.infer<Z> = {};
  formData.forEach((_, key, parent) => {
    const value = parent.getAll(key);
    if (schema[key] instanceof ZodArray) {
      data[key] = value;
    } else {
      data[key] = value[0];
    }
  });
  if (schema.safeParse(data).success) throw new Error(""Invalid form data"");
  return data as z.infer<Z>;
};
```

### Use case

```ts
const credentialsSchema = z.object({
  email: z.string(),
  password: z.string(),
});

export const singIn = async (formData: FormData) => {
  const credentials = parseFormData(formData, credentialsSchema);
  const user =
    (await getUserByEmail(credentials.email)) ??
    (await saveUser(credentials.email, credentials.password));
  saveCookie(ACCESS_TOKEN, encode({ email: user.email, userId: user.id }));
};

```",,
2090498914,3162,deepPartial removes descriptions from optional and nullable fields,"The following simple schema loses its description after the `.deepPartial()` call. I found the cause to be the unwrapping happening in `deepPartialify`.

```js
const person = z.object({
        name: z.string(),
        age: z.number().optional().describe(""not everyone wants to say""),
}).deepPartial();
```

https://github.com/colinhacks/zod/blob/dd849254d1149bc1f2ef0f47f0f7607955e4db85/src/types.ts#L2215-L2243

To fix the issue there are multiple options:
- remove the checks for ZodOptional and ZodNullable meaning the resulting ZodObject could have nested ZodOptionals
- call `.describe()` on the unwrapped schema if the unwrapped schema has no description and the initial schema had a description

In our case both of these are valid helpful solutions and created a hotfix to a copy for the latter approach. Since we have a hotfix this issue has no prio at all. Just wanted to raise awareness to the issue and can gladly create a PR with a hotfix for the prefered approach.

Thanks for this amazing library!",,
2088632630,3157,z.input for .readonly should infer ZodReadonly,"Now `ZodReadonly` inferred from `z.output` or `z.TypeOf`, but not from `z.input`
IMO it's incorrect and `z.input` also should infer `ZodReadonly` when `.readonly` used",,
2088324746,3156,beginner question: z.infer(),"Hello,

i have a beginner question:
```js
const cb = () => z
    .function()
    .args(z.number())
    .returns(z.string());

const myCalculator1 = z
    .function()
    .args(z.number(), z.number(), cb()
    )
    .returns(z.string())
    .implement((num1, num2, cb) => {
        let sum = num1 + num2;
        let value = cb(sum);
        return value;
    });

type myFunction = z.infer<typeof myCalculator1>;
```

![image](https://github.com/colinhacks/zod/assets/44213573/57b19b56-abb7-401c-ab9c-c6b7cb0d3da8)
- what is here the problem?

best wishes.",,
2084391319,3146,Enum error message cannot be customized,"According to #580 , custom error message for enum should be like this.

```ts
z.enum(['aaa', 'bbb', 'ccc'], {
  errorMap: () => ({ message: 'custom error message' })
})
```

which is counterintuitive. Though enum params also provided `required_error` and `invalid_type_error`, they are not working for custom errors.

Also, I assume `required_error` and `invalid_type_error` are the same for enum, so I hope custom error message should be like:

```ts
z.enum(['aaa', 'bbb', 'ccc'], { message: 'custom error message' })
```",,
2084099145,3144,Infer strict type for empty object,"With the following code, `Empty` is inferred as `{}`. But `{}` in TypeScript matches any object, not just the empty object. Is there any way to infer a more strict type, such as `Record<string, never>`?

```ts
const empty = z.object({});
type Empty = z.infer<typeof empty>;
const myObject: Empty = {
  foo: ""bar"", // I want this to fail!
};",,
2084056144,3143,"[Suggestion] Parse option that expects Output type as argument, to be used for casting default values","Hi,
I am trying to use Zod for both validation and casting tool, so that I can define my buissness logic default values there and then I can pass a partly object to it and it fill up the gaps, a.k.a default values.

for example:

```ts
const userSchema = z.object({
	id: z.string(),
	coins: z.number().int().nonnegative().default(0),
});

const parsedUser = userSchema.parse({
	id: '123'
});
```
now that would work as intended, but the problem is that if I will add another mandatory field, for example `firstName`, all the places where I used user.parse() for filling in default values would break, and I wouldn't know about it on build time.
A workaround that I can do is either wrapping it under my own function, or do:
```ts
const parsedUser = user.parse({
	id: '123'
} satisfies z.infer<typeof userSchema >);
```

But having this as a built in option would be really helpful.",,
2081862616,3139,`Satisfies` fails when using `preprocess`,"Version: 3.22.4.

The following minimal example code snippet
```typescript
const testSchema = z.preprocess((value) => value, z.array(z.string())) satisfies z.ZodType<string[]>;
```
produces this error:
```
Type 'ZodEffects<ZodArray<ZodString, ""many"">, string[], unknown>' does not satisfy the expected type 'ZodType<string[], ZodTypeDef, string[]>'.
  Types of property '_input' are incompatible.
    Type 'unknown' is not assignable to type 'string[]'
```
If we remove `satisfies`, the type is inferred correctly (`string[]`). 


",,
2080525973,3136,Type error when combining `catchall` and `array`,"Hi everyone. Thank you very much for the great work on zod!

I am getting an error with the following code:

```typescript
const team = z
    .object({
        members: z.array(z.object({
            name: z.string(),
        })),
    })
    .catchall(z.array(z.string()));
type Team = z.infer<typeof team>;

const t1: Team = {
    members: [
        { name: 'Alice' },
    ],
    aliases: ['a', 'b'],
};
```

The error message is:

```
TS2322: Type
  {
    members: {
      name: string;
    }[];
    aliases: string[];
  }
is not assignable to type
objectOutputType<{
  members: ZodArray<ZodObject<{
      name: ZodString;
    }, 'strip', ZodTypeAny, {
      name: string;
    }, {
      name: string;
    }>, 'many'>;
  },
  ZodArray<ZodString, 'many'>,
  'strip'
>

Type
  {
    members: {
      name: string;
    }[];
    aliases: string[];
  }
is not assignable to type
{ [k: string]: string[]; }

Property members is incompatible with index signature.
Type { name: string; }[] is not assignable to type string[]
Type { name: string; } is not assignable to type string
```

It seems to be a bug to me - or is `catchall()` simply not designed to be used this way?

(I'd love to receive suggestions for a workaround.)",,
2080237963,3133,Type Narrowing Not Retained in Chained Array Methods with safeParse,"
When using Zod's safeParse in conjunction with TypeScript's array filter method, the type narrowing does not persist to the subsequent map method.
The workaround involves using mySchema.parse(item) in map, which correctly infers the type, but it seems redundant to call parse after safeParse has already been used. 
Is there a more streamlined way to achieve this without the additional parsing line? Ideally, the type should be correctly narrowed without requiring a second parsing step. 

**Example:**
```typescript
// Incorrectly inferred type
const result = myArray
    .filter(item => mySchema.safeParse(item).success)
    .map(item => item.property);  // Type of 'item' is not correctly narrowed

// Correctly inferred type with type assertion
const correctResult = myArray
    .filter(item => mySchema.safeParse(item).success)
    .map(item => mySchema.parse(item))
    .map(item => item.myField); // Type of 'item' is correctly inferred 
```

",,
2077201281,3130,String tag validation,"While I understand Zod tracks TypeScript closely, one important, as-yet-unsupported validation feature for the non-JSON JavaScript which Zod is capable of handling, is for string tag checks, i.e., the result of calling:

```js
Object.prototype.toString.call(obj).slice(8, -1)
```

...on an object and validating against the result). So something like:

```js
z.stringTag('ArrayBuffer');
```

This remains a well-used mechanism by which built-in types in the browser or server are distinguishable, and it is often such targeting which is desired by an app over duck-typing. While this could be added by refinement, I think it fits more as a fundamental feature.",,
2076662695,3129,Feature request: allow .required() and .partial() on discriminatedUnion,"My goal is to be able to achieve the following:

```ts
export const jwkSchema = z.discriminatedUnion('kty', [
  jwkRsaKeySchema,
  jwkEcKeySchema,
  jwkEcSecp256k1KeySchema,
  jwkOkpKeySchema,
  jwkSymKeySchema,
])

export const jwkWithKidSchema = jwkSchema.require({ kid: true })
```

Meaning that I want to be able to use `z.object` (namely `.required()`) methods on the result of a `discriminatedUnion` (all member of which are objects).",,
2074932520,3127,TypeScript Error in Discriminated Union,"### Code
```typescript
const paymentMethods = [
  ""COD"",
  ""CREDITCARD"",
  ""DEBITCARD"",
] as const;

const methodsEnum = z.enum(paymentMethods);

const PaymentValidator = z.discriminatedUnion(
  ""methods"",
  paymentMethods.map((pm) => {
    if (pm !== ""COD"") {
      return z.object({
        methods: z.literal(methodsEnum.enum[pm]),
        amount: z.number(),
        transaction_id: z.string(),
      });
    }
    return z.object({
      methods: z.literal(methodsEnum.enum.COD),
      amount: z.number(),
    });
  }),
);
```
### Issue Description
The provided TypeScript code for a discriminated union using Zod is producing the following error:
Given code is showing typeScript error 
```sh
Argument of type '(ZodObject<{ methods: ZodLiteral< ""CREDITCARD"" | ""DEBITCARD"">; amount: ZodNumber; transaction_id: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }> | ZodObject<...>)[]' is not assignable to parameter of type '[ZodDiscriminatedUnionOption<""methods"">, ...ZodDiscriminatedUnionOption<""methods"">[]]'.
Source provides no match for the required element at position 0 in the target.
```
However, the code seems to work as intended during runtime. When using PaymentValidator.safeParse, the validation results are as expected. Despite this, TypeScript errors persist.

### Expected Behavior
The TypeScript code should not produce the mentioned error, given that the runtime behavior appears correct.
### Additional Information
* Zod Version: 3.22.4
* TypeScript Version: 5.3.3

Any insights or suggestions to address this TypeScript error would be greatly appreciated. Thank you!",,
2074090247,3123,Order of z.object props with preprocess gives wrong parse results,"Version: **3.22.4**

It seems that Zod is unable of properly validating props with `preprocess` if they are not placed at the beginning of the Zod Object.

The following schema should always return an error for `second`.
```ts
const schemaWrong = z.object({
  first: z.string(),
  second: z.preprocess(() => undefined, z.string()),
});

schemaWrong.safeParse({}) // Shows only 1 error in `first`
```

If we switch the order of the props, then it works: 
```ts
const schemaFixed = z.object({
  second: z.preprocess(() => undefined, z.string()),
  first: z.string(),
});

schemaWrong.safeParse({}) // Correctly shows 2 errors.
```

Playground: https://stackblitz.com/edit/typescript-wqj5ep?file=schemas%2FschemaWithDefaultType.ts

Note: Version **3.21** works correctly",,
2073438821,3122,Discussion: Simplify `.safeParse()` response type to include `error: null` for a better dev experience,"Currently, `safeParse()` and `safeParseAsync()` have the following typings:

```typescript
safeParse(data: unknown, params?: Partial<ParseParams>): SafeParseReturnType<Input, Output>;
safeParseAsync(data: unknown, params?: Partial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;
```

`SafeParseReturnType<Input, Output>` is further defined into:

```typescript
type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;

type SafeParseSuccess<Output> = {
    success: true;
    data: Output;
};
type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
};
```

We use Jest heavily in our code base and we try to refrain from casting as much as possible (Granted there are use cases)

As a simple example:
```
      test('Expect Parse to Fail', () => {
        expect.assertions(3);
        const result = ExampleZodFilter.safeParse(input);
        expect(result).toBeTruthy();
        expect(result.success).toBeFalse();
        expect(result.error).toBeInstanceOf(ZodError); //TS Exception as error does not exist in the response type
      });
```

It has become somewhat of an annoyance having to add additional assertions to validate that `result.error` does exist on the returned type. Currently the easiest way this is being done is by essentially using `success` as a discriminator and casting the response type.
_(I am totally open to suggestions on better ways to go about this.)_

That being said, my question is why not simply add `error: null` on the success type to make it easier on the developer experience and type inference? 

If there is some other reason why the type is being handled this way I would genuinely be interested in understanding the ""Why"".
",,
2068482549,3114,The required error message is not functioning properly,"I have the same problem as mentioned [here](https://stackoverflow.com/questions/77118018/zod-schema-not-triggering-required-error-for-empty-strings#:~:text=The%20required_error%20property%20in%20Zod%20triggers%20only%20if,at%20least%201%2C%20ensuring%20the%20field%20isn%E2%80%99t%20empty.)

thing i have tried : 
- using  `required_error:`
- using `required()`
- using `{ required: ""lastName is required"" }`  in react hook form
- using `rules={{ required: ""first name is required"" }}`  in `Controller `component (react hook form)

```jsx
const registerSchema = z
	.object({
		email: z.string({ required_error: ""firstName is required"", invalid_type_error: ""firstName must be a string""}).email().trim().toLowerCase().min(3).max(20),
	.required() // makes all properties required.
	});
	
const {
		register,
		handleSubmit,
		control,
		formState: { errors, isSubmitSuccessful},
	} = useForm({
		mode: ""onBlur"", // when to validate the form
		resolver: zodResolver(registerSchema ),
	});
	
	....
<>
	<Controller
				defaultValue=""""
				rules={{ required: ""first name is required"" }}
				name=""firstName""
				control={control}
				render={({ field: { name, ...field }, fieldState: { invalid, error }, formState }) => <TextField {...field} label=""First Name"" error={!!error} helperText={error?.message} sx={{ gridColumn: ""span 2"" }} />}
		/>
		<TextField {...register(""lastName"", { required: ""lastName is required"" })} label=""Last Name"" error={!!errors.lastName} helperText={errors.lastName?.message} sx={{ gridColumn: ""span 2"" }} />	
		<TextField {...register(""location"")} label=""Location"" error={!!errors.location} helperText={errors.location?.message} sx={{ gridColumn: ""span 4"" }} />
		<TextField {...register(""job"")} label=""Job"" error={!!errors.job} helperText={errors.job?.message} sx={{ gridColumn: ""span 4"" }} />
		<TextField {...register(""picture"")} label=""Picture"" error={!!errors.picture} helperText={errors.picture?.message} sx={{ gridColumn: ""span 4"" }} />
</>
```",,
2067031002,3108,Wrong type after parse,"Hi all!

I have written this schema:

```ts
export const createEmployeeAbsence = z
  .object({
    startDate: z.date(),
    endDate: z.date().optional(),
    employeeId: z.string(),
    absence: absenceReasons,
  })
    .superRefine((val, ctx) => {
      if (val.absence !== ""LONGTERMSICK"" && val.endDate === undefined) {
        return ctx.addIssue({
          code: z.ZodIssueCode.invalid_date,
          message: ""Slutdato skal være udfyldt"",
          path: [""endDate""],
        })
      }

    if (
      val.endDate &&
      isBefore(val.endDate, val.startDate) &&
      val.absence !== ""LONGTERMSICK""
    ) {
      return ctx.addIssue({
        code: z.ZodIssueCode.invalid_date,
        message: ""Slutdato skal være efter startdato"",
        path: [""endDate""],
      })
    }
  })
  .transform((val) => {
    if (val.absence === ""LONGTERMSICK"") {
      return {
        ...val,
        endDate: generateUTC(new Date(2150, 0, 1)),
      }
    }

    return val
  })
  ```
  
I try to prompt the user to always provide an endDate unless absence of LONGTERMSICK is chosen, hence the first issue in the superrefine. If LONGTERMSICK is chosen, then I will transform the endDate to a date. So in every case, the endDate will be set.

When I try to parse the schema, the endDate type is set to Date | undefined. 

I dont know if this is an bug or just me?

Thank you in advance! :)",,
2064644707,3105,`custom` should exist on the method chain instead of only at the root,"Hello, and thanks for the excellent library.

I want to use Zod to type assert a value to a known type. For example:

```ts
const numPlayers = z.number().int().min(2).max(100);
type NumPlayers = z.infer<typeof numPlayers>;
type RealNumPlayers = IRange<2, 100>; // 2 | 3 | 4 | ... | 100
```

Here, `NumPlayers` is `number`, which is not really correct. It should actually be equal to `RealNumPlayers`.

I'm fine with Zod not doing this automatically under the hood, as that would probably have performance implications for large numbers. However, I want the ability to do it myself. So I need a way to type assert a value after Zod has already performed its validation.

## Existing Solution: `z.custom`

The `z.custom` function allows you to perform a type assertion. For the above example, it would look like this:

```ts
const numPlayers = z.custom<RealNumPlayers>(
  (val) => typeof val === ""number"" && Number.isInteger(val) && val >= 2 && val <= 100
);
```

But this is not ideal, because we are having to duplicate all of the Zod functionality ourselves in app-side TypeScript, which is much more verbose. It would be better if we could utilize Zod like this:

```ts
const numPlayers = z.number().int().min(2).max(100).custom<RealNumPlayers>();
```

But this pattern doesn't work because `custom` only exists at the root instead of along the method chain! Thus, this issue is to request that it be added there.

## Discussion on `z.refine`

Even though `z.custom` does not exist on the method chain, `z.refine` does. But unfortunately `z.refine` does not have the ability to take in a generic parameter. So we can't use it for this purpose. It might be possible for Zod to add a generic parameter to `z.refine` to fix this problem. But then it seems like we would just be duplicating the functionality of `z.custom`, which would be confusing.

Thus, I think `z.refine` should be used for ""extra validation without changing the type"" and I think `z.custom` should be used for ""changing the type, with or without additional validation steps"".",,
2064621815,3104,TypeScript Mismatch using Pick or Omit,"I have a NestJS application using Prisma and Zod, where I define a `StoreOwnerModel` representing a database table with all fields, and a `StoreOwnerEntity` which is a minimal representation containing only specific fields for frontend responses.

I have the following function to retrieve a single `StoreOwnerEntity` based on the `storeOwnerId`:

```typescript
async getOne(storeOwnerId: number): Promise<StoreOwnerEntity> {
  const storeOwnerOfTypeModel = await this.prismaService.storeOwner.findUniqueOrThrow({
    where: { id: storeOwnerId },
  });

  // My question is why TypeScript is not throwing an error here, even though
  // I'm trying to return a `StoreOwnerModel` instead of the expected `StoreOwnerEntity`.
  // Shouldn't there be a type mismatch error since the return type is declared as `StoreOwnerEntity`?

  // return storeOwnerOfTypeModel; // No TypeScript Error
  return this.storeOwnerEntityMapper.modelToEntity(storeOwnerOfTypeModel);
}
```

Additionally, I've defined a `StoreOwnerEntitySchema` using Zod with only the necessary fields:

```typescript
export const StoreOwnerEntitySchema = StoreOwnerSchema.pick({
  id: true,
  email: true,
});

export class StoreOwnerEntity extends createZodDto(StoreOwnerEntitySchema) {}
```

```typescript
export const StoreOwnerSchema = z.object({
  id: z.number().int(),
  email:  z.string().email();,
  createdAt: z.date().default(new Date()),
});
```

I would appreciate insights into why TypeScript is not throwing an error in this case and guidance on ensuring type safety when mapping and returning entities. Thank you!",,
2062835304,3101,Empty error message gets evaluated as falsy and overriden,"Doing this

```ts
import z from 'zod';

z.number().min(0, { message: '' }).parse(-1);
```
Results in an error of 
```
Error: [
{
""code"": ""too_small"",
""minimum"": 0,
""type"": ""number"",
""inclusive"": true,
""exact"": false,
""message"": ""Number must be greater than or equal to 0"",
""path"": []
}
]
```
instead of having an empty message.

Would it be possible to explicitly check if the message is undefined rather than checking if it's falsy? After asking this on the Discord scotttrinh found the line causing this

https://github.com/colinhacks/zod/blob/3e4f71e857e75da722bd7e735b6d657a70682df2/src/helpers/parseUtil.ts#L31
",,
2061838919,3099,Cannot use z.infer. Property 'infer' does not exist on type ,"Version zod: `^3.22.4`
When I try to use` z.infer<typeof SomeSchema>` I don't have a `infer` in `z`

**All code**:
```
import  z  from ""zod"";

export const ProductsSchema = z.object({
  title: z.string().max(255),
  description: z.string().max(255),
  price: z.number(),
});


export const ProductsSchemaType = z.infer<typeof ProductsSchema>;
```

And have this error when trying to use infer:
`Property 'infer' does not exist on type 'typeof import(""/project/node_modules/zod/index"")'.`

+ My autocomplete doesn't see this infer when I type dot after `z` as if he doesn't exist at all",,
2061814992,3098,z.infer doesn't infer types correctly,"When i have the following:

```
export const test = z.object({
    one: z.string().startsWith(""test:""),
    two: z.literal(""thisisatest""),
});

export type testType = z.infer<typeof test>;
```

The type of testType is inferred as follows:

```
type testType = {
    one: string;
    two: ""thisisatest"";
}
```

When it should presumably infer to:

```
type testType = {
    one: `test:${string}`;
    two: ""thisisatest"";
}
```

Unless i'm missing something? Or is this a bug?

Thanks!",,
2061157658,3095,Default generates same value for object array when passed a function,"## Description

In an object array, default method when passed a function, does not call the function for each object. 

## Use case

Using default method to generate unique id in case it is not passed.

## Version

- zod: 3.22.4
- typescript: 5.3.3

## Sample code to reproduce the issue:

```javascript
import { z } from ""zod"";

const testSchema = z.object( {
  id: z.number().default(Math.random()),
  name: z.string(),
  books: z.object( {
    id: z.number().default(Math.random()),
    title: z.string(),
  } ).array(),
} );

const testObject = {
  name: ""John"",
  books: [
    { title: ""Book 1"" },
    { title: ""Book 2"" }
  ]
};

console.log(testSchema.parse(testObject));
```

## Output

```json
{
  ""id"": 0.6215207601546078,
  ""name"": ""John"",
  ""books"": [
    { ""id"": 0.06822490162582584, ""title"": ""Book 1"" },
    { ""id"": 0.06822490162582584, ""title"": ""Book 2"" }
  ]
}
```

In the output, the `books` object array has 2 ids with exact same value while `Math.random` generates unique value each time.
",,
2061029554,3093,Wrong type infered when using refine inside a merge,"## Description

I want to create a schema of three fields.
One is mandatory.
The other two are optional, but one or the other must be defined.

I'm trying to achieve that by merging two schemas.
The first one, with the mandatory field.
The second one, with the optional fields. I'm doing a refine to validate that one or the other is defined.

When doing so, the type I get from `z.infer` is not what I expect:

```ts
const schema = z
  .object({
    id: z.string().min(1)
  })
  .merge(
    z
      .object({
        name: z.string().min(1),
        description: z.string().min(1)
      })
      .partial()
      .refine((fields) => atLeastOneDefined(fields), {
        message: 'Name or description must be defined'
      })
  );

type T = z.infer<typeof schema>;
```

## Expected behavior

```ts
type T = {
  id: string;
  name?: string;
  description?: string;
}
```

## Actual behavior

```ts
type T = {
    [x: string]: any;
}
```

## Without refine

The refine inside the merge seems to be the problem.

If I remove the refine, the type gets inferred correctly:

```ts
const schema = z
  .object({
    id: z.string().min(1)
  })
  .merge(
    z
      .object({
        name: z.string().min(1),
        description: z.string().min(1)
      })
      .partial()
  );

type T = z.infer<typeof schema>;

// type T = {
//   id: string;
//   name?: string | undefined;
//   description?: string | undefined;
// }
```

If I do a refine without any merge, the type is also correct:

```ts
const schema = z
  .object({
    one: z.string().min(1),
    two: z.string().min(1)
  })
  .partial()
  .refine((fields) => atLeastOneDefined(fields));

type T = z.infer<typeof schema>;

// type T = {
//   one?: string | undefined;
//   two?: string | undefined;
// }
```",,
2060782973,3091,Add a `.message()` method to Zod schemas for a default error message,"## Description:
Currently, Zod allows us to specify error messages for each validation method like `min`, `max`, etc. However, there is no way to specify a default error message for a field that applies when any validation fails.

For example, consider this schema:

```typescript
const guestUserSchema = z.object({
  name: z
    .string({
      invalid_type_error: ""Invalid name"",
      required_error: ""Name is required"",
    })
    .min(3, {
      message: ""Name must be at least 3 characters long"",
    })
    .max(20, {
      message: ""Name must be at most 20 characters long"",
    }),
  username: z.string().min(3).max(20).startsWith(""guest_""),
  method: z.array(z.literal(""guest"")).default([""guest""]),
});
```

I would like to be able to specify a default error message for the name field that is shown when any validation fails, like this:
```typescript
const guestUserSchema = z.object({
  name: z
    .string()
    .min(3)
    .max(20)
    .message(""Name must be between 3 to 20 characters""),
  username: z.string().min(3).max(20).startsWith(""guest_""),
  method: z.array(z.literal(""guest"")).default([""guest""]),
});
```
In this example, the .message() method would set a default error message for the name field that is shown when the min or max validation fails.

## Use Case:
This feature would be useful for providing more general error messages when any validation fails for a field, instead of having to specify an error message for each validation method.

## Proposed Solution:
Add a .message() method to Zod schemas that sets a default error message for a field. This message would be shown when any validation fails for the field.

## Alternatives Considered:
An alternative is to use the `.refine()` method to add a custom validation that always passes but provides a custom error message when any other validation fails. However, this is more of a workaround than a solution, and it would be more convenient to have a built-in method for this purpose.",,
2060750680,3089,How to type the zod schema object based on a predefined type?,"I have the following code:
```ts
class MyModel {
  propA: string
  propB: number
  propC: boolean
  constructor() {
    this.propA = ''
    this.propB = 123
    this.propC = true
  }
}
```

I want to create a Zod schema object based on this class, so that the **keys** and the **values** will correspond to this type:
```ts
const mySchema = z.object<SOME_GENERIC_METHOD_HERE<MyModel>>({
propA: z.string(),
  propB: z.number(),
  propC: z
    .boolean()
    .optional()
    .transform((i) => i),
})
})
```

I have tried to create a simple generic function that worked perfectly when `strictNullChecks` option in the **tsconfig.json** is disabled:

```ts
type ZodSchemaKeysFrom1<E> = {
  [k in keyof E]: ZodType<E[k]>
}

const mySchema = z.object<ZodSchemaKeysFrom1<MyModel>>({
  propA: z.string(),
  propB: z.number(),
  propC: z
    .boolean()
    .optional()
    .transform((i) => i),
})

type MySchemaFields = z.infer<typeof mySchema>
```

In this case `MySchemaFields` type is being inferred correctly as:
```ts
type MySchemaFields = {
    propA?: string;
    propB?: number;
    propC?: boolean;
}
```
It's the same type that will be inferred if you remove the generic angle brackets from `z.object<xxx>()`

Now, the problem is, I don't want to disable this typescript flag, I want my code to be as  strict as possible to avoid future mistakes.

So when I remove this flag (`strictNullChecks`), I get the following error only on the propC in the zod schema:

[![enter image description here][1]][1]


The error messsage is:

```
Type 'ZodEffects<ZodOptional<ZodBoolean>, boolean | undefined, boolean | undefined>' is not assignable to type 'ZodType<boolean, ZodTypeDef, boolean>'.
  Types of property '_type' are incompatible.
    Type 'boolean | undefined' is not assignable to type 'boolean'.
      Type 'undefined' is not assignable to type 'boolean'.ts(2322)
index.ts(6, 3): The expected type comes from property 'propC' which is declared here on type 'ZodSchemaKeysFrom1<MyModel>'

(property) propC: ZodType<boolean, z.ZodTypeDef, boolean>

```

How can I avoid this error?

I have created a code sandbox for everyone to try it out.

[Click here to see and try it in my devbox codesandbox][2]


  [1]: https://i.stack.imgur.com/vXAqY.png
  [2]: https://codesandbox.io/p/devbox/zod-keys-schema-9krk5v?file=%2Fsrc%2Findex.ts",,
2057596775,3087,Different behavior for union() and or(),"## Steps to reproduce
1. Create a function that takes both the Zod schema and an object that should have that schema.
```
function testFunction<TypeValidator extends z.ZodFirstPartySchemaTypes>(
  value: z.infer<TypeValidator>,
  schema: TypeValidator
) {}
```

2. Create two schemas: one with union(), one with or().
3. Call that function with the two schemas and an object that does not conform to the schema (it should throw an error).

## Expected behavior
TS results in an `Argument of type [...] is not assignable to parameter of type [...]` error in both cases.

## Actual behavior
TS results in an `Argument of type [...] is not assignable to parameter of type [...]` error only when using the .or() operator.

## Note
For some reason, this only works when the schema is created directly as a function argument.
If the schema is assigned to a constant and then that const is passed to the function, everything works correctly.
See the sandbox link to see this behavior.

## Sandbox
https://codesandbox.io/p/sandbox/zod-union-or-issue-xj3tv9 (file `src/index.ts`).",,
2054838903,3084,playground.ts file throws error.,"When I run **yarn play** in the root of the project I get the following error.

```/home/user/Documents/programs/javaScriptProjects/forked/zod/playground.ts:31
const a = new Arg();
          ^


ReferenceError: Arg is not defined
    at <anonymous> (/home/babu/Documents/programs/javaScriptProjects/forked/zod/playground.ts:31:11)
    at Object.<anonymous> (/home/babu/Documents/programs/javaScriptProjects/forked/zod/playground.ts:32:3)
    at Module._compile (node:internal/modules/cjs/loader:1256:14)
    at Object.F (/home/babu/Documents/programs/javaScriptProjects/forked/zod/node_modules/@esbuild-kit/cjs-loader/dist/index.js:1:941)
    at Module.load (node:internal/modules/cjs/loader:1119:32)
    at Module._load (node:internal/modules/cjs/loader:960:12)
    at ModuleWrap.<anonymous> (node:internal/modules/esm/translators:169:29)
    at ModuleJob.run (node:internal/modules/esm/module_job:194:25)
```

Can I own this issue?",,
2054801228,3083,ZodBigInt#isOptional throws,"from using zod-openapi-library
```
✘ [ERROR] TypeError: Cannot convert undefined to a BigInt
      at [object Object]
      at ZodBigInt._parse
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/zod/lib/index.mjs:1570:26)
      at ZodBigInt._parseSync
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/zod/lib/index.mjs:624:29)
      at ZodBigInt.safeParse
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/zod/lib/index.mjs:654:29)
      at ZodBigInt.isOptional
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/zod/lib/index.mjs:811:21)
      at OpenAPIGenerator.isOptionalSchema
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/@asteasolutions/zod-to-openapi/dist/openapi-generator.js:588:26)
      at OpenAPIGenerator.generateSimpleParameter
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/@asteasolutions/zod-to-openapi/dist/openapi-generator.js:193:32)
      at OpenAPIGenerator.generateParameter
```",,
2054419307,3082,type checking,"hello
I created schema and made required all fields but out put of z.infer<typeof mySchema> fields are optional

Thank you for your guidance",,
2054288424,3080,Issue with enum initiated with Array<Something> type,"I'm trying to migrate quite big types definitions library (100+ files) from superstruct to zod for following reasons
- readonly()
- discriminatedUnion()

So far it's been smooth ride I'm having issue with ""enum"" type. We mostly used 2 patterns in superstruct:
```
// (1) real enum
enum SomethingType {
  SOMETHING = 'SOMETHING'
}

// (2) fake enum 
const SomethingType = {
  SOMETHING: 'SOMETHING'
} as const

// both were used fine in superstruct enum - by simply converting then into Array of something
const sortedValues = Object.values(SomethingType) // Array<""SOMETHING"">
const superstructEnum = enums(sortedValues)

export const zodEnum = z.enum(SomethingType) // error Argument of type SomethingType[] is not assignable to parameter of type readonly [string, ...string[]]
```

Why we used fake enum is a bit out of scope of this question, but if you're curious: for migrating between the versions where enum members change. The issue I'm having with zod is that none of these ways of defining enums seem to work. I guess it's all because of the requirement of having first element in the tuple:

`createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>`

can I ask - what's the reason or benefit of having this?

Also, I know I probably could change from enum() to union() but for this I need to define all these strings as literals, which is quite big change and affects the library's public API. Is there any other way to define the enum in zod, which is similar to the one in superstruct?

Would this PR https://github.com/colinhacks/zod/pull/2338 fix my problem?",,
2053204669,3079,Typescript declaration file fails to infer type properly,"I notice that the behavior of inferred types using `z.infer` is different when using it on a local project, then when exporting it to a package and using typescript declaration files.

Here is what I noticed:

If I create a basic schema:

```typescript
export const MySchema = z.object({
  /**
   * This is a very important js doc comment
   */
  name: z.string(),
});
```

and create a type inferring from it: 
```typescript
export type MyType = z.infer<typeof MySchema>;
```

The type and comment work fine if I try to use it in the same project:

![image](https://github.com/colinhacks/zod/assets/34727800/8277600f-b470-4118-ac6c-5606b2a7391e)


However, the compiled file will look something like this:
```typescript
export declare const MySchema: ZodObject<{
    /**
     * This is a very important js doc comment
     */
    name: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
    name: string;
}, {
    name: string;
}>;
export type MyType = z.infer<typeof MySchema>;
```

Notice that, the 5 components of `ZodObject` are not compatible making the `Schema['_output']` (which is used to inferring) not keep the comments from the original raw shape (likely due new types being created).
![image](https://github.com/colinhacks/zod/assets/34727800/0f98be35-0475-4857-a47c-cbf4885ade71)

Now, I noticed that if I remove `strip` and `z.ZodType` from the list of generics, it manages to resolve the comments again.

So I looked deep into the code and found the place where the output is being created at `objectOutputType` and replicated pretty much the same thing, except I did not add those 2 extra types:

This is my utility type:
```typescript
export type SchemaType<T extends ZodObject<any>> = objectUtil.flatten<
  objectUtil.addQuestionMarks<baseObjectOutputType<T[""shape""]>>
>;
``` 
And now the comments are back:
![image](https://github.com/colinhacks/zod/assets/34727800/691b659b-78f5-4957-9d4c-5cd241d2af60)



I am not very sure if this utility type could become something in zod itself.

Could `infer` or `TypeOf` stop using `_output` and do this instead? What would be the impact of losing those 2 extra types from the inferred type?

",,
2053140429,3077,Exception handling in transform or safeParse,"```
import { z } from ""zod"";

const invalidJson = '{""ax: 1}'

console.log(
  z
    .string()
    .transform((val) => JSON.parse(val))
    .safeParse(invalidJson)
);
```

--

Expected:
```json
{ ""success"": false, ""error"": ... }
```

--

Result:
It throws the exception. ""Unexpected end of JSON input"".

--

Basically exceptions are not handled in `transform` or `safeParse` as you would expect them to. 

I've checked the documentation and it doesn't mention anything about handling exceptions in `transform`.

There seem to be similar behaviour for `refine` as well.

zod package version - 3.22.4",,
2049507750,3072,The .transform method is throwing errors,"Hi,

I used the transform method to change some data after parsing. The implementation used to work before but now an error is thrown and i don't understand whats going on as i didn't change anything. here is an example of some code i have using .transform

```ts
const convertToStringsArray = (value: string) => {
    if (!value || value === '') return null;
  
    const array = value.split('\n');
  
    return array;
};

export const sheetArrays = z.string().transform(convertToStringsArray);
```

the error being thrown is this
```
TypeError: effect.transform is not a function
    at ZodEffects._parse (types.js:3375:31)
    at ZodObject._parse (types.js:1957:29)
    at ZodObject._parseSync (types.js:170:25)
    at eval (types.js:1811:23)
    at Array.map (<anonymous>)
    at ZodArray._parse (types.js:1810:34)
    at ZodArray._parseSync (types.js:170:25)
    at ZodArray.safeParse (types.js:207:25)
    at eval (products.ts:722:63)
    at step (products.ts:146:17)
```
",,
2045361094,3066,Zod continues to throw errors while using async refinements with react hook form when zod resolver mode is set to async,"The title pretty much sums it up but, Zod throws errors when using async refinements via react hook form and Zod resolver even when you set mode to 'async'. This shouldn't be the case as it makes no sense. Refinements regardless of being async or not should not result in Zod throwing an error and instead should result in a validation error similar to any other function in Zod (e.g. min()). 


I don't think this is an issue with Zod (though maybe?) but, it absolutely is a failure of the docs to not cover this specific situation given that Zod is so commonly used with RHF.

EDIT: Messed something up on my end.",,
2045018869,3064,Recursive schema that uses other schemas not working due to incompatible inputs and outputs,"Example:

```typescript
import { z } from 'zod'

const Column = z.union([
    z.object({
        type: z.literal('string'),
    }),
    z.object({
        type: z.literal('integer'),
    }),
])

const TableBase = z.object({
    name: z.string(),
    columns: z.record(Column).default({}),
})

type TableWithExtends = z.infer<typeof TableBase> & {
    extends: TableWithExtends
}

//    Error -- Type 'undefined' is not assignable to type 'Record<string, { type: ""string"" } | { type: ""integer"" }>'
//    ||||| 
//    vvvvv
const Table: z.ZodType<TableWithExtends> = TableBase.extend({
    extends: z.lazy(() => Table),
})
```

The error goes away if I change `z.infer` to `z.input` but then the output of `Table` changes to the input as well which is not what I need. It seems since `z.ZodType` assumes output will match input, this use case falls apart, but manually supplying input and output doesn't seem to work either. Could use some pointers here.",,
2042622708,3058,Adding .required does not make returned type have required field,"I have a type with a required field, for which I've generated a Zod schema.  The generated schema is coming from `openapi-to-zod`, but the small example below replicates the relevant code and demonstrates the problem.  In the documentation, the section on Objects leads off with sample code in which it is said that by default fields of `z.object` are required, and that the example is equivalent to a TypeScript definition where the fields are required.

As shown below, that's not the case today.

```js
import { z } from 'zod';

type E = {
    programID: string;
    eName?: string;
};

// Establish that programID is required
const badE: E = {};
// Property 'programID' is missing in type '{}' but required in type 'E'.
const goodE: E = { programID: '99' }
// No error

const parseE = z.object({
    programID: z
                .string()
                .regex(new RegExp(""^[a-zA-Z0-9_-]*$""))
                .min(1)
                .max(128)
                .describe(""URL safe VTN assigned object ID.""),
    eName: z.string().default('ZILCH').optional()
}); // .required(); // { programID: true });

// Generate Zod's view of the type described by the schema
type tE = z.infer<typeof parseE>;

// This is the type shown when hovering the mouse over `tE`
// Notice that programID is shown as optional.
// No addition of .required() in the parseE definition changes this
//
// type tE = {
//     programID?: string;
//     eName?: string;
// }

// tE should require programID, therefore this should give
// the same error as above
const badE2: tE = {};
// No error

const e: E = parseE.parse({
    // Commenting this out results in a parse error
    // saying that programID is required 
    programID: 'Program-ID-99'
});

console.log(e);
```

The field `E.programID` is required.  In `parseE` I'm trying to work out how to make `programID` be required as well.

Compiling the above gives the following error:

```
src/index.ts:30:7 - error TS2322: Type '{ programID?: string; eName?: string; }' is not assignable to type 'E'.
  Property 'programID' is optional in type '{ programID?: string; eName?: string; }' but required in type 'E'.

30 const e: E = parseE.parse({
```

The error message says the Zod schema returned by `parseE.parse` has `programID` as optional.  TypeScript complains that it is not assignable because `programID` is required.

No matter the setup of the `.required()` call, the error message does not change.

In Visual Studio Code, and hovering the mouse over things - the `parseE.parse` function shows `programID` as optional.

As noted in the comments, using `z.infer` to retrieve the type Zod thinks is correct shows `programID` to be optional.  No option for `.required()` changes this.

But, if the object passed to `parseE.parse` does not have `programID`, then when the program is run an error is thrown with this issue:

```js
{
      code: 'invalid_type',
      expected: 'string',
      received: 'undefined',
      path: [ 'programID' ],
      message: 'Required'
    }
```

So.. the parser knows that `programID` is required, while TYpeScript compiler is still giving the error saying `programID` is optional.

",,
2042533754,3057,Zod Lazy - optional recursion,"From the recursion example from the [docs](https://github.com/colinhacks/zod#recursive-types):

```
const baseCategorySchema = z.object({
  name: z.string(),
});

type Category = z.infer<typeof baseCategorySchema> & {
  subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
  subcategories: z.lazy(() => categorySchema.array()),
});
```

However, I'm getting a type error:

<img width=""594"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/9795404/80a29756-81c9-4282-a893-4b1428c59609"">
",,
2042514898,3056,Zod Tuple type shows,"On a zod tuple, there is an additional parameter at the end of the tuple. `...unknown[]`. Is this expected? Possibly in relation to the support for `.rest`, but shouldn't the spread items not even appear in the type of `.rest` is omitted?

```
import { z } from 'zod';

const athleteSchema = z.tuple([
  z.string(), // name
  z.number(), // jersey number
  z.object({
    pointsScored: z.number(),
  }), // statistics
]);
```

Here is the type I expect:

```
type Athlete = z.infer<typeof athleteSchema>;
// type Athlete = [string, number, { pointsScored: number }]
```

However, this is the type that I see (note the `...unknown[]`:
```
// type Athlete = [string, number, { pointsScored: number }, ...unknown[]]
```

From the type tuple, this should be invalid:
```
const a: Athlete = ['1', 2, { pointsScored: 3 }, 4];
```

Is this a bug, or expected behavior? Feels like a bug to me, but as a beginner-intermediate zod user, maybe there is an explanation.",,
2041575134,3054,Nested schema w/ .default doesn't generate the default value if it is used with .optional,"Consider these three schema objects -- all generated by `ts-to-zod` from TypeScript source.

```js
export const dateTimeSchema = z.string().datetime().default(""0000-00-00"");

export const durationSchema = z
  .string()
  .regex(
    /^(-?)P(?=\d|T\d)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)([DW]))?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/,
  )
  .default(""PT0S"");

export const intervalPeriodSchema = z.object({
  start: dateTimeSchema,
  duration: durationSchema.optional(),
  randomizeStart: durationSchema.optional(),
});
```

In `durationSchema` there is a default value, which is a Duration string for zero seconds.

Calling `intervalPeriodSchema.parse` with an object that does not include the `randomizeStart` field, I get the following:

```js
{
  // ...
  intervalPeriod: { start: '2023-02-20T00:00:00Z', duration: 'P3M' },
  // ...
}
```

What I'm reasoning is that `intervalPeriodSchema.parse` calls `durationSchema.parse` which notices the missing field, notices the `.optional`, and therefore does not call into `durationSchema.parse`, and therefore the `.default` value is not substituted.

I have generated the same schema using a different tool - `openapi-to-zod` - which generates the following schema, and in that case the default value shows up.

```js
    intervalPeriod: z
      .object({
        start: z.string().datetime().describe(""datetime in ISO 8601 format""),
        duration: z
          .string()
          .regex(
            new RegExp(
              ""^(-?)P(?=\\d|T\\d)(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)([DW]))?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?)?$""
            )
          )
          .describe(""duration in ISO 8601 format"")
          .default(""PT0S""),
        randomizeStart: z
          .string()
          .regex(
            new RegExp(
              ""^(-?)P(?=\\d|T\\d)(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)([DW]))?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?)?$""
            )
          )
          .describe(""duration in ISO 8601 format"")
          .default(""PT0S""),
      })
```

 
",,
2040598336,3052,Cannot make discriminated unions with certain things / types break in weird ways,"It seems that trying to make discriminated unions with certain things breaks some types - errors look something like this:

Argument of type: 
```
ZodDiscriminatedunion<
	""code"",
	[
		ZodObject<
			{ code: ZodLiteral<""a"">; a: ZodNumber }.
			""strip"",
			ZodTypeAny,
			{ code: ""a""; a: number },
			{ code: ""a""; a: number }
		>,
		ZodObject<...>
	]
>
```

is not assignable to parameter of type `AnyZodObject`. 

Type:

```
ZodDiscriminatedunion<
	""code"",
	[
		ZodObject<
			{ code: ZodLiteral<""a"">; a: ZodNumber }.
			""strip"",
			ZodTypeAny,
			{ code: ""a""; a: number },
			{ code: ""a""; a: number }
		>,
		ZodObject<...>
	]
>
```

is missing the following properties from type:

```
ZodObject<
	any,
	any,
	any,
	{ [x: string]: any },
	{ [x: string]: any }
>
```

:
- _cahced
- _getCached
-  shape
- strict
and 14 more

Here is an example [codesandbox](https://codesandbox.io/p/sandbox/angry-parm-vm86j5?file=%2Fsrc%2Findex.ts%3A23%2C1&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clq4cg0lq0006356jcyzpyh6r%2522%252C%2522sizes%2522%253A%255B100%252C0%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clq4cg0lq0002356jjc32u1u9%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clq4cg0lq0003356jsgnmwg3z%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clq4cg0lq0005356jdx873vru%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clq4cg0lq0002356jjc32u1u9%2522%253A%257B%2522id%2522%253A%2522clq4cg0lq0002356jjc32u1u9%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clq4chsdz0002356jyyh0ydqx%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522initialSelections%2522%253A%255B%257B%2522startLineNumber%2522%253A23%252C%2522startColumn%2522%253A1%252C%2522endLineNumber%2522%253A23%252C%2522endColumn%2522%253A1%257D%255D%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%252C%2522activeTabId%2522%253A%2522clq4chsdz0002356jyyh0ydqx%2522%257D%252C%2522clq4cg0lq0005356jdx873vru%2522%253A%257B%2522id%2522%253A%2522clq4cg0lq0005356jdx873vru%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clq4cg0lq0004356jbktmpqmd%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A0%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522activeTabId%2522%253A%2522clq4cg0lq0004356jbktmpqmd%2522%257D%252C%2522clq4cg0lq0003356jsgnmwg3z%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clq4cg0lq0003356jsgnmwg3z%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Afalse%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)",,
2038053248,3046,errorUtil code causes a TypeError when running in a Tauri app,"Steps to replicate:

1. `import { z } from ""zod"";` into a web app running in [Tauri](https://github.com/tauri-apps/tauri)
2. Run application using `npm run tauri dev`

Expected: Application runs as usual.
Observed: Application fails with `TypeError: Cannot assign to read only property` logged to console.

This seems to be because Tauri by default freezes `Object.prototype` for security. [This Tauri issue](https://github.com/tauri-apps/tauri/issues/3416) describes the same issue occurring with different libraries.

There is a workaround of disabling the freezing of `Object.prototype`, but ideally it would be better to leave this enabled and still have the ability to use zod with Tauri.

Looking at the code that causes the issue, it seems to be [errorUtil.ts](https://github.com/colinhacks/zod/blob/master/src/helpers/errorUtil.ts#L5). This ends up as something like this in js:

```js
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === ""string"" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === ""string"" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));
```

Specifically it seems to be the `errorUtil.toString = ...` assignment that causes the error - renaming the const avoids the issue.",,
2037553306,3045,Recursive types interpret transformed properties wrong,"Hello, first of all not sure if it's a bug, or if I'm doing something wrong, but I'll put it out there just in case.

Recursive types don't handle transformed properties
My recursive type follows this example: https://zod.dev/?id=recursive-types

```ts
const StringToNumSchema = z
  .string()
  // It works fine when you comment out the .transform method
  .transform((value, ctx) => {
    const number = Number(value);

    if (isNaN(number)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: ""Value must be a number"",
      });

      return z.NEVER;
    }

    return { value: number };
  });

export type StringToNum = z.infer<typeof StringToNumSchema>;

const _BaseRecursiveObjectSchema = z.object({
  num: StringToNumSchema,
});

export type RecursiveObject = z.infer<typeof _BaseRecursiveObjectSchema> & {
  recursive_object: RecursiveObject;
};

export const RecursiveObjectSchema: z.ZodType<RecursiveObject> =
  _BaseRecursiveObjectSchema.extend({
    recursive_object: z.lazy(() => RecursiveObjectSchema),
  });
```

```shell
error TS2322: Type 'ZodObject<{ num: ZodEffects<ZodString, { value: number; }, string>; recursive_object: ZodLazy<ZodType<RecursiveObject, ZodTypeDef, RecursiveObject>>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<RecursiveObject, ZodTypeDef, RecursiveObject>'.
  Types of property '_input' are incompatible.
    Type '{ num: string; recursive_object: { num: { value: number; }; } & { recursive_object: RecursiveObject; }; }' is not assignable to type 'RecursiveObject'.
      Type '{ num: string; recursive_object: { num: { value: number; }; } & { recursive_object: RecursiveObject; }; }' is not assignable to type '{ num: { value: number; }; }'.
        Types of property 'num' are incompatible.
          Type 'string' is not assignable to type '{ value: number; }'.

32 export const RecursiveObjectSchema: z.ZodType<RecursiveObject> =
                ~~~~~~~~~~~~~~~~~~~~~

```

Live demo: https://codesandbox.io/p/devbox/musing-sanne-mg5hhm",,
2034063148,3035,Can we avoid .nonempty() changing the inferred input type?,"Take below example:

```ts
import { z } from 'zod';

const schema = z.number().array().nonempty();

// expected type to be number[], but instead is [number, ...number[]]
type inputType = z.input<typeof schema>;

// simplified for demo
const formValidation: (userInput: inputType) => boolean = (userInput) => {
  // ....
  return true;
};

// user input of either correct array or incorrect empty array...
const formData: number[] = Math.random() % 2 ? [2] : [];

// this should typecheck, but doesn't because the .nonemtpy() call pollutes the inferred input type.
const isValid = formValidation(formData);
```
Is this a bug? or intentional?

I can imagine zod being intentionally like this, as this behaviour is the one that utilises TS to the limit, but I would expect that this is the opposite of what the usual use case would demand.

Is there some elegant solution to this, that doesn't involve breaking typesafety with multiple schema definitions and/or forced casts especially when the array is actually in a nested zod object schema, so I can't easily just create a simple and a chained .nonemtpy variant?",,
2033448186,3030,cannot figure out how to create a schema from the discriminator key of a discriminated union,"Howdy, all. First off, thanks for the amazing library. We really enjoy using it here at the office.

Context: We'd like to create a Zod schema that represents the set of values used as discriminator keys in a discriminated union.

Given this code:

```js
const Result = z.discriminatedUnion(""status"", [
  z.object({ status: z.literal(""success""), data: z.string() }),
  z.object({ status: z.literal(""failed""), error: z.instanceof(Error) }),
]);

type Result = z.infer<typeof Result>;
```

We'd like to produce a new schema:

```js
const ResultStatus = Result.shape.type // does not compile

type ResultStatus = z.infer<typeof ResultStatus>;
```

There is no `shape` property on the thing returned from a call to `z.discriminatedUnion`. I surely must be doing this wrong.

Thanks in advance!",,
2031547875,3028,`@deprecated` JSDoc not applying to properties after compilation to .d.ts,"The `@deprecated` JSDoc is not applying to properties after compilation to .d.ts

The feature I am trying to take advantage of the `@deprecated` jsdoc annotation. 
1. It works in the same project that you are using it. 
2. It doesn't work if you export it in a library, because it loses the deprecated hinting, even though the annotation is still present in the type declaration.

<details><summary>My example code and setup</summary>
<p>

The original file:
> my-library/index.ts
```ts
export const purchaseDetailValidator = z.object({
  productId: z.string(),
  /** @deprecated use amount instead */
  number: z.number().optional(),
  amount: z.number(),
});

const purchaseDetail = purchaseDetailValidator.parse({
  productId: ""03830-01828"",
  amount: 1,
})

purchaseDetail.number
```

![Screenshot 2023-12-07 at 2 03 52 PM](https://github.com/colinhacks/zod/assets/71348224/2f4ebab3-6359-47c9-8f0c-a89b15cd21aa)

It compiles to:

> dist/index.d.ts
```ts
declare const purchaseDetailValidator: z.ZodObject<{
    productId: z.ZodString;
    /** @deprecated use amount instead */
    number: z.ZodOptional<z.ZodNumber>;
    amount: z.ZodNumber;
}, ""strip"", z.ZodTypeAny, {
    productId: string;
    amount: number;
    number?: number | undefined;
}, {
    productId: string;
    amount: number;
    number?: number | undefined;
}>;

export { purchaseDetailValidator };
```

But it doesn't show up in:

> consumer-project/example.ts
```ts
import { purchaseDetailValidator } from ""@my-library/shared"";

const purchaseDetail = purchaseDetailValidator.parse({
  productId: ""03830-01828"",
  amount: 1,
});
purchaseDetail.number
```
![Screenshot 2023-12-07 at 2 06 17 PM](https://github.com/colinhacks/zod/assets/71348224/04f06b90-0ed1-4d86-81c0-e130111949c2)

### Edit:
My build step is this:
`tsup src/index.ts --format cjs,esm --dts`

and my tsconfig.json is this:
```json
{
  ""compilerOptions"": {
    ""target"": ""es2016"", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    ""module"": ""commonjs"", /* Specify what module code is generated. */
    ""esModuleInterop"": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    ""forceConsistentCasingInFileNames"": true, /* Ensure that casing is correct in imports. */
    ""strict"": true, /* Enable all strict type-checking options. */
    ""skipLibCheck"": true, /* Skip type checking all .d.ts files. */
    ""noUncheckedIndexedAccess"": true,
    ""noEmit"": true,
    ""allowJs"": true,
  }
}
```

</p>
</details> 
",,
2031386211,3026,Bug: .merge changes schema to disallow extra props when importing commonJs build,"The following error occurs when the parser encounters an unexpected property:
`Expected never, received <type - array/string/etc.>`.
In other words, it's as if it has `.strict()`, even though that was never applied.

This happens in the following scenario:
- importing a schema from a commonJs file AND
- performing a `.merge` with that schema THEN
- with the new schema, parsing an object that has extra (unexpected) properties.

This issue can best be explained / understood by looking at the CodeSandbox. The CodeSandbox runs the tests to show which case fails. CodeSandbox: https://codesandbox.io/p/devbox/zod-vite-bug-y2qsc8?file=%2Fsrc%2Ftest.spec.ts

CodeSandbox test file:
```typescript
// baseSchema is a basic `z.object({ property1: z.string() })` that has been compiled to cjs and esm
// using tsup. This build occurs in the CodeSandbox.
import { baseSchema as baseSchemaCjs } from ""../external_package_mock_dist/index.cjs"";
import { baseSchema as baseSchemaEsm } from ""../external_package_mock_dist/index.js"";
import { z } from ""zod"";

it(""imported cjs zod schema parse - no extra properties (PASS)"", () => {
  expect(() =>
    baseSchemaCjs.parse({
      property1: ""1"",
    }),
  ).not.toThrow();
});

it(""imported cjs zod schema parse - extra properties (PASS)"", () => {
  expect(() =>
    baseSchemaCjs.parse({
      property1: ""1"",
      extraProperty: ""str"",
    }),
  ).not.toThrow();
});

it(""imported cjs zod schema merged parse - extra properties (FAIL)"", () => {
  const schema = baseSchemaCjs.merge(
    z.object({
      property2: z.string(),
    }),
  );

  expect(() =>
    schema.parse({
      property1: ""str"",
      property2: ""str"",
      extraProperty: ""str"",
    }),
  ).not.toThrow();
});

it(""imported esm zod schema merged parse - extra properties (PASS)"", () => {
  const schema = baseSchemaEsm.merge(
    z.object({
      property2: z.string(),
    }),
  );

  expect(() =>
    schema.parse({
      property1: ""str"",
      property2: ""str"",
      extraProperty: ""str"",
    }),
  ).not.toThrow();
});

it(""locally created zod schema merged parse - extra properties (PASS)"", () => {
  const baseSchemaLocal = z.object({
    property1: z.string(),
  });
  const schema = baseSchemaLocal.merge(
    z.object({
      property2: z.string(),
    }),
  );

  expect(() =>
    schema.parse({
      property1: ""str"",
      property2: ""str"",
      extraProperty: ""str"",
    }),
  ).not.toThrow();
});
```

**Expected result**

According to the docs, By default Zod object schema strip unknown keys from the output.",,
2031187614,3025,Specific condition on the schema method called transform,"When using the transform method, to exchange the keys of an object after it is validated.
```typescript
const SalesOrderProductSchema = z.object({
  integration_order_code: z.string().max(60),
  order_code: z.number().optional(),
  order_number: z.string().max(15).optional(),
}).transform((data) => ({
  code_pedido_integracao: data.integration_order_code,
  codigo_pedido: data.order_code,
  numero_pedido: data.order_number,
}))
```

At the output of this action, it was expected that the object would have the name of the keys equal to the items that are within the transform method.
however, this does not happen, the object is returning the same as the input object and there is no error occurring.

Is the form presented correct?
Is there any other way to get the expected result? or is it a bug found?",,
2030411420,3024,TypeScript error when pass schema to a function,"I've got an amazing type of error message today. 

```ts
export const timestampToDate = (data: number): Date => {
  const timestamp = new Date(data);
  if (isNaN(timestamp.getTime())) {
    throw new Error('Invalid timestamp');
  }
  return timestamp;
};

export const timestampToDateSchema = z.coerce.number().transform(timestampToDate);
  
  
export const MyUsersSchema = z.array(
  z.object({
    created: timestampToDateSchema,
  }),
);

  async do<T>(data, schema: z.ZodType<T>) {
    return schema.parse(data);
  }
  
const myUsers = MyUsersSchema.parseAsync([]);
const myUsers2 = this.do([], MyUsersSchema);
```

As you can see, both myUsers, and myUsers2 should be typed the same. But Typescript shows an error for myUsers2

```
Argument of type 'ZodArray<ZodObject<{ created: ZodEffects<ZodNumber, Date, number>; }, ""strip"", ZodTypeAny, { created: Date; }, { created: number; }>, ""many"">' is not assignable to parameter of type 'ZodType<{ created: Date; }[], ZodTypeDef, { created: Date; }[]>'.
  Types of property '_input' are incompatible.
    Type '{ created: number; }[]' is not assignable to type '{ created: Date; }[]'.
      Type '{ created: number; }' is not assignable to type '{ created: Date; }'.
        Types of property 'created' are incompatible.
          Type 'number' is not assignable to type 'Date'.
```

So it creates a type, which conflicts with the type itself. 

created has a Date type for ZodType Input, but also it has a number type for Output",,
2029401994,3022,An unsafe `instanceof`,"> Not much I can do about this. Without a public constructor there's no way for TypeScript to validate that the argument to `z.instanceof` is actually a class. 
>
> Here's the workaround (this is what `z.instanceof` does under the hood anyway):
>
> ```ts
> const txSchema = z.custom< TransactionAmount >(arg => arg instanceof TransactionAmount)
> ```

_Originally posted by @colinhacks in https://github.com/colinhacks/zod/issues/1065#issuecomment-1093557684_

---

Typescript allows `instanceof` on anything that implements `NewableFunction`, the constructor type implies that, but it is more restrictive than it needs. In fact if you pass a function with a private constructor and ignores typescript it works.

What could be done is provide a separate `unsafeInstanceOf<T extends NewableFunction>`.

Why make it a new function and call it unsafe instead of changing the existing one?

Because if you pass any class with a protected or private constructor there are cases where TS will reduce the type to any because there is no way to properly refer to ""an instance of this type that has a private constructor"". So it works exactly as anyone would expect, but the type may become any.",,
2023913948,3015,Zod preprocessor ignores default value,"* Use case
I'm trying to get the default value of a preprocessed input.

I tried

```typescript
const test_value = z.preprocess(stringParser, z.string().default(""test_key""));
const parsed_value = test_value.parse(undefined); // => void
```

and 

```typescript
const test_value = z.preprocess(stringParser, z.string().default(""test_key"")).default(""test_key"");
const parsed_value = test_value.parse(undefined); // => void
```

* Current behavior

The default value is not computed and `z.parse` returns nothing

* Expected behavior

Default value should be returned if input couldn't be preprocessed",,
2022269548,3014,"Module '""zod""' has no exported member 'ZodTypeAny'. ts(2305)","```ts
import type { ZodTypeAny } from ""zod"";
```

Causes this TypeScript error:

```
Module '""zod""' has no exported member 'ZodTypeAny'. ts(2305)
```

Any idea why it's doing that? Weird as hell.",,
2018263559,3008,Support single value in enum's `.exclude` & `.extract`,"```ts
const granularitySchema = z.enum([
  'day',
  'week',
  'fortnight',
  'month',
  'quarter',
  'semester',
  'year',
]);
```

Right now I need to always pass an array to these methods even if I just want to exclude/extract 1 value

```ts
const notDaySchema = granularitySchema.exclude(['day']);
const daySchema = granularitySchema.extract(['day']);
```

It would be nice if I could just do

```ts
const notDaySchema = granularitySchema.exclude('day');
const daySchema = granularitySchema.extract('day');
```",,
2018255879,3007,Add docs for enum's `.exclude` & `.extract`,"I was looking for these in the docs but couldn't find them, type hints made me aware of their existence though",,
2016013576,3001,Error with infer when creating zod wrapper (TS2503: Cannot find namespace),"Hi, am I doing something wrong please? The end goal is to wrap zod so I can swap/adjust validator implementations, decorate with custom logging and other functions or methods, etc. I am new to JS/TS. Thanks in advance!

```js
import { z } from 'zod';

const myZ = z;

const SomeSchema = myZ.strictObject( {
	'type': myZ.union( [
		myZ.literal( 'hello' ),
		myZ.literal( 'world' )
	] )
} ); // <=== works

console.log( SomeSchema ); // <=== works

export type SomeType = myZ.infer<typeof SomeSchema>;  // <=== ERROR TS2503: Cannot find namespace 'myZ'
```

Here is my tsconfig.json:

```json
{
    ""include"": [""**/*.ts"", ""**/*.tsx"", ""types/""],
    ""compilerOptions"": {
        ""target"": ""ES6"",
        ""moduleResolution"": ""node"",
        ""strict"": true,
        ""jsx"": ""react-jsx"",
        ""esModuleInterop"": true,
        ""plugins"": [{ ""name"": ""typescript-plugin-css-modules"" }]
    }
}
```",,
2015160332,2999,Add a sub-code for Zod custom issue,"### Discussed in https://github.com/colinhacks/zod/discussions/2997

There are many zod standard errors, and just one single custom.

Adding a sub-code to custom errors would allow the users to extend the custom error and have their codes as well.

Like when a model defines a password form (where a user enters a new password twice - see details in the [discussion](https://github.com/colinhacks/zod/discussions/2997)) the custom errors for a `password-mismatch` is different from `password-complexity`. Why would these be squeezed into a single custom category?

In the discussion we came to the conclusion that it would be helpfull to have sub-codes in custom errors, in particular for i18n.

Something like that:

```typescript
export interface ZodCustomIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.custom;
  subCode?: string;          // <<<==== add this
  params?: { [k: string]: any };
}
```

This seems like a trivial change. I could try a PR if you like the proposal.
",,
2015083835,2998,`z.discriminatedUnion` does not work when key is `constructor`,"The same issue applies for other keys on `object` too:
```ts
interface Object {
    constructor: Function;
    toString(): string;
    toLocaleString(): string;
    valueOf(): Object;
    hasOwnProperty(v: PropertyKey): boolean;
    isPrototypeOf(v: Object): boolean;
    propertyIsEnumerable(v: PropertyKey): boolean;
}
```

A working fix is to add the keys as optional keys on `ZodRawShape`:
```ts
type ZodRawShape = { [k: string]: ZodTypeAny; constructor?: ZodTypeAny }
```

[TS Playground repro](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQAxhAHYDO8A7gBYCG8AvCgHTHD0qUUMFocApsQCqtYHQAU+GgxhQArlRjR8AGjgBtCnGO8IAIwBW4zfKTLG6zdABcvADbAY4qGzeK2+ACU6IE6RibIPOZWNnZ0DhpaUK6RHl4+fvhmQSFhALqB1PHM7DAATHDckfyCwiCiEtKyCvhaAMqqogDmugbhxpHR1jC2cO2dtF0pPGnevv45aKH9ppbDo+PCk9OzGYrZwUv5gUA)

Unfortunately `ZodRawShape` is `type { [k: string]: ZodTypeAny };`, rather than an interface, so this cannot be fixed in userspace by declaration-merging",,
2012531221,2996,Regression: z.refine type inside z.object returns (RefineType) & (RefineType | undefined),"Seems related to https://github.com/colinhacks/zod/issues/2203 (and others), but I haven't seen anyone mention this issue with `refine`.

This happens in **3.22.0** and worked fine in **3.21.0**.

```ts
const customIdSchema = z
  .string()
  .refine((value): value is `${number}` | `c${number}` =>
    /^c?\d+$/.test(value)
  );

const myObjectSchema = z.object({
  id: customIdSchema,
});

type MyObject = z.infer<typeof myObjectSchema>;

// Result
// {
//    id: (`${number}` | `c${number}`) & (`${number}` | `c${number}` | undefined);
// }

// Expected
// {
//    id: `${number}` | `c${number}`;
// }
```",,
2011102508,2994,Schema Object Contains Optional Properties,"I'm confused about the return type when creating a schema. For example, here is my schema:

```typescript
export const AuthorSchema = z
  .object({
    firstName: z.string().min(2),
    lastName: z.string().min(2),
  })
  .required();
```

This is the return type of `AuthorSchema`:

```typescript
const AuthorSchema: z.ZodObject<{
    firstName: z.ZodString;
    lastName: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
    firstName?: string;
    lastName?: string;
}, {
    firstName?: string;
    lastName?: string;
}>
```
I don't want these properties to be optional, they are required. Inferring the type has this result:

`export type CreateAuthorDto = z.infer<typeof AuthorSchema>;`

```typescript
type CreateAuthorDto = {
    firstName?: string;
    lastName?: string;
}
```

My expectation is that it looks like this:
```typescript
type CreateAuthorDto = {
    firstName: string;
    lastName: string;
}
```

I'm obviously missing something, but haven't been able to track down what.
",,
2010559160,2991,TypeError: _missingExportShim is not a function at ZodSchema.getJsonSchema,"Following code taken from example and adopted to Deno https://github.com/lgrammel/modelfusion/blob/main/examples/middle-school-math-agent/src/MiddleSchoolMathOpenAITools.ts

```
const apiKey = Deno.env.get('OPENAI_API_KEY')

const input = { text: 'solve this' }

MathAgent();

async function MathAgent() {
  const { text: problem } = input;

  const { OpenAIApiConfiguration, OpenAIChatMessage, openai, useToolsOrGenerateText, Tool, ZodSchema } = await import(""https://dev.jspm.io/modelfusion"");
  const { z } = await import(""https://dev.jspm.io/zod"");

  const calculator = new Tool({
    name: ""calculator"",
    description: ""Execute a calculation"",

    parameters: new ZodSchema(
      z.object({
        a: z.number().describe(""The first number.""),
        b: z.number().describe(""The second number.""),
        operator: z.enum([""+"", ""-"", ""*"", ""/""]).describe(""The operator.""),
      })
    ),

    execute: async ({ a, b, operator }) => {
      switch (operator) {
        case ""+"":
          return a + b;
        case ""-"":
          return a - b;
        case ""*"":
          return a * b;
        case ""/"":
          return a / b;
        default:
          throw new Error(`Unknown operator: ${operator}`);
      }
    },
  });

  const messages = [
    OpenAIChatMessage.system(
      ""You are solving math problems. "" +
      ""Reason step by step. "" +
      ""Use the calculator when necessary. "" +
      ""The calculator can only do simple additions, subtractions, multiplications, and divisions. "" +
      ""When you give the final answer, provide an explanation for how you got it.""
    ),
    OpenAIChatMessage.user(problem),
  ];

  console.log(`PROBLEM: ${problem}\n`);

  const { text, toolResults } = await useToolsOrGenerateText(
    openai.ChatTextGenerator({
      api: new OpenAIApiConfiguration({ apiKey }),
      model: ""gpt-4-1106-preview"",
      temperature: 0,
      maxCompletionTokens: 500,
    }),
    [calculator],
    messages
  );

}
```

And probably the error is triggered when running around here https://github.com/lgrammel/modelfusion/blob/61562b19863b8ad7c990a0af920a93dc94594941/src/tool/generate-tool-calls-or-text/generateToolCallsOrText.ts#L139C45-L139C53

```
OPENAI_API_KEY=$(cat .openai-key) deno run --allow-all nov25-third.ts
PROBLEM: solve this

error: Uncaught (in promise) TypeError: _missingExportShim is not a function
        return _missingExportShim(this.zodSchema);
               ^
    at ZodSchema.getJsonSchema (https://dev.jspm.io/npm:modelfusion@0.80.0/_/EQpO4pnp.js:79:16)
    at https://dev.jspm.io/npm:modelfusion@0.80.0:7555:49
    at Array.map (<anonymous>)
    at OpenAIChatModel.doGenerateToolCallsOrText (https://dev.jspm.io/npm:modelfusion@0.80.0:7550:26)
```",,
2008882755,2986,Throw own exception in catch block of Zod objects,"Instead of returning a value in a catch block, I'd rather throw my own exception.

Right now doing this would result in the `z.ZodCatch` type being assigned as a wrapper.

Ex:

```ts
export const IdField = z
    .string()
    .uuid()
    .readonly()
    .catch((ctx): string => {
        throw new InvalidIdError('v4', ctx.input);
    });
```

Although this works by itself, when using `z.merge` later on, this breaks in the input field of the context of another object.


```ts
const MyObject = z
    .object({
        id: IdField,
        name: z.string(),
    })
    .catch((ctx) => {
         throw new InvalidObjectError(ctx.input.id); <-- id is unknown
    })
```

Is there anyway we can do this in Zod?

IMO this is because ZodCatch doesn't extend ZodObject so we can't chain them together :(
",,
2004713406,2983,"[Expo][Web][Metro] Unable to resolve ""zod""","I am having an issue with compiling `zod` under expo web project using metro bundler. 
However it works on mobile within the same repository.
This is a completely new project so it utilizes the latest versions of all libraries.



The only error that I can see is this error which metro throws.
I couldn't find any other related logs so if you have idea how I can find that please guide me.

<img width=""405"" alt=""Screenshot 2023-11-21 at 17 31 47"" src=""https://github.com/colinhacks/zod/assets/18654447/8d7d18cf-3310-4a4c-a1e6-dd566b229b84"">

The error that I can see in browser actually doesn't say much and most likely comes from lack of properly bundled package.
<img width=""944"" alt=""Screenshot 2023-11-21 at 17 32 53"" src=""https://github.com/colinhacks/zod/assets/18654447/b01a600b-c4cf-4574-96dd-6af1be1f6c1e"">



tsconfig:

```{
  ""extends"": ""expo/tsconfig.base"",
  ""compilerOptions"": {
    ""strict"": true,
    ""baseUrl"": ""./src"",
    ""paths"": {
      ""@/*"": [""*""]
    },
    ""skipLibCheck"": true
  },
  ""include"": [""**/*.ts"", ""**/*.tsx"", "".expo/types/**/*.ts"", ""expo-env.d.ts""]
}
```


babel.config.js

```
module.exports = function (api) {
  api.cache(true);

  return {
    presets: [""babel-preset-expo""],
    plugins: [
      ""expo-router/babel"",

      // optional, only if you ever use process.env
      ""transform-inline-environment-variables"",
      // NOTE: this is optional, you don't *need* the compiler
      [
        ""@tamagui/babel-plugin"",
        {
          components: [""tamagui""],
          config: ""./tamagui.config.ts"",
          logTimings: true,
          // @TODO: disable on production
          disableExtraction: true,
        },
      ],
      // NOTE: this is only necessary if you are using reanimated for animations
      ""react-native-reanimated/plugin"",
    ],
  };
};
```
",,
1999503449,2975,Cannot figure how to work with existing types ZodType,"```
export const oidcSchema: z.ZodType<{ client_id: string, issuer: string}> = z.object({
  client_id: z.string(),
  issuer: z.string().url(),
});
```

```
Property 'client_id' is optional in type '{ client_id?: string; issuer?: string; }' but required in type '{ client_id: string; issuer: string; }'
```

What am I doing wrong?",,
1995759828,2970,Zod schema validation with union fails when schema has missing fields,"I'm having some a hard time understanding why my schema with union is failing.

Here's the schema: 
```ts
export const reportFormSchema = () => {
  const { validator } = reportTemplateNameValidator();

  const fieldSchema = z.object({
    id: z.nativeEnum(ReportFieldName),
    content: z.string().min(1),
    isTransferDisabled: z.boolean().optional(),
    isIndicator: z.boolean()
  });

  const reportFormSchemaBase = z.object({
    direction: z.nativeEnum(ReportDirection),
    format: z.nativeEnum(ReportFormat),
    type: z.nativeEnum(ReportType),
    fields: z
      .array(fieldSchema)
      .refine((items) => items.some((item) => item.isIndicator)),
    daysBeforeDepartures: z.array(z.string())
  });

  const reportTemplateFormSchema = reportFormSchemaBase.extend({
    name: z.string().trim().refine(validator, {
      message: ""nameAlreadyExists""
    }),
    mode: z.literal(FORM_MODE.REPORT_TEMPLATE),
    scopeCode: z.undefined()
  });

  const reportGenerateFormSchema = reportFormSchemaBase.extend({
    name: z.string().trim().min(1, { message: ""fieldRequired"" }),
    mode: z.literal(FORM_MODE.REPORT_GENERATE),
    scopeCode: z.string().min(1)
  });

  return z
    .union([reportTemplateFormSchema, reportGenerateFormSchema])
    .refine((formData) =>
      formData.type === ReportType.OD_CLASS_DBD ||
      formData.type === ReportType.LEG_CLASS_DBD
        ? formData.daysBeforeDepartures.length > 0
        : formData.daysBeforeDepartures.length === 0
    );
};

export type ReportFormSchema = z.infer<ReturnType<typeof reportFormSchema>>;
```

I want `scopeCode` to be a `string` when in `FORM_MODE.REPORT_GENERATE` and `undefined` when in `FORM_MODE.REPORT_TEMPLATE`, however, when I try to parse this data:
```ts
const result = reportFormSchema();
    const parseResult = result.safeParse({
      scopeCode: ""SC0000000432"",
      mode: FORM_MODE.REPORT_GENERATE,
      daysBeforeDepartures: [],
    });
```
My test fails, which is expected since there are missing fields, however, `scopeCode` should not be on error since it is not `undefined` and I'm in `mode:  FORM_MODE.REPORT_GENERATE`, here's the error on field `scopeCode:
```ts
{
  ""code"": ""invalid_type"",
  ""expected"": ""undefined"",
  ""received"": ""string"",
  ""path"": [
    ""scopeCode""
  ],
  ""message"": ""Expected undefined, received string""
}
```
What's even stranger is that I get this error too:
```ts
{
  received: 'reportGenerate',
  code: 'invalid_literal',
  expected: 'reportTemplate',
  path: ['mode'],
  message: 'Invalid literal value, expected ""reportTemplate""',
},
```
I'm not sure why I'm getting this error and I suspect that's why I'm getting the error on `scopeCode`.

When validating the schema with all the required data, the test passes and `scopeCode` isn't on error anymore.
```ts
const result = reportFormSchema();
    const parseResult = result.safeParse({
    direction: ReportDirection.BY_COLUMN,
    format: ReportFormat.XLSX,
    type: ReportType.WEEK_AGGR,
    name: ""test"",
    fields: [
      {
        id: ReportFieldName.DEPARTURE_DATE,
        content: ""Operator"",
        isTransferDisabled: false,
        isIndicator: true,

      {
        id: ReportFieldName.DEPARTURE_WEEK,
        content: ""Departure Date"",
        isTransferDisabled: false,
        isIndicator: false,
      },
    ],
      scopeCode: ""SC0000000432"",
      mode: FORM_MODE.REPORT_GENERATE,
      daysBeforeDepartures: [],
    });
```
I dont know what I'm doing wrong, from my understanding of how `union` works in Zod, the schema should be working.

I've created a [codesandbox](https://codesandbox.io/p/sandbox/blissful-rui-52hx66?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cloziuxm800073b6hbmdtfarm%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cloziuxm800033b6ha3ld1hnk%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cloziuxm800053b6hvjo15gfs%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cloziuxm800063b6hum4d05m0%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B81.36440013442366%252C18.63559986557634%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cloziuxm800033b6ha3ld1hnk%2522%253A%257B%2522id%2522%253A%2522cloziuxm800033b6ha3ld1hnk%2522%252C%2522activeTabId%2522%253A%2522clozj74u101gl3b6hng9icvjf%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cloziuxm800023b6hdfll1qbt%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Ftsconfig.json%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fjest.config.ts%2522%252C%2522id%2522%253A%2522clozixax400ae3b6h4hoz6izq%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522clozj2xzu00n13b6hqi40tqie%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.test.ts%2522%252C%2522id%2522%253A%2522clozj74u101gl3b6hng9icvjf%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%257D%252C%2522cloziuxm800063b6hum4d05m0%2522%253A%257B%2522id%2522%253A%2522cloziuxm800063b6hum4d05m0%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cloziuxm800053b6hvjo15gfs%2522%253A%257B%2522id%2522%253A%2522cloziuxm800053b6hvjo15gfs%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cloziuxm800043b6hiz1mj1h2%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TERMINAL%2522%252C%2522shellId%2522%253A%2522cloziuxqe0009efd97phg3lq4%2522%257D%255D%252C%2522activeTabId%2522%253A%2522cloziuxm800043b6hiz1mj1h2%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D) with the schema and some testes, the one failing is `'should return a VALID SCHEMA object when report in ""reportGenerate"" mode and only ""scopeCode"" and ""daysBeforeDepartures""'`

Any help would be appreciated.",,
1994652411,2967,"Using a (big) enum in a type predicate for `refine` causes ""Expression produces a union type that is too complex to represent"" error and type predicate not taken in account (`3.21.2`-`3.22.5` only)","Hello!

I'm using the following schema to represent something that is ""likely enum"" so to speak (where `Enum` is an arbitrary TypeScript numeric non-const enum):

```ts
const EnumZod = z.number().int().refine((v): v is Enum | (number & {}) => true);
```

This makes TypeScript to show a bit more useful type than just `number`:

![2023-11-15 14_45_59-zod-big-enum-error - playground ts](https://github.com/colinhacks/zod/assets/6554045/e69c5a46-07e8-47e8-9a2b-6acde9831620)

After deciding to update zod from `3.20.2` to the latest version as of time I'm writing this (`3.22.4`), `z.infer` started to remove `Enum` part of the type, but **only if this schema is used within `z.object`**:

```ts
const Schema = z.object({
  a: z.object({
    b: EnumZod,
  }),
  c: EnumZod,
});
```

![2023-11-15 14_51_49-● zod-big-enum-error - playground ts](https://github.com/colinhacks/zod/assets/6554045/660b99a3-8f4b-42f7-a00e-3c245fdedcec)

Moreover, if the enum contains more than 314 members (~related to Pi? :D~) AND the enum schema is used in a **nested** `z.object`, it's not even allowing to have such a schema:

![2023-11-15 14_55_46-● zod-big-enum-error - playground ts](https://github.com/colinhacks/zod/assets/6554045/8e24ce55-9227-4f3c-b497-fe287d89d5e4)

If I remove `a` member of `Schema`, the error will move to `z.infer`:

![2023-11-15 14_59_54-zod-big-enum-error - playground ts](https://github.com/colinhacks/zod/assets/6554045/5e36df55-2f40-4f16-89c4-2804ecb91470)

---

The exact version after which this behaviour began to be observed is `3.21.2`: https://github.com/colinhacks/zod/compare/v3.21.1...v3.21.2

",,
1994091625,2966,Incorrect Type Inference for Non-Optional Field with z.unknown(),"I encountered an unexpected behavior in Zod's type inference system when using z.unknown(). The issue arises when defining an object schema with a field that should be required, but the inferred TypeScript type incorrectly marks it as optional.

```typescript
import { z } from 'zod';

const test = z.object({
  shouldExist: z.unknown(),
});
type Test = z.infer<typeof test>;
// Expected: { shouldExist: unknown }
// Actual: { shouldExist?: unknown } (Incorrect, field should not be optional)
```

**Expected Behavior:**
The expected behavior is for the type Test to be inferred as { shouldExist: unknown }, indicating that shouldExist is a required field of unknown type.

**Actual Behavior:**
The actual inferred type is { shouldExist?: unknown }, incorrectly suggesting that the shouldExist field is optional.


",,
1993177318,2965,Problems while parsing the models when consuming prisma-generated zod models for typescript : 'You may need an additional loader to handle the result of these loaders',"My issue is that I'm generating the zod models in the backend using the generator **zod-prisma** (link to the project here [here](https://github.com/CarterGrimmeisen/zod-prisma)), till here all good the types are working in the backend without problem. 
At this point I create a symbolic link between the folder in which i generate the types and from the frontend. 
Here things that to not work anymore and I'm getting this:

> ERROR in ../backend/src/db_types/listinoarticolo.ts 16:7
> Module parse failed: Unexpected token (16:7)
> File was processed with these loaders:
 > ./node_modules/@pmmmwh/react-refresh-webpack-plugin/loader/index.js
 > ./node_modules/source-map-loader/dist/cjs.js
 > You may need an additional loader to handle the result of these loaders. 
 
 > export interface MyModel extends z.infer<typeof AnotherModel> {
    .....
webpack compiled with 1 error `

Do you ever encounter any problem like this? I feel that the symbolic link is breaking something.
For reference:

Ract: 18.2.0
Zod: 3.22.4 (both frontend and backend) 

## UPDATE:

By copying the models folder instead of using a symbolic link solved the problem and so I start to think that is something related to CRA and the fact that is kind of outside the directory and so i created a config-override.js to solve this problem but still the problem persist with the symbolic link.



",,
1992579369,2964,Discrepancy between inferred type and z.ZodType when default() is used,"Given a type and a matching schema

```ts
type DurationRecord = {
  hours?: number | undefined;
  minutes: number;
};

const DurationRecordSchema: z.ZodType<DurationRecord> = z.object({
  hours: z.number().optional(),
  minutes: z.number().default(0),
}); 
```

I would expect no error, but instead I get the following typescript error:

```
Type 'ZodObject<{ hours: ZodOptional<ZodNumber>; minutes: ZodDefault<ZodNumber>; }, ""strip"", ZodTypeAny, { minutes: number; hours?: number | undefined; }, { ...; }>' is not assignable to type 'ZodType<DurationRecord, ZodTypeDef, DurationRecord>'.
  The types of '_input.minutes' are incompatible between these types.
    Type 'number | undefined' is not assignable to type 'number'.
      Type 'undefined' is not assignable to type 'number'.ts(2322)
```

If we instead infer the type from the schema, we get what *seems* to be the same type:

![image](https://github.com/colinhacks/zod/assets/434495/88950b4b-52d0-4014-be67-f8bc186e9fad)
",,
1992060423,2962,zod > 3.22.2 causes `JavaScript heap out of memory` when running `tsc`,"Versions:

nodejs: 18.17.0
typescript: 5.2.2

We get the following error when updating zod to 3.22.3 or 3.22.4 and running `tsc`:

```
$ tsc

<--- Last few GCs --->

[17523:0x160078000]    93868 ms: Scavenge 4044.0 (4128.4) -> 4036.7 (4128.9) MB, 4.5 / 0.0 ms  (average mu = 0.770, current mu = 0.506) allocation failure; 
[17523:0x160078000]    93875 ms: Scavenge 4044.2 (4128.9) -> 4037.0 (4129.4) MB, 4.5 / 0.0 ms  (average mu = 0.770, current mu = 0.506) allocation failure; 
[17523:0x160078000]    93882 ms: Scavenge 4044.5 (4129.4) -> 4037.3 (4145.4) MB, 4.7 / 0.0 ms  (average mu = 0.770, current mu = 0.506) allocation failure; 


<--- JS stacktrace --->

FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory
 1: 0x1009666e4 node::Abort() [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 2: 0x1009668c8 node::ModifyCodeGenerationFromStrings(v8::Local<v8::Context>, v8::Local<v8::Value>, bool) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 3: 0x100abd60c v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 4: 0x100c67ec4 v8::internal::EmbedderStackStateScope::EmbedderStackStateScope(v8::internal::Heap*, v8::internal::EmbedderStackStateScope::Origin, cppgc::EmbedderStackState) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 5: 0x100c6686c v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 6: 0x100c5a900 v8::internal::HeapAllocator::AllocateRawWithLightRetrySlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 7: 0x100c5b144 v8::internal::HeapAllocator::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 8: 0x100c410c4 v8::internal::Factory::NewFillerObject(int, v8::internal::AllocationAlignment, v8::internal::AllocationType, v8::internal::AllocationOrigin) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 9: 0x100fe16c0 v8::internal::Runtime_AllocateInYoungGeneration(int, unsigned long*, v8::internal::Isolate*) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
10: 0x10133104c Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
11: 0x1067ae514 
12: 0x106ed0fe8 
13: 0x106816574 
14: 0x106256010 
15: 0x106d26c70 
16: 0x106d0de3c 
17: 0x1070b89ac 
18: 0x106fb472c 
19: 0x106d295e8 
20: 0x106fd9008 
21: 0x106257c18 
22: 0x106d29538 
23: 0x106fd9008 
24: 0x106257c18 
25: 0x1070b96c8 
26: 0x106fb472c 
27: 0x106d295e8 
28: 0x106fd9008 
29: 0x106257c18 
30: 0x106d29538 
31: 0x106fd9008 
32: 0x106257c18 
33: 0x1070b96c8 
34: 0x106fb472c 
35: 0x106d295e8 
36: 0x106fd9008 
37: 0x106257c18 
38: 0x106d29538 
39: 0x106fd9008 
40: 0x106257c18 
41: 0x1070b96c8 
42: 0x106fb472c 
43: 0x106d295e8 
44: 0x106fd9008 
45: 0x106257c18 
46: 0x106d29538 
47: 0x106fd9008 
48: 0x106257c18 
49: 0x1070b96c8 
50: 0x106fb472c 
51: 0x106d295e8 
52: 0x106fd9008 
53: 0x106257c18 
54: 0x106d29538 
55: 0x106fd9008 
56: 0x106257c18 
57: 0x1070b96c8 
58: 0x106fb472c 
59: 0x106d295e8 
60: 0x106fd9008 
61: 0x106257c18 
62: 0x106d29538 
63: 0x106fd9008 
64: 0x106257c18 
65: 0x1070b96c8 
66: 0x106fb472c 
67: 0x106d295e8 
68: 0x106fd9008 
69: 0x106257c18 
70: 0x106d29258 
71: 0x106fd9008 
72: 0x106257c18 
73: 0x1070b96c8 
74: 0x106fb472c 
75: 0x106d295e8 
76: 0x106fd9008 
77: 0x106257c18 
78: 0x106d29538 
79: 0x106fd9008 
80: 0x106257c18 
81: 0x1070b96c8 
82: 0x106fb472c 
83: 0x106d295e8 
84: 0x106fd9008 
85: 0x106257c18 
86: 0x106d29538 
87: 0x106fd9008 
88: 0x106257c18 
89: 0x1070b96c8 
90: 0x106fb472c 
91: 0x106d295e8 
92: 0x106fd9008 
93: 0x106257c18 
94: 0x106d29538 
95: 0x106fd9008 
96: 0x106257c18 
97: 0x1070b96c8 
98: 0x106fb472c 
99: 0x106d295e8 
100: 0x106fd9008 
101: 0x106257c18 
102: 0x106d29538 
103: 0x106fd9008 
104: 0x106257c18 
105: 0x106d29538 
106: 0x106fd9008 
107: 0x106257c18 
108: 0x1070b96c8 
109: 0x106fb472c 
110: 0x106d295e8 
111: 0x106fd9008 
112: 0x106257c18 
113: 0x106d29258 
114: 0x106fd9008 
115: 0x106257c18 
116: 0x1070b96c8 
117: 0x106fb472c 
118: 0x106d295e8 
119: 0x106fd9008 
120: 0x106257c18 
121: 0x106d29258 
122: 0x106fd9008 
123: 0x106257c18 
124: 0x106993134 
125: 0x106257f30 
126: 0x106258058 
127: 0x106d29538 
128: 0x106fd9008 
129: 0x106257c18 
130: 0x106993134 
131: 0x106257f30 
132: 0x106d0ed60 
133: 0x106d29814 
134: 0x106fd9008 
135: 0x106257c18 
136: 0x106816618 
137: 0x106256130 
138: 0x1070b96c8 
139: 0x106fb472c 
140: 0x106d295e8 
141: 0x106fd9008 
142: 0x106257c18 
143: 0x106d29258 
144: 0x106fd9008 
145: 0x106257c18 
146: 0x10695fdd0 
147: 0x1070b77f4 
148: 0x106ee448c 
149: 0x1069a7c28 
150: 0x1069886e0 
151: 0x10681a4b0 
152: 0x106771878 
153: 0x10672afa0 
154: 0x10672046c 
155: 0x10680adb8 
156: 0x107089c98 
157: 0x106732df0 
158: 0x1067619d4 
159: 0x10676530c 
160: 0x10672ae84 
161: 0x10672046c 
162: 0x10680adb8 
163: 0x107089c98 
164: 0x10676eec4 
165: 0x10698a254 
166: 0x10681a4b0 
167: 0x106771878 
168: 0x10672afa0 
169: 0x10672046c 
170: 0x10680adb8 
171: 0x107089c98 
172: 0x106732df0 
173: 0x1067619d4 
174: 0x10676530c 
175: 0x10672ae84 
176: 0x10672046c 
177: 0x10680adb8 
178: 0x107089c98 
179: 0x10676eec4 
180: 0x10698a254 
181: 0x10681a4b0 
182: 0x106771878 
183: 0x10672afa0 
184: 0x10672046c 
185: 0x10680adb8 
186: 0x107089c98 
187: 0x106732df0 
188: 0x1067619d4 
189: 0x10676530c 
190: 0x10672ae84 
191: 0x10672046c 
192: 0x10680adb8 
193: 0x107089c98 
194: 0x10676eec4 
195: 0x10698a254 
196: 0x10681a4b0 
197: 0x106771878 
198: 0x10672afa0 
199: 0x10672046c 
200: 0x10680adb8 
201: 0x107089c98 
202: 0x106732df0 
203: 0x1067619d4 
204: 0x10676530c 
205: 0x10672ae84 
206: 0x10672046c 
207: 0x10680adb8 
208: 0x107089c98 
209: 0x10676eec4 
210: 0x10698a254 
211: 0x10681a4b0 
212: 0x106771878 
213: 0x10672afa0 
214: 0x10672046c 
215: 0x10680adb8 
216: 0x107089c98 
217: 0x106732df0 
218: 0x1067619d4 
219: 0x10676530c 
220: 0x10672ae84 
221: 0x10672046c 
222: 0x10680adb8 
223: 0x107089c98 
224: 0x10676eec4 
225: 0x10698a254 
226: 0x10681a4b0 
227: 0x106771878 
228: 0x10672afa0 
229: 0x10672046c 
230: 0x10680adb8 
231: 0x107089c98 
232: 0x106732df0 
233: 0x1067619d4 
234: 0x10676530c 
235: 0x10672ae84 
236: 0x10672046c 
237: 0x10680adb8 
238: 0x107089c98 
239: 0x10676eec4 
240: 0x10698a254 
241: 0x10681a4b0 
242: 0x106771878 
243: 0x10672afa0 
244: 0x10672046c 
245: 0x10680adb8 
246: 0x107089c98 
247: 0x106732df0 
248: 0x1067619d4 
249: 0x10676530c 
250: 0x10672ae84 
251: 0x10672046c 
252: 0x10680adb8 
253: 0x107089c98 
254: 0x10676eec4 
255: 0x10698a254 
[1]    17523 abort      tsc
```

I'm happy to add more information if someone tells me what to look for. Our project is fairly big. I have no idea which part might cause this.

Any help appreciated!",,
1991270683,2960,z.string().cuid2() validator doesn't conform to the upstream format,"Regex which is defined for cuid2 format validation doesn't conform to the one defined in the cuid2 library itself. 
It bothers me as i can't use this validator with ids generated by this elixir implementation of cuid2: https://github.com/joseph-lozano/cuid2

Said regex in the zod codebase:
https://github.com/colinhacks/zod/blob/master/src/types.ts#L549

Regex in the upstream cuid2 codebase:
https://github.com/paralleldrive/cuid2/blob/main/src/index.js#L105
",,
1989245828,2957,ZodError[] doesn't contain error from `refine()` or `superRefine()`,"Hi there ✌🏾,

Basically, I have set up my schema for `products` with a few custom error messages and a `superRefine()` to throw an error if the `comparedAt` price is lower than the actual `price`. I use `safeParse()` to do the validation and get the errors.

Everything is working fine until I have 2 errors not coming from the `superRefine()` AND the one coming from the `superRefine()`.
In that case, the error coming from `superRefine()` won't show up in the `ZodError[]`. I have tried the `refine()` and `superRefine()` ways, both lead to the same outcome.

Take a look at the logging of the errors (don't pay attention to the double rendering):

![image](https://github.com/colinhacks/zod/assets/77295465/18cc6892-0ac5-4611-9ba0-d361298f2bf0)

**1st step:** I have only 2 errors, both not coming from `superRefine()`

**2nd step:** I add another not-from `superRefine()` error to make sure that the `ZodError[]` is actually able to contain more than 2 errors.

**3rd step:** I add the `superRefine()` error. I had to solve the `price` error to make it higher than the `comparedAt` price. That's why the `price` error isn't present anymore, but the `comparedAt` one should be there.

**4th step:** I solve the `name` error and only then the `superRefine()` error shows up.

**5th step:** I add the `name` error again and the `superRefine()` one disappears from the `ZodError[]` whereas it is still invalid.

Here's my schema:

```typescript
export const ZodProduct = z
  .object({
    name: z.string({required_error: 'Please, set a name.'}).min(1),
    images: z.object({
      mainImage: z.string().min(1, 'Please, set a main image.'),
      secondaryImages: z.array(z.string().min(1)).optional(),
    }),
    price: z
      .number({required_error: 'Please, set a price.'})
      .min(0, 'The price cannot be negative.'),
    comparedAt: z.number().min(0, 'The compared price cannot be negative.'),
    weight: z.number().min(0),
    width: z.number().min(0),
    height: z.number().min(0),
    length: z.number().min(0),
    sku: z.string().min(1),
  })
  .partial({
    comparedAt: true,
    weight: true,
    width: true,
    height: true,
    length: true,
    sku: true,
  })
  .superRefine((data, ctx) => {
    if (data.comparedAt && data.comparedAt <= data.price) {
      ctx.addIssue({
        type: 'number',
        code: 'too_small',
        minimum: data.price,
        inclusive: false,
        path: ['comparedAt'],
        message: 'The compared price should be higher than the actual one.',
      })
    }
  })",,
1988325515,2953,zod OR doesn't work as expected when parsing.,"**Link to Repl**: https://replit.com/@jarrodmedrano/zod-Or-bug-Optional#index.ts

I have two types, animal and person. Animal species is optional.

```ts
const personResult = z.object({
  name: z.string()
});

// when species optional, result gives nothing {}
const animalResult = z.object({
  species: z.string().optional(),
});

// when species is not optional, result will be correct
const animalResultWorks = z.object({
  species: z.string(),
});

```
When you parse them...
```ts
const aPerson = {
  name: ""Jerry""
}

const animalorPerson = z.object({
  something: animalResult.or(personResult).optional(),
}).optional();

const parsed = animalorPerson.safeParse({
  something: aPerson
}); 
```
You will get this result:
```ts
 { success: true, data: { something: {} } }
 ```

What it should be:
```ts
{
  success: true,
  data: { something: { name: 'Jerry' } }
}
```

You will get the correct result if you take the 'optional' off of species.
You will get the correct result if you reverse the order of the .or operation
if Species is optional and aPerson contains something totally invalid, you won't see any error message.
",,
1987532407,2952,Built-in support for GeoJSON data,"Example:
```ts
import { z, object, number, literal } from 'zod';

/**
 * A Position is an array of coordinates.
 * https://tools.ietf.org/html/rfc7946#section-3.1.1
 * Array should contain between two and three elements.
 * The previous GeoJSON specification allowed more elements (e.g., which could be used to represent M values),
 * but the current specification only allows X, Y, and (optionally) Z to be defined.
 */
export const GeoJsonPositionSchema = number().array();
export type GeoJsonPosition = z.infer<typeof GeoJsonPositionSchema>; // [number, number] | [number, number, number];

/**
 * Point geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.2
 */
export const GeoJsonPointSchema = object({
	type: literal('Point'),
	coordinates: GeoJsonPositionSchema,
});
export type GeoJsonPoint = z.infer<typeof GeoJsonPointSchema>;

/**
 * MultiPoint geometry object.
 *  https://tools.ietf.org/html/rfc7946#section-3.1.3
 */
export const GeoJsonMultiPointSchema = object({
	type: literal('MultiPoint'),
	coordinates: GeoJsonPositionSchema.array(),
});
export type GeoJsonMultiPoint = z.infer<typeof GeoJsonMultiPointSchema>;

/**
 * LineString geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.4
 */
export const GeoJsonLineStringSchema = object({
	type: literal('LineString'),
	coordinates: GeoJsonPositionSchema.array(),
});
export type GeoJsonLineString = z.infer<typeof GeoJsonLineStringSchema>;

/**
 * MultiLineString geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.5
 */
export const GeoJsonMultiLineStringSchem = object({
	type: literal('MultiLineString'),
	coordinates: GeoJsonPositionSchema.array().array(),
});
export type GeoJsonMultiLineString = z.infer<typeof GeoJsonMultiLineStringSchem>;

/**
 * Polygon geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.6
 */
export const GeoJsonPolygonSchema = object({
	type: literal('Polygon'),
	coordinates: GeoJsonPositionSchema.array().array(),
});
export type GeoJsonPolygon = z.infer<typeof GeoJsonPolygonSchema>;

/**
 * MultiPolygon geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.7
 */
export const GeoJsonMultiPolygonSchema = object({
	type: literal('MultiPolygon'),
	coordinates: GeoJsonPositionSchema.array().array().array(),
});
export type GeoJsonMultiPolygon = z.infer<typeof GeoJsonMultiPolygonSchema>;

// The same for Geometry, GeometryCollection, GeoJsonProperties, Feature, FeatureCollection, etc.
```

GeoJSON types: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/geojson/index.d.ts
GeoJSON specification: https://datatracker.ietf.org/doc/html/rfc7946",,
1984770572,2947,"Simple fix to setErrorMap not working as expected, and be able to Translate error messages","Context:

z.setErrorMap let us define a function that will be called after have found an error and modify the final response. This could allow us to create localized messages for different languages, but the result of this function is getting overwritten with the error message defined on the schema, and is not working properly.

The problem is on the function makeIssue that prioritize the issueData message over the error returned from the error map.

```
export const makeIssue = (params: {
  data: any;
  path: (string | number)[];
  errorMaps: ZodErrorMap[];
  issueData: IssueData;
}): ZodIssue => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...(issueData.path || [])];
  const fullIssue = {
    ...issueData,
    path: fullPath,
  };

  let errorMessage = """";
  const maps = errorMaps
    .filter((m) => !!m)
    .slice()
    .reverse() as ZodErrorMap[];
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }

  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage,
  };
};
```

I've created PR #2950 that introduce a new parameter 'force' that could be returned from the errorMap in order to overwrite the schema message, and use the schema message as a translation key to find the translated message as needed.",,
1981218374,2942,z.effect for preprocessing returns correct type but z.preprocess returns unknown for z.input,"Hi,

first, thanks for this awesome package!

I found out by accident that `z.preprocess()` would return `unknown` if infering with z.input but, if using `z.effect()` for preprocessing, z.input would return the right type. 2 questions:
* Why can't preprocess correctly infer the input type? I know that the arg is typed as `unknown` but what if we know that it will be a string? There is no way to pass a generic type to it.
* Why does z.effect work and why I don't find it in the documentation? I think is worth to add this method of preprocessing.

```typescript
const emptyStringToUndefined = (v) => (v === '' ? undefined : v);

const SchemaUnknown = z.object({
  name: z.preprocess(emptyStringToUndefined, z.string().optional()),
});

const SchemaCorrect = z.object({
  name: z.effect(z.string().optional(), {
    type: 'preprocess',
    transform: emptyStringToUndefined,
  }),
});

// name?: unknown;
type A = z.input<typeof SchemaUnknown>;

// name?: string;
type B = z.input<typeof SchemaCorrect>;
```",,
1980722388,2941,ZodEnum of ZodDiscriminatedUnion discriminator options?,"I have a ZodDiscriminatedUnion defined like this:

```
const SuperType = z.discriminatedUnion(""type"", [TypeA, TypeB, ..., TypeZZ])
```

Is there a simple solution to derive a ZodEnum that holds all values that the discriminator can take as per this definition?

The Typescript type is relatively easy to get:

```
type T = SuperType[""type""]
```

But since I need the enumeration anyway, I would rather have it as a ZodEnum and derive the Typescript type from that.

The following gives me an array of (typed) ZodLiterals ...

```
const e = SuperType._def.options.map((option) => option._def.shape().type)
```

... but `.map()` produces no `const` array, so that I can't pass it to `z.enum()` afterwards.

Is there an other way to get a ZodEnum from the union?",,
1980478732,2940,Custom error map does not override original message,"I'm setting a message for `z.number().max(100, ""too_old"")`

In the contextual error map, wanted to override this and return `very old`.

Have verified that the error map is being called, but the error is the result still comes up with the original message `too_old`

Tracing this down:

https://github.com/colinhacks/zod/blob/481c9ba1932203777f6fe9497bb2a8a1d33c620e/src/helpers/parseUtil.ts#L31

Should the above be changed to the following?

```ts
message: errorMessage || issueData.message
```


Test Case:

```ts
test(""zod custom error map"", () => {
  const schema = z.object({
    age: z.number().max(100, ""too_old""),
  });

  let errorMapMessage = """";
  const errorMap: z.ZodErrorMap = (issue, ctx) => {
    if (issue.message === ""too_old"") {
      errorMapMessage = ""very old"";
      return { message: errorMapMessage };
    }
    return { message: ctx.defaultError };
  };

  const result = schema.safeParse({ age: 101 }, { errorMap });
  expect(result.success).toBe(false);
  expect(errorMapMessage).toBe(""very old"");
  if (!result.success) {
    expect(result.error.issues[0].message).toBe(""very old""); // fails: actual is still ""too_old""
  }
});
```",,
1979426370,2938,z.infer returns z.object for objects with passthrough and preprocess or transform,"When an object has both the passthrough flag and undergoes a preprocess or transform: 
z.infer returns the zod object, instead of the typescript evaluation.

Below is a small snippet illustrating the bug. In the first two instances, the type should be (working as of 3.21.0):
[Working Demo](https://stackblitz.com/edit/typescript-syvzmi?file=index.ts)

`
{
    a: ({
        b: number;
    } & {
        [k: string]: unknown;
    })[];
}`

```
import {z} from 'zod';
const innerObject = z.object({
  b: z.number(),
}).passthrough();

// Broken
const preProcessObject = z.object({
 a: z.preprocess(x => [x], z.array(innerObject)),
});
const transformObject = z.object({
  a: innerObject.transform(x => [x]),
});

// These evaluate to: 
// {
//   a: z.objectOutputType<{
//       b: z.ZodNumber;
//   }, z.ZodTypeAny, ""passthrough"">[];
// }
type PreProcessObject = z.infer<typeof preProcessObject>;
type TransformObject = z.infer<typeof transformObject>;

// Working
const refinedObject = z.object({
  a: innerObject.refine(x => x.b > 5),
});

type RefinedObject = z.infer<typeof refinedObject>;
```",,
1979333995,2936,Nullability discrepancy z.infer and z.ZodSchema,"### Issue
If you infer a type from a schema that has a null filter on it, the schema won't match the inferred type. This is perhaps easiest shown rather than explained , so here is the minimal reproduction i could make.


```typescript
import { z } from ""zod"";

const NullableSchema = z
  .array(z.string().nullable())
  .transform((arr) => arr.filter((val): val is string => val !== null));

const func = (schema: z.ZodType<z.infer<typeof NullableSchema>>) => schema;
func(NullableSchema); // Typescript error null is not assignable to string
```

[![Edit determined-bartik-9g26qp](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/p/sandbox/determined-bartik-9g26qp?file=%2Fsrc%2Findex.ts&embed=1)

Just by removing the `nullable()` part it works as you would expect.

### Expected behavior
The Schema should match the type `z.ZodType<z.infer<typeof Schema>>`",,
1977751068,2933,Unused find function,"The find function in https://github.com/colinhacks/zod/blob/481c9ba1932203777f6fe9497bb2a8a1d33c620e/src/helpers/util.ts#L60 is not referenced in any place in the code base

Can I open a pull request to remove this chunk of code?",,
1974696249,2925,ZodUnion support for spread operator?,"Really: `[Symbol.iterator]()`

This would just be a convenient mechanism to save a few keystrokes for something like:
```
const U0 = z.union([z.literal(""foo""), z.literal(42)]);
const U1 = z.union([z.literal(""bar""), z.literal(true)]);


// What you have to do now:
const U = z.union([...U0._def.options, ...U1._def.options]);

// What would be nice:
const U = z.union([...U0, ...U1]);
```

Admittedly you can just do:
```
const U = U0.or(U1);
```

The iterator approach is nice when you're doing more dynamic/programmatic type creation, whereas the `.or()` is obviously nice for composing types ""statically"" (more akin to how you'd do it in pure Typescript).",,
1974143891,2924,`z.error#flatten` method does not respect schema transformation?,"I've created a schema and used a transform to modify its structure. When I use the `z.error#flatten` function on a failed `safeParse`, the structure of the errors I receive seems to be based on the input only without the schema transformation being applied.

[Codesandox](https://codesandbox.io/p/sandbox/ecstatic-tereshkova-px86wl?file=%2Fsrc%2Findex.ts&embed=1&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cloh4twux00073b6gv596oe7m%2522%252C%2522sizes%2522%253A%255B75.87052673904303%252C24.12947326095697%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cloh4twuw00033b6g3hlyeaal%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cloh4twuw00053b6gwml3sfps%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cloh4twuw00063b6go4j1qa53%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B100%252C0%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cloh4twuw00033b6g3hlyeaal%2522%253A%257B%2522id%2522%253A%2522cloh4twuw00033b6g3hlyeaal%2522%252C%2522activeTabId%2522%253A%2522cloh4u097005c3b6g08e9llvp%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cloh4twuw00023b6gb2k8flx3%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fyarn.lock%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522cloh4u097005c3b6g08e9llvp%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fpackage.json%2522%252C%2522id%2522%253A%2522cloh58zxg01cg3b6g62faxhxq%2522%252C%2522mode%2522%253A%2522temporary%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%257D%252C%2522cloh4twuw00063b6go4j1qa53%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522cloh4twuw00063b6go4j1qa53%2522%257D%252C%2522cloh4twuw00053b6gwml3sfps%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cloh4twuw00043b6gapr5njmb%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%257D%255D%252C%2522id%2522%253A%2522cloh4twuw00053b6gwml3sfps%2522%252C%2522activeTabId%2522%253A%2522cloh4twuw00043b6gapr5njmb%2522%257D%257D%252C%2522showDevtools%2522%253Afalse%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)


```
import { z } from ""zod"";

const schemaWithTransform = z
  .object({
    email: z.string().email(""Invalid email address""),
    name: z.string(),
  })
  .transform((data) => ({
    details: {
      email: data.email,
      name: data.name,
    },
  }));

type SchemaErrorsType = z.inferFlattenedErrors<typeof schemaWithTransform>;

const payload = schemaWithTransform.safeParse({
  email: ""invalid@email"",
  name: ""name here"",
});

if (!payload.success) {
  const flattendErrors = payload.error.flatten();

  type ShouldBeSame = IfEquals<
    typeof flattendErrors,
    SchemaErrorsType,
    ""same"",
    ""different""
  >; // different
}

type IfEquals<T, U, Y = unknown, N = never> = (<G>() => G extends T
  ? 1
  : 2) extends <G>() => G extends U ? 1 : 2
  ? Y
  : N;

```

In this scenario, I expected that ﻿`SchemaErrorsType` and the `type of ﻿flattendErrors` should be the same and reflect the transformed schema. However, that's not what I observe - ﻿flatten seems to be returning errors based on the input payload.
",,
1973755625,2923,Inconsistent inference between using static schema from local variable and dynamic schema from function parameter,"First of all, i'd like to apologize for a poorly formulated issue title, this is the best line I could come up with to describe the issue.
Second of all, this is _most certainly_ not a bug in zod itself - rather my lack of typescript skills, or me using the library not in the way it was intended to, but still I'm opening this issue as an opportunity for me to get help and get better and for zod authors and contributors to once again review API design decisions

Now to the issue

Imagine I want a function to wrap some schema (e.g. `{ foo: string, bar: number }`) in a discriminated union with metadata about operation outcome (e.g. `{ success: true, result: { foo: string, bar: number } } | { success: false, error: string }`. We create such function like so:
```ts
const wrapSchema = <T extends z.ZodTypeAny>(schema: T) => {
  return z.union([
    z.object({
      success: z.literal(true),
      result: schema,
    }),
    z.object({
      success: z.literal(false),
      error: z.string(),
    }),
  ]);
};
```

We would use this function like this:
```ts
const someSchema = z.object({ foo: z.string(), bar: z.number() });
const wrappedSchema = wrapSchema(someSchema);
const parsed = wrappedSchema.parse({ success: true, result: { foo: '', bar: 0 } });
if (parsed.success) {
  console.log(`Success with result ${parsed.result}`);
} else {
  console.log(`Failure with error ${parsed.error}`);
}
```
Every type in this example is inferred exactly as you would expect it (see the [playground link](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8A7lAIZgDK1AFgKYg2cALxwAPABU4fAB4w+dYgxQA6AFokJATzB8AgnS0A+ABQNeAtgC44EgJQijiCnDhQ+MAK5Q6qz3WB6EwBtF1dVCAAjACs+ahgTBDDwuAZPamo+BgYbZBUAG2B5dnyTGChPPjsAGmTw9zT8mBtzfkFalLQauryo2PjEutc0jKyc1ULitlLMaYYqjpTpKBwoXJUmKGA6AHMTbs6DuABdO0o0Shp6JjhmIp5OGDYYYGpuNqFRSWk5BSVVDTEbS6AzGMwWQQ2eyOZyuWiMeCYCAQd6WEQRGJxBJIJEQdabbZ7GpwSJsNaqOieECRPhQfboM5heE3VgcXTEVGCdGsrgQtgmXGctiM1wwHR8OAAJSyniawIlojy20wtLEYt0EEwt3YYHZQqMlDh13gYDJ82I3J1er5KlNUHmiVS6Uy2Rs5Uq1TcMqaNhxyJsAHIA57SeSAAzoBmGuDALUmO3mjbOsYOJIpZkQfJ8AoQPYAA04yeyt3uXsa8AAJAgE3xiCoGrKYGg8yLI3x8vNYeEM1mc-mAGJsYD5bwSu4wHjLVZwKs1uu01bN1toCgXKjMlj3IV6BgABTJbBAHlp6O+snkimUeUB8tBplalihDmETjTcA32rZtaFlo4QvBHytuqErSuW8rokqdAqlAaripqn66t+fIGkyxpwHOv6IRyNo1o6IwuuM7p8J6DY+ogWD+nAQYhmSNgRhgXTRrGcDxmatZJqM2SpnUPbZvkuYmAWRbKOOk6kZW1ZsXW4lLtGGDtp2b5GowmZ8QJeaDsOo4lhOU7QDOkn2uxC7QLJYQrmuQA))

But suddenly everything breaks if I want `someSchema` to be dynamically defined by caller:
```ts
const withSchemaAsParameter = <T extends z.ZodTypeAny>(schema: T) => {
  const wrappedSchema = wrapSchema(schema);
  const parsed = wrappedSchema.parse({ success: true, result: { foo: '', bar: 0 } });
  if (parsed.success) {
    console.log(`Success with result ${parsed.result}`); // Property 'result' does not exist on type see playground link
  } else {
    console.log(`Failure with error ${parsed.error}`); // Property 'error' does not exist on type see playground link
  }
};
```

Is it possible to accomplish with zod?",,
1969756886,2919,nativeEnum invalid_type_error not returning error on wrong enum,"Zod returns `Invalid enum value` although `invalid_type_error` is set.

## Steps to reproduce

```ts
const schema = z.nativeEnum({MY_ENUM:""MY_ENUM""}, {
  invalid_type_error: ""this is an error"",
})

console.log(""result"", schema.parse(""AAA""));
// returns error ""Invalid enum value. Expected 'MY_ENUM', received 'AAA'""
```

## Expected behavior
When the type is wrong, Zod should return whatever I give in  `invalid_type_error`.
In the example, it should return `this is an error`

If `invalid_type_error` is meant to be used for something else, I would expect the following:
1. Add in the `nativeEnum` documentation section what is `invalid_type_error` for
2. Add with JS Docs what is `invalid_type_error` for
3. Add an `invalid_enum_error` to the `params` of `nativeEnum` where we can define a custom message. 
",,
1967865418,2915,.catch() become unknown type when used with a generic function,"When I try
```ts
import zod from 'zod';

const userSchema = zod.object({
  name: zod.string(),
  address: zod.string().catch('')
});

const unparsedUser: any = {
  name: 'Alice',
  address: null
}

const parsedUser = userSchema.parse(unparsedUser)
```
The `address` of `parsedUser` will have the `string` type.
But if I create a generic function and then parse a data with it
```ts
function apiResponseSchema<T>(dataSchema: zod.ZodType<T>) {
  return zod.object({
    data: dataSchema
  })
}

const userApiResponseSchema = apiResponseSchema(userSchema)

const unparsedApiResponse: any = {
  data: unparsedUser
}

const user = userApiResponseSchema.parse(unparsedApiResponse).data
```
The `address` of the `user` will have the `unknown` type while it should be returning a `string` type also.

Here's the demo in [typescript playground](https://www.typescriptlang.org/play?noImplicitAny=false#code/JYWwDg9gTgLgBALwgEzgMyhEcDkTk4DcAUMQMYQB2AzvAK7UCmUAymQBaMgCGcAvIhQA6CACMAVozIwAFAG9icOJW4hGALkHIhtKMEoBzGQEoANIrjdkyKI2rVN+HTD2GTQstxgcZOHMeIAX2MSYjQ6SmlgKkswYAAlO0gaRjZOHgAeABUAPhlkL240rm5HYQAtFCyATzBGbJzjOAUlWxg6KEotEQkpWRalOAKYUqHC4p4LYKDSChp6SjBuKCZkAFUmKE1uSmr+ZosVNU0cAEEAG2AyRhxzJSsbOwdlOnPzmfIqWjgllcZ1zb7BjMCbcIS-JgyCIQ-4bZgBAD0CMGcAAegB+WZfeibU5xRLUZJMUH7bj4pJfVIcEpQzaggKfeZwaHLVZ4hIUlLbXb7AbDUYsv4A5gfObfYFQIG48mEymg8GsxhQxaK5DsglExjGIT84hIlEYoA).",,
1967068668,2914,Type declarations not found ,"Typescript compiler doesn't seem to find zod type declarations in nuxtjs 3 :point_down: 

```Cannot find module 'zod' or its corresponding type declarations.ts(2307)```
",,
1965766323,2911,Undefined values in record with optional values get stripped,"When using a Zod schema that should accept undefined values in a record, those entries get stripped anyway.

For example, this code

```
import z from ""zod"";

const schema = z.object({
  items: z.record(z.string().optional())
});

const data = {
  items: {
    a: ""qwerty"",
    b: undefined
  }
};

console.log(schema.parse(data));
```

outputs `{items:{a:""qwerty""}}`


According to Typescript, the inferred type is
```
{
    items: Record<string, string | undefined>;
}
```

So I expected` {items:{a:""qwerty"", b: undefined}}`",,
1964606303,2909,Extend within generic function doesn't infer type as expected,"I was using the suggested means of typing generic functions [as covered in the documentation](https://zod.dev/?id=writing-generic-function). My goal was to write a method that would `extend` any provided zod object with another hardcoded zod object.

Using

```ts
const extender = <T extends z.AnyZodObject>(p: T) => p.extend({ foo: z.boolean() });
```

Results in the incorrect type being inferred.

```ts
const schema = extender(z.object({ bar: z.number() }}));
z.infer<typeof schema> // === { [x: string]: any; [x: number]: any; [x: symbol]: any; foo?: boolean | undefined; }
```

Regardless of the object submitted as `p`.

The example below covers the cases I'd tested and a workaround I found that used `z.ZodRawShape` instead.

```ts
import { z } from ""zod"";

const schema = z.object({ bar: z.number() }).extend({ foo: z.boolean() });

const brokenExtender = <T extends z.AnyZodObject>(p: T) => p.extend({ foo: z.boolean() });
const schema2 = brokenExtender(z.object({ bar: z.number() }));

const workingExtender = <T extends z.ZodRawShape>(p: z.ZodObject<T>) => p.extend({ foo: z.boolean() }) ;
const schema3 = workingExtender(z.object({ bar: z.number() }));

/* As expected: type s1 = { bar: number; foo: boolean; } */
type s1 = z.infer<typeof schema>;
/* Not expected: type s2 = { [x: string]: any; [x: number]: any; [x: symbol]: any; foo?: boolean | undefined; } */
type s2 = z.infer<typeof schema2>;
/* As expected: type s3 = { bar: number; foo: boolean; } */
type s3 = z.infer<typeof schema3>;
```
[codesandbox](https://codesandbox.io/p/sandbox/agitated-https-s79s3p?file=%2Fsrc%2Findex.ts%3A7%2C35)

Note: This same behaviour occurs with `.merge()` as well.
```ts
const extender = <T extends z.AnyZodObject>(p: T) => p.merge(z.object({ foo: z.boolean() }));
const schema = extender(z.object({ bar: z.number() }}));
z.infer<typeof schema> // === { [x: string]: any; [x: number]: any; [x: symbol]: any; foo?: boolean | undefined; }
```
",,
1962933364,2903,How to keep a TypeScript interface in sync with a Zod schema?,"I have an existing project primarily written in TypeScript where we originally had no runtime validations for our data. As we're expanding our API and also have JavaScript users, I've decided to introduce Zod to validate our data at runtime.

**Example**
```ts
import { z } from 'zod';

interface MyData {
  name: string;
  age: number;
  isStudent?: boolean;
}

const MyDataSchema = z.object({
  name: z.string(),
  age: z.number(),
  isStudent: z.boolean().optional()
});
```

The challenge I'm facing is keeping the `MyData` interface and the `MyDataSchema` in sync. Every time I update the TypeScript interface, I have to manually update the Zod schema. This manual process is error-prone and can lead to inconsistencies.

I tried using `satisfies z.ZodType<MyTypescriptType>` (example below), but it doesn't handle optional types well.

```ts
const MyDataSchema = z.object({
  name: z.string(),
  age: z.number(),
  isStudent: z.boolean().optional()
}) satisfies z.ZodType<MyData>;
```

Is there an efficient way to enforce synchronization between a TypeScript interface and a Zod schema? Ideally, I'd like an approach where updating the interface would either automatically update the schema or at least throw an error if they're out of sync.",,
1960465868,2898,Zod Metadata,"I know this issue has been raised before but I want to bring it up again as I am encountering quite some problems trying to plug together an ecosystem around zod.

First point: I love zod!
And I really think that having one source of truth for models is a big plus in any TS code base. Without code generation steps and everything. I like that it is just plain code and Typesystem expressions.

So I want to use zod for building my data types and typescript interfaces. I want to infer UI models from it to generate forms, widgets and other components in a more declarative style (using zod-metadata).
I want to derive persistence schema for mongodb (using mongoose-zod)

Problem is that the way these libraries extend the Zod Types using d.ts files and somehow they clash. It is not possible to use them both. I am struggling hard and I am not getting these to work.  Trying to get multiple dts files work in mono-repo setup with multiple packages and all these different flavors of dependencies....man... Am I getting old? I remember when node.js kicked-ass compared to many other stacks...but I am loosing myself here....

The point is: I think it would be so much simpler for all sorts of third party code that builds on top of zod to have one very simple mechanism to add their own data to each type. In my opinion this would make the world a better place. I mean, it would allow extensions to add whatever processing metadata they need.


So, dear Colin. Can you please reconsider to add this method?",,
1955254078,2893,"Making all fields of an object ""nullable""","Currently, it is possible to make an object's properties optional by using `.Partial`. However, this does **NOT** make the object properties nullable, so there would be a repetitive task of adding `nullable()` to every field as seen below. Could we have an option to make all fields all nullable?

```
const MyObjectSchema = z
  .object({
    p1: z.string().nullable(),
    p2: z.number().nullable(),
    p3: z.boolean().nullable(),
    p4: z.date().nullable(),
    p5: z.symbol().nullable(),
  })
  .partial();
```",,
1955151749,2891,Add a `change` function to change the existing properties of a schema,"**Feature request:**

Similar to extend, but you are only allowed to change the existing properties of a schema, not extend it.

This is technically possible with `.extend`, but there is no typescript autocompletion for this.

```typescript
const schema = z.object({
    name: z.string(),
    age: z.number().optional(),
});

// You are only allowed to change properties that already exist in the schema you are changing.
const changedScema = schema.change({
    age: z.number(),    // remove optional
});

const changedSchema2 = schema.change({
    occupation: z.string().optional(),    // typescript error, because this property does not exist on `schema`
});
```",,
1953791143,2887,How to create a generic zod parser factory that gives a picked schema with types?,"Hi all, 

I'm trying to create a generic zod parser factory that takes a schema and a list of fields that transforms that schema into a picked schema, but I am having an issue where the return type information is filtered out to any. 

Here's what I have so far:
```ts
    const parseFactory = (schema: z.AnyZodObject) =>  { 
        return <T extends keyof z.infer<typeof schema>>({item, fields}: {item: unknown, fields: T[]}): Pick<z.infer<typeof schema>, T> | undefined=> {
          try {
            const pickedSchema = schema.pick(Object.fromEntries(fields.map(field => [field, true])))
            return pickedSchema.parse(item)
          } catch (error) {
            // error handling
          }
        }
    }
```

However, in the above, the type of the return is : 
```ts
    {
        [x: string]: any;
        [x: number]: any;
    }
```

Any help would be appreciated!
",,
1953401804,2886,How to get def.checks in schema containing refine/superRefine?,"I have a schema like:
```typescript

const RegisterUsernameExtraSchema = z.object({
    username: z.string().min(1, { message: ""msg_required"" }),
    password: z.string().min(1, { message: ""msg_required"" }),
    email: z
        .string()
        .optional()
        .superRefine((val, ctx) => {
            const leg = Number(val?.length)
            if (!val || leg === 0) return true
            if (leg < WebConfig.Validation.email.min) {
                ctx.addIssue({
                    code: z.ZodIssueCode.too_small,
                    message: 'msg_error_register_field_email_require_minimum',
                    minimum: 4,
                    type: 'string',
                    inclusive: false
                })
            }
            if (leg > WebConfig.Validation.email.max) {
                ctx.addIssue({
                    code: z.ZodIssueCode.too_big,
                    message: 'msg_error_register_field_email_require_maximum',
                    maximum: 150,
                    type: 'string',
                    inclusive: false
                })
            }
            if (WebConfig.Validation.email.regex && !new RegExp(WebConfig.Validation.email.regex).test(val)) {
                ctx.addIssue({
                    code: z.ZodIssueCode.invalid_string,
                    message: 'email_invalid',
                    validation: 'email'
                })
            }
        })
})```

How to get `message information` and `minimum/maximum value` in superRefine of the email field? Please help me, thanks all guys!",,
1953128691,2885,Best way to create a zod validator for a list of literal strings,"I want to do something like this:

```
export const levels = ['level1', 'level2', 'level3', 'level4'] as const;

export const levelValidator = z.union(
  levels.map(l => z.literal(l))
);

export type Level = z.infer<typeof levelValidator>;
```

Goal is to create a list of literal strings and enforce that the property contains one of these strings.

I could certainly do:
```
z.union([
  z.literal('level1'),
  z.literal('level2'),
  z.literal('level3'),
  z.literal('level4'),
]);
```

But I want to have an array of these values that I can render as the options for a select input.

That map doesn't work because the type definition for `union` is so strict that it enforces that the array has at least 2 elements. This array does, but the compiler can't enforce that.

Any suggestions on the best way to proceed?

This issue is similar:
https://github.com/colinhacks/zod/issues/2691

But I can't imagine using ~100 lines of code for this.",,
1953039725,2884,"Feature: Allow using a function for validation ""message"" prop","It would be useful if the `message` prop for validation methods like `.min`, `.max` etc... could be `string | ((val) => string)` rather than just `string`. This would help in cases where you might be using a translation library and would like to defer the retrieval of the string until the moment it is needed. e.g..
```ts
const nameSchema1 = z.string().min(1, { message: 'Too Short' });
const nameSchema2 = z.string().min(1, { message: () => 'Too Short' });
```

This is a real-world example. As soon as the module/file is loaded, the string is materialized and this could be before your I18n library is available or the language is known.
```ts
export const nameSchema = z
  .string()
  .trim()
  .min(1, { message: I18n.t('common:validation.required') })
  .max(64, { message: I18n.t('common:validation.tooManyCharacters') });
```

I'm aware that this could be worked around by avoiding the `message` prop entirely and using `.refine()` at the end instead... OR by creating a custom `errorMap` function on the `string()`, but this greatly reduces the simplicity and legibility of the schema and makes the `message` option kind of pointless unless you have static hardcoded strings.",,
1950699886,2880,runtime-only unions?,"Hi there - I am wondering if there's a way to define optional or union types for the sake of backwards-compatibility that is stricter at compile time. For example:

```ts
const Input = z.object({ status: z.string().optional({ runtimeOnly: true }) })

const a: z.infer<typeof Input> = {} // compile-time error, z.infer<typeof Input> has type { status: string }
const b = Input.parse({}) // no error, `status` is optional at runtime, so it's allowed to be missing

b.status.slice() // compile-time error, the output type is `{ status: string | undefined }`
```

Similarly with union types:

```ts
const Input = z.object({ status: z.enum(['open', 'closed']).or(z.string(), { runtimeOnly: true })

const a: z.infer<typeof Input> = {.status: 'invalid' } // compile-time error, z.infer<typeof Input> has type { status: 'open' | 'closed' }
const b = Input.parse({.status: 'invalid' }) // no error, `status` is optional at runtime, so it's allowed to be missing

b.status // has type `string`
```

The idea being that you could make changes to schemas that have deployed clients who may send the old value for some amount of time - but the typescript compiler will catch any out-of-date usage to make it easier to get those clients up to date.

If this doesn't exist (I couldn't find it) - would you be open to a PR adding it?",,
1950305509,2879,Make entire schema readonly,"Making a large schema deeply readonly is a LOT of `.readonly()`. It would be grand if there was a way to either set `.deepReadonly()` (like `deepPartial`), or `readonly` had an argument that would go deeeeeeeep.

Instead of

```ts
const Recipe = z.object({
  id: z.string().readonly(),
  name: z.string().readonly(),
  ingredients: z.array(z.string().readonly()).readonly(),
}).readonly();
```

we could do 

```ts
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
}).deepReadonly(); 
```

or maybe

```ts
const ReadonlyRecipe = z.deepReadonly(Recipe)
```

or maybe

```ts
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
}).readonly({ deep: true });
```

If this seems good, I can submit a PR. ",,
1948936524,2876,"odTypeAny, { ...; }, { ...; }>, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodObject<any, UnknownKeysParam, ZodTypeAny, { [x: string]: any; }, { [x: string]: any; }>'.   Type 'ZodEffects<ZodObject<{ email: ZodString; password: ZodString; newPassword: ZodString; confirmPassword: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }, { ...; }>' is missing the following properties from type 'ZodObject<any, UnknownKeysParam, ZodTypeAny, { [x: string]: any; }, { [x: string]: any; }>': _cached, _getCached, shape, strict, and 14 more.  64   @UsePipes(new ZodValidationPipe(resetPasswordSchema))","```
//filte reset-password.schema.ts
import { z } from 'zod';

export const resetPasswordSchema = z
  .object({
    email: z
      .string({
        required_error: 'Email is required',
        invalid_type_error: 'Email should be a valid email',
      })
      .email(),
    password: z
      .string({
        required_error: 'Password is required',
        invalid_type_error: 'Password should be a valid string',
      })
      .trim(),
    newPassword: z
      .string({
        required_error: 'New password is required',
        invalid_type_error: 'New password should be a valid string',
      })
      .trim(),
    confirmPassword: z
      .string({
        required_error: 'confirm password is required',
        invalid_type_error: 'confirm password should be a valid string',
      })
      .trim(),
  })
  .required()
  .superRefine((values, ctx) => {
    if (values.newPassword !== values.confirmPassword) {
      ctx.addIssue({
        message: 'Passwords do not match',
        code: 'custom',
      });
    }
    return values;
  });

export type ResetPasswordDto = z.infer<typeof resetPasswordSchema>;
```

```
import { PipeTransform, ArgumentMetadata } from '@nestjs/common';
import { ZodObject } from 'zod';

export class ZodValidationPipe implements PipeTransform {
  constructor(private schema: ZodObject<any>) {}
  transform(value: any, metadata: ArgumentMetadata) {
    this.schema.parse(value);
    return value;
  }
}
```

  @UsePipes(new ZodValidationPipe(resetPasswordSchema)) 
  
  how can I solve this",,
1948370690,2875,Inaccurate Error Reporting in Unions,"I believe there is a bug with the error reporting for unions of strict partial objects.  My expectation is that if there is N schemas in the union, a failed parsed should return N unionsErrors.  

```typescript
import * as z from 'zod';

const x = z.object({ x: z.number() });

try {
  const a = z.object({ a: x.optional() }).strict();
  const b = z.object({ b: x.optional() }).strict();
  const ab = z.union([a, b]);
  ab.parse({ b: { y: 1 } });
} catch (error) {
  if (error instanceof z.ZodError) {
    // Expected: 2 unionErrors:
    //   Error #1: - [b] Unrecognized key(s) in object: 'b'
    //   Error #2: - [b][x] Required
    //
    // Actual: 1 error:
    //   [b] Unrecognized key(s) in object: 'b'  <=== Unexpected
    console.log(JSON.stringify(error, null, 2));
  }
}
``` 

Output:
```
{
  ""issues"": [
    {
      ""code"": ""unrecognized_keys"",
      ""keys"": [
        ""b""
      ],
      ""path"": [],
      ""message"": ""Unrecognized key(s) in object: 'b'""
    }
  ],
  ""name"": ""ZodError""
}
``` 

Note that with non-optional properties, this behaves as expected:

```typescript
try {
  const a = z.object({ a: x }).strict();
  const b = z.object({ b: x }).strict();
  const ab = z.union([a, b]);
  ab.parse({ b: { y: 1 } });
} catch (error) {
  if (error instanceof z.ZodError) {
    // Expected & Actual: 2 unionErrors:
    //   Error #1: - [a] Required
    //             - [b] Unrecognized key(s) in object: 'b'
    //   Error #2: - [b][x] Required

    console.log(JSON.stringify(error, null, 2));
  }
}
``` 

Output:

```
{
  ""issues"": [
    {
      ""code"": ""invalid_union"",
      ""unionErrors"": [
        {
          ""issues"": [
            {
              ""code"": ""invalid_type"",
              ""expected"": ""object"",
              ""received"": ""undefined"",
              ""path"": [
                ""a""
              ],
              ""message"": ""Required""
            },
            {
              ""code"": ""unrecognized_keys"",
              ""keys"": [
                ""b""
              ],
              ""path"": [],
              ""message"": ""Unrecognized key(s) in object: 'b'""
            }
          ],
          ""name"": ""ZodError""
        },
        {
          ""issues"": [
            {
              ""code"": ""invalid_type"",
              ""expected"": ""number"",
              ""received"": ""undefined"",
              ""path"": [
                ""b"",
                ""x""
              ],
              ""message"": ""Required""
            }
          ],
          ""name"": ""ZodError""
        }
      ],
      ""path"": [],
      ""message"": ""Invalid input""
    }
  ],
  ""name"": ""ZodError""
}
``` 

Am I missing something?",,
1947193868,2873,Support coercion for arrays,"Currently there is no way to tell Zod ""if you get a single value of correct type, just put it into an array"". Existing `.coerce()` operation could be used for this.

Here is a reference implementation of this logic: https://github.com/lokalise/zod-extras/blob/main/src/utils/toArrayPreprocessor.ts
Test: https://github.com/lokalise/zod-extras/blob/main/src/utils/toArrayPreprocessor.test.ts",,
1944499571,2870,why zod doesn't make no empty string by default for required fields?,"I am using react hook form and zod as a validator resolver.

```ts
export const SignInValidator = z.object( {
    email: z.string().email( ""Invalid email address"" ),
    password: z.string(),
} )

const form = useForm( {
    resolver: zodResolver( SignInValidator ),
    defaultValues: {
        email: """",
        password: """",
    },
} )
```
  
SignInValidator is passes even if the password is an empty string. the default value is empty string, if I don't create an empty string at the default value, a Warning will occur: A component changed an uncontrolled input to a controlled one. This is likely caused by changing a value from undefined to a defined value, which should not happen. Decide between using controlled or uncontrolled input elements during the lifetime of the component.

why zod doesn't make noEmptystring by default for required fields?",,
1941571565,2864,Type inference when combining objects seems wrong,"Hi, sorry to bother you with this, I've been successfully using the lib until I ran into this issue I'm not sure if it's a misuse from my side or a bug/limitation in Zod.

I have these reusable types defined:

```typescript
import { z } from ""zod""

const SuccessResponse = <T>(schema: z.Schema<T>) => z.object({
  success: z.literal(true),
  data: schema
})
const ErrorResponse = z.object({
  success: z.literal(false),
  error: z.string()
})
const Response = <T>(schema: z.Schema<T>) => z.discriminatedUnion(
  ""success"",
  [
    SuccessResponse(schema),
    ErrorResponse
  ]
)

const Model = z.object({name: z.string()})

const response: unknown = {success: true, data: null}
```

And I'm able to use them just fine in this case:
```typescript
const model = Response(Model).parse(response)
if (model.success) {
  model.data.name
} else {
  model.error
}
```

But if I try to abstract the above code in a function then the type of the `parse` result does not allow me to type-guard on the `success` field:
```typescript
function responseData<T>(schema: z.Schema<T>, response: unknown): T {
  const model = Response(schema).parse(response)
  if (model.success) {
    return model.data // 'data' does not exist on type
  }
  throw new Error(model.message) // 'message' does not exist on type
}
```

I have a codesandbox created with this code: https://codesandbox.io/p/sandbox/silly-wing-m4gnt8",,
1938366642,2859,Defining function rest parameters,"This is essentially the same issue as the closed #1282. I have a function that is shaped like this:

```ts
export type  MyFunc = (...args: string[]) => object;
```

I tried a couple of the solutions offered in the original issues.

#### Attempt 1

This is my attempt to use the [original solution](https://github.com/colinhacks/zod/issues/1282#issuecomment-1237743124) offered by @colinhacks:

```ts
import { z } from 'zod';

const MyFuncSchema = z
  .function()
  .args(z.tuple([]).rest(z.string()))
  .returns(z.void());

export type MyFunc = z.infer<typeof MyFuncSchema>;

const myFunc: MyFunc = (...args) => {
  args.forEach((arg) => {
    console.log(arg);
  });
};

myFunc('a', 'b', 'c');
```

When I run I run `tsc`, I get this error:

```
my-func.ts:16:8 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'string[]'.

16 myFunc('a', 'b', 'c');
```

When I hover on the the `MyFunc` type (line 8) in the above,  VSCode kindly tells me that the type resolves to this:

```ts
type MyFunc = (args_0: string[], ...args_1: unknown[]) => void 
```

I think this means that Zod interprets `arg_0` as the tuple defined in the arguments, and the rest is whatever it is (which makes sense in from the syntax). 

#### Attempt 2

This is my attempt to use the [solution](https://github.com/colinhacks/zod/issues/1282#issuecomment-1374609774) offered by @maxArturo:

```ts
import { z } from 'zod';

const possibleInputs: [] | [z.ZodString, ...z.ZodString[]] = [
  z.string(), //
  z.string(),
];

const MyFuncSchema = z
  .function() //
  .args(...possibleInputs)
  .returns(z.void());

export type MyFunc = z.infer<typeof MyFuncSchema>;

const myFunc: MyFunc = (...args) => {
  args.forEach((arg) => {
    console.log(arg);
  });
};

myFunc('a', 'b', 'c');
```

For now, I'm going with this solution because, as @maxArturo says, this works! However, when I hover on `MyFunc`, I get this:

```ts
type MyFunc = (args_0: string, ...args_1: unknown[]) => void
```

This means I don't get the strong type checking on values in `args_1` that I want. 😢 

#### What I want

What I'd love to have is the ability to define the function schema like this:

```ts
const MyFuncSchema = z
  .function()
  .args().rest(z.string())
  .returns(z.void());
```

This would result in a function type like this:

```ts
type MyFunc = (...args_0: string[]) => void 
```

#### Details

I'm using:

- tsc v5.2.2
- zod v3.22.4",,
1935130016,2852,Using .catch causes input type to become unknown ,"When using a .catch block the typescript input type of the schema becomes unknown. 

**Without catch**

```typescript
const schema = z.number().min(1).max(255)
type SchemaType = z.input<typeof schema>
```
_SchemaType is number_

**With catch**

```typescript
const schema = z
  .number()
  .min(1)
  .max(255)
  .catch((err) => {
    return 1
  })

type SchemaType = z.input<typeof schema>
```
_SchemaType is unknown_

This seems to happen for all types string, number boolean etc",,
1935091502,2851,Please adhere to SemVer,"I started using `zod` in one of the packages in my team's monorepo, and everything was great. The `zod` version that Yarn installed was `v3.22.2`.

I then add `zod` to another package in my team's monorepo and it's still great. At this point, `v3.22.4` is released, and Yarn chooses to install that version. 

I then import a `zod` schema from the first package into the second package, try to use it to create a new schema, and the typescript server freaked out.

Here's an exerpt from my `tsserver.log` (manually prettified)

```json
Info 1066 [10:56:04.300] event:
{
	""seq"":0,
	""type"":""event"",
	""event"":""semanticDiag"",
	""body"":{
		""file"":""/<my team's monorepo>/packages/api/src/types/root.schema.ts"",
		""diagnostics"":[{
			""start"": { ""line"": 116, ""offset"": 28 },
			""end"": { ""line"": 122, ""offset"": 3 },
			""text"": ""Type instantiation is excessively deep and possibly infinite."",
			""code"": 2589,
			""category"": ""error""
		}, {
			""start"": { ""line"": 116, ""offset"": 14 },
			""end"": { ""line"": 116, ""offset"": 25 },
			""text"": ""The inferred type of 'Declaration' cannot be named without a reference to '@lll/shared/node_modules/zod'. This is likely not portable. A type annotation is necessary."",
			""code"": 2742,
			""category"": ""error""
		}]
	}
}
```

where `Declaration` is the schema I was constructing in `root.schema.ts`, using an import from `@lll/shared`.

It's worth noting, that error appeared only when adding a field to the object schema that used a schema from `@lll/shared`.

```ts
import { Schemas } from ""@lll/shared"";

//...

export const RootType = z.object({
//...
});

//...

export const Declaration = RootType.extend({
	// Inline schema properties. No dependency on @lll/shared
    //...

	allergens: Schemas.Primative.Allergens
});
```",,
1929777188,2844,Cannot extend schema if target shape has .readonly(),"Zod version: 3.22.4
Typescript version: 5.2.2

Fails with `Property  shape  does not exist on type` error on last string in example

```
import { z } from 'zod';

export const Entity = z.object({
  id: z.string(),
}).readonly();

export const IdNameEntity = z
  .object({
    name: z.string(),
  })
  .extend(Entity.shape);
```",,
1925978146,2838,Loss of type (=any) when inferring branded schema type,"See TS Playground: `b1 = any` and `b2 = string`

[TS Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHAREiAE1wCgSBjCAOwGd4AxCCOAXjiQDo6pgqBzABQBKDgCMoAQyqEBAckYRZQitTpwAQhKit2XGD37CyAemNwJARh3defOADJd6gEoBBAHIARADy4FuAD44AUooKABTchhlSlp4Sx0FDjAtGnCBXFxlElNzACZrfVtg0IiomNV4grZNKGTU9Mzs3NErNikAT2CAdyx+Cri4Vp0UqDSM3AAaOAVms1FquBt+Eugy6JVBhZGGiena7PQAVyoo4Go4UbTvAHlpzzhwgA8YcOkaXQAtIgAVDrBwp5wuhpgBJAICABuEgANkdwgAuOAnADWVAg3So0xo5AAFuEQBIkZwAMp4gkSW73MEBIRIm6IEhwZlwCIwI5QKhLcmE+pjdLQuHhZQoIA)

```ts
export declare class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<T[""_output""] & BRAND<B>, ZodBrandedDef<T>, T[""_input""]> 
```

TS struggles inferring the BRAND intersection to fit into `z.Schema` (=`z.ZodType`): 
```ts
ZodType<T[""_output""] & BRAND<B>, ZodBrandedDef<T>, T[""_input""]>
```

The following works around the issue 100% for me with different types ([TS Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHAREiAE1wCgSBjCAOwGd4AxCCOAXjiQDo6pgqBzABQBKDgCMoAQyqEBAckYRZQitTpwAQhKit2XGD37CVteJqgKdnAKZUAriAEBtWQEFZAGjiz1HrwGFZAF1lEgB6ULgJAEYdbl4+OAAyXXUAJRcAOQARAB5cBVwAPjgBSigoK3IYZUoTSJi2BQ4wLRorAVxcEPDIgCZY-XiSsoqqmtV4CX62M2bW9s7uiNEGyKoATxKAdwkaOC2sfgBuOCoILbgRyurjNRWdFqg2jtxPBSW4UWm4OP5h6FGN1qd2+j2enU8Zg+5B0uBcuDgAB88OoEcjcH4EaUAddxnUYWwwQtXhotO8yIRKgAbLRWDC2KhVYDUOBEnIAeU8WTgVgAHjAbIQ9pwAFpEAAq6zAViyVnQngAkp4AMo8-mC4UcZXkAAWVhAEg5XMVhUKAgAbhIqbYrAAuOAMgDWZy2VE8NF1+ok9uVQh9jlwAH0ILYYGBQ7hAkA)):
```ts
declare function parse<
  O, 
  D extends z.ZodTypeDef, 
  I, 
  S extends z.Schema<O, D, I>
>(value: unknown, schema: S): S[""_output""]
```",,
1925584643,2837,Tuple type produce uknown[] rest type when rest() not called (when strictNullChecks is set to false),"According to docs, basic tuple type should have produce:
```
const athleteSchema = z.tuple([
  z.string(), // name
  z.number(), // jersey number
  z.object({
    pointsScored: z.number(),
  }), // statistics
]);

type Athlete = z.infer<typeof athleteSchema>;
// type Athlete = [string, number, { pointsScored: number }]
```

But in reality, it produce
```
type Athlete = [string, number, {
    pointsScored?: number;
}, ...unknown[]]
```

Similar example
```
const pointSchema = z.tuple([z.number(), z.number()]);
type Point = z.infer<typeof pointSchema>;
```
expextion `[number, number]` but gents `[number, number, ...unknown[]]` which is really not useful. 

This happen when Typescript config has strictNullChecks: false",,
1922413794,2832,Parse doesn't work when schema passed as generic type,"Hi I have a function like this 
```
export const parseMyObject = <T, Z extends z.ZodType<object>>(
  value: object,
  schema: Z
): T | string => {
  const result = schema.safeParse(value);
  console.log(result)
  if(result.success) {
    return obj;
  } else {
  return  result.error.message
}
```
Let's say I'm passing
```
type MyObject = {
  latitude: number;
  longitude: number
  timezone: string;
}
const mySchema = z.object({
  latitude: z.number(),
  longitude: z.number(),
  timezone: z.string(),
)}
parseMyObject<MyObject, typeof mySchema>({hi: ""mom""}, mySchema); 
  ```
For the signature I have tried `Z extends z.ZodType<T>` and `Z extends z.ZodTypeAny` as well.
When I pass a valid T for value, I get the object back.  But when I pass a wildly invalid value for T then console log is `{ success:true, data:{} }`
I have the same result when using schema.parse(value).  It does not throw, it returns `{ success:true, data:{} }`.
When I run parse and safeParse directly on the schema e.g. where the schema is defined and I have it in hand, it works as expected.

The above function is distilled from the real world function, so there maybe subtle errors, but the overall idea is correct.  e.g. I'm returning a type like what safeParse returns but I didn't want to type all that out. 

I feel like there's some subtle thing I'm doing wrong, but if not, then maybe there's a bug.
thanks
Raif",,
1921992369,2831,Intersection does not have a shape,"When using a union/intersection type, the resulting object does not have a shape.

```ts
export const GetPulseMeterCurrentUsageParams = z
    .object({
        duration: z.number().optional(),
    })
    .and(
        z
            .object({ iotDeviceID: z.string() })
            .or(z.object({ pulseMeterID: z.string() }))
    );

GetPulseMeterCurrentUsageParams.shape // undefined
```",,
1921802521,2830,Union doesn't return all options issues when used with string-specific validation,"```javascript
const { z } = require(""zod"")

const schema = z.union([z.string().startsWith(""1""), z.string().startsWith(""2"")])
const result = schema.safeParse(""3"")
!result.success && console.log(result.error.issues)
```

Returns:
```javascript
[
  {
    code: 'invalid_string',
    validation: { startsWith: '1' },
    message: 'Invalid input: must start with ""1""',
    path: []
  }
]
```

Expected:
```javascript
[
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            code: 'invalid_string',
            validation: { startsWith: '1' },
            path: [],
            message: 'Invalid input: must start with ""1""'
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            code: 'invalid_string',
            validation: { startsWith: '2' },
            path: [],
            message: 'Invalid input: must start with ""2""'
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [],
    ""message"": ""Invalid input""
  }
]
```

Looks like it works when removing these lines: https://github.com/colinhacks/zod/blob/ae0f7a2c15e7741ee1b23c03a3bfb9acebd86551/src/types.ts#L2836-L2839

But I'm not sure what is `dirty` ",,
1916500841,2816,`.nullish()` does not include the `null` type when using `z.infer()`,"```ts
const schema = z.object({
  prop: z.string().nullish(),
});

type Schema = z.infer<typeof schema>;
```

Expected type of `Schema` as a result:

```ts
type Schema = {
    prop?: string | null;
}
```

Actual type of `Schema`:

```ts
type Schema = {
    prop?: string;
}
```

Somehow the null is not included into the type. ",,
1916116998,2815,Inferred types somehow break with .catchall(),"Hey! Zod is fantastic. I've been heavily using it for a really ugly schema, which means I've been running into all sorts of edge cases with strange behavior. This one doesn't cause any compilation or runtime errors, but it can make for sometimes annoying development as I can't hover check certain variable types.

```ts
export type Stat = z.infer<typeof zStatSchema>;
export const zStatSchema = z
    .object({
        std: z.union([z.number(), z.null(), z.string()]).optional(),
        default: z.number().optional(),
        abilities: z.string().or(z.string().array()).optional(),
        notes: z.string().array().optional(),
        note: z.string().optional(),
    })
    .catchall(z.number());
const stat: Stat = {};
```
When I hover the type ""Stat"" I get a good type.
```ts
type Stat = {
    std?: string | number | null | undefined;
    default?: number | undefined;
    abilities?: string | string[] | undefined;
    notes?: string[] | undefined;
    note?: string | undefined;
} & {
    [k: string]: number;
}
```
 But when I hover the variable ""stat"" I get:
```ts
const stat: z.objectOutputType<{
    std: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodNull, z.ZodString]>>;
    default: z.ZodOptional<z.ZodNumber>;
    abilities: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, ""many"">]>>;
    notes: z.ZodOptional<...>;
    note: z.ZodOptional<...>;
}, z.ZodNumber, ""strip"">
```

Here's a minimal version that can be played with:

```ts
export const Foo = z
	.object({
		str: z.string().optional(),
	})
	.catchall(z.number().optional());
export type Foo = z.infer<typeof Foo>;
const stat: Foo = {}; // Valid, but the hover over types for stat are the zodified version. Hovering Foo gives the nice types.

const res: Foo = Foo.parse({ str: 'foo', bar: 3 }); // perfectly valid, no issues
const foo = res.str; // hover type checks as a string
const bar = res.bar; // hover type checks as a number
```


",,
1912005246,2807,How to use Zod schema with existing TypeScript interface?,"### Discussed in https://github.com/colinhacks/zod/discussions/2796

<div type='discussions-op-text'>

<sup>Originally posted by **adamerose** September 24, 2023</sup>
I see Zod described as a ""TypeScript-first"" library but am struggling to figure out how to actually integrate it with my TypeScript definitions. Is there a way to pass a TypeScript interface to my Zod schema as a generic and have my linter tell me if they're not compatible? 

[This](https://github.com/jquense/yup#ensuring-a-schema-matches-an-existing-type) is how it looks in Yup:
```typescript
import { object, number, string, ObjectSchema } from 'yup';

interface Person {
  name: string;
  age?: number;
  sex: 'male' | 'female' | 'other' | null;
}

// will raise a compile-time type error if the schema does not produce a valid Person
const schema: ObjectSchema<Person> = object({
  name: string().defined(),
  age: number().optional(),
  sex: string<'male' | 'female' | 'other'>().nullable().defined(),
});

// ❌ errors:
// ""Type 'number | undefined' is not assignable to type 'string'.""
const badSchema: ObjectSchema<Person> = object({
  name: number(),
});
```

I found discussion [here](https://github.com/colinhacks/zod/issues/53) and [here](https://github.com/colinhacks/zod/issues/2086) but didn't see any solution I could understand, or relied on codegen and external libraries.

I think something like this might work? But it's very boilerplatey and I don't see anything like this in the docs:
```typescript
interface Person {
  name: string;
  age?: number;
  sex: ""male"" | ""female"" | ""other"" | null;
}

const zodSchema = z.object({
  name: z.string(),
  age: z.number().optional(),
  sex: z.enum([""male"", ""female"", ""other""]).nullable(),
});

type InferredPerson = z.infer<typeof zodSchema>;
function assertType<T>(_value: T) {}
assertType<Person>({} as InferredPerson);
```</div>",,
1910433916,2791,Uncatchable `invalid_union` error,"This code should catch and ignore the error, but it does not. There seems to be no way to catch the error.

```ts
try {
    const schema = z.union( [ z.literal( 1 ), z.literal( 2 ) ] )
    const result = schema.safeParse( 3 )
    !result.success && console.log( result.error.issues )
} catch {
    // do nothing
}
```

```
[
  {
    code: ""invalid_union"",
    unionErrors: [
      159 |     const json = JSON.stringify(obj, null, 2);
160 |     return json.replace(/""([^""]+)"":/g, ""$1:"");
161 | };
162 | class ZodError extends Error {
163 |     constructor(issues) {
164 |         super();
            ^
ZodError: [
  {
    ""received"": 3,
    ""code"": ""invalid_literal"",
    ""expected"": 1,
    ""path"": [],
    ""message"": ""Invalid literal value, expected 1""
  }
]
 errors: [
  {
    ""received"": 3,
    ""code"": ""invalid_literal"",
    ""expected"": 1,
    ""path"": [],
    ""message"": ""Invalid literal value, expected 1""
  }
]

      at new ZodError (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:164:8)
      at /home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:2589:75
      at map (:1:20)
      at _parse (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:2589:32)
      at _parseSync (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:624:23)
      at safeParse (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:654:23)
      at /home/jacob/software/bun-sandbox/src/zod.ts:21:19
, 159 |     const json = JSON.stringify(obj, null, 2);
160 |     return json.replace(/""([^""]+)"":/g, ""$1:"");
161 | };
162 | class ZodError extends Error {
163 |     constructor(issues) {
164 |         super();
            ^
ZodError: [
  {
    ""received"": 3,
    ""code"": ""invalid_literal"",
    ""expected"": 2,
    ""path"": [],
    ""message"": ""Invalid literal value, expected 2""
  }
]
 errors: [
  {
    ""received"": 3,
    ""code"": ""invalid_literal"",
    ""expected"": 2,
    ""path"": [],
    ""message"": ""Invalid literal value, expected 2""
  }
]

      at new ZodError (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:164:8)
      at /home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:2589:75
      at map (:1:20)
      at _parse (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:2589:32)
      at _parseSync (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:624:23)
      at safeParse (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:654:23)
      at /home/jacob/software/bun-sandbox/src/zod.ts:21:19

    ],
    path: [],
    message: ""Invalid input""
  }
]
```

```ts
// package.json
{
    ""dependencies"": {
        ""zod"": ""^3.22.2"",
    },
    ""devDependencies"": {
        ""bun-types"": ""latest""
    },
}
```",,
1910412579,2789,Function to create a union of literal dynamically,"Currently, it does not seem to be possible to create a function that does union of literal, like:

```ts
function unionOfLiterals<T extends string | number>(constants: readonly T[]): z.ZodUnion<[ZodTypeAny, ...ZodTypeAny[]]> {
  const literals = constants.map((constant) => z.literal(constant)) as [z.ZodLiteral<T>, ...z.ZodLiteral<T>[]];
  return z.union(literals);
}

const MY_CONSTANTS = ['a', 'b', 1] as const;
const unionType = createUnionType(MY_CONSTANTS);
```

This code gives the following typing error:

```
Argument of type '[ZodLiteral<T>, ...ZodLiteral<T>[]]' is not assignable to parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
  Source provides no match for required element at position 1 in target.ts(2345)
```

And a call to this method returns a z.ZodUnion<[ZodTypeAny, ...ZodTypeAny[]]> object.

Providing the constants directly is straightfoward:
```ts
z.union([z.literal('a'), z.literal('b'), z.literal(1)])
```

If that was possible, it would enable several use cases for using solely zod for API input validation. Now I end up losing typing when doing that indirectly.

Amazing library, by the way.",,
1910398393,2788,How to use Zod schema with existing TypeScript interface?,"I see Zod described as a ""TypeScript-first"" library but am struggling to figure out how to actually integrate it with my TypeScript definitions. Is there a way to pass a TypeScript interface to my Zod schema as a generic and have my linter tell me if they're not compatible? 

[This](https://github.com/jquense/yup#ensuring-a-schema-matches-an-existing-type) is how it looks in Yup:
```typescript
import { object, number, string, ObjectSchema } from 'yup';

interface Person {
  name: string;
  age?: number;
  sex: 'male' | 'female' | 'other' | null;
}

// will raise a compile-time type error if the schema does not produce a valid Person
const schema: ObjectSchema<Person> = object({
  name: string().defined(),
  age: number().optional(),
  sex: string<'male' | 'female' | 'other'>().nullable().defined(),
});

// ❌ errors:
// ""Type 'number | undefined' is not assignable to type 'string'.""
const badSchema: ObjectSchema<Person> = object({
  name: number(),
});
```

I found discussion [here](https://github.com/colinhacks/zod/issues/53) and [here](https://github.com/colinhacks/zod/issues/2086) but didn't see any solution I could understand, or relied on codegen and external libraries.

I think something like this might work? But it's very boilerplatey and I don't see anything like this in the docs:
```typescript
interface Person {
  name: string;
  age?: number;
  sex: ""male"" | ""female"" | ""other"" | null;
}

const zodSchema = z.object({
  name: z.string(),
  age: z.number().optional(),
  sex: z.enum([""male"", ""female"", ""other""]).nullable(),
});

type InferredPerson = z.infer<typeof zodSchema>;
function assertType<T>(_value: T) {}
assertType<Person>({} as InferredPerson);
```",,
1910194189,2787,Zod email validation blocks the main thread in version 3.22.2,"Here is the version 3.21.4 of Zod:


https://github.com/colinhacks/zod/assets/56435044/0cb44a0c-90ac-486d-a435-a44590234c1b

And here is the version 3.22.2:


https://github.com/colinhacks/zod/assets/56435044/64ec1f54-3c08-4f7b-a159-96d4fc9a9510

here is the demo code:

```svelte
<script>
    import { z } from 'zod';

    let emailVal = '';

    let success;
    let counter = 0;

    $: {
        success = z.string().email().safeParse(emailVal).success;
        counter++;
    }
</script>

<input type=""text"" bind:value={emailVal} />
<p>success: {success} | {counter}</p>

```

and I also tried something like this:

```svelte
<script>
    import { z } from 'zod';
    import { onMount } from 'svelte';

    onMount(() => {
        console.log(z.string().email().safeParse('a'.repeat(50)).success);
    });
</script>
```

Both of them blocks the main thread and the second code doesn't even let me to see the page.

When I opened the performance tab in devtools I noticed it is doubling the time it takes the complete the task every time when I enter a new character to the input.

![chrome_yMIe5E2Et1](https://github.com/colinhacks/zod/assets/56435044/371295ce-0672-41b8-8f19-b41bf652bb0e)

| task | time     |
|------|----------|
| 1    | 10ms     |
| 2    | 19.33ms  |
| 3    | 38.42ms  |
| 4    | 75.17ms  |
| 5    | 151ms    |
| 6    | 299.96ms    |
| 7    | 598.56ms |
| 8    | 1.21s    |",,
1908968112,2762,keep undefined values in .record(),"### Discussed in https://github.com/colinhacks/zod/discussions/2760

<div type='discussions-op-text'>

<sup>Originally posted by **DanielHoffmann** September 22, 2023</sup>
is there a way where I can type a record while keeping the keys that have `undefined` as a value?

For example, how could I set up this schema so this test passes?

```typescript
  import { z } from 'zod'
  test('allow undefined values', () => {
    const keySchema = z.string().startsWith('_')
    const valueSchema = z.union([z.number(), z.undefined()])
    const schema = z.record(keySchema, valueSchema)
    expect(
      Object.keys(
        schema.parse({
          _test: undefined,
        }),
      ),
    ).toEqual(['_test'])
  })
```

in this case the `Object.keys(schema.parse(...))` is returning empty array

Could this be a bug? For example, this tests passes:

```typescript
import { z } from 'zod'
test('allow undefined values', () => {
    const schema = z.object({
      a: z.union([z.number(), z.undefined()]),
    })
    expect(
      Object.keys(
        schema.parse({
          a: undefined,
        }),
      ),
    ).toEqual(['a'])
})
```

I would kind of expect `.record()` and `.object()` to behave the same in regards to the values</div>",,
1908589741,2759,Type error when using `transform()` together with an explicit type,"It seems that when you use `transform()` with an explicit type, the transformed type is not used, and you get a type error.

``` typescript
import { z } from ""zod"";

const BasePart = z.object({
    foo: z.number().transform(number => number.toString())
});

// The inferred type here is correct: `foo` is given type `string`
type WholeType = z.infer<typeof BasePart> & {
    bar: WholeType
}

// Type error: `foo` is seen as a number instead of a string (it is not using the transformed type)
const RecursivePart: z.ZodType<WholeType> = BasePart.extend({
    bar: z.lazy(() => RecursivePart)
})

// I found the error when following the example for a recursive type (shown above), but it can be shown more trivially:
type NonrecursiveType = z.infer<typeof BasePart> & {
    bar: number
}

// Same type error
const NonrecursivePart: z.ZodType<NonrecursiveType> = BasePart.extend({
    bar: z.number()
})

// But this is fine
const ImplicitType = BasePart.extend({
    bar: z.number()
})

/* 
Gives the correct type:
{
    foo: string;
    bar: number;
}
*/
type ImplicitType = z.infer<typeof ImplicitType>;

```",,
1907623256,2756,Having an issue with a discriminatedUnion,"I haven't found this asked anywhere so I'm trying to figure out if this is possible.
Sorry if this has been asked/answered before but I'm having a hell of a time getting this to work.

```ts
export const ContactUsFormSchema = z.discriminatedUnion(formIds.whatIsYourRequestAbout, [
  z.object({
    whatCanWeHelpYouWith: z.nativeEnum(WhatCanWeHelpYouWith),
    whatIsYourRequestAbout: z.literal(Core.ICantAttendAnUpcomingCoresession),
    whichCoreSessionWillYouMiss: z.string(),
    reason: z.nativeEnum(AbsentReason),
  }),
  z.object({
    whatCanWeHelpYouWith: z.nativeEnum(WhatCanWeHelpYouWith),
    whatIsYourRequestAbout: z.nativeEnum(WhatIsYourRequestAbout),
    tellUsMoreAboutYourRequest: z.string(),
  }),
]);
```
If `whatIsYourRequestAbout` is a specific value I need a different object(first in the list).  
Otherwise I can accept any value from the WhatIsYourRequestAbout emum and apply the 2nd object.

Current error I'm getting when I select anything other than `Core.ICantAttendAnUpcomingCoresession` for `whatIsYourRequestAbout`:
```ts
{
    ""whatIsYourRequestAbout"": {
        ""message"": ""Invalid discriminator value. Expected 'I can't attend an upcoming core session' | 'Billing' | 'NominatingAColleague' | 'UpdatingMyProfile' | 'MyMembershipStatus' | 'CommunityGuidelines' | 'ChiefSwag' | 'ChiefsEmailCommunications' | 'Sponsorship' | 'GeneralMembership' | 'ZoomLinkForACoreMeeting' | 'CorePolicies' | 'ChangingCoreGroups' | 'ASuggestionToImproveCore' | 'GeneralCoreQuestion' | 'NeedToCancelARSVP' | 'ZoomLinkForAnEvent' | 'FeedbackForAnEvent' | 'SuggestionForAnEvent' | 'GeneralEventQuestion' | 'ModifyingAMeetingRoomReservation' | 'GeneralQuestionAboutTheClubhouse' | 'FeedbackAboutAClubhouse' | 'SuggestionForTheWebsite' | 'ReportAWebsiteBugOrIssue' | 'GeneralWebsiteQuestion' | 'SuggestionForTheMobileApp' | 'ReportAMobileAppBugOrIssue' | 'GeneralMobileAppQuestion' | 'BoardServices' | 'ChiefsEditionalServices' | 'ExecutiveCoaching' | 'ChiefsPartnerships' | 'AQuestionAboutMyCoreGroupOrGroups' | 'MemberAttendance' | 'ZoomSupport' | 'ReportAGuidePortalBugOrIssue' | 'ContentOrAGroupExercise'"",
        ""type"": ""invalid_union_discriminator"",
        ""ref"": {}
    }
}
```

I'm using `zod` with `react-hook-form`'s `zodResolver`.

Any hints or insight would be greatly appreciated.  
Would I need to break out the 2nd `z.object` in to an object for each of the possible options?",,
1899805812,2746,ZodRecord.create ZodType checking issue,"Hi, I have a use case in which I use Zod internally in my JS library, but I also want users to be able to use Zod to define plugins for the library (defined externally to my NPM package).

I have run into an issue where ZodRecord.create() results in unexpected behavior due to this `if` statement:

https://github.com/colinhacks/zod/blob/28c19273658b164c53c149785fa7a8187c428ad4/src/types.ts#L3409

The `instanceof ZodType` check fails due to having two independent ""copies"" of Zod: the one internal to my JS library, and one in userland. The user then ends up with `z.record(z.string(), first)` but they expected `z.record(first, second)`.

Observable notebook with minimal reproducer: https://observablehq.com/d/25a9954667141376

Perhaps there is a better way to check for the second parameter being a Zod schema that would work across multiple independent copies of Zod imports.
",,
1899563531,2745,Is it possible to get previous errors in superRefine,"When using superRefine on a zod object, is it possible to know which fields validation failed in the object?

Here is an example where I want to ensure that some fields are as expected before doing additional checks : 

```typescript
export const EMAIL_SCHEMA = DEFAULT_SCHEMA.merge(
	z.object({
		type: z.literal(FormElementTypes.EMAIL),
		default_value: z.string().email().optional(),
		domain: z
			.string()
			.regex(/^([a-z]+\.){1,3}[a-z]{2,3}$/)
			.optional(),
	})
).superRefine(({ default_value, domain }, ctx) => {
        // here we are not sure if default_value and domains match expected format
        // doing format checked once more here would be overkill
	if (default_value && domain && !default_value.endsWith(domain)) {
		ctx.addIssue({
			code: z.ZodIssueCode.invalid_string,
			message: 'Invalid',
			path: ['default_value'],
			validation: 'email',
		});
	}
});
```
it is possible to do so?? if so, how to achieve it? else, does a workaround exist?",,
1899473992,2744,JsDoc `@deprecated` is not included in the build files,"In previous commits ([1](https://github.com/colinhacks/zod/pull/440), [2](https://github.com/colinhacks/zod/commit/347332c30b801c608ea29c89f61f0247a953bb83)) `ZodString.nonempty` was marked as `@deprecated` but when I use it, the IDE doesn't cross out it. 
I doubled-checked the code, it's done perfectly

https://github.com/colinhacks/zod/blob/28c19273658b164c53c149785fa7a8187c428ad4/src/types.ts#L979-L984

However, upon inspecting the file in my `node_modules`, I could not locate the `@deprecated` annotation. [Please refer to line 200 in `zod/lib/types.d.ts` for verification](https://www.npmjs.com/package/zod?activeTab=code)

It seems like an issue with the build options.",,
1899146167,2743,Zod Preprocess returning unknown type,"This preprocess method:

```ts
IBAN: z.preprocess(
    (v: string): String => v.replace(/[ \_]/g, """"),
    z.string().toUpperCase().min(15).max(34)
  ),
```

returns unknown type instead of string.

Zod version: 3.22.2",,
1899144961,2742,Cannot read properties of undefined (reading 'coerce'),"My error is suspiciously similar to https://github.com/colinhacks/zod/issues/1193, but there are no circular dependencies. Also, this error only occurs inside vitest, and I'm seeing it as a result of converting my project from jest to vitest.

My code as as follows:

```ts
import React from 'react';
import { FormattedNumber } from 'react-intl';
import { z } from 'zod';

/** The input is a number and is not NaN. */
export const realNumberSchema = z.coerce.number().refine(n => !isNaN(n));

// ...more functions
```

I'm not sure if this is a problem in zod, vitest, or just my configuration.",,
1898790194,2740,Generate zod schema code from schema already defined,"Hello there!!

My use case is pretty specific. I wont to use `drizzle-orm` and `drizzle-zod` to generate insert schemas. I would like to use the schema in the server side and the client side.

The problem is that if I import the zod schema definition from the client side I get all the database dependencies.

```typescript
import { pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core'
import { createInsertSchema } from 'drizzle-zod'

const usersTable = pgTable('users', {
    id: uuid('id').primaryKey().defaultRandom(),
    createdAt: timestamp('created_at').notNull().defaultNow(),
    email: text('email').notNull().unique(),
})

const insertUserSchema = createInsertSchema(usersTable, {
    id: (schema) => schema.id.uuid()
})

const insertUserCommandSchema = insertUserSchema.pick({ email: true })
```

If I try to import the `insertUserCommandSchema` to perform client-side validations I am getting all the server side stuff. That make sense.


Is it possible to generate the `zod` schema definition code from `insertUserCommandSchema`? Is there any tool that can achieve this?

Thanks in advance!!
",,
1898256257,2739,Extend zod.object() with zod.record(),"Hey,

I know that the request most likely sounds awkward, but my goal is to enforce specific keys on an object and allow further unknown keys with a limited set of value types. My typescript type representing my goal looks like this:

```ts
declare type PasteEnvironment = {
    operatingSystem: {
        name: string
        version: string
        architecture: string
    },
    javaVirtualMachine?: {
        name: string
        vendor: string
        version: string
    }
} & { [key: string]: CustomMetadataValueType }

declare type CustomMetadataValueType = string | number | boolean | string[] | number[]
```

My attempt was the following:
```ts
export const CreatePasteSchema = zod.object({
    application: zod.object({
        name: zod.string(),
        version: zod.string()
    }).required(),
    environment: zod.object({
        operatingSystem: zod.object({
            name: zod.string(),
            version: zod.string(),
            architecture: zod.string()
        }).required(),
        javaVirtualMachine: zod.object({
            name: zod.string(),
            vendor: zod.string(),
            version: zod.string()
        }).optional(),
    }).extend(
        zod.record(
            zod.string(),
            zod.union([zod.number(), zod.string()])
        )
    ).required()
})
```

Sadly Sadly zod.extends want's a RawZodShape which requires defined keys - therefor that does not work and creates an typescript error:
<img width=""826"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/27054324/34083a3c-5a54-4ab7-9984-27309c826b61"">

Is there any possibility to achieve my goal somehow?",,
1898152421,2738,z.enum with default give type incompatibility,"I'm trying to create a mutually recursive type, but on one of both types, I have an enum with a default value that gives me a type compatibility error. Check the following code:

```javascript
export const pricePlainSchema = z.object({
  productId: z.string().uuid(),
  id: z.string().uuid(),
  status: z.enum(['active', 'archived']).default('active'),
  name: z.string(),
  price: number,
  duration: z.number().optional(),
  created: z.string().datetime(),
  updated: z.string().datetime(),
});

export const productPlainSchema = z.object({
  id: z.string().uuid(),
  productId: z.string().uuid(),
  status: z.enum(['draft', 'published', 'archived']).default('draft'),
  name: z.string(),
  created: z.string().datetime(),
  updated: z.string().datetime(),
});

export type Price = z.infer<typeof pricePlainSchema> &{
  product?: Product;
}

export type Product = z.infer<typeof productPlainSchema> & {
  price?: Price;
};

let priceSchema : z.ZodType<Price>;
export const productSchema: z.ZodType<Product> = productPlainSchema.extend({
  price: z.lazy(()=>priceSchema.optional())
});

priceSchema = pricePlainSchema.extend({
  product: productSchema.optional()
})
```
I'm having the next errors in the productSchema definition

> Les types de la propriété 'status' sont incompatibles.
          Impossible d'assigner le type '""draft"" | ""published"" | ""archived"" | undefined' au type '""draft"" | ""published"" | ""archived""'.
            Impossible d'assigner le type 'undefined' au type '""draft"" | ""published"" | ""archived""'.

Similar for the price schema:

> Les types de la propriété 'status' sont incompatibles.
          Impossible d'assigner le type '""archived"" | ""active"" | undefined' au type '""archived"" | ""active""'.
            Impossible d'assigner le type 'undefined' au type '""archived"" | ""active""'

If I remove the default construct, i have no error, so the problem is that when an attribute has a default construct the type generated should mark it as optional, and not mandatory as it is doing now.

Even more, If I create the types manually as follows, it works like a charm too (you can see that the attributes with default are defined as optional), but it is not the idea to build the types manually
```javascript
export type Price = {
  productId: string;
  id: string;
  status? : 'active' | 'archived';
  name: string;
  duration?: number;
  created: string;
  updated: string;
  product?: Product;
}

export type Product = {
  id: string;
  productId: string;
  status?: 'draft' | 'published' | 'archived';
  name: string;
  created: string;
  updated: string;
  paymentOffer?: PaymentOffer;
};
``` ",,
1895535313,2735,[Question] How to describe a RegExp object?,"So I'm building a config schema for my tool, and I'd like it to have a regex option for pattern matching.

This is the type I'm trying to get from Zod schema:

```typescript
interface Config {
  ...

  exclude: (string | RegExp)[]

  ...
}
```

I'm using Zod for like two days now, so my experience with it is near zero. My google searches did not return any meaningful results for my usecase, so help would be appreciated",,
1894859759,2734,"Properties with Symbol keys are stripped from objects, even with passthrough()","TL;DR Properties with symbol keys are stripped from objects regardless of the object shape.  

`ZodRawShape` is defined as `[k: string]: ZodTypeAny` but according to Typescript rules, this [does not mean that a passed object should only have string keys](https://github.com/microsoft/TypeScript/issues/53265).  I think this is why Zod allows the object shape but then doesn't handle the presence of Symbol keys.

Therefore there should probably, at least, be a runtime exception to indicate that they are not handled.

```ts
const bar = Symbol('bar')

const Schema = z.object({
  foo: z.string(),
  [bar]: z.string()
})

const input: z.infer<typeof Schema> = {
  foo: 'foo',
  [bar]: 'bar',
}

const output = Schema.parse(input)
```

Results in:

```js
{
  foo: 'foo'
}
```

It seems that symbol keys are ignored in the object specification, as `z.string().default('bar')` also does not result in there being a property for `Symbol(bar)` with value `bar` in the output.

This also happens if the symbol property is included or omitted, and the schema has `.passthrough()` added.
",,
1894771510,2733,Question: is it possible to create a schema for a recursive structure that also use generic parameter?,"Is it possible to create a zod schema for the following type?
```ts
export interface GroupItem<T> {
  key: unknown;
  items: GroupItem<T>[] | T[] | null;
  count?: number;
  summary?: unknown[];
}
```

I cannot wrap my head around how to define the ""items"" property with zod.",,
1893922060,2732,Unable to create an object with readonly property,"Possibly related to #728, but without the need for recursive application to the object properties. 

```
z.object({
  id: z.string().readonly(),
  description: z.string(),
})
```

As of Zod 3.22.2, syntactically this is acceptable, but based on the description of `readonly()` it probably should not apply to primitive types).  The resulting type drops the `readonly` and gives `{ id: string, description: string }`.

I also tried an intersection of objects:

```
z.intersection(
  z.object({ id: z.string() }).readonly(),
  z.object({ description: z.string() })
)
```

But this oddly gives `{ id: any, description: string }`, thus losing both the type and the `readonly` protection.

In my application, I have entities where the ID should not be changed (storage requires the old entity to be deleted and one with a new identity created).  Zod is preventing me from creating a schema that enforces this.

The only way I can figure out how to set the `id` to be readonly is to cast the return type from `parse`, e.g:

```
schema.parse(input) as (z.infer<typeof schema> & { readonly deviceId: string })
```

or to create a type from the schema with a similar union:

```
type X = z.infer<typeof schema> & { readonly deviceId: string }
```

which seems like a total fudge.


",,
1893497561,2729,How to workaround type export when schema is defined inside the component (blocked scope)?,"Imagine this case:

Is there any smooth way to workaround this? I believe this is a common case, how can I export the type for other modules to use?

```tsx
const MyComponent = (): JSX.Element => {
  type SchemaType = z.output<typeof schema> // ⚠️I can only define it here because the schema is block-scoped

  const { data: existingEmails } = useQuery(...) // fetch data dynamically

  // Schema can only be defined here due to usage of scoped variable existingEmails in the schema
  const schema = z.object({
    email: z.string().email()
      .refine(val => !existingEmails.includes(val))
  })

  return <div>...</div>
}

export type { SchemaType } // ⚠️This won't work due to SchemaType is block-scoped
```",,
1890832077,2726,[Question/Help Needed] Can you infer a generic ZodObject from a generic ZodRawShape in an interface?,"👋  Hello! 

I have an interface that looks like this (I'm on TypeScript v4.9.5):

```ts
import { z } from 'zod';

export interface Endpoint<T extends z.ZodRawShape> {
  args?: (schemaTypes: typeof z) => T;
  fx: {
    (
      ctx: Context<
        ReturnType<typeof z.object<ReturnType<Required<Endpoint<T>>['args']>>>
      >,
      next?: any
    ): any;
  };
}
```

Here's an example of its usage:
```ts
return {
  args({ string }) {
    return {
      email: string().email(),
      password: string().min(8),
    };
  },
  fx(ctx, next) {
    const { email, password } = ctx.requestContext.args;
    // ...
  },
};
```

^ It represents an endpoint that is encapsulated in an object and is handled by the `fx` key. The arguments *for* that endpoint come from the `args` key.

Now here's what `Context` looks like:

```ts
interface Context<T extends z.ZodTypeAny = any> {
  requestContext: {
    args: z.infer<T>;
  };
}
```

`ctx.requestContext.args` is being inferred as:
```ts
RequestContext<ZodObject<any, ""strip"", ZodTypeAny, { [x: string]: any; }, { [x: string]: any; }>>.args: {
  [x: string]: any;
}
```

So when I hover over the `email` or `password` keys, their type is `any`. Is there a way to dynamically infer their type?


Thank you for your help 😃 ",,
1889789458,2724,wrap internal errors from `preprocess` and `refine`,"As [explained here](https://github.com/colinhacks/zod/issues/2401) zod intentionally does not catch errors from within `preprocess` and `refine`.

> This is behaving as intended currently. An error in a refinement is considered an application-level bug, not a validation error. The thinking is that catching this error in Zod would make it harder to debug actual real-life bugs, and you can always use try/catch. But if Zod catches these errors, there's no way to opt-out of this and allow errors to bubble up.

However, consider this schema:
```typescript
z.object({ a: z.array(z.object({ b: z.preprocess(data => { throw new Error('asdf') }, z.date()) }))}).parse({a: [{}]})
```
The error will be:
```
Uncaught Error: asdf
    at Object.transform (REPL12:1:66)
    at ZodEffects._parse (/node_modules/zod/lib/types.js:2137:38)
    at ZodObject._parse (/node_modules/zod/lib/types.js:1070:37)
    at ZodObject._parseSync (/node_modules/zod/lib/types.js:109:29)
```

This makes it difficult to know where the error came from.
Consider an object schema with many properties (that may also be nested) - if I get this error I don't know which property caused it.

In contrast, the regular zod parsing errors are amazing:
```typescript
z.object({ a: z.array(z.object({ b: z.date()})) }).parse({a: [{}]})
```
Error:
```json
[
  {
    ""code"": ""invalid_type"",
    ""expected"": ""date"",
    ""received"": ""undefined"",
    ""path"": [
      ""a"",
      0,
      ""b""
    ],
    ""message"": ""Required""
  }
]
```
It tells me exactly the path to the problem in my object.

### Proposed solution
I propose that zod will catch my internal error and wrap it in a zod error (and re-throw it) that will at least tell me where the error occurred in the object.

For example something like:
```typescript
z.object({ a: z.array(z.object({ b: z.preprocess(data => { throw new Error('asdf') }, z.date()) }))}).parse({a: [{}]})
```
Expected error:
```json
[
  {
    ""code"": ""preprocess_error"",
    ""path"": [
      ""a"",
      0,
      ""b""
    ],
    ""message"": ""Uncaught Error: asdf"",
    ""originalError"": <the original error object>
  }
]
```",,
1887360746,2721,Is there another good way to avoid checking for hidden elements at submitting?,"When using useForm,I'd like to use a specific check rule based on the page element being shown and hidden, but I can't move forward with this error,or is there another good way to avoid checking for hidden elements at submitting,How to make `shouldUnregister` take effect in zod?

<img width=""627"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/105040671/d480330b-7320-4db5-9bf9-1219e94a2da2"">
Error:There should be 3 parameters, but getting 1,types.d.ts(13, 74): no independent variable for ""context"" provided.
<img width=""611"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/105040671/8941bc0c-5df2-4596-8a7d-ce6ef923a96a"">
",,
1886094777,2718,Update to Custom Schemas example in Documentation,"Hi, 

I'm interested in updating the Custom Schemas example in the documentation.  The function type takes in an unknown, so the example casts the value to a string in order to operate on it with a RegExp

```typescript
const px = z.custom<`${number}px`>((val) => {
  return /^\d+px$/.test(val as string);
});
```

I want to propose using Type Narrowing. It's helped me catch errors from validating a non-expected type, and I believe it would help others as well as a good practice with interacting with the unknown type.

```typescript
const px = z.custom<`${number}px`>((val) => {
  return typeof val === ""string"" ? /^\d+px$/.test(val) : false;
});
```

Please let me know if this is a welcome change.  I can make a fork of the repo and create a PR!",,
1884416613,2715,Zod schema.parse method return Partial object (every field is nullable) in nestjs app,"Suppose a user schema as follows
```js
import { z } from ""zod"";

const UserSchema = z.object({
  name: z.string(),
});

type User = z.infer<typeof UserSchema>;
```

Here type **User** is equivalent to

```js
type User = {
    name?: string;
}
```

instead of 
```js
type User = {
    name: string;
}
```

What is wrong with zod here, I want name field to be non nullable but it is not here? It works pretty much fine on both simple **nodejs app** and **deno**, but it does not work in **nestjs** app.

## Steps to reproduce

1. Create a new nest app
```terminal
nest nest testzod
```

2. create a schema file with user schema
```js 
import { z } from ""zod"";

const UserSchema = z.object({
  name: z.string(),
});

type User = z.infer<typeof UserSchema>;
```

3. Check it

 ",,
1879103283,2706,Regex not working as expected,"I'm trying to add a validator to ensure keys of records are written in camel case. The regex works as expected when used directly, but within the schema parser, it doesn't behave the same.

I wrote a test to illustrate.

```ts
import { z } from 'zod'

const REG = /^[a-z]([A-Za-z0-9]+)$/

const schema = z.record(
  z.string(),
  z.string().regex(REG, 'Key must be camelCase'))

describe('Zod Regex', () => {

  // Valid camelCase strings

  it('should idenfify valid camelCase strings directly', () => {
    expect(REG.test('camelCase')).toBe(true)
    expect(REG.test('camel')).toBe(true)
    expect(REG.test('camelCaseId')).toBe(true)
    expect(REG.test('camelCaseID')).toBe(true)
  })

  it('should parse zod record with valid camelCase keys', () => {
    expect(() => schema.parse({ camelCase: 'value' })).not.toThrow()
    expect(() => schema.parse({ camel: 'value' })).not.toThrow()
    expect(() => schema.parse({ camelCaseId: 'value' })).not.toThrow()
    expect(() => schema.parse({ camelCaseID: 'value' })).not.toThrow()
  })

  // Invalid camelCase strings

  it('should idenfify invalid camelCase strings directly', () => {
    expect(REG.test('CamelCase')).toBe(false)
    expect(REG.test('camel_Case')).toBe(false)
    expect(REG.test('camelCase_')).toBe(false)
    expect(REG.test('CAMEL_CASE')).toBe(false)
    expect(REG.test('_camelCase')).toBe(false)
  })

  it('should throw error when parsing zod record with invalid camelCase keys', () => {
    expect(() => schema.parse({ CamelCase: 'value' })).toThrow()
    expect(() => schema.parse({ camel_case: 'value' })).toThrow()
    expect(() => schema.parse({ camelCase_: 'value' })).toThrow()
    expect(() => schema.parse({ CAMEL_CASE: 'value' })).toThrow()
    expect(() => schema.parse({ _camelCase: 'value' })).toThrow()
  })
})
```

The test fails during the first expect of the last test:
```
expect(() => schema.parse({ CamelCase: 'value' })).toThrow()
```

Am I using it the wrong way? I know with the `record` type, values go first, opposite of how TS generics work. I've tried it both ways just to be sure.

Using the latest version of Zod `3.22.2`, and Node `16.14.2`, but the same results under different node versions 18 and 20.
",,
1876421029,2698,Skypack error on 3.19+,"Perhaps related to https://github.com/colinhacks/zod/issues/965 although it's a different error message.

Importing zod@3.18 and earlier works fine: https://codepen.io/luisfarzati/pen/RwERpMg

Importing zod@3.19 and newer fails, the console shows:

```
""[Package Error] 'zod@v3.19.0' could not be built. 
[1/5] Verifying package is valid…
[2/5] Installing dependencies from npm…
[3/5] Building package using esinstall…
Running esinstall...
Cannot find module 'zod/locales/en.d.ts'""
```

https://codepen.io/luisfarzati/pen/rNoLyrB
",,
1875953739,2697,Zod 3.22.2 TS 5.2.2: TS2589: Type instantiation is excessively deep and possibly infinite,"```ts
const EventSchema = z.union([
  z.object({
    action: z.enum(['create', 'drop', 'update', 'hydrate']),
  }),
  z.object({
    action: z.literal('rollback'),
    tag: z.string().optional().default('initialState'),
  }),
]);
```

Error: ` src/handler.ts(64,3): error TS2589: Type instantiation is excessively deep and possibly infinite` 

Related  (both closed): #495 and #577 

Tried rimraf node modules and reinstalling. That type seems so simple that I don't see what I can do to simplify it. 

Is there a playground that I can pull Zod into to reproduce it? ",,
1875628009,2696,Extract the inferred type is not working as expected,"In documentation says that we can infer the type from a schema like this:

![image](https://github.com/colinhacks/zod/assets/32942055/f4152ac1-d07d-45a4-834d-04ff9b412ae7)

But when I try this with the example above, I was expecting attributes required by default and optional only for those I set as optional...
```
import { z } from 'zod';

export const createDiscountCouponSchema = z.object({
  accountId: z.number().optional(),
  coupon: z.string(),
  additionalDiscount: z.number(),
  expirationDate: z.date(),
  status: z.string(),
  campaign: z.string().optional(),
});

export type CreateDiscountCouponDto = z.infer<
  typeof createDiscountCouponSchema
>;
```

however, I'm receiving all attributes as optionals, 

![image](https://github.com/colinhacks/zod/assets/32942055/0a3ee60e-26f6-46e2-93bd-f265872bdb0f)

is that right?

I'm using zod ```3.22.2``` and typescript ```5.0.3```",,
1870070988,2691,How to make ZodUnion from a enum?,"Imagine we have an API where some types are list of options. It can be done via enums, arrays or objects. Here's a enum example:

```ts
enum color {
  red = ""red"",
  green = ""green"",
};
```

Imagine also, that we have to validate user input. Using Zod we can create a schema:

```ts
const colorSchema = z.union([z.literal(""red""), z.literal(""green"")])
```

and then use it for validation:

```ts
const color = colorSchema.parse(userInput)
      //^? color: ""red"" | ""green""
```

The problem with this approach is that we're breaking the DRY principle: we have to repeat every value from every enum from the API, which brings even bigger problem with keeping it up to date. If a new color gets added to the enum, how will our schema know about it? There is no way. So the only solid way to do it, is to convert **enums to z.unions**.

However, I couldn't figure out how to do this.
`z.union()` accepts an array of literals, but I cannot find a solution how to create `ZodUnion` from a enum. 

Here are a couple of sandboxes, that differ only in the way how options are defined:
- [using enum](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFA9NXAIIAKAkgFxwDuApnABYCGANx4BnXDybNOvYAGNecKFxgBXKADsRcGLy4guWgEYBPOLIgAbaHGDERVLupV5zVqIgpxFXYnAC8BEqkADSecADmSo7+BJFcjvihaJQwxmA8AMKW0My+AQDWXMYQmNppXCVm2VBUqelwACq6+gBKXACOKgbwAQhhrjnE7FluuZTJVMRcshb8Slgq6rIwwBDqEcpNelz0YMAAFErt7FutHV0iMACU7PzqxpQ0dADKGQASAKIAsvTshirwbhwdTxHzaCBwQT8Cy2fgwHgqERcdzAdRgAFwfbYXBmGFYaxcAAe-HAFi4Nyo5k08AGUDanW6z3ken4MWQADoIIYAFbTGD7PpeWm5dgcxardT7ADaHJh8Kg0P2+CC+CuwRQ7LlyMV+DiCSuAF01XBaHAAFQWihoK6PU0AVWe9AA4h92GSYAByLQcKDAeFwMT6KpTKiYRbLCUbGCnLj7YVDAMwX3qcJXDxCtaXbwMrMBWn0i4wJnNfjssBzJECqqjXzWyheBsN2gAPQA-GFwptmjs9odzt0bVaKEA)
-  [using object](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFA9NXAIIAKAkgFxwDuApnABYCGANx4BnXDybNOvYAGNecKFxgBXKADsRcGLy4guWgEYBPOLIgAbaHGDERVc5vjmrUOAF5EFOIq7F2+EqkADTecADmSlzqAZFc0fihGPxajiIwlDDGYDwAwpbQzMQecAAUWTkQmGYFUACUANoA1lzGVdrZXO0u0AC6lBQVPAAquvoASlwAjioG8J4IYT1QRez5rkWUaAPEXLIW-EpYKuqyMMAQ6hHKo3pc9GDApUpT7LcT07Ppdez86sYDWhwADKuQAEgBRACy9HYhhU8G4cHU8T82ggcEE-Astn4MB4KhEXDcwHUYARZWwuDMOKw1i4AA9+OALFwfg5Lukaq5JjM5sD5Hp+CVkAA6CCGABWexgpUWPmWqxQopOF3UpQaYpx+Kg2NKgT8+DqwWV2uJevwcQSdV6xrgQIAVE6KGg6oC6ABVYH0ADiEPYrJgAHItBwoMB8XAxPoarsqJgTmc1dcYO8uKVFf4ozBw+pwnUvArOfAXl95tzoLyywKxvxRWBDkS5RWVsVXZQfJ3O7QAHoAfjC4RuY3uj2enzmbpdFCAA)

Check out the `***`-marked lines.




",,
1869457393,2689,`string().array().or(record(any()))` as key in `object()` has wrong type,"Works fine:
```ts
const test = string().array().or(record(string()));
type Test = z.infer<typeof test> // string[] | Record<string, string>
```

Don't work:
```ts
const test = object({ values: string().array().or(record(string())) });
type Test = z.infer<typeof test>; // { values: (string[] | Record<string, string>) & (string[] | Record<string, string> | undefined); }
```",,
1869062588,2687,Preprocessing hides errors in zod 3.22.x,"Consider this piece of code:

```typescript
import { z } from ""zod"";

const zodStringWithPreprocess =
  // Notice that in this simplified example, the preprocessing does nothing
  z.preprocess((val) => val, z.string()) as z.ZodEffects<
    z.ZodString,
    string,
    string
  >;

const validatorWithoutPreprocess = z.object({
  name: z.string(),
  town: z.string(),
});

const validatorWithPreprocess = z.object({
  name: zodStringWithPreprocess,
  town: zodStringWithPreprocess,
});

const dataToValidate = {};

const parsedWithoutPreprocess =
  validatorWithoutPreprocess.safeParse(dataToValidate);
console.log(""Without preprocess"");
console.log(JSON.stringify(parsedWithoutPreprocess, null, 2));

const parsedWithPreprocess = validatorWithPreprocess.safeParse(dataToValidate);
console.log(""With preprocess"");
console.log(JSON.stringify(parsedWithPreprocess, null, 2));
```

# Expected behavior


In Zod 3.21.4, the result is the same regardless of preprocessing:

```
Without preprocess
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""name""
        ],
        ""message"": ""Required""
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""town""
        ],
        ""message"": ""Required""
      }
    ],
    ""name"": ""ZodError""
  }
}
With preprocess
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""name""
        ],
        ""message"": ""Required""
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""town""
        ],
        ""message"": ""Required""
      }
    ],
    ""name"": ""ZodError""
  }
}
```

# Actual behavior

In Zod 3.22.x (x <= 2), the version with preprocessing stops at the first error:

```text
Without preprocess
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""name""
        ],
        ""message"": ""Required""
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""town""
        ],
        ""message"": ""Required""
      }
    ],
    ""name"": ""ZodError""
  }
}
With preprocess
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""name""
        ],
        ""message"": ""Required""
      }
    ],
    ""name"": ""ZodError""
  }
}
```

Notice that the `""expected"": ""string"",` for the `town` property is missing.

It seems to be a regression for Zod.",,
1868451385,2686,Allow number in enums,"It would be helpful to allow numbered enums such as in this example

```typescript
const userMap = {
  1: { name: ""John"" },
  2: { name: ""Bob"" },
};

const ids = Object.keys(prices).map(Number) as [keyof typeof prices];
const idSchema = z.enum(ids);
```

While `""${number}""` could be used to index the userMap, if this were a network request, it would annoyingly also cause the request to format the numbers into strings. Respectively, I think there are valid use-cases where a numbered enum can be helpful.",,
1863027292,2682,Limit valid schema types to things that come from strings,"I think this relates to #2421 and #2519 but I'm filing it separately because I'm not using `z.input` in any way.

I am looking to write a generic function for parsing data, which I know comes in the general form of:

```ts
{
  [K: string]: string | string[] | undefined
}
```

Some of those strings are of course other things, that I want to parse and transform. And so I'm trying to set up a generic function to validate that shape and do type coercion into a more useful shape. Where I want to limit the list of valid values to parsing functions that accept a string as input.

```ts
type ObjectSchema = Record<string, ObjectValue>
// Value must be optional or defaulted, let's flag our future parse error as a type error
type ObjectValue = z.ZodOptional<Inner1> | z.ZodDefault<Inner1>
// Value can either be a primitive or an array of primitives
type Inner1 = Inner2 | z.ZodArray<Inner2>
// Anything we can coerce from a string is fine
type Inner2 = z.ZodType<any, z.ZodTypeDef, string>

const objectSchema: ObjectSchema = {
  // arg0: z.string(), // Type Error, as expected
  arg1: z.string().optional(),
  arg2: z.string().default(""""),
  arg3: z.coerce.number().default(0), // Type Error, is z.ZodNumber, knows nothing of its input type
  arg4: z.string().transform(val => parseInt(val, 10)).optional(), // Works, but not as pretty as the new syntax
  arg5: z.string().array().default([]),
}

type OutputType<T extends ObjectSchema> = z.infer<z.ZodObject<T>>

typeof OutputType<typeof objectSchema> = {
    arg1: string | undefined;
    arg2: string;
    arg3: number; // if it could be included
    arg4: number | undefined;
    arg5: string[];
}
```

I couldn't see anything obvious I could latch onto here to make this work using the new coerce options.",,
1861566286,2678,Default not applied for transform with default,"I've created a transform to perform string coercion without the default zod string coercion that turns null and undefined values into ""null"" and ""undefined"":
```
export const CoerceString = z
  .any()
  .transform((val) => val?.toString())
  .pipe(z.string());
```
When I define an object using this with a default value the default isn't applied, instead the mock has `undefined` as the value:
```
const MyType = z.object({
  a: CoerceString.default(""""),
});
```
In the VSCode debugger I see the value of ""a"" in MyType as ZodDefault, but the mock generator isn't picking up on that.",,
1861378270,2677,zod.preprocess v3.22.2 issues are ignored in case of another error in the model,"Another issue we found in v3.22.2 is that the schema inside `preprocess` either isn't executed or doesn't add issues to the context in case the model being parsed contains an error in another field (`nonNullableObject` below):
```ts
import * as zod from 'zod';

const wrapToArray = <T extends zod.ZodTypeAny>(elementSchema: T) =>
  zod.preprocess((val) => [val], zod.array(elementSchema));

const singleItemSchema = zod.object({
  quantity: zod.number(),
});

const itemsStepSchema = zod.object({
  nonNullableObject: zod.object({}),
  items: wrapToArray(singleItemSchema), // swapping this line with the one below results in correct behaviour (2 issues instead of 1)
  // items: singleItemSchema,       
});

const res = itemsStepSchema.safeParse({
  nonNullableObject: null,
  items: {},
});

//@ts-ignore
console.log(res.error.issues.length);  // 3.21 shows 2 errors, 3.22 - only 1
console.log(res);
```
An error in `nonNullableObject` hides the `preprocess` errors. Also, if I remove the `preprocess` call completely the behaviour becomes correct. This doesn't look right as preprocess stops errors from being populated.
[3.21.4](https://codesandbox.io/s/jolly-yalow-3k6lyg?file=/src/index.ts):
<img width=""404"" alt=""Screenshot 2023-08-21 at 19 06 17"" src=""https://github.com/colinhacks/zod/assets/32125472/fa6c0a7e-ec18-43b9-9b9d-f95e15b44b7a"">

[3.22.2](https://stackblitz.com/edit/typescript-aejujt?file=index.ts):
<img width=""274"" alt=""Screenshot 2023-08-21 at 19 05 12"" src=""https://github.com/colinhacks/zod/assets/32125472/3a241228-08f1-4ee7-9fcf-7d26c368bad9"">",,
1860201512,2674,z.nativeClass(MyClass),"# Problem
Zod solves typing very well, but due to our stack, we have trouble integrating Zod with our existing class-based deserializer code (due to using NestJS default scaffolding).  We need a way to break out of the class-based typing into Zod, implementing the ""strangler pattern"".

# Solution
Implement a schema `z.nativeClass(MyClass)` with similar pattern to `z.nativeEnum(MyEnum)` that reflects out the structure of `MyClass` and ensures that parsed values have compatible shape to `MyClass`.

Note that unlike `z.instanceOf(MyClass)`, `z.nativeClass(MyClass)` does not validate the inheritance change; this is because TypeScript already does not provide this guarantee and therefore it is not typically helpful to assume a class-typed value has a correct inheritance chain. Further, I would expect the schema to be composed with other Object schema methods which would definitely not have a preserved inheritance chain.",,
1859355405,2671,The result of zod.preprocess v3.22.2 is ignored and falls back to the original value inside a further refine,"This code is on [sandbox](https://stackblitz.com/edit/typescript-olfm9s?file=index.ts). We noticed this behaviour in v3.22.2.
```ts
const schema = zod
  .object({
    inactiveObject: zod
      .object({
        isInactive: zod.boolean(),
      })
      .refine(
        ({ isInactive }) => isInactive === false, // <-- This refine fails leading to the preprocess below to be ignored
        { message: 'object is inactive' }
      ),
    arr: zod.preprocess((val) => [val], zod.array(zod.object({}))), // <-- The result of this code is ignored, `arr` remains `val` in the refine below
  })
  .refine(({ arr }) => arr.some((elem) => elem !== null)); // arr.some is not a function

schema.safeParse({
  inactiveObject: {
    isInactive: true,
  },
  arr: {},
});
```
I debugged the code and it turns out the bug occurs [here](https://github.com/colinhacks/zod/blob/792b3ef0d41c144cd10641c6966b98dae1222d82/src/types.ts#L4276):
```ts
if (effect.type === ""preprocess"") {
  const processed = effect.transform(ctx.data, checkCtx);
  if (ctx.common.issues.length) {
      return {
          status: ""dirty"",
          value: ctx.data
      };
  }
...
```
-- the result of `transform` is ignored. This condition was absent in v.3.21.4 which worked fine for the usecase above.",,
1855322771,2665,Signature of superRefine() changed from zod@3.21 to zod@3.22,"With `zod@3.21` the following code was valid:

```
import { z } from ""zod"";

const schema = z.object({
  name: z.string(),
  value: z.string(),
});

const schemaRefine = schema.superRefine((val, _ctx) => {
  return val.value !== 'INVALID';
});
```

After upgrading to `zod@3.22` we are seeing the following typescript error:

```
Type 'boolean' is not assignable to type 'void | Promise<void>'.
```
",,
1854772228,2664,`z.preprocess` ignores `.optional()` modifier,"zod version: 3.17.3

code:
```typescript
const schema = z.preprocess(data => data === '' ? undefined : data, z.number()).optional();

schema.parse(undefined) // works, returns undefined
schema.parse('') // throws
```

However, this works:
```typescript
const schema = z.preprocess(data => data === '' ? undefined : data, z.number().optional());
schema.parse(undefined) // works, returns undefined
schema.parse('') // works, returns undefined
```

I would expect the first schema to behave the same as the second schema.",,
1853756839,2663,"TypeError: Not assignable to parameter of type ZodType<any, any, any>","I've created this `schema` to use in `React Hook Form`, but I'm getting an error that I'm not sure how to fix.

```
import { z } from 'zod';

export const schema = z.object({
  email_domains: z.string().min(1, { message: 'At least one domain is required' }),
  add_to_groups: z.string(),
  expires_at: z.string(),
  language: z.string(),
  name: z.string().min(1),
});

export type FormValuesType = z.infer<typeof schema>;
```

```
import { zodResolver } from '@hookform/resolvers/zod';
import { FormProvider, useForm } from 'react-hook-form';

import { defaultExpiresAt, defaultName } from '@/lib/invite-links';

import {
  FormValuesType,
  schema,
} from '@/components/InviteLinkCreatePage/schema';

export default function Form() {
  const methods = useForm<FormValuesType>({
    resolver: zodResolver(schema),
    values: {
      email_domains: '',
      add_to_groups: '',
      expires_at: defaultExpiresAt(),
      language: '',
      name: defaultName(),
    },
  });

  const handleSubmit = (data: FormValuesType) => {
    console.log({ data });
  };

  return (
    <FormProvider {...methods}>
      ...
    </FormProvider>
  );
}
```

The error coming back is: 

```
Argument of type 'ZodObject<{ email_domains: ZodString; add_to_groups: ZodString; expires_at: ZodString; language: ZodString; name: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodType<any, any, any>'.
  The types of 'refine(...)._def.typeName' are incompatible between these types.
    Type 'import(""/Users/ernstoarllano/Sites/dispel/packages/cweb/node_modules/zod/lib/types"").ZodFirstPartyTypeKind.ZodEffects' is not assignable to type 'Zod.ZodFirstPartyTypeKind.ZodEffects'.
      Property 'ZodReadonly' is missing in type 'Zod.ZodFirstPartyTypeKind'.
```",,
1851590446,2658,Stricter Array Types,"Hey crew!

We rely on [noUncheckedIndexedAccess](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess) on our repos so we rely on nonempty array types.

<img width=""706"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/18017094/334317a6-aab8-4c42-bf07-73a90b1c458b"">

This makes enforcing array type lengths very important.

This proposes enhancements to `min` and `length` checks to create even more accurate types which can work well with `noUncheckedIndexedAccess`.

```ts
z.string().min(3);
// [string, string, string, ...string[]];

z.string().length(3);
// [string, string, string];
```

We could type the following
```ts

type MaxArray<
  T,
  Max extends number,
  Min extends number = 0,
  R extends T[] = Tuple<T, Max>
> = R[""length""] extends Min
  ? Min extends 0
    ? []
    : never
  : R extends [infer U, ...infer V]
  ? U extends undefined
    ? never
    : V extends T[]
    ? R | MaxArray<T, Max, Min, V>
    : never
  : never;

z.string().max(3);
// [] | [string] | [string, string] | [string, string, string];
```

But that would require a little bit of rework to pipe min and max cardinality around and probably isn't all that helpful in general.
 ",,
1850593470,2655,.passthrough() pass through excess nested properties as well,"Appears `.passthrough()` only operates on root properties.

```
import { z } from 'zod';

const schema = z.object({
  first: z.string(),
  details: z.object({
    hair: z.string(),
  }),
});

const myObj = {
  first: 'me',
  last: 'mine',
  details: {
    hair: 'red',
    eyes: 'blue',
  },
};

const res = schema.passthrough().safeParse(myObj);
console.log(res);
```

Actual results
```
{
  success: true,
  data: { first: 'me', details: { hair: 'red' }, last: 'mine' }
}
```

Expected results
```
{
  success: true,
  data: { first: 'me', details: { hair: 'red', eyes: 'blue' }, last: 'mine' }
}
```

Additional functionality which would be very handy, as it relates to nested properties:
1. `.pick()` allow picking and choosing for nested props",,
1850571649,2654,Schema in object being inferred differently (and weirdly),"See the following TS snippet:

```ts
import { z } from ""zod"";

const EventNameSchema = z.string().or(z.array(z.string()));

type EventName = z.infer<typeof EventNameSchema>;
// EventName is string | string[]

const EventSchema = z.object({
  name: z.string().or(z.array(z.string())) // this is the same as the EventNameSchema
});

type EventWithName = z.infer<typeof EventSchema>;
type EventName2 = EventWithName[""name""];
// EventName2 is (string | string[]) & (string | string[] | undefined)
```

And the TS playground: [link](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8AogG4CmdMAcgIYjsAytQAW7ELzgBeFADomUYHQDmACgCUs6KuSzeUKLwCeO+TEUqN69ZQowjYdnDace-JzN1LM7KAB57RwhMZw4uPgFhMQkAPkoAenjQ1winYAY4BSVlOAAfTPNsgG0AXSpaRhYwmCjxSU8tACMAK3ZqGFUECjg4OncALjksy01tXX1DE11htWt1CjQbKkCnFy4AdWAYEVTpOW9fAId2YOSuWtjKFbO3AQAmPbWYTe3Uovw+gXwShKSn1Ie6TgqhmeQKFmUpXUcAAZMDQfkZqUwQBXOjEdiYJTsYjqIA)

I'm not sure if this is intended or a bug or maybe just a user error. Using zod `3.21.4` and TS `4.8.4`",,
1849966118,2653,"Function ""setErrorMap"" Not Overriding Default Mapping","## Issue Title: `setErrorMap` Function Not Overriding Default Mapping

### Description
**Affected Library:** ZOD

**Current Behavior:**
The `setErrorMap` function in the ZOD library, which is intended to allow users to set their own error mappings for different languages, is not functioning as expected. According to the documentation, this function should override the default error mapping with the custom mapping provided by the user.

**Expected Behavior:**
When using the `setErrorMap` function, it is expected that the custom error mapping provided by the user should completely replace the default error mapping. However, in its current state, the library appears to be retaining elements of the default mapping, resulting in unexpected behavior when trying to change the language of error messages.

**Steps to Reproduce:**
1. Initialize the ZOD library.
2. Use the `setErrorMap` function to set a custom error mapping for a specific language.
3. Trigger a validation error in that language.

**Current Outcome:**
Despite setting a custom error mapping using `setErrorMap`, the error messages still contain elements from the default mapping. This makes it difficult to fully customize the error messages for different languages.

**Expected Outcome:**
Upon using `setErrorMap`, the custom error mapping should take precedence over the default mapping, resulting in error messages that are fully customized according to the user's specifications.

### Additional Information
- Version of ZOD Library: ""^3.21.4""
- Browser/Environment: node v16.13.0
- Code Example:
  ```javascript
      const { z } = require(""zod"");
      z.setErrorMap((issue, _ctx) => {
        let message = ""Test"";
        // all errors should be ""Test""
        return { message }
      });
      
I temporarily solved this in my project by changing the order of the errorsMaps in the ""addIssueToContext"" function in ""./helpers/parseUtil.ts"". It can be seen in the function of the same file ""makeIssue"" because it does not work as expected, a reverse is being used, I don't know if it is intentional or because it is due.

      

",,
1848791460,2651,zod.function as property of zod.object loses `this`,"Quoting myself from discord:

```
const MyObj = z.object({ foo: z.function() });
class MyObjImpl implements z.infer<typeof MyObj> { private bar: string; constructor(){this.bar = 'baz';} foo() { console.log(this.bar); } };
const inst = MyObj.parse(new MyObjImpl()); //ok
inst.foo(); // kablooey :( ""this is undefined""
```

The problem is that the parsed object's parsed method is an arrow function, and thus has a ""this"" of the ZodFunction (see: https://github.com/colinhacks/zod/blob/1ecd6241ef97b33ce229b49f1346ffeee5d0ba74/src/types.ts#L3755). A similar problem applies to async functions.

I can think of two possible solutions here. First is to make the parsed result a normal function instead of an arrow function, then apply its `this` to the underlying `fn`. The second is to use proxies on either the parsed function, the parsed object, or both to get a similar behavior.

I'll have a not-yet-mergeable PR for the former strategy up for this shortly. Would love help getting it over the line.",,
1847401199,2649,Schema properties become optional if passed to generic function,"When passing a schema with a normally matching generic type as a function parameter, object properties seem to become optional. So the following code fails with type error `Type 'undefined' is not assignable to type 'string'.`:
```typescript
// not working
function test1<T extends ZodType<string>>(schema: T) {
  return z.object({ value: schema }) satisfies ZodType<{ value: string }>
                                  // ^ Type 'undefined' is not assignable to type 'string'.
}
```

When passing the schema with a specific type, it is working, but as stated in the documentation, some type information will be lost:
```typescript
// working
function test2(schema: ZodType<string>) {
  return z.object({ value: schema }) satisfies ZodType<{ value: string }>
}
```

I'm not sure whether this is a TypeScript quirk, a bug in Zod or something I'm doing wrong. Any help would be appreciated.

[Reproduction on StackBlitz](https://stackblitz.com/edit/typescript-d7ho4u?file=index.ts&view=editor)
Maybe related: #2198",,
1845111708,2643,"cant make an array of ""open"" objects","in typescipt we can make the following

```ts
type OpenObject  = {
    id: string
} & {
    [key: PropertyKey]: unknown
}
type OpenObjectList = OpenObject[] // or Array<OpenObject>
```
Trying to define that using zod and z.infer seem to fail...
Wondering if this is a bug or a known limitation or if i'm missing someting
```ts
import {z} from ""zod""

const openObject = z.object({
  id: z.string()
}).catchall(z.unknown())

type OpenObject = z.infer<typeof openObject>
// correct type output
// type OpenObject = {
//     id: string;
// } & {
//     [k: string]: unknown;
// }
const openObjectList = z.array(simpleOpenObject)

type OpenObjectList = z.infer<typeof openObjectList> 
// type output is not as expected 
// type OpenObjectList = z.objectOutputType<{
//    id: z.ZodString;
// }, z.ZodUnknown, ""strip"">[]

// expected one of 
// type OpenObjectList = Array<OpenObject>
// type OpenObjectList = OpenObject[]
// type OpenObjectList = { 
//        [key: PropertyKey]: unkown
//         id: string
// }[]
```
",,
1843521546,2639,String format request: xid,"In line with `UUID`, `ULID`, `CUID`, and `CUID2`, I think it would be great to add an additional format as well: `xid`.

It seems like it's fairly simple and well supported, and I'm looking to use it in a project that I use `zod` for, so support would be great.

Here's the source repo: https://github.com/rs/xid
Here's a typescript implementation: https://github.com/yiwen-ai/xid-ts

I can start on a PR if that would be appreciated!",,
1838278906,2635,Nullable Enums fail validation,"It seems to me that the enum validation happens first and therefore `undefined` and `null` fail this test, eventhough `.nullish()` is appended to the definition.

I sadly do not have the time to investigate this and it seems adding `undefined` to the enum itself is not possible. I'll try my luck with a union.

Thank you for all the work on this library and sorry for the sparse information.",,
1836615732,2630,z.enum() cannot accept parameter from a json file,"# What's the Issue

I have a json file that stores a list of slugs
```
/* dataSlugs.jsona */

{
  ""slugs"": [""one"", ""two"", ""three""]
}
```

Then I import this json and pass it as parameter to`z.enum`
```
import dataSlugs from './dataSlugs.json'

type DataSlugJson = {
  slugs: string[]
}

const slugs = (dataSlugs as DataSlugJson).slugs

export const mySchema = z.enum(slugs) /* this throws a type error */

```

I get the error:
<img width=""896"" alt=""Screenshot 2023-08-04 at 7 52 38 PM"" src=""https://github.com/colinhacks/zod/assets/30344224/77b3898c-ad98-4e68-966e-e4286b22be3f"">


I found in the docs about `z.enum`  can use `as const`

```
/* THIS WORKS */
const slugs = [""one"", ""two"" ""three""] as const
export const mySchema = z.enum(slugs)

```

```
/* BUT THIS DOESN't */
const slugs = (dataSlugs as DataSlugJson).slugs as const
 /* ERROR A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals.ts(1355) */
 
export const mySchema = z.enum(slugs)

```

How can I get a data from a json file, and pass it as parameter to `z.enum()` ?

## ZOD Version
`""zod"": ""^3.21.4""`",,
1835485699,2628,large schemas make it hard to read the type,"first of all thanks for making this amazing project. it is one of my favorite libraries.

i have some really big zod objects in my project. You can see here what it looks like when i hover over a parsed object (`finalEntities`):
![image](https://github.com/colinhacks/zod/assets/32936978/54718237-dc98-4748-916f-3e96364b7c9a)

it shows the entire type definition and not the name. But if i do this with a regular ts type instead of zod, it would just show `Promise<SpaceType>` and allow me to easily navigate to that type.

sometimes i may have many large similar schemas in a union at which point it becomes almost impossible to read.

I'm trying to stay 100% inferred. so my app just uses the result of `const finalEntities = SpaceInstanceArray.parse(entities);`.
would be cool if i could hover over `finalEntities` and see the name of the schema and be able to go to the schema easily.

I tried using z.infer to get the type and then cast it as that type , like this:
```
type SpaceType = z.infer<typeof SpaceInstanceArray>;
 const finalEntities = SpaceInstanceArray.parse(
        entities
  ) as unknown as SpaceType;
```
but i still just see the entire type definition when i hover over finalEntities. Is there anyway to get around this or improve DX on this?
",,
1834874616,2627,Object type inference breaks when passing generic parameters,"[Reproduction](https://codesandbox.io/s/typescript-playground-export-forked-shpc4g?file=/index.ts)

Summary:

We interface with a library that converts Rust structs into JSON. A rust enum will be converted like such:

```rs
enum PrimaryColor {
  Red,
  Yellow,
  Blue,
}
```
```json
{ ""__kind"": ""Red"" }
```

To simplify parsing these enums, we created a factory function to generate the schemas.

```ts
const rustEnum = <T extends string, U extends Readonly<[U, ...U]>>(values: U) =>
  z.object({ __kind: z.enum(values) }).transform(({ __kind }) => __kind);
```

However, type inference of `z.object` seems to break when passing in generic parameters that are used for an enum within that shape. Here ""breaking"" means that `undefined` is added to the union of enum values.

There are some simple workarounds such as simply copy-pasting the code or adding a non-null assertion.

",,
1830840530,2624,Zod compiles d.ts files with errors,"My team recently noticed an issue that came up in the .d.ts files after zod compiled 1 of our schemas.

Original zod schema:
```ts
export const UserEventMetadataSchema = EventMetadataSchema.extend({
  userId: z.string().or(z.null()),
  journeyId: z.string(),
  locale: z.string(),
  os: z.string().optional(),
  device: z.string().optional(),
  browser: z.string().optional(),
})
```
The output in our d.ts file:
```ts
export declare const UserEventMetadataSchema: z.ZodObject<z.extendShape<{
    appVersion: z.ZodString;
    environment: z.ZodEnum<[""production"", ""staging"", ""development""]>;
    clientVersion: z.ZodString;
   ....
},
```
The problem is that in the d.ts file Typescript cannot find the exported module extendShape:
![image](https://github.com/colinhacks/zod/assets/17296943/17d12ef9-486a-474e-81c3-009dea22f943)

Package versions:
```json
""dependencies"": {
    ""zod"": ""^3.21.4"",
    ""typescript"": ""^4.9.4""
  },
```

Does anyone know why the d.ts files are generated with typescript errors?",,
1830446542,2623,`z.record` with a key of a union or enum schema results in a partial record,"If a union or enum schema is passed to `z.record` as a key type, the resulting schema has all properties as optional for both the parsing logic and the inferred TypeScript type.

I propose that we make the behavior of `z.record` similar to that of TypeScript's. If you pass an union or enum type to Record in TypeScript, the resulting type has all properties required.

I understand changing the existing behavior of `z.schema` would be a breaking change. For now, how about introducing a new zod type `z.strictRecord` where all properties are required?

I apologize if this has been considered before. Please let me know if there are specific reasons the behavior of`z.schema` differs from TypeScript's 🙇 

I also found related issues and listed them below for reference.

- https://github.com/colinhacks/zod/issues/2320
- https://github.com/colinhacks/zod/issues/2448
- https://github.com/colinhacks/zod/issues/55

The following example code illustrates the current behavior of `z.record`.

```ts
import { z } from 'zod';

const exampleEnumSchema = z.enum(['foo', 'bar']);
const exampleRecordSchema = z.record(exampleEnumSchema, z.string());

type ExampleRecord = z.infer<typeof exampleRecordSchema>;
// {
//     foo?: string | undefined;
//     bar?: string | undefined;
// }

exampleRecordSchema.parse({foo: 'foo'}); // doesn't error
```

The following example code illustrates the behavior of TypeScript Record.

```ts
enum ExampleEnum {
    Foo = 'foo',
    Bar = 'bar',
}

type ExampleRecord = Record<ExampleEnum, string>;
// {
//     foo: string;
//     bar: string;
// }

const exampleRecord: ExampleRecord = {
    [ExampleEnum.Foo]: 'foo',
}
// Property '[ExampleEnum.Bar]' is missing in type '{ foo: string; }' but required in type 'ExampleRecord'.
```

If the schema created by `z.record()` is used for a property on another object schema, the property's type is inferred as a `Partial` type.

```ts
const tempSchema = z.object({baz: exampleRecordSchema});

type Temp = z.infer<typeof tempSchema>;
// {
//     baz: Partial<Record<""foo"" | ""bar"", string>>;
// }
```",,
1830307114,2622,[Feature request] Marking a field as deprecated,"Use case
--- 

I am creating an API using Zod and TRPC, and I can't guarantee that all of the clients will upgrade immediately upon deploy (e.g. long opened tabs). 

I would like to deprecate fields out of the TRCP input or output schema without forcing an immediate client refresh; and I didn't spot an approach to doing this in the docs.

If I have missed any easier approach, please let me know :) 

Proposal
---

A `deprecated` method which removes the key from the input, or output, types based on the setting (naming just a first-thought, not a suggestion).

- `input`: 
   - optional in validation
   - is **not** in the input type
   - is in the output type
- `output`: 
   - same as before in validation (optional or required)
   - is in the input type
   - is **not** in the output type

Why not just temporarily use `optional`
---

- For `input` types, it will not prevent consumers from continuing to attempt to supply this data. A two step deprecation allows all consumer code to be updated (and type checked) before updating the server code.
- For `output` types, it ensures that no consumers are still expecting this field before the server stops sending it entirely

In both situations, deprecating for a situation-appropriate amount of time helps to avoid API mismatch.

Examples
---

```ts
export const appRouter = t.router({
  hello: publicProcedure
    .input(
      z.object({
        // consumers of this API route will not see `name` in the input types
        // but it is still available here to be responded to for old consumers
        name: z.string().deprecated('input'),
      }),
    )
    .query((opts) => {
      const name = opts.input.name;
      if (name) { /* do the old version */ }
      else { /* do the new version */ } 
      return {
        greeting: ""Hello"",
      };
    }),
});
```

```ts
export const appRouter = t.router({
  // this method is being deprecated, so new consumers will see `{}` as the output type
  // it will still work for older consumers, allowing time for all clients to update to the latest build
  // this specific situation may be better managed at a TRPC level as well
  hello: publicProcedure
    .input(
      z.object({
        name: z.string().deprecated('input'),
      }),
    )
    .output(
      z.object({
        greeting: z.string().deprecated('output'),
      }),
    )
    .query((opts) => {
      const name = opts.input.name;
      return {
        greeting: ""Hello"",
      };
    }),
});
```",,
1827835924,2617,Cannot import Zod schema from monorepo package when deploying Firebase Cloud Function,"I am using Zod for runtime validation in my Firebase Cloud Functions.

I also have a monorepo setup. All my TypeScript models and Zod schema are exported from a single internal package.

There are no IDE errors. But when I import Zod schema from that internal monorepo package into my Firebase Cloud Function I get this error during deploy or emulate:

> Failed to load function definition from source: FirebaseError: Functions codebase could not be analyzed successfully. It may have a syntax or runtime error

This only happens when importing and deploying Zod schema. Importing and deploying plain TypeScript interfaces does not have the same problem.

Also if I move the Zod Schema into the Firebase Function itself everything works fine. So there is a problem specifically with importing Zod Schema from the internal monorepo package.

Any ideas what's going on here?

This is the internal package:

**`my-app/packages/types/src/index.ts`**
```
import { z } from ""zod"";

export const SerpGridOnCallSchema = z.object({
  companyId: z.string(),
  companyLocationId: z.string(),
  companyLocationCid: z.string(),
  keyword: z.string(),
  centerCoordinates: z.object({
    lat: z.number(),
    lng: z.number(),
  }),
  gridSizePerSide: z.number(),
  gridNumPointsPerSide: z.number(),
  mapZoomLevel: z.number(),
});

export type SerpGridOnCall = z.infer<typeof SerpGridOnCallSchema>;
```

**`my-app/packages/types/package.json`**
```JSON
{
  ""name"": ""@seoturbo/types"",
  ""version"": ""1.0.0"",
  ""license"": ""UNLICENSED"",
  ""description"": ""Typescript types"",
  ""main"": ""src/index.ts"",
  ""types"": ""src/index.ts"",
  ""scripts"": {
    ""lint"": ""eslint --ext .js,.ts ."",
    ""build"": ""tsc""
  },
  ""dependencies"": {
    ""@turf/helpers"": ""^6.5.0"",
    ""firebase"": ""^9.17.2"",
    ""firebase-admin"": ""^11.10.1"",
    ""quasar"": ""^2.12.1"",
    ""zod"": ""^3.21.4""
  },
  ""devDependencies"": {
    ""@seoturbo/eslint-config-custom"": ""*"",
    ""@seoturbo/tsconfig"": ""*"",
    ""eslint"": ""^8.9.0"",
    ""typescript"": ""^5.1.6""
  }
}
```

This is the Firebase Functions file where the internal monorepo package is imported and used:

**`my-app/apps/functions/src/api/http/on-call/test.ts`**
```
import { CallableRequest, onCall } from ""firebase-functions/v2/https"";
import { SerpGridOnCall, SerpGridOnCallSchema } from ""@seoturbo/types"";

export const test = onCall(async (req: CallableRequest<SerpGridOnCall>) => {
    SerpGridOnCallSchema.parse(req.data);
  }
);
```",,
1826444169,2613,Make zod faster,"I found repo with [validators benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/). Zod in it not so good as I expected.

I wrote simple test for my model and custom validation function, which fully corresponds to the Zod scheme.

When running, I saw a 15x (1500%) execution speed difference.

![image](https://github.com/colinhacks/zod/assets/4066631/8912ac24-83d1-416f-8b7a-d1bd1f5c1e18)

My performance test code:
```js
const z = require('zod')

const DATA = {
    id: 1,
    yo: 1,
    email: 'me@email.name',
    username: 'admin',
    score: 0,
    roles: ['owner'],
    userProfiles: [
        { profileId: 1, profileName: 'Yo!1' },
        { profileId: 2, profileName: 'Yo!2' },
    ],
}
const TRY_COUNT = 100000

function validateZod(data, tryCount) {
    const userSchema = z.object({
        id: z.number(),
        email: z.string(),
        username: z.string(),
        score: z.number(),
        roles: z.array(
            z.enum(['admin', 'manager', 'owner', 'customer'])
        ),
        userProfiles: z.array(
            z.object({ profileId: z.number(), profileName: z.string() })
        ),
    })

    for(let i = 0; i < tryCount; i += 1) {
        userSchema.parse(data)
    }
}

function validateCustom(data, tryCount) {
    function parse(data) {
        if (!data || typeof data !== 'object') {
            throw new Error('data is not object')
        }

        const out = {}

        if (typeof data.id !== 'number') {
            throw new Error('id is not number')
        }
        out.id = data.id

        if (typeof data.email !== 'string') {
            throw new Error('email is not string')
        }
        out.email = data.email

        if (typeof data.username !== 'string') {
            throw new Error('username is not string')
        }
        out.username = data.username

        if (typeof data.score !== 'number') {
            throw new Error('score is not number')
        }
        out.score = data.score

        if (!Array.isArray(data.roles)) {
            throw new Error('roles is not array')
        }
        out.roles = data.roles.map((data, i) => {
            if (!data || typeof data !== 'string') {
                throw new Error(`roles[${i}] is not string`)
            }

            if (!['admin', 'manager', 'owner', 'customer'].includes(data)) {
                throw new Error(`roles[${i}] is not string`)
            }

            return data
        })

        if (!Array.isArray(data.userProfiles)) {
            throw new Error('userProfiles is not array')
        }
        out.userProfiles = data.userProfiles.map((data, i) => {
            if (!data || typeof data !== 'object') {
                throw new Error(`userProfiles[${i}] is not object`)
            }

            const out = {}

            if (typeof data.profileId !== 'number') {
                throw new Error(`userProfiles[${i}].profileId is not number`)
            }
            out.profileId = data.profileId

            if (typeof data.profileName !== 'string') {
                throw new Error(`userProfiles[${i}].profileName is not string`)
            }
            out.profileName = data.profileName

            return out
        })

        return out
    }

    for(let i = 0; i < tryCount; i += 1) {
        parse(data)
    }
}

// Zod test

let startTs = Date.now()
let ticksStart = process.hrtime.bigint()

validateZod(DATA, TRY_COUNT)

let ticksEnd = process.hrtime.bigint()
let endTs = Date.now()

console.log(`ZOD: Time sec ${(endTs - startTs) / 1000}, ticks: ${Math.round(Number(ticksEnd - ticksStart) / 1000)}`)

// Custom validation test

startTs = Date.now()
ticksStart = process.hrtime.bigint()

validateCustom(DATA, TRY_COUNT)

ticksEnd = process.hrtime.bigint()
endTs = Date.now()

console.log(`CUSTOM: Time sec ${(endTs - startTs) / 1000}, ticks: ${Math.round(Number(ticksEnd - ticksStart) / 1000)}`)
```

I know the overhead is unavoidable, but maybe you can optimize the code by precompiling the Zod-schema and make 15x gap smaller.
My suggestion is to compile the Zod-schema with a `new Function()` (at least for simple cases) and use it when calling validation.

```js
function compileSchema(zodSchemaDefinition) {
    let code = ''

    if (zodSchemaDefinition.nullable) {
        code += `if (value === null) return null;\n`
    }

    if (zodSchemaDefinition.optional) {
        code += `if (value === undefined) return undefined;\n`
    }

    if (zodSchemaDefinition.type !== 'string') {
        // MVP compiler: only for strings at the moment
        return null
    }

    code += `if (typeof value !== 'string') throw new Error('value is not a string');\n`

    if (zodSchemaDefinition.min) {
        code += `if (value.length < ${zodSchemaDefinition.min}) throw new Error('Minimum value length is ${zodSchemaDefinition.min}');\n`
    }

    code += 'return value;'

    return new Function('value', code)
}

// Schema must get from Zod schema metadata
const validator = compileSchema({
    nullable: true,
    type: 'string',
    min: 2,
})

console.log('Generated validator function:')
console.log(validator.toString())
console.log()
console.log('Value ""qwe"" validation: ', JSON.stringify(validator('qwe')))
console.log()
console.log('Next validation of number 1 must throw error')
console.log(validator(1))
```

![image](https://github.com/colinhacks/zod/assets/4066631/02d3ebdd-bca9-4fe6-967d-b92b5d3bda9a)
",,
1823894878,2611,how use zod pass the File object,"This is my trpc+zod code.
```
  test: t.procedure
    .input(
      z.object({
    input_image: z.any(),
      }),
    )
    .mutation(async (req) => {
      const img = req.input.input_image
      console.log(input_image) //{}
      return true
    }),
```
I ended up with an empty object

",,
1823083620,2608,Error reported inside union are wrong,"Using the following code:

```ts
import { ZodError, z } from ""zod"";

async function superRefineFunction(val: any, ctx: any) {
    if (val !== 'Z') { 
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: ""This value is not in db"",
        });    
    }
}

const schema = z.union([
    z.string().regex(/^P=\d{4}$/),
    z.string().regex(/^A=\d{4}$/).pipe(z.string().superRefine(superRefineFunction)),
]);

async function run(data: unknown) {
    try {
        const result = await schema.parseAsync(data);
        console.log(`${result}: ok`);
    } catch (e) {
        console.log(`${data}: ${(e as ZodError).issues.map((i)=>i.message).join(',')}`)
    }
}

run('A=2222').then(() => {});
```

The error reported is not the one reported in the superRefineFunction. But, if I invert the order of the elements in the array of the argument passed to z.union, then I receive the right error.

```ts
const schema = z.union([
    z.string().regex(/^A=\d{4}$/).pipe(z.string().superRefine(superRefineFunction)),
    z.string().regex(/^P=\d{4}$/),
]);
```

Conclusion: Using union, It seems only the first error encountered is reported. Would it be better to report all the errors encountered?",,
1822932544,2607,`omit` & `pick` allowing keys not present in the object,"It seems that `z.omit` and `z.pick` allow any keys to be omitted/picked, as long as **one** of the omitted/picked keys **is** in the object.

```ts
import { z } from ""zod""

export const SomeZodObject = z.object({
  a: z.string(),
  b: z.string(),
})

export const ErroneousOmit = SomeZodObject.omit({
  c: true, // <-- Errors because `c` is not in `SomeZodObject`, and it is the only key being omitted
})

export const AllowedOmit = SomeZodObject.omit({
  a: true,
  c: true, // <-- Does *not* error because `a` *is*` part of `SomeZodObject`, so any key is now allowed
})
```

The same behavior as above happens with `pick`.

Note that TypeScript's `Omit` type **does** allow omitting keys not present in the object:

```ts
type SomeZodObjectInput = z.input<typeof SomeZodObject>

// No errors
export type TSOmitted1 = Omit<SomeZodObjectInput, ""c"">
export type TSOmitted2 = Omit<SomeZodObjectInput, ""a"" | ""c"">
```

But TypeScript's `Pick` type does **not**:

```ts

type SomeZodObjectInput = z.input<typeof SomeZodObject>

// Both of these error
export type TSPicked1 = Pick<SomeZodObjectInput, ""c"">
export type TSPicked2 = Pick<SomeZodObjectInput, ""a"" | ""c"">
```

Is this intended behavior? And if so, is there a way to get TS to error for **any** key that doesn't exist in the object?

TSPlayground: https://tsplay.dev/wO1pdm
",,
1821515236,2606,Parsing Union of objects removes property from object,"```TypeScript
import { z } from ""zod"";

const UpdateBookingSchema = z.union([
  z.object({
    propertyType: z.string()
  }),
  z.object({
    region: z.string()
  }),
  z.object({
    propertyType: z.string(),
    region: z.string()
  })
]);

const updateBooking = UpdateBookingSchema.parse({
  propertyType: ""unit"",
  region: ""vic_bayside""
});

console.log({ updateBooking });
```

Output:
```
{ propertyType: ""unit"" }
```

Expected:
```
{
  propertyType: ""unit"",
  region: ""vic_bayside""
}
```

https://codesandbox.io/s/hungry-mcclintock-9dzmnp

If I move the last `z.object` to the first item in the union it works as expected",,
1814621799,2598,Zod infers undefined field as optional,"### Given:
`zod 3.21.4`

```typescript
({ }) satisfies { x: undefined };   // 1
({ }) satisfies z.infer<typeof x>;  // 2
const x = z.object({ x: z.undefined() });
```

### Expected:
- `1` should not typecheck because field is not optional
- `2` should not typecheck as well because `x` models the same type

### Actual:
- `1` typechecks (and it is correct)
- `2` does not typecheck (`zod` for unknown reason makes field optional)

It is not the problem with `strict: true` in tsconfig.",,
1813066074,2596,Bloating with esbuild bundled output,"Hi Colin!

Awesome project, I came across this issue as referred by the following:

_Originally posted by @gustavopch in https://github.com/colinhacks/zod/issues/294#issuecomment-1638064507_
            
The thread confirms your intention of having tree-shakable esm code, and it is marked as resolved and closed. However, esbuild currently bundles all of Zod into your output if you import a simple zod schema.

Steps to replicate: 
- Creating a simple ts project that uses esbuild with bundled output enabled.
- Create a simple zod schema:

`
import {z} from ""zod""
const testSchema = z.string().min(10)
`
- Validate some random string using the test schema
- Build the project with esbuild using bundled output (also bundling external node_modules, so would be zod module in our case. This is currently how edge functions such as wrangler cli for cloudflare workers bundle ts, and the bundled code is several thousand lines of unused js from Zod in an edge environment supposed to be small and lightweight)

Another similar comment in thread:
_Originally posted by @ekwoka in https://github.com/colinhacks/zod/issues/294#issuecomment-1438548315_

Is treeshaking working as expected? Looking forward to hearing from you,
Cheers!",,
1810907979,2590,Feature request: allow for single element unions,"In Typescript I can do something like:

```typescript
type Animal =
    | { type : 'bird', name: 'Graculus' }
```

-- with the assumption that there could be future union values in future, and to hint to future maintainers that some function is set up to be extended to support multiple values.

Would be nice if zod could match that and allow a single element union.",,
1810197546,2588,Zod Preprocess returning unknown type,"Same as https://github.com/colinhacks/zod/issues/1458, 

The type returned from [z.preprocess](https://zod.dev/?id=preprocess) is giving out type ""unknown"" instead of expected behavior of inferring from schema passed as second argument and throw the error on runtime if the processed value is different from schema.

```ts
const processedObject = z.preprocess(
    (v) => (typeof v === ""string"" ? JSON.parse(v as string) : v),
    z.array(jsonSchema),
) // typeof processedObject returning unknown
```

using zod v3.21.4",,
1809717388,2587,Importing zod schemas exported from a different package forces ZodError to lose its type,"Hi, I was trying to reuse zod schemas by importing them from another package, but when I do so, parse function does not return ZodError instance anymore. I am currently compiling my source code with esbuild into an esm module, so I tried to compile it into commonjs instead but it still failed with the same behavior. Exported schemas are compiled with tsc and it's in commonjs.

Below is the compiled typescript code with esbuild.

<img width=""665"" alt=""Screen Shot 2023-07-18 at 4 02 42 AM"" src=""https://github.com/colinhacks/zod/assets/35556519/4da5b239-06fc-4f3b-935f-0211b628c8ff"">

From the above code, if I remove ""import_base_payload"" then it works as expected.
But If I run the validation function with imported schema, then I get this as an error object caught in the catch block:

<img width=""1213"" alt=""Screen Shot 2023-07-18 at 4 13 15 AM"" src=""https://github.com/colinhacks/zod/assets/35556519/1479f822-47c4-4fec-a927-6ad3a1b2323d"">

Usually, errors that are caught in the catch block are instances of ZodError but this one isn't. Very weirdly, error.constructor.name happens to be ""ZodError"" but the err is not the zod instance for some reason. 

Exported schemas are the discriminated union of two zodObjects and both objects did not involve any transformation. Below is exported schema's directory structure and schemas are exported from payload.ts file.

<img width=""177"" alt=""Screen Shot 2023-07-18 at 4 23 56 AM"" src=""https://github.com/colinhacks/zod/assets/35556519/bac7bc55-4d8f-4eff-971c-cf045ba9f123"">

Any help would be appreciated. Thanks in advance!",,
1809412104,2586,parse and safeParse differ in their result,"I have been caught out by this twice now, once using zod directly and once with drizzle-zod.
I have the expectation that zodObject.safeParse().success will always be false in scenarios where zodObject.parse will throw and
zodObject.safeParse().success will always be true in scenarios where zodObject.parse will not throw.

However, this is not the case.
Drizzle-Zod example:
```
import { int, mysqlTable } from 'drizzle-orm/mysql-core';
import { createSelectSchema } from 'drizzle-zod';
import { expect } from 'chai';

describe('table.update.test.ts', () => {
  const tableSchema = mysqlTable('test_table', {
    wordDelimiterTest: int('word_delimiter_test').notNull(),
  });
  const parser = createSelectSchema(tableSchema).partial();
  it('should fail validation if the key is the wrong case', () => {
    expect(parser.parse.bind(parser, { word_delimiter_test: 1 })).to.throw; //pass, throws error
    expect(parser.safeParse({ word_delimiter_test: 1 }).success).to.be.false; //fail, success is true
  });
});
```

parse does throw an error but safeParse returns success as true.. this makes safeParse unusable as it is the one that is incorrect.
I would try to find out what causes this disparity but I don't have the time to hunt for the actual methods in the codebase.

UPDATE: I retested the first occurrence I found of this behaviour and due to the parser (zod schema) being changed it is no longer reproducible.",,
1807662085,2585,Decide correct schema from union by specific key,"Hey,

I don't really know how to name it, but I am running into an issue trying to validate design tokens from a json file:

**Setup**
1. I have schemas for each token type, for example:

```js
export const fontWeightToken = baseToken
  .merge(
    z.object({
      $type: z.literal('fontWeight'),
      $value: z.union([fontWeightValue, referenceValue]),
    }),
  )
  .strict()
  ```
2. All specific types have the `$type` property, but it is not required for all tokens, a token can also only have the `$value` property. To validate this case I have the following `genericToken` schema:

```js
const genericTokenValue = baseToken
  .pick({$description: true})
  .merge(
    z.object({
      $value: z.union([z.string(), z.number(), referenceValue]),
    }),
  )
  .strict()
```

The problem that I run into is that if the `$type` matches with a schema, but the `$value` is wrong, it does not error, but falls through to the `genericToken` and returns an error about an invalid property `$type`.

For example if I have a fontWeight token with an invalid number:
```js
        ""light"": {
          ""$type"": ""fontWeight"",
          ""$value"": 350 // should be 300, it matches against some literals
        }
```
I want to get an error like `Invalid $value for ""light""`. However instead it goes on and says:
```js
Validation error: Unrecognized key(s) in object: '$type' at ""base.text.weight.light""
```
Because it tests this object against the `genericToken`. Is there a way that I can tell `zod` that if an item has one of the specified `$types` (so a valid type) it should match against the specific schema?

If not, is there a way to use `preprocess` or something else to go through the entire object and add `$type: ""noType""` or something like this to the items that have no `$type` object?",,
1806155120,2583,Compilation error after updating from 3.20.6 to 3.21.0,"After updating Zod from 3.20.6 to 3.21.0 I receive this error when compiling.

```
TS2345: Argument of type 'ZodObject<{ data: ZodObject<{ type: ZodLiteral<IotStateUpdateType.LOCK_STATE>; result: ZodNativeEnum<typeof IotLockEventResult>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; ... 9 more ...; version: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodTypeAny'.
  Types of property '_parse' are incompatible.
    Type '(input: ParseInput) => ParseReturnType<{ expires?: Date | undefined; version?: number | undefined; sent?: Date | undefined; id: string; idType: IotIdType; data: { ...; }; ... 4 more ...; source: IotHardware; }>' is not assignable to type '(input: ParseInput) => ParseReturnType<any>'.
      Types of parameters 'input' and 'input' are incompatible.
        Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/helpers/parseUtil"").ParseInput' is not assignable to type 'Zod.ParseInput'.
          The types of 'parent.common.issues' are incompatible between these types.
            Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue[]' is not assignable to type 'Zod.ZodIssue[]'.
              Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue' is not assignable to type 'Zod.ZodIssue'.
                Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
                  Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'Zod.ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }'.
                    Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodInvalidUnionIssue'.
                      Types of property 'unionErrors' are incompatible.
                        Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodError<any>[]' is not assignable to type 'Zod.ZodError<any>[]'.
                          Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodError<any>' is not assignable to type 'Zod.ZodError<any>'.
                            Types of property 'issues' are incompatible.
                              Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue[]' is not assignable to type 'Zod.ZodIssue[]'.
                                Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue' is not assignable to type 'Zod.ZodIssue'.
                                  Type 'ZodInvalidArgumentsIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
                                    Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodInvalidArgumentsIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'Zod.ZodInvalidArgumentsIssue & { fatal?: boolean | undefined; message: string; }'.
                                      Type 'ZodInvalidArgumentsIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodInvalidArgumentsIssue'.
                                        The types of 'argumentsError.addIssue' are incompatible between these types.
                                          Type '(sub: import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue) => void' is not assignable to type '(sub: Zod.ZodIssue) => void'.
                                            Types of parameters 'sub' and 'sub' are incompatible.
                                              Type 'Zod.ZodIssue' is not assignable to type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue'.
                                                Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
    386 |       if (lockEventResult) {
    387 |         this.pubsubService.publishState(
  > 388 |           AxaSchema.StateMessage,
        |           ^^^^^^^^^^^^^^^^^^^^^^
    389 |           AxaDto.newStateMessage(
    390 |             payload.imei,
    391 |             {
```

I can provide more details if the cause isn't immediately obvious.
",,
1805042689,2580,Email Validation Hangs at 100% CPU usage,"Hello,

I came across an issue with the email validation for a specific input string (a long and complex email address).
When attempting to validate/parse the string, the process immediately goes to 100% CPU usage, and never actually finishes parsing. I have waited for ~15 minutes max.
 
Here's some code to reproduce, which also shows 2 other RegExes for which the problem doesn't occur:

```typescript
import {z} from ""zod""

const email = ""noreply1@1-90y790o645vz81zq6287dhb9x1x28ab4q521nuv7b1og4y9c3q.5r-h8uter0.sc016.case.sandbox.salesforce.com""

const otherRegex1 = /[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/gi
const otherRegex2 = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/gi

console.log(otherRegex1.test(email)) // true
console.log(otherRegex2.test(email)) // true

const parsed = z.string().email().parse(email) // hangs at 100% CPU

console.log(parsed) // never reached
``` 

![Screenshot 2023-07-14 at 10 58 23 AM](https://github.com/colinhacks/zod/assets/13756082/63d01f8a-4f6c-44c7-93c9-63a7083541b8)


Using Zod `v3.21.4`
on a 2023 M2 Macbook Pro",,
1803318259,2576,Huge output `.d.ts` files when using `.catchall` with `.passthrough`,"After upgrading from `zod@3.21.0` to `zod@3.21.4`, output `.d.ts` files for schemas combining `.catchall` with `.passthrough` grew exponentially - on our project for one particular schema it exploded **from 350 lines to 70k lines**

This is a problem because it causes worse compile performance & GC failures when using tools like webpack.

You can check out a sample case to reproduce the error here (the repo also contains the comparison of output declaration sizes for different errors): https://github.com/vmajsuk/zod-d-ts-regression",,
1800532500,2573,Intersection between `z.object` and `z.record` incorrectly merges validators,"When intersecting a `z.object` and a `z.record`, zod applies validators for the keys and values of the record to the rest of the object. 

```typescript
const ConfigSchema = z
  .object({
    name: z.object({
      first: z.string(),
    }),
  })
  .and(
    z.record(
      z.enum(['a', 'b']),
      z.object({
        sub: z.string(),
      })
    )
  );

const validInput: z.infer<typeof ConfigSchema> = { // typescript type is correct and doesn't complain here 👍
  name: {
    first: '',
  },
  a: {
    sub: '',
  },
};

ConfigSchema.parse(validInput);
// ^ this throws 2 errors because:
// 1. 'name' doesn't match ['a', 'b']
// 2. 'name.sub' is required (even though this will never exist)
```
<img width=""185"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/34844898/90ce3c93-ec39-4357-a782-a0f0928f3e2e"">

**[Reproduction URL: stackblitz.com](https://stackblitz.com/edit/typescript-dauayd?file=index.ts,package.json)**

**Expected behavior:** validators for record keys and values should only apply to the record.

The same problem occurs with intersections of records that have native enum keys and template literal keys (eg. `[key: dynamic/${string}]`). ",,
1798036752,2569,Creating discriminated unions from functions,"```typescript
export const Parent = (id: string, ...ids: string[]) => {
  const toObj = (i: string) =>
    z.object({
      type: z.literal(`${i}_id`),
      [`${i}_id`]: z.string()
    });
  return z.discriminatedUnion(""type"", [toObj(id), ...ids.map(toObj)]);
};

const P = Parent(""system"", ""user"");
type P = z.infer<typeof P>;
//   ^? { [x: string]: string; type?: `${string}_id` | undefined }

const P2 = z.discriminatedUnion(""type"", [
  z.object({
    type: z.literal(""system_id""),
    system_id: z.string()
  }),
  z.object({
    type: z.literal(""user_id""),
    user_id: z.string()
  })
]);
type P2 = z.infer<typeof P2>;
//   ^? { type: ""system_id""; system_id: string; } | { type: ""user_id""; user_id: string; }
```

I am expecting the types, P and P2, to be identical

Maybe @conorbrandon will know :D",,
1797755484,2567,Extending discriminated union types,"In Typescript I can do something like this:

```typescript
type Nestable =
  | {
      has_children: false;
    }
  | {
      has_children: true;
      children: [string, ...string[]];
    };
```

and compose that with other types:

```typescript
type Prototype = {
  object: ""block"";
  id: string;
  created_at: Date;
  updated_at: Date;
};

export type Block = Prototype & Nestable;
```

such that I will get compile errors if I declare a block object like so:

```typescript
const b: Block = {
  object: ""block"",
  id: ""xxx"",
  ...
  has_children: false,
  children: [""yyy""] // <-- error: ""children"" does not exist on type
};
```

With zod, I can't achieve this in a similarly composable way. I can use discriminated unions to achieve the same type checking, but then I lose the ability to compose that type with other types.

```typescript
const Nestable = z.discriminatedUnion(""has_children"", [
  z.object({
    has_children: z.literal(false)
  }),
  z.object({
    has_children: z.literal(true),
    children: z.string().array()
  }),
]);

const Prototype = Nestable.extend({  // <-- error: property 'extend' does not exist on type ...
  // similar zodified schema declaration
});
```

I can do it slightly differently and make each type _in the discriminated union_ extend Prototype, but that is annoying. And still leaves me with an un-extendable ""final type"" (which is of type z.ZodDiscriminatedUnion<...>

I'm not requesting anything specific, unless there are features in flight that might make this easier to do, but rather looking for suggestions on how to implement such types with zod.",,
1797705065,2566,Better type inference for arrays,"```typescript
// This is what I want:
type A = [string, ...string[]];

const A = z.array(z.string()).min(1);
// But this is what I get
type  Z = z.infer<typeof A>; // string[]
```",,
1797157826,2565,Wrong infered type when using passthrough with an array?,"Is there a reason why it doesn't just infer to: `Array<{ foo: string; } & { [k: string]: unknown; }>`

```ts
import { z } from 'zod'

type Passthrough = z.infer<typeof passthrough>
//  { foo: string; } & { [k: string]: unknown; }
const passthrough = z.object({ foo: z.string() }).passthrough()

type PassthroughWithArray = z.infer<typeof passthroughWithArray>
// z.objectOutputType<{ foo: z.ZodString; }, z.ZodTypeAny, ""passthrough"">[]
const passthroughWithArray = z.object({ foo: z.string() }).passthrough().array()

type PassthroughWithArray2 = z.infer<typeof passthroughWithArray2>
// z.objectOutputType<{ foo: z.ZodString; }, z.ZodTypeAny, ""passthrough"">[]
const passthroughWithArray2 = z.array(z.object({ foo: z.string() }).passthrough())
```

repro:
https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgFBkwCeYApnAAoCGAzizABY4CuA5h3AC8KAHTAAdplpQAPNToRMcMK3ZcIfDgD4yAel1xDRwwD0A-GQDGEce2WrOPfkNEQARgCtalmAAokmBAQAFyi7FASvL4AlOjRIipsjhr8MRTy9MxJ6poA6sCcAIJQUExULshiktJyNLSK9tlOHPlFJWU6+sbG5lY2dolqza0cxaXlwpXuXj7+WEGhleGRMXEJDjmp8UztVGmUdYwbwwWjuwBMFVVSshkNg8l5p2Nl550G3aYW1rbwD5stZ4XK47ca+Kaebx+AILMIwCLiKKxNDxf7NGLRIA",,
1796657921,2564,Incorrect ZodCatch Output type,"The `Output` type of `ZodCatch` is currently set to `unknown`. Consider the following:

```ts
import { z } from 'zod';

type ParentSchema = z.infer<typeof parentSchema>; // type ParentSchema = { property: string }

const parentSchema = z.object({
  property: z.string(),
});

type ChildSchema = z.infer<typeof childSchema>; // type ChildSchema = { property: string }

const childSchema = parentSchema.extend({
  property: z.string().catch(''),
});

declare let p1: ParentSchema;
declare let p2: ParentSchema;
declare let c1: ChildSchema;
declare let c2: ChildSchema;

p1 = c1; // Works
c2 = p2; // Works

declare function testSchema(schema: z.Schema<ParentSchema>): void

testSchema(childSchema); // Doesn't work
```

When trying to call `testSchema(childSchema)` the following Error is thrown:

```
Argument of type 'ZodObject<{ property: ZodCatch<ZodString>; }, ""strip"", ZodTypeAny, { property: string; }, { property?: unknown; }>' is not assignable to parameter of type 'ZodType<{ property: string; }, ZodTypeDef, { property: string; }>'.
  The types of '_input.property' are incompatible between these types.
    Type 'unknown' is not assignable to type 'string'.ts(2345)
```

It appears that the `Output` type of `ZodCatch` should be `any`.

Related https://github.com/colinhacks/zod/issues/1816",,
1795797654,2563,Problems with typing of `error.format()` of discriminated union ,"<img width=""700"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/26056783/96ffdf84-161c-4a61-827f-10b0cc22082c"">

Here we define a discriminated union, and try to get the typing of `error.format()`. However, the typing seems broken and we cannot get to the error of each case. Also, `f.tag` is typed as `{}`, which is too general.

<img width=""531"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/26056783/c8cc1eba-6249-42e2-9aa3-82034f022269"">


Reproduction on codesandbox:

https://codesandbox.io/s/problems-with-typing-of-error-format-of-discriminated-union-l2c68d?file=/index.ts",,
1793453168,2561,z.string().nullish() throws an error on undefined value,"I upgraded `zod` to `3.21.4` and the validation `zod.string().nullish().optional()` started to fail with the error:
```typescript
{
    code: ""invalid_type"",
    expected: ""string"",
    message: ""Required"",
    path: [""myField""],
    received: ""undefined""
}
```

It can be circumvented by transforming the value:
```
.transform(value => {
     return value ? value : null;
})
```",,
1793106443,2560,z.or() typescript is wrong,"Hey,

With this code:

```ts
const airportSchema = z
  .object({
    id: z.number().int().positive(),
  })
  .or(airportsStoreSchema.body);

const body = z.object({
  company: z.string().min(2).max(255),
  state: z.nativeEnum(States),
  lta: z.string().min(2).max(255),
  flightNumber: z.string().min(2).max(255),
  departureTime: z.coerce.date(),
  arrivalTime: z.coerce.date(),
  handOverTime: z.coerce.date().optional(),
  expeditor: z.string().min(2).max(255),
  weightLimit: z.number().min(0),
  volumeLimit: z.number().min(0),
  quantityLimit: z.number().min(0),
  departureAirport: airportSchema,
  arrivalAirport: airportSchema,
});
```


I should be able to call `flight.departureAirport.id` and `flight.departureAirport.name` which is inside airportsStoreSchema.body but typescript tells me that .id doesn't exist.
",,
1792210943,2558,"`z.union` parse method is not doing schema validation first, instead is throwing union error.","I think the point of z.union would be to keep the parser's behavior - that is, to throw the error - but not to ignore the validation of the schema first.

Example:
```ts
import { z } from 'zod';

const baseSchema = z.object({
  amount: z
    .number({ required_error: 'Amount must be provided' })
    .positive({ message: 'Amount should be a positive number' })
    .finite(),
});

const schema = baseSchema.or(z.array(baseSchema)); // could be z.union too, same result.

// those two work normally
console.log(
  schema.parse({
    amount: 20,
  })
);

console.log(
  schema.parse([
    {
      amount: 20,
    },
    {
      amount: 20,
    },
  ])
);

try {
  console.log(
    schema.parse({
      amount: 0,
    })
  );
} catch (err) {
  console.log(err.issues); // OK: Amount should be a positive number
}

try {
  console.log(
    schema.parse({
      amount: undefined,
    })
  );
} catch (err) {
  console.log(err.issues); // Wrong?: Invalid input
}
```
cc: @ramos-ph",,
1790883651,2554,[feat] Cloning an object schema while stripping some props,"I did not find any api for this, so i built it. it's not very clean but serves the purpose well. Please instruct if there's better way to do this:

```ts
import { z, ZodObject } from ""zod"";

type Cloned<T, K extends string | number | symbol> =
  T extends ZodObject<infer Shape, infer UnknownKeys, infer Catchall, infer Output, infer Input>
    ? ZodObject<Omit<Shape, K>, UnknownKeys, Catchall, Omit<Output, K>, Omit<Input, K>>
    : never

export function cloneSchema<
  T extends ZodObject<any>,
  K extends (keyof T['shape']),
>(schema: T, without: K[] = []) {
  const shape = Object.fromEntries(
    Object.keys(schema.shape)
      // @ts-ignore
      .filter(key => !without.includes(key))
      .map(key => [key, schema.shape[key]])
  )

  return z.object(shape) as Cloned<T, K>
}
```

usage:

```ts
const userSchema = z.object({
  userId: z.string(),
  email: z.string(),
})

const onlyEmail = cloneSchema(userSchema, ['userId'])
```",,
1790729810,2550,Intersections can result in duplicate errors,"An intersection like this
```typescript
const schema = z
  .object({ packageCount:  z.coerce.number().optional() })
  .and(z.object({ packageCount:  z.coerce.number().optional() }))
schema.parse({ packageCount: 'asd' })
```
will result in 2 invalid_type errors instead of just one.

Obviously this is a contrived example, but I'm doing something like this in real code so that I can apply a `refine()` to one part of the union (see https://github.com/colinhacks/zod/issues/2524#issuecomment-1622897861)",,
1787809031,2547,Transformer should have a different style with schema,"Day 1 on zod.

At my first glance, I thought `z.string().trim()` is schema for trim-ed string.

```js
// validations
z.string().max(5);
z.string().min(5);
z.string().length(5);
z.string().email();
z.string().url();
z.string().emoji();
z.string().uuid();
z.string().cuid();
z.string().cuid2();
z.string().ulid();
z.string().regex(regex);
z.string().includes(string);
z.string().startsWith(string);
z.string().endsWith(string);
z.string().datetime(); // defaults to UTC, see below for options
z.string().ip(); // defaults to IPv4 and IPv6, see below for options

// transformations
z.string().trim(); // trim whitespace
z.string().toLowerCase(); // toLowerCase
z.string().toUpperCase(); // toUpperCase
```

Or Suggest 1

```js
import { z } from ""zod/schema-only-no-transform"";


// @ts-expect-error: Property 'trim' does not exist on z.string()
z.string().trim()

```

Or Suggest 2

-  `z.XXX()` are schema,  `z.string().trim()` is schema to match trim-ed string

-  `Z.transform.XXX` are transformer,  `z.string().transform.trim` is schema to match string, and do string-trim transform





",,
1786361446,2546,"Use of ParseReturnType<T> instead of SyncParseReturnType<T> as param for isAborted, isDirty and isValid, isAsync util functions","I'm new to the codebase, was going through the parseUtil helper functions, found that a bunch of type predicate functions were accepting the broader `ParseReturnType` type and consequently needing to use `as any` before checking the status when it seems the `SyncParseReturnType` type would be narrower and avoids using `as any`:

```export type INVALID = { status: ""aborted"" };
export const INVALID: INVALID = Object.freeze({
  status: ""aborted"",
});

export type DIRTY<T> = { status: ""dirty""; value: T };
export const DIRTY = <T>(value: T): DIRTY<T> => ({ status: ""dirty"", value });

export type OK<T> = { status: ""valid""; value: T };
export const OK = <T>(value: T): OK<T> => ({ status: ""valid"", value });

export type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
export type ParseReturnType<T> =
  | SyncParseReturnType<T>
  | AsyncParseReturnType<T>;

export const isAborted = (x: ParseReturnType<any>): x is INVALID =>
  (x as any).status === ""aborted"";
export const isDirty = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
  (x as any).status === ""dirty"";
export const isValid = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
  (x as any).status === ""valid"";```

Is there any reason why it was done this way?",,
1786198087,2545,Alias `z.infer` to `z.Infer`?,"Given that Infer is a type, are you open to aliasing it to a pascal-cased alternative? Similar for `z.input` and `z.output`?",,
1785585036,2543,Put typeName into `ZodTypeDef` interface,"As we see here: https://github.com/colinhacks/zod/blob/master/src/types.ts#L56 `ZodTypeDef` only has `errorMap` and `description` but if check interfaces that extends `ZodTypeDef` we see that all of them have `typeName: ZodFirstPartyTypeKind` so why can’t we put typeName as property of `ZodTypeDef` ?

i also experience a problem when trying to programmatically explore zod schema at runtime like this:
```
declare const someSchema: ZodSchema;
console.log(someSchema._def.typeName; // getting ts error here
```
While we always know that `typeName` will be present in every zod type…",,
1781759398,2537,schema.shape[key].parse(value) not infering correctly when typeof key is a key of the schema.,"This is what happens:
![image](https://github.com/colinhacks/zod/assets/38871879/fc044357-c6b7-43f2-9439-48eb961f23eb)

A workaround (besides using the generic to manually set type) is using pick and then getting the value using the key:
![image](https://github.com/colinhacks/zod/assets/38871879/46f8370b-ab62-42be-b18d-3bae314fb67b)

But either way it's not expected behaviour.

Code example:
```ts
import { prisma } from ""@/prisma"";
import { z } from ""zod"";

const globalSettingsSchema = z.object({
  fee: z.number(),
  hello: z.string().optional(),
});
export type globalSchemaType = z.infer<typeof globalSettingsSchema>;

export async function getSetting<K extends keyof globalSchemaType>(key: K) {
  const setting = await prisma.globalSettings.findUniqueOrThrow({
    where: {
      key,
    },
  });
  const parsedValue = JSON.parse(setting.value);
  // const result = globalSettingsSchema.pick({ [key]: true }).parse(parsedValue);
  // return result[key];
  const result = globalSettingsSchema.shape[key].parse(parsedValue);
  return result //as globalSchemaType[K];
}
```",,
1779125805,2534,Nested union of tuples is not recognised as an iterable,"Something appears to have broken in `3.21.2`. The following reproduction shows the problem: https://codesandbox.io/s/hopeful-golick-q5lx85?file=/src/index.tsx

```ts
import { z } from ""zod"";

const TupleUnion = z.union([
  z.tuple([z.string()]),
  z.tuple([z.string(), z.string()])
]);

const Schema = z.object({
  breaks: TupleUnion,
  works: z.tuple([z.string(), z.string()])
});

type Schema = z.infer<typeof Schema>;
type TupleUnion = z.infer<typeof TupleUnion>;

function parse(s: Schema, bt: TupleUnion) {
  const [a, b] = s.breaks;
  const [c, d] = s.works;
  const [e, f] = bt;
}
```

Somehow TypeScript doesn't know that the returned tuple is iterable. I'd expect the array destructuring to work as expected here. Note how the case with `TupleUnion` by itself works, but when nested inside `z.object` it breaks.

This is the error reported by TypeScript:

```
Type '[string] | [string, string]' must have a '[Symbol.iterator]()' method that returns an iterator. ts(2488)
```

It appears to be dependant on that specific `tsconfig.json`, I'm not sure exactly what is causing the problem here.

These are the versions:
TypeScript: `5.1.3`
Zod: `3.21.2` (verified to break in both `3.21.3` and `3.21.4`)

These are the compiler options set in `tsconfig.json`:

```json
""compilerOptions"": {
  ""lib"": [
    ""dom"",
    ""dom.iterable"",
    ""esnext""
  ],
  ""strict"": true,
  ""alwaysStrict"": true,
  ""strictBindCallApply"": true,
  ""strictFunctionTypes"": true,
  ""strictNullChecks"": true,
  ""allowJs"": false,
  ""skipLibCheck"": true,
  ""noImplicitAny"": true,
  ""noImplicitThis"": true,
  ""forceConsistentCasingInFileNames"": true,
  ""esModuleInterop"": true,
  ""module"": ""esnext"",
  ""moduleResolution"": ""node"",
  ""resolveJsonModule"": true,
  ""isolatedModules"": true,
  ""downlevelIteration"": true,
  ""noUncheckedIndexedAccess"": true,
  ""incremental"": true,
  ""target"": ""es2019"",
  ""jsx"": ""preserve"",
  ""noEmit"": true,
  ""exactOptionalPropertyTypes"": false,
  ""strictPropertyInitialization"": false
}
```",,
1776752498,2531,[features] add frendlyname in zodType.,"Hi,

I have started to `overZod` my projects. So I have lots of Zod types.

I'm now implementing some custom formatting code to report my zod rejection, but to make them easier to read, I'm adding an extract of the parsed data and a unique name of my zod type.

For the parsed data, I use a custom method to update the error message and include part of the incoming data, but I do not see any non-over-boilerplate way to add a friendly name to my types.

It would be nice to add something like that:

```ts
export const LoginPostModel = z.object({
  email: z.string().email(),
  password: z.string().max(50),
}).friendly(""Login Post control input"");
```

And maybe add a reference to the parsed data in the ZodError.

Feel free to add your point of view.",,
1772048500,2528,Is there any way to specify a minimum record count in z.record?,"If I could specify a minimum number of records then I wouldn't get `possibly undefined` errors when using these records.

```ts
export enum NetworkNames {
    development = 'development',
    staging = 'staging',
    production = 'production',
}

const NetworkNamesSchema = z.nativeEnum( NetworkNames )

export const NetworkConfigSchema = z.record(
    NetworkNamesSchema,
    z.object( {
        endpoint: z.string().url(),
    } ).required()
).min( 1 ) // <--------------------------- something like this
```

Even when I specify a `.default` on the end of the `.record`, TS doesn't realise that there will be a value in the NetworkConfigSchema.",,
1769449743,2526,z.string().datetime() accepts invalid timestamp values,"`z.string().datetime()` values where both month and day values are out of range are incorrectly parsed successfully.

https://codesandbox.io/s/practical-hill-t8s9qj?file=/src/index.ts

```ts
import { z } from ""zod"";

const invalid = ""2023-13-13T17:45:07.289Z""; // 13th month and 13th day should be prohibited
const valid = ""2023-12-13T17:45:07.289Z""; // 12th month, 13th day should be allowed

console.log(z.string().datetime().safeParse(invalid).success); // true, should be false
console.log(new Date(invalid)); // Invalid Date, as it should be
console.log(z.coerce.date().safeParse(invalid).success); // false, as it should be. Using using this in addition to string().datetime() can serve as a workaround

console.log(z.string().datetime().safeParse(valid).success); // true, as it should be
console.log(new Date(valid)); // Wed Dec 13 2023 17:45:07 GMT+0000 (Greenwich Mean Time), as it should be
```
",,
1767515075,2525,How to discard paricular field in `.refine()` or somewhere else without changing the schema?,"Re-use the example in #2524:
https://stackblitz.com/edit/vitejs-vite-c6cz55?file=src%2FApp.tsx

In the example above, I first entered something in `passport`, then switched to `driver_license`, but when I submit the form, the value of `passport` is there as well.

I know this is expected since I defined it in the schema, just want to know whether there's a way to get around?

The discarding totally satisfies the schema, since both `passport` and `driver_license` is `optional`, hence discarding them won't break the type.

I'm aware that I can use `z.discriminatedUnion()` for this particular case, but it's not really my preferred solution, as in the real-world case, the complexity of the form is ridiculous, where usage of `Discriminated Union` will only make the schema even harder to organize in my opinion.

And I want the interface to looks like a simple single one instead of complex `intersection` with `discriminated union`

```ts
// This is what I need
interface User {
  name: string;
  age: number;
  id_type: 'passport' | 'driver_license'
  driver_license?: string;
  passport?: string;
}
// Instead of
type User = {
  name: string;
  age: number;
} & ({
  id_type: 'passport';
  passport: string;
} | {
  id_type: 'driver_license'
  driver_license: string;
})
// Or
type User = {
  id_type: 'passport';
  name: string;
  age: number;
  passport: string;
} | {
  id_type: 'driver_license';
  name: string;
  age: number;
  driver_license: string;
}
```  

![image](https://github.com/colinhacks/zod/assets/45784210/beda643b-2ad9-48da-919f-d36e2f9353bf)

In `yup`, I can still do `transform` after `when` condition (e.g. transform to `undefined`), can I do something similar like conditionally discard a field in `.refine()` or `.superRefine()` in `zod`? I currently can't find a way to do so.

---

Or, as another solution, is it possible to make a new feature that removes all `falsy` value or any specified value during parse? e.g. Automatically remove empty string `''`",,
1766737992,2524,"[Feature request] An option to always execute `refine`s even if parse failed, or workaround","This is a simple form, with `zod` and `react-hook-form`, using `@hookform/resolvers` for integration.
Reproduction link: https://stackblitz.com/edit/vitejs-vite-c6cz55?file=src%2FApp.tsx

This is an issue we've been talking about for a while... as in #479, #1394 and many other places... But I can't really find an ultimate solution for this.

So as part of my example, the validation schema is like this:
```ts
const schema = z
  .object({
    name: z.string().min(1),
    age: z.string()
      .transform((val) => (val ? +val : val))
      .pipe(z.number().min(18)),
    id_type: z.enum(['passport', 'driver_license']),
    passport: z.string().optional(),
    driver_license: z.string().optional(),
  })
  .refine(
    ({ id_type, passport }) => (id_type === 'passport' ? !!passport : true),
    { path: ['passport'], message: 'passport is required' }
  )
  .refine(
    ({ id_type, driver_license }) => id_type === 'driver_license' ? !!driver_license : true,
    { path: ['driver_license'], message: 'driver_license is required' }
  );
```

So in my reproduction, what I'm expecting is, once you click ""Submit` button, all error messages should appear, including the ""passport"" one (by default if you don't select driver license).

But due to `name` and `age` are not entered at all (i.e. value is `''` as the default value defined), hence it will halt and `.refine()` won't be executed at all.

I'm aware there's a concept called `stopping` or `non-stopping` issue (e.g. `invalid_type` compared to `too_small`), hence if I enter something like just a `1` in the age input box, the `refine`s will be triggered. I also know it's due to type-safety purposes and I respect that...

But in the real-world use case, most likely it's not going to work like that. Apparently, I want to show all the error messages even if nothing is filled. This can be easily achieved by API like `yup.when()` but as @colinhacks clearly says it won't be part of `zod`, hence it's really a huge headache here.

---

One way to workaround is by `z.intersection()`, and define the `id_type` / `passport` and `driver_license`, as well as those `.refine()`s into another schema, but that's not really what I want. Although it works in particular cases, but it does break my expected typing system, e.g.
```ts
// When I can have something like this
type MyType = {
  foo: string;
  bar: string;
}
// Why do I have to do this?
type A = { foo: string };
type B = { bar: string };
type MyType = A & B;
```
And even worse, it's now a `ZodIntersection` instead of a `ZodObject` where I can't do something like `.pick()` / `.omit()` after that which is not good for extensibility.

---
Something to note:
- I can't use `z.merge()` there since `ZodObject` cannot be merged with `ZodEffect` (the return type of `.refine()`)
- Since `react-hook-form`'s resolver only accepts one single schema, so I'm not sure how the `.partial()` solution works, or maybe it's not working for this case at all
- `z.discriminatedUnion()` is NOT what I need:
  - It will break the object shape, the same as `z.intersection()`
  - A real-world form may contain lots of conditions, so using this on every conditions is awkward

---

I think this is the end of my explanation as everyone working on this kind of real-world form validation will run into this issue. Is there any chance we can have this feature (at least as an OPTION) implemented in `zod` or are there any better workarounds other than the awkward `z.intersection()`?

It's kinda a show-stopper for my migration from `yup` to `zod`... so I badly want a workaround without breaking the type (i.e. the final schema should still be a single object to align with my API)",,
1766601326,2523,Incompatibility with TypeScript 5.1.3 - discriminatedUnion,"### Description
I recently updated TypeScript from version 4.9.5 to 5.1.3 and I noticed that my code that uses `zod` is no longer working as expected. It seems that types are not being correctly extracted when using TypeScript 5.1.3.

### Code to reproduce the issue

Here is the code in which I define a `zod` type:

```typescript
import * as z from 'zod';

export const ZApiGatewayClientSchema = z.enum(['One', 'Two']);

const ZGetExampleBySelectorInputSchemaOne = z.object({
  gateway: z.literal(ZApiGatewayClientSchema.Enum.One),
  env: ZApiEnvironmentSchema,
  language: z.string().length(2).optional(),
  brand: z.string().optional(),
  bookingSystem: ZBookingSystemSchemaLegacy.optional(), // optional
});

const ZGetExampleBySelectorInputSchemaTwo = z.object({
  gateway: z.literal(ZApiGatewayClientSchema.Enum.Two),
  env: ZApiEnvironmentSchema,
  language: z.string().length(2).optional(),
  brand: z.string().optional(),
  bookingSystem: ZBookingSystemSchemaLegacy, // required
});

export const ZGetExampleBySelectorInputSchema = z.discriminatedUnion('gateway', [
  ZGetExampleBySelectorInputSchemaOne,
  ZGetExampleBySelectorInputSchemaTwo,
]);

export type TGetExampleBySelectorInputSchema = z.infer<
  typeof ZGetExampleBySelectorInputSchema
>;
```

And here is the code in which I attempt to extract the discriminated union using Extract:

```typescript
async getExampleBySelector(
  input: Extract<TGetExampleBySelectorInputSchema, { gateway: 'One' }>,
): Promise<ApiExampleResponseOne> {
  return await this.requestHotels(input);
}
```

This code worked correctly with TypeScript 4.9.5, but after updating to TypeScript 5.1.3, the types are not extracted correctly.

### Expected behavior
The types should be correctly extracted even after updating TypeScript to version 5.1.3.

### Actual behavior
The types are not correctly extracted after updating to TypeScript 5.1.3.

### Environment:
- TypeScript Version: 5.1.3
- Zod Version: 3.21.4
- Node Version: 18.15.0",,
1765667681,2519,`z.input<…>` of coercibles should be `any`,"In this code …

```ts
import { z } from 'zod'

const b = z.coerce.boolean()

type B = z.input<typeof b>
```

… `B` evaluates to …

```ts
type B = boolean;
```

I expected `B` to evaluate to …

```ts
type B = any;
```

If this is intended behaviour, I'd be happy if you could share your reasoning. Thank you. :pray: 

This is related to #2421.

zod version: v3.21.4",,
1765526293,2518,Using/building in packages,"I moved my zod types into a separate package.

However, when trying to use them, all the fields are now optional. Which is not how I defined them. For example,

### Definition
```ts
export const coordinates = z.object({
  latitude: z.number(),
  longitude: z.number(),
  elevation: z.number().optional(),
});
export type Coordinates = z.infer<typeof coordinates>;
```


### Output in `index.d.ts`
```ts
export declare const coordinates: z.ZodObject<{
    latitude: z.ZodNumber;
    longitude: z.ZodNumber;
    elevation: z.ZodOptional<z.ZodNumber>;
}, ""strip"", z.ZodTypeAny, {
    latitude?: number;
    longitude?: number;
    elevation?: number;
}, {
    latitude?: number;
    longitude?: number;
    elevation?: number;
}>;
export type Coordinates = z.infer<typeof coordinates>;
```

**Do you know what I should do when putting zod types in a separate package?** 

Thanks for zod!",,
1762759368,2511,How to tighten the type of a schema,"In `yup`, I can do something like this to tighten the type of a string schema simply:
```ts
type Foo = 'foo' | 'bar'

const a = yup.string<Foo>().required()
type A = yup.InferType<typeof a>
//   ^? Foo
```

But in `zod`, seems currently the only way I can achieve it is by `z.custom`? Is there any better alternative or more straight forward way to do so?
```ts
const b = z.custom<Foo>(str => typeof str === 'string' && ['foo', 'bar'].includes(str))
type B = z.infer<typeof b>
//   ^? Foo
```
And it's even worse if I want to make it optional... where I have to write more in the `check` function and invoke `optional()` just for the type, where it actually does nothing. Overall the whole thing seems weird.
```ts
const c = z.custom<Foo>(str => str === void 0 || typeof str === 'string' && ['foo', 'bar'].includes(str))
  .optional()
type C = z.infer<typeof c>
//   ^? Foo | undefined
```

There's actually another way, but way more chaos... (Look at that I need to write another `optional()` just for type inference which actually does nothing!)... This is a little bit disgusting to deal with. Compare to `yup`'s `yup.string<Foo>()`😥. But I believe there should be an easier way right?

```ts
const d = z.string().optional()
  .refine(val => val ? ['foo', 'bar'].includes(val) : true)
  // Here I have to write "".optional()"" again otherwise it won't be in the final inferred type
  .pipe(z.custom<Foo>().optional());
type D = z.infer<typeof d>
//   ^? Foo | undefined
```

Also, the type of `check` function of `z.custom` is a little bit weird to me, like it's reasonable to make received `val` to be `unknown`, but why it's returning `any` instead of `boolean`? 

And also what's the usage of `.refinement()`? I can't find anything related in the documentation

---

https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAKjgQwM5wJ4FcxwGZQQhwDk2YJAUKJLHAN5wBecAvvocSUxACZWVKMDGACmcAGIQIcALyk80knAA+pAEbIoAygGMIAO1TxkczDgB0xqMAMBzADxSIAPgAUASgtRRARyzAPryeQiLiAIJm5BYAkgZ4olAAKmEOwmIQeCgulAD0uXCFAHoA-IJ6hsZw6mZMFrpYxkRO0u7Wci5w6aKZcO2yA6TWtnbKAGRjcADaJIoQJAA0GlokALoWtroANli8oqhu1h4eoWJwAEK1G-GJaWG96jn5hXClgvpG8LpXDU0gLa5DjAoB0+sC5IMAG4QYC8OAABlUam6vX6gxIw3s40mMzmi2W2nWmx2ewORxOhQsEDAMGAhmQWxC3TgAGErrYElA7hksrongVimV3pV4HD5HVMXZPFSaXSDAyQpSfHhbKI3JCGaCNVs4CVprMlEsSJpCddtrt9uqGR44AAuLpQLCiClwZ4ACUS4hicAAFshIeIYDIAO42GDiABEMtp9MZHgjKDsyFscAgMB9iWDwFQ4mA8GDhhI8HUuYMXQz+Fsmo5iSCXTClEpYGAYjcdV+Qf+zncXmpMflcY8AG5TuIACLsm5clFZXj8l5vIA",,
1762166459,2510,"[Source code digging] What's the purpose of `T extends [any, ...any[]]` rather than `any[]`?","I'm currently looking into this part, but found out this part is a little bit weird.

What's the purpose of `T extends [any, ...any[]]` rather than `T extends any[]` straight away? In other words, when will it match `[any, ...any[]]`? To me, the difference is non-empty arrays (or TUPLE?) and empty-able arrays, but I don't see a reason to separate them.

I've did some experimental here, where seems like any kind of `Array` will fall into `any[]`, and only `Tuple` will fall into `[any, ...any[]]`. I'm really confused about the purpose of doing this since usually we won't pass a tuple? Is this the intended design?
https://www.typescriptlang.org/play?#code/C4TwDgpgBAggPAFQHxQLxQVCAPYEB2AJgM5QDaAhviADRQB0jVIZAuqwLABQUUA-FACM3XgC4MWXARJRmbEb35QATArFQAzN24BjAPb5iwWQCcTacoLrK6Gzl32Hj+CEYiEYZi2Svkbm9l0DIywAWzBQTxNxfABXUIAjCBM2b3tuUEgoACELeAA5A3zYgBsSigSSiDhMiD0AM1MTJCRuAHo2xQA9Pm0uWqgAYTy4QvxisoqqmvA6xpc3DzMW9s7eHr6BgBERsYnyyurahrCIkCiVrg7u3q4+xxDgWLAq8TI4xOS6IxMAS3wAOasby+ADkylB6X6sygAFFdkVSgdpsdGk8XhBLtd1nwgA

I also found out that for `any[]`, we are not using `?` modifier, I'm aware it's because of TS limitation but I think `[K in keyof T]: T[K]` is pretty much the same as `[k: number]: T[number]` when `T extends any[]` matches, isn't it? hence why can't we use the same syntax as other two branches did to add the `?` modifier? Or is there any special intention here?

Or I can be wrong about above, hence can someone tell me what's happening there?
https://github.com/colinhacks/zod/blob/5e23b4fae4715c7391f9ceb4369421a034851b4c/src/ZodError.ts#L175-L185

---

This is trivial compared to the above one, but here's another place I'm confused about here in `util.ts`, I don't know why we have to force the array to be non-empty here (or is it matching non-empty TUPLE only?). If it's empty then simply return an empty object `{}` which is fine from my perspective.

https://github.com/colinhacks/zod/blob/5e23b4fae4715c7391f9ceb4369421a034851b4c/src/helpers/util.ts#L20-L28

---

Thanks a lot for anyone having a look at this. Appreciated.❤",,
1759803541,2509,Factory function for create object schema with keys passed by args,"So, i have this example: 
```
function createSchema(keys: ZodRawShape){
 
    return z.object(keys);
}

const userSchema = createSchema({

    id: z.number(),
    name: z.string()
});

type UserSchemaType = z.infer<typeof userSchema>;

const u1: UserSchemaType = {
    //Nothing inferred 
}
```

The type inference not works.. any though on this? Thx for help!",,
1759369714,2508,Can I name my project ZodBus?,"Hey, thank you for Zod; it's great and we all love it.

I'm building an event bus that uses Zod to define the schema, infer everything, and validate the data.
Is it ok with you if I call it `ZodBus`?

It's on https://github.com/3rd/zodbus, and I just published it to NPM as `zodbus`, so that the name won't get sniped by trolls.

https://github.com/3rd/zodbus/assets/59587503/08d2c13c-cccd-407f-b14c-957d7dd5115d",,
1759147721,2507,Upgrading from 3.2.1 to 3.3.0 introduces breaking changes,"I believe that changing the `content` field to being optional is a breaking change. I'm using TypeScript so it's only breaking my build, but this is going to cause a ton of projects to start failing at runtime if the API is indeed leaving it out now.

// Version 3.2.1

```TypeScript

export interface ChatCompletionResponseMessage {
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'role': ChatCompletionResponseMessageRoleEnum;
    /**
     * The contents of the message
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'content': string;
}

```

// Version 3.3.0


```TypeScript

export interface ChatCompletionResponseMessage {
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'role': ChatCompletionResponseMessageRoleEnum;
    /**
     * The contents of the message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'content'?: string;
    /**
     *
     * @type {ChatCompletionRequestMessageFunctionCall}
     * @memberof ChatCompletionResponseMessage
     */
    'function_call'?: ChatCompletionRequestMessageFunctionCall;
}
```",,
1750280047,2497,Dynamic object validation,"Hi,
at first I want to mention that I already spent some time looking for similar problem, but didn't find anything close to it. 
### Context
I'm working on some NestJS app with already installed Zod for requests validation. Currently I'm trying to create validation for custom configuration file.
For the sake of simplicity, here is the example configuration object, even though it's going to be loaded from .yml file.
```ts
const config = {
  languages: ['en', 'de'],
  resources: [
    {
      names: {
        en: 'Apple',
        de: 'Apfel',
      },
    },
    {
      names: {
        en: 'Cherry',
        de: 'Kirsche',
      },
    },
  ],
};
```
The main goal of validation is to require setting every name translation, according to entered languages. For example if I choose English only, then config should look like this:
```ts
const config = {
  languages: ['en'],
  resources: [
    {
      names: {
        en: 'Apple',
      },
    },
    {
      names: {
        en: 'Cherry',
      },
    },
  ],
};
```
If I choose more languages it should look like this:
```ts
const config = {
  languages: ['en', 'de', 'pl'],
  resources: [
    {
      names: {
        en: 'Apple',
        de: 'Apfel',
        pl: 'Jabłko',
      },
    },
    {
      names: {
        en: 'Cherry',
        de: 'Kirsche',
        pl: 'Wiśnia',
      },
    },
  ],
};
```
Of course, every missing or excess translation should result in validation error. So next two examples are considered invalid.
```ts
const config = {
  languages: ['en'], // missing 'de'
  resources: [
    {
      names: {
        en: 'Apple',
        de: 'Apfel',
      },
    },
    {
      names: {
        en: 'Cherry',
        de: 'Kirsche',
      },
    },
  ],
};
```
```ts
const config = {
  languages: ['en', 'de', 'pl'],
  resources: [
    {
      names: {
        en: 'Apple',
        de: 'Apfel',
        // missing pl:
      },
    },
    {
      names: {
        en: 'Cherry',
        de: 'Kirsche',
        pl: 'Wiśnia',
      },
    },
  ],
};
```
As for now I came up with two step solution. At first it checks an array of languages and then uses it to construct a resources schema validation.
```ts
const supportedLanguages = ['en', 'pl', 'de'] as const;
const languagesSchema = z.array(z.enum(supportedLanguages)).nonempty();
const languages = languagesSchema.parse(config.languages);
console.log(languages);

const resourcesSchema = z.array(
  z.object({
    names: z.object(
      languages.reduce(
        (acc, lang) => ({ ...acc, [lang]: z.string() }),
        {} as Partial<Record<(typeof languages)[number], z.ZodString>>,
      ),
    ),
  }),
);
const resources = resourcesSchema.parse(config.resources);
console.log(resources);
```
### Problem
It works well, but the only problem is that resource names are of type `unknown` rather than `string`.
![image](https://github.com/colinhacks/zod/assets/33811303/22812f70-5e71-4554-a89f-7f3647f0ad25)

Any help will be appreciated, even if it doesn't resolve `unknown` type issue, but maybe changes config structure or schema construction.
",,
1746094290,2493,Cannot find module 'zod' or its corresponding type declarations.,"I have a strange issue that when I run my tests locally, they pass, but in a Github Action, the runner cannot find the `zod` NPM package after running `npm ci`. The runner does not have this problem with other NPM packages. Any ideas?",,
1745649548,2492,Custom error messages can't be modified with ErrorMap,"According to the [documentation](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#customizing-errors-with-zoderrormap) it should be possible to override all error messages, but it only works with custom errors only if the original message is undefined. Messages defined in refinements seem to be hardcoded and values returned by ErrorMap are ignored.

[codesandbox example](https://codesandbox.io/s/laughing-voice-10u0wk?file=/src/index.ts)",,
1745068165,2491,`.optional().default()` doesn't make property optional in typeScript type inference,"Hello,

I've encountered an issue when trying to use .optional().default() on a Zod schema. Even when a property is marked as .optional(), the inferred TypeScript type requires the property to be present.

Here's a simple example to illustrate the problem:

```typescript
import { z } from 'zod';

const schema = z.object({
  name: z.string(),
  rootDir: z.string().optional().default(""default/path""),
});

type SchemaType = z.infer<typeof schema>;

function processConfig(config: SchemaType) {
  // Function implementation...
}

const config = {
  name: ""myApp"",
};

processConfig(config); // TypeScript error: 'rootDir' is missing in type '{ name: string; }' 
```

In this example, TypeScript expects both 'name' and 'rootDir' to be present in the 'config' object, even though 'rootDir' is marked as optional with a default value in the Zod schema.

My expectation would be that, since 'rootDir' is marked as .optional(), it should not be required in the inferred TypeScript type. I would expect this code to compile without errors, and for Zod to apply the default value of 'rootDir' at runtime when it's not provided.

Is this the intended behavior or am I misunderstanding the usage of .optional().default()?

Thanks for your help!",,
1744369214,2490,Error during the parsing with a readonly schema.,"Hi,

I've been very disappointed by the fact that we can't parse an object with a readonly z.object schema: indeed, it is not secure to not freeze a public complex schema, used by several functionnalities of a software. A developer may do a mistake by modifying the internal data of the schema somewhere, which impacts directly the rest of the software functionnalities. This is not safe coding. :/

The error message during the execution of the Schema.parse method is :
`TypeError: Cannot assign to read only property '_cached' of object '#<O>'

      at O._getCached (../node_modules/@mylib.js:1:44278)
      at O._parse (../node_modules/@mylib.js:1:44518)
      at O._parseSync (../node_modules/@mylib.js:1:22947)
      at O.safeParse (../node_modules/@mylib.js:1:23438)
      at O.parse (../node_modules/@mylib.js:1:23121)`

I suppose the zod library stores a cache inside the z.object schema, which causes the problem. The library should store nothing inside the schema after its creation. If a cache must be used, why not store its contents somewhere inside an internal Map in the zod library inner files, associating a schema to the value(s) to cache associated to it? Plus the advantage you can manage a global cache, with a limited size and/or with a time-limited storage.

zod version: 3.21.4

Regards.",,
1744206459,2489,How to strictify ZodType,"Using z.ZodType<Obj>, typescript tells me that I'm missing the name key from the objSchema, correctly.

```ts
type Obj = {
  id: string
  name: string
}

const objSchema: z.ZodType<Obj> = z.object({
  id: z.string()
}).strict() 
```

But, this example:

```ts
type Obj = {
  id: string
  name: string
}

const objSchema: z.ZodType<Obj> = z.object({
  id: z.string(),
  name: z.string(),
  extraParam: z.string() // unwanted extra param
}).strict()
```

Doesn't warn me that I have an extra key in my schema definition. How can I achieve the same level of strictness from the generic type of the strict() method?",,
1740376443,2481,How do I reuse a scheme as a nested field of another type,"trying to achieve this:

```ts
type A {
   field1: string;
   field2: number;
}

type B {
  arrayOfA: A[];
}
```

I'm not clear on the syntax to achieve that:

```ts
// equivalent to type A
const AZod = z.object({
field1: z.string(),
field2: z.number()
});


// equivalent to type B
const BZod = z.object(z.array(z.infer<typeof AZod>) // is this correct?
```


also, wondering if it is possible to skip this entirely and just infer directly from the types I already have?

Want to do this:

```ts
type A {
   field1: string;
   field2: number;
}

// type A schema zod validator directly from the type
const AZod = z.Zod<A> // create the A zod type without typing everything?

type B { ... } 
const BZod = z.Zod<B> // ?
```
",,
1736520215,2473,[idea - needs work][discussion] `z.satisfies` companion to `z.infer`,"TLDR;

Allows for overriding the output of `z.infer` while still being constrained to it's requirements.

```ts
type satisfies<T extends z.infer<Zod>, Zod extends z.ZodType> = T extends z.infer<Zod> ? T : never;
```

## Why

Due to a combination of the way Zod is built and the limitations of TS's type system, types produced by `z.infer` can be difficult to read. While intellisense does a lot of the legwork for us, there are some cases where it's worth the extra work of manually writing a type just to clean up TS's inference. This becomes increasingly true for larger unions and non-trivial object structures.

## How

```ts
type satisfies<T extends z.infer<Zod>, Zod extends z.ZodType> = T extends z.infer<Zod> ? T : never;
```

The generic `Zod` here must be a valid input to `z.infer`, and the generic `T` must satisfy that inferred constraint. This leads to some interesting behavior beyond simply working as a `satisifes` clause for the user-defined type. Some of these are desirable, others less so, and ultimately this does *not* enforce everything that the schema enforces.
Therefore, the purpose of this is less ""it guides you as you write your own inferred type, blocking anything which is not permitted"" and more of a ""you know what you're doing and recognise this is **satisifies**, not **implements**"".

An implements type could be created with a little bit more work, though I doubt that it would be used much. The kind of user who would need a strict constraint when manually defining the type of their schema is the kind of user who more than likely wouldn't want to go down that route to begin with.

## Key Benefit

The major benefit of this I see is that Zod schemas can be made infinitely generic. For example, some `z.any()` can instead be made generic, allowing library authors or (more likely) users to create their own type safety for situations where the internal workings don't care what data is at a certain place, but consumers want to ensure they adhere to some structure or other when manipulating it.

```ts
const mySchema = z.object({
  foo: z.string(),
  bar: z.string(),
  baz: z.record(z.string(), z.any())
});
type MySchemaTyped<T extends Record<string, any> = Record<string, any>> = z.satisfies<{
  foo: string;
  bar: string;
  baz: T;
}, typeof mySchema>

// consumer
const myData = mySchema.parse({
  foo: ""foo"",
  bar: ""bar"",
  baz: {
    thisIsNot: ""assignable to `Thing`"",
//  ^^^^^^^^^ ts(2322)
  },
} satisfies MySchemaTyped<Thing>) as MySchemaTyped<Thing>;
```

This could be more user-friendly and less verbose with a modified `parse` signature. It would no longer allow any input, however it would use TS to validate that the input matches the additional constraint. This would not effect the runtime at all; this is a self-imposed restriction rather than a validation restriction.

```ts
// additional parse signature example
    parse(data: unknown, params?: Partial<ParseParams>): Output;
    parse<EnforceInput extends Output = Output>(data: EnforceInput, params?: Partial<ParseParams>): T;

const myData = mySchema.parse<MySchemaTyped<Thing>>({
  foo: ""foo"",
  bar: ""bar"",
  baz: {
    thisIsNot: ""assignable to `Thing`"",
//  ^^^^^^^^^ ts(2322)
  },
});
```",,
1728962962,2464,Using undefined() incorrectly marks keys as optional,"From [this Stackoverflow question](https://stackoverflow.com/questions/71477015/specify-a-zod-schema-with-a-non-optional-but-possibly-undefined-field) (I'm hitting the same thing):

This code:
```typescript
const schema = z.object({
  x: z.string().or(z.undefined()),
});
type Schema = z.infer<typeof schema>;
```

Produces a schema with an optional key:
```typescript
type Schema = {
    x?: string | undefined;
}
```

Same with:
```typescript
z.undefined().or(z.string())
```
Same with any variation of union (which seems to be how `.or()` resolves under the hood anyway)
```typescript
x: z.union([z.string(), z.number(), z.undefined()])
```
",,
1728499913,2463,object.extend broken referential transparency,"Hi,

This is a weird one, but I'm seeing the following issue. Here's the minimal code to repro:

```typescript
const mapType = <
    SchemaType extends z.ZodTypeAny,
    FinalSchemaType extends z.ZodType<z.output<SchemaType>>
>(
    schema : SchemaType
) : FinalSchemaType => {
    return schema as unknown as FinalSchemaType;
};

const foo = z.object({}).extend({
    foo: mapType(z.string())
});

const extension = {
    foo: mapType(z.string())
};

const foo2 = z.object({}).extend(extension);

type Foo = z.output<typeof foo>['foo'];
type Foo2 = z.output<typeof foo2>['foo'];

// @ts-expect-error
export const shouldNotAllowNumber : Foo = 1;

// @ts-expect-error
export const shouldNotAllowNumber2 : Foo2 = 1;
```

For some reason `Foo` resolves to `any`, while `Foo2` correctly resolves to `string`.

This is weird, right? In both cases the exact same object is used to extend the object. ",,
1727701796,2462,Type that allows any type of schema?,"I want a function to receive any zod schema as an argument. If I use `z.ZodSchema` as a the type of the argument it works mostly fine, but if I use `.transform` or `.pipe` in the schema I'm passing as an argument it breaks.

This is my function:
```javascript
import axios from 'axios';
import { z } from 'zod';

async function apiFetcher<O>(zodSchema: z.ZodSchema<O>, options) {
  const response = await axios.request<O>(options);
  return zodSchema.safeParse(response.data);
}
```

And here's what doesn't work:
```javascript
const DataSchema = z.object({
  expiration_date: z.string().datetime().pipe(z.coerce.date()),
});

const data = apiFetcher(DataSchema, {/* options */});
```",,
1727581829,2460,z.infer does not show unions,I have a schema  where I need to hide/show different fields based on another fields value. I was able to accomplish the validation using `union` but now those fields in the union do not appear whenever i try to `z.infer<typeof schema` to have the type autocomplete and TS linter errors saying those fields do not exist (when they actually do exist),,
1722975597,2456,isOptional/isNullable aren't compatible with async transforms,"```
z.string().optional().transform(async x => x).isOptional()
Uncaught:
Error: Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.
    at ZodEffects._parse (/Users/andy/stl-api/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/types.js:2842:27)
    at ZodEffects._parseSync (/Users/andy/stl-api/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/types.js:127:29)
    at ZodEffects.safeParse (/Users/andy/stl-api/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/types.js:157:29)
    at ZodEffects.isOptional (/Users/andy/stl-api/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/types.js:311:21)
```

I can understand that `isOptional` is kind of an expedient.  But we're trying to use some 3rd-party OpenAPI schema generation libs that rely on `isOptional`, crashing on our schemas that have async transforms.

For the OpenAPI schema generation use case at least, ""static analysis"" would work well enough for most cases:

```
// ZodType
isOptional() {
  // subclasses should override
  return false;
}
```
```
// ZodOptional, ZodUndefined, ZodVoid
isOptional() {
  return true
}
```
```
// ZodUnion
isOptional() {
  return this.options.some(o => o.isOptional());
}
```
```
// ZodLazy
isOptional() {
  return this.schema.isOptional();
}
```
etc...",,
1718558749,2454,Universal unwrap for types and term,"I often find myself building interfaces that want to take a zod type, and then need to perform some branching logic based on the zod type that was given, either at the type level, term level, or both.

I've done this enough times now, facing pain each time, that I thought I'd make an issue. The out come of this issue might be:

1. Better Docs
2. Better Utility types

Take this example:

<img width=""401"" alt=""CleanShot 2023-05-21 at 12 08 10@2x"" src=""https://github.com/colinhacks/zod/assets/284476/36fb6ab9-44fa-43b1-b743-a16f6fe37b42"">

`.unwrap` is nice, but it is not universally available. Nor is it clear which subset of zod types support it. My solution to this varies. I don't remember every incarnation but often it's something about constraining the input type from being any zod type to being something narrow. Often I start extremely narrow and then open up based on consumer needs. That approach however doesn't work for library design where the callsite/consumer and the interface are far apart.

Perhaps some additional type categories groups would be helpful such as `z.SomePrimitiveType` which would allow `boolean` `string` etc. but also crucially the various additional things such as `pipe` `optional`, union, etc.

Also, the ability to universally unwrap any zod type to its primitive type, or multiple (if it's a union etc.) would be useful as well.

Note, I have seen this doc: https://github.com/colinhacks/zod#writing-generic-functions.


",,
1718011155,2451,Does `.shape` not work on recursive types in zod?,"I am unable to use `.shape` when I use `z.ZodType<Type>`:

```ts
/* eslint-disable sort-exports/sort-exports */
import { z } from 'zod'

export const LOAD_FIND_TEST = [
  'bond',
  'base_link_mark',
  'head_link_mark',
  'base_mark',
  'head_mark',
  'base_text',
  'miss_bond',
  'have_bond',
  'have_text',
] as const

export type Load = {
  find?: LoadFind
  read?: LoadRead
  save?: LoadSave
  task?: string
}

export type LoadFind = LoadFindLink | Array<LoadFindLink>

export type LoadFindBind = {
  form: 'bind'
  list: Array<LoadFindLink>
}

export type LoadFindLike = {
  base: LoadFindLikeLinkBond
  form: 'like'
  head: LoadFindLikeBond | LoadFindLikeLinkBond
  test: LoadFindTest
}

export type LoadFindLikeBond = string | boolean | null | number

export type LoadFindLikeLinkBond = {
  link: string
}

export type LoadFindLink = LoadFindLike | LoadFindRoll | LoadFindBind

export type LoadFindRoll = {
  form: 'roll'
  list: Array<LoadFindLink>
}

export type LoadFindTest = (typeof LOAD_FIND_TEST)[number]

export type LoadRead = {
  [key: string]: true | LoadReadLink
}

export type LoadReadLink = {
  find?: LoadFind
  read: LoadRead
}

export type LoadSave = {
  [key: string]: Array<LoadSaveBase> | LoadSaveBase
}

export type LoadSaveBase = {
  find?: LoadFind
  read?: LoadRead
  save?: LoadSave
  task?: string
}

export type LoadSort = {
  name: string
  tilt: '+' | '-'
}

export const Load: z.ZodType<Load> = z.object({
  find: z.optional(z.lazy(() => LoadFind)),
  read: z.optional(z.lazy(() => LoadRead)),
  save: z.optional(z.lazy(() => LoadSave)),
  task: z.optional(z.string()),
})

export const LoadFind: z.ZodType<LoadFind> = z.union([
  z.lazy(() => LoadFindLink),
  z.array(z.lazy(() => LoadFindLink)),
])

export const LoadRead: z.ZodType<LoadRead> = z.record(
  z.union([z.lazy(() => LoadReadLink), z.literal(true)]),
)

export const LoadSave: z.ZodType<LoadSave> = z.record(
  z.lazy(() => LoadSaveBase),
  z.array(z.lazy(() => LoadSaveBase)),
)

export const LoadFindBind: z.ZodType<LoadFindBind> = z.object({
  form: z.literal('bind'),
  list: z.array(z.lazy(() => LoadFindLink)),
})

export const LoadFindRoll: z.ZodType<LoadFindRoll> = z.object({
  form: z.literal('roll'),
  list: z.lazy(() => z.array(LoadFindLink)),
})

export const LoadFindTest = z.enum([
  'bond',
  'base_link_mark',
  'head_link_mark',
  'base_mark',
  'head_mark',
  'base_text',
  'miss_bond',
  'have_bond',
  'have_text',
])

export const LoadFindLike: z.ZodType<LoadFindLike> = z.object({
  base: z.lazy(() => LoadFindLikeLinkBond),
  form: z.literal('like'),
  head: z.union([
    z.lazy(() => LoadFindLikeLinkBond),
    z.lazy(() => LoadFindLikeBond),
  ]),
  test: LoadFindTest,
})

export const LoadFindLink: z.ZodType<LoadFindLink> = z.union([
  z.lazy(() => LoadFindLike),
  z.lazy(() => LoadFindRoll),
  z.lazy(() => LoadFindBind),
])

export const LoadFindLikeBond: z.ZodType<LoadFindLikeBond> = z.union([
  z.string(),
  z.boolean(),
  z.null(),
  z.number(),
])

export const LoadFindLikeLinkBond: z.ZodType<LoadFindLikeLinkBond> =
  z.object({
    link: z.string(),
  })

export const LoadReadLink: z.ZodType<LoadReadLink> = z.object({
  find: z.optional(LoadFind),
  read: LoadRead,
})

export const LoadSaveBase: z.ZodType<LoadSaveBase> = z.object({
  find: z.optional(LoadFind),
  read: z.optional(LoadRead),
  save: z.optional(LoadSave),
  task: z.optional(z.string()),
})

export const LoadSort: z.ZodType<LoadSort> = z.object({
  name: z.string(),
  tilt: z.enum(['+', '-']),
})

console.log(LoadFindLike.shape)
```

> Property 'shape' does not exist on type 'ZodType<LoadFindLike, ZodTypeDef, LoadFindLike>'.ts(2339)

How do I get `.shape` to work when I have to use `z.ZodType` for the recursive types?

This is the only way I have figured it out so far:

```ts
export const LoadSort: z.ZodType<LoadSort> = z.object({
  name: z.string(),
  tilt: z.enum(['+', '-']),
})

// console.log((LoadFindLike._def as z.ZodObjectDef).shape())

assertZod(LoadSort)

console.log(LoadSort.shape)

export function assertZod<S extends z.ZodObject<z.ZodRawShape>>(
  x: unknown,
): asserts x is S {
  if (!(x instanceof z.ZodObject)) {
    throw new Error()
  }
}
```

Update: [Cross post](https://stackoverflow.com/questions/76293170/property-shape-does-not-exist-on-type-in-zod).",,
1717868486,2448,"When z.infer a Record with Template Literal Type as a key, it becomes a Partial Record.","This issue is very similar to #2069 but instead of Branded key, the same issue is with Template Literal Type key.

When z.infer a Record with Template Literal Type as a key, it becomes a Partial Record.


With defining a Record type normally:

```ts
import { z } from ""zod""

const zodKey = z.custom<`${number}`>()

type ZodKey = z.infer<typeof zodKey>
type ZodRecord = Record<ZodKey, number>
// type ZodRecord = {
//     [x: `${number}`]: number;
// }
```

With defining a Record type with `z.infer`:
```ts
import { z } from ""zod""

const zodKey = z.custom<`${number}`>()
const zodRecord = z.record(zodKey, z.number())

type ZodRecord = z.infer<typeof zodRecord>
// type ZodRecord = {
//     [x: `${number}`]: number | undefined;
// }
```
It has `undefined`.

---
The extra Partial<...> is more explicit in this case:

```ts
import { z } from ""zod""

const zodKey = z.custom<`${number}`>()
const zodRecord = z.record(zodKey, z.object({ a: z.number(), b: z.number() }))
const zodWrapper = z.object({ zodRecord })

type ZodWrapper = z.infer<typeof zodWrapper>
// type ZodWrapper = {
//     zodRecord: Partial<Record<`${number}`, {
//         a: number;
//         b: number;
//     }>>;
// }
```",,
1716413394,2445,Keep async validations in regular `parse`,"I'm building a form validation library that accepts a zod schema. I'd like to run `.parse()` as I do currently but retain async validations in the result

So if a consumer provided us with a schema like 

```js
const schema = z.object({
  age: z.number().min(18),
  username: z.string().refine(userNameExists, { message: ""Username taken"" })
})
```
I could call `.parse()` and get an immediate result with  `{ success: true, loading?: Promise<Result> }`

Right now I can emulate the behaviour with something like this

```js
try {
  let r = schema.parse(value, {async: false})
  updateValidation(r)
} catch (e) {
  if (isAsyncValidationError(e)) {
    setLoading(true)
    schema.safeParseAsync(value).then((r) => {
      setLoading(false)
      updateValidation(r)
    })
  }
}
```
But obviously this isn't ideal as I'm having to re-parse the whole object twice. What I'd prefer is something like this

```js
let result = schema.safeParse(value)

if (result.loading) {
  setLoading(true)
  result.loading.then(r => updateValidation(r))
  setLoading(false)
} else {
  updateValidation(r)
}
```",,
1716183447,2444,Even explicitly declaring circular z.ZodObject types seems impossible,"I need to declare some circular object schemas, but I'm wishing I'd be able to `.partial()` on them without casting...so I tried declaring more refined explicit types, but even that doesn't work...

```ts
import z from ""zod"";

type ExtendedZodObject<
  Base extends z.SomeZodObject,
  Aug extends z.ZodRawShape
> = z.ZodObject<z.objectUtil.extendShape<Base[""shape""], Aug>>;

const baseUser = z.object({
  id: z.string(),
  name: z.string().optional(),
});

type UserType = ExtendedZodObject<
  typeof baseUser,
  {
    posts: z.ZodArray<z.ZodLazy<PostType>>;
  }
>;
const User: UserType = baseUser.extend({
  posts: z.array(z.lazy(() => Post)),
});

const PartialUser = User.partial();  // <-- this is why I don't want just const User: z.ZodType<...> 

const basePost = z.object({
  id: z.string(),
  body: z.string(),
  userId: z.string(),
});

type PostType = ExtendedZodObject<
  typeof basePost,
  {
    user: z.ZodLazy<UserType>;
  }
>;
const Post: PostType = basePost.extend({
  user: z.lazy(() => User),
});
```

### Errors
```
Type of property 'posts' circularly references itself in mapped type 'baseObjectOutputType<{ id: ZodString; name: ZodOptional<ZodString>; posts: ZodArray<ZodLazy<PostType>, ""many"">; }>'.ts(2615)
Type of property 'posts' circularly references itself in mapped type '{ id: ""id""; name: never; posts: never; }'.ts(2615)
Type of property 'user' circularly references itself in mapped type 'baseObjectOutputType<{ id: ZodString; body: ZodString; userId: ZodString; user: ZodLazy<UserType>; }>'.ts(2615)
Type of property 'user' circularly references itself in mapped type '{ [k in keyof baseObjectOutputType<{ id: ZodString; body: ZodString; userId: ZodString; user: ZodLazy<UserType>; }>]: undefined extends baseObjectOutputType<...>[k] ? never : k; }'.ts(2615)
```

I'm not a TS expert, but it makes me wonder if some less complicated type mapping would be possible than what `baseObjectOutputType` is doing, that would be compatible with TS...",,
1714426329,2440,superRefine breaks compatibility with discriminatedUnion,"# Problem

Here's an easy demo, using zod@3.21.4

```ts
import * as z from ""zod"";

const schemaA = z.object({
  version: z.literal(""a""),
}); // observation, no use of superRefine

z.discriminatedUnion(""version"", [schemaA]); // works

const schemaB = z
  .object({
    version: z.literal(""b""),
  })
  .superRefine(() => {}); // observation, use of superRefine

z.discriminatedUnion(""version"", [schemaB]); // doesn't work

/*
Type 'ZodEffects<ZodObject<{ version: ZodLiteral<""b"">; }, ""strip"", ZodTypeAny, { version: ""b""; }, { version: ""b""; }>, { version: ""b""; }, { version: ""b""; }>' is missing the following properties from type 'ZodObject<{ version: ZodTypeAny; } & ZodRawShape, UnknownKeysParam, ZodTypeAny, { [x: string]: any; version?: any; }, { [x: string]: any; version?: any; }>': _cached, _getCached, shape, strict, and 14 more.ts(2740)
*/
```

The type-error is correct, and it breaks at runtime as well.

In otherwords, ZodEffect<ZodObject> isn't supported... but it should be! A schema that has assertions on top of it is still a compatible schema.

# Expectation

`z.discriminatedUnion` to still work on `.superRefine`d schemas.",,
1712576631,2437,Option to allow bitwise operations on enums,"I'd like to be able to use bitwise operations on enums and have them validated using zod. 
```ts
enum Flags {
  None = 0,
  Good = 1 << 0,
  Bad = 1 << 1,
  Solid = 1 << 2
}

const Thing = z.object({
  flags: z.nativeEnum(Flags),
  name: z.string()
});

type Thing = z.infer<typeof Thing>;

const thing: Thing = {
  flags: Flags.Good | Flags.Solid,
  name: ""Test""
};

Thing.parse(thing);
```
Currently, I'm given an `invalid_enum_value` error, as the value of `Flags.Good | Flags.Solid`, `5`, is not one of `[ 0, 1, 2, 4  ]`. Is there any way I can allow bitwise operations on enums and have them validated? Or should I just required a number and hope the user does the right thing. ",,
1712195853,2435,Creating default for a property in a recursive schema causes error,"Here is a minimal example:

```ts
export const mySchemaBase = zod.object({
  someOptionalThing: zod.boolean().default(true),
});

export type SchemaWithChildren = zod.infer<typeof mySchemaBase> & {
  children: SchemaWithChildren[];
};

export const finalSchema: zod.ZodType<SchemaWithChildren> = mySchemaBase.extend({
  children: zod.lazy(() => finalSchema.array()),
});

// Note that the type is correct, and when we parse, the parsing is fine
type MyType = zod.infer<typeof finalSchema>;
    // ^?
```

Error happens at `export const finalSchema`

When I check the type on the final line, it seems to be correct.  When I parse items, it seems to parse correctly giving the default value.  It appears to be an error with `finalSchema` because we are ""helping"" the type for the recursive schema using `zod.ZodType`.

Playground link: https://www.typescriptlang.org/play?ssl=17&ssc=10&pln=1&pc=1#code/JYWwDg9gTgLgBAKjgQwM5wF4QCZwGZQQhwDkW2JA3AFDUCmAHpLHAMYQB2q8IAngMqsAFnRDIAQmjpwAvJhwA6CACMAVnVYwAFAG9qcOKiJ0A8mBjBOyADYAVIcA4BzAFzzsC5RAjW6yDloAlArYdHjIAK7W2jBQEXSBADTUAL6BNPRM0PAwvGDSgiJiAOrAMEIAwg7W2FB0HLLuCo54dFAAPLn5EHhwfIWiElIAfHAAZHB6BsLANXUcbgMlZZXVtfUA2gC6NCkZjMzw7FzweI42S8hu5AoAWji2eXTtl6XlVbPrHKNy-cKDklQdAUjBg9Wwun0bDW82uimsyAwvC0QVkozOHAu-zECmQUCgyGRgSSqXStAA9OS4AA5CBguDlZA5EQMp5wYDodj4jQwRIoDi4ADuIgagukYDxQL55XFkscTnZ6AxdGoXWkAFleI98o0bi02p0nj18OdrJdhjQDAZKXAAHoAfiAA",,
1710766692,2433,Invalid emoji regular expression,"Here is the full error message: 

```Invalid regular expression: /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/: Invalid property name```

based on sentry, it says the error is happening on this line:

```const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;```

Looking thru the zod source code quickly it seems like [this line](https://github.com/colinhacks/zod/blob/a8be4500851923aa865e009fe9c2855e80482047/src/types.ts#L556) is the origin.

For context, this is happening on a NextJS (13.1.6) site with zod v3.21.4. 

Based on sentry it seems like it's happening on Android phones exclusively on the following browsers: 
- UC Browser 13.4.2: 24%
- Chrome Mobile 68.0.3440: 16%
- Chrome Mobile 66.0.3359: 16%
- Chrome Mobile WebView 62.0.3202: 12%
- Other: 30%",,
1708525028,2427,Global installation to be able to use zod with Code Runner,"Is it also possible to globally install zod to be used with for example Code Runner?

Something like:
`yarn add zod -g`
**settings.json**
```
  ""code-runner.executorMap"": {

    ""python"": ""python"",    
    ""javascript"": ""node"",
    //""javascript"": ""node -r esm $fullFileName""
    ""typescript"": ""node"",
    //""typescript"": ""node -r esm $fullFileName""
  },
```

### **Tried:**
**zod.ts** (how to access the globally installed module?) ==> 😕
```
// import { z } from 'zod'; // => SyntaxError: Cannot use import statement outside a module
// const z = require('zod') // => SyntaxError: Unexpected token 'export'
const scheme = z.number(); // => error TS2304: Cannot find name 'z'

export const toString = (num: unknown) => {
  return String(scheme.parse(num));
};
console.log(toString(1))
console.log(toString(""1""))
```
**zod.mts** (with errors, seems to behaves the same as `ts`) ==> 😕
```
// import { z } from 'zod'; // => SyntaxError: Cannot use import statement outside a module
// const z = require('zod') // => SyntaxError: Unexpected token 'export'
const scheme = z.number();

export const toString = (num: unknown) => {
  return String(scheme.parse(num));
};
console.log(toString(1))
console.log(toString(""1""))
```
**zod.mjs** (without errors, but without typescript and by importing `zod`) ==> 😢
```
import { z } from 'zod';
// const z = require('zod')
const scheme = z.number();

export const toString = (num) => {
  return String(scheme.parse(num));
};
console.log(toString(1)) // => 1
console.log(toString(""1"")) // => ZodError: ""Expected number, received string""
```

",,
1706807450,2424,No way to merge multiple schemas. request function to merge deep multiple schemas like javascript object spread,"v3.20.6

We got no way to merge the **3 or more schemas** into 1 schema.

GiftVehicle.ts file
```
export const VehicleSchema = merge CarSchema, TruckSchema and SuperCarSchema 

Goal:
VehicleSchema = z.object({
  authToken: z.string(),
  colour:  z.string(),
  options: z
    .object({
      giftMessage: z.string().optional(),
      isConvertible: z.boolean().optional(),
      hasHugeWheels: z.boolean().optional(),
    })
    .optional(),
})
```

If we use `merge`, for more than 2 e.g. `CarSchema.merge(TruckSchema).merge(SuperCarSchema)`

it doesn't copy the deeper `options` correctly. after test, the `TruckSchema.options.hasHugeWheels` disappears.

`union` or `discriminatedUnion`  is not making it due to the way it works. its not merging of object properties.

any suggestions? please help thank you...

.
.
.
.
.


GiftCar.ts file
```
export const CarSchema = z.object({
  authToken: z.string(),
  colour:  z.string(),
  options: z
    .object({
      giftMessage: z.string().optional(),
      isConvertible: z.boolean().optional(),
    })
    .optional(),
})

call giftCar API
```

GiftTruck.ts file
```
export const TruckSchema = z.object({
  authToken: z.string(),
  colour:  z.string(),
  options: z
    .object({
      giftMessage: z.string().optional(),
      hasHugeWheels: z.boolean().optional(),
    })
    .optional(),
})

call giftTruck API
```

GiftSuperCar.ts file
```
export const SuperCarSchema = z.object({
  authToken: z.string(),
  colour:  z.string(),
  options: z
    .object({
      giftMessage: z.string().optional(),
      isConvertible: z.boolean().optional(),
    })
    .optional(),
})

call giftSuperCar API
```",,
1705765651,2421,"z.input: ""enum"" should infer to ""string"" and ""coerce"" to the coercible types","Given this [TS example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHAREiAE1wCgSBjCAOwGd4AxCCAIwEMo4BeOJAOhYBWAU3IwAFAhJxpGJgC4evOlGBUA5mICUvGFFa100EGIBuXAHxwTvADZD1MABaaANFJlsoCvvYCuxgG1cT1wXPEMIXABdV3dpCM9vJV1VDW1mPSpCMVwE9lxNEhRCkhgATzAhOEYWdgBJLkVVMF8YAB5yyoh0aqZPc1KKqprPAHlGvlV0ISgOoe7e2qgBknRfKlFgajhyKCFWGCER9jFm1oVjqDrNRDid6jpZJcbL3jB2GiFTqhaYQpk4AB6QFwXhg3hFMjAuBCAAerHAdjgMAgMNovj2cAA7o57HAyhBfDtHPo1MM+uwwk4DvjCRwbBBWIQZvdmXBgDQ4KwbDRUb4wIQDkJCCRobjMXsQMBYQBaDmOOAMpkzMLMVpwGigYA2djsqhwCBOFmUKiHWEwGgkVg0MobDDrTbbJXMqBiPYARwUACUhO7fEI6DdJACTY9DFAcNxWFjWMB4B7eOGQAARA6sLR3UPwPIcbi7faHS4SO4AiIKADKKXUYiTvDJ4gA5BEG5pYgCAYk4JWVNXa-WxA3PC22+34hSvF2qxo+0JGznh3dikUgA)

> The inferred input type (z.input) of z.enum should be string, not the literal.

Found another, similar case, updated adding this [coerce example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHAREiAE1wCgSBjCAOwGd4AxCCAIwEMo4BeOJAOhYBWAU3IwAFAhJxpGJgC4evOlGBUA5mICUvGFFa100EGIBuXAHxwTvADZD1MABaaANFJmGW7BX2WqN2sx6VIRiuJ5sULiu7tKRnj68lEJQ5EK8VACuIMwpWrzsegCeWiQommQwRWBCcIxeUACSXIqqYJkwADxVNRDodUyR5iQ9tfWRAPItfKroKd3VQn0DDcMk6JlUosDUcORQQqwwQuPsYm0dCqdNmoixe9R0sg0t17xg7DRC51TtMBUyOAAeiBcF44PuBxgmSgVGekTKZBBcCEAA9WOA7HAYBAUbQYbUAO6OexwIoQTJ7Rz6NRjQbsFzY6nwckwuA2CCsQgpB7cuDAGhwVg2Gi4zJgQhHISEEjIkkHOAHEDAVEAWgFjnZnO5UEZzA6cBooGANnY-LhECcPMoVGOqJgNBIrBoRS2GE2212HK5eQOAEcFAAlIR+zJCOi3SSAm1PQxQHDcViE1jAeD+3hxkAAESOrFK0ce8AiZu4+0Ox2uEnugIScAAyrp-GJM7xaeIAOSeduaGKAmv0qAKBsqdTNoytoQd4tQbu9vtxdi1lttgCCNhsYXiTGivBArDAYmH-gBMnKZSAA)

> The inferred input type (z.input) of coerce should be a union of types coercible.

If the examples aren't enough to understand why it makes more sense, I can clarify more in detail.",,
1699607474,2414,Proper way to use zod enum without using native enum.,"I have a sample enum as an object:

```ts
export const timeFilter = {
    ANY: """" as const,
    DAY: ""r86400"" as const,
    WEEK: ""r604800"" as const,
    MONTH: ""r2592000"" as const,
}
```
and I want to build the type: `z.enum(["""", ""r86400"", ""r604800"", ""r2592000""])`

If I use the syntax `z.enum(Object.values(timeFilter))` that will failed `Object.values` will return the type `string[]`

I also tried to used a const array with a const type:
```ts
export const validTimeFilter = Object.values(timeFilter) as typeof timeFilter[keyof typeof timeFilter][];
```
by now the error is:
```
Argument of type '("""" | ""r86400"" | ""r604800"" | ""r2592000"")[]' is not assignable to parameter of type '[string, ...string[]]'.
```

I do not want to use enum for various reasons.

And I'm sure that a typical case should be present in the Zod documentation.

---

The syntax: 
```ts
export enum TimeFilter {
    ANY = """",
    DAY = ""r86400"",
    WEEK = ""r604800"",
    MONTH = ""r2592000"",
}
z.nativeEnum(TimeFilter)
```
works but that is a native enum.",,
1699253006,2413,Runtypes-like `.guard()`,"I miss this feature from runtypes and i would like to implement it (making issue first, as CONTRIBUTING.md said)

## My use case
I am recently got tasked with integrating multiple 3rd-party APIs, and i have chosen following pattern for it

```typescript
class ExampleApiUnkownError extends Error { ... }
class ExampleApiError extends Error { ... }

const BaseResponse = z.object({
  response: z.custom((value) => value !== undefined)
})

type BaseResponse = z.static<typeof BaseResponse>; 

const ErrorResponse = z.object({
  error: z.object({ ... })
})

class ExampleApiClient {
  async request({...}): Either<ExampleApiError | ExampleApiUnknownError, BaseResponse> {
    try {
      const response = await fetch(...);
      const json = await response.json();
      
      // And here i would like to 
      // 1. Check if json matches BaseResponse -> return early
      // 2. Check if json matches ErrorResponse -> make ExampleApiError from it and return early
      // 3. return left(new ExampleApiUnkownError(""..."", { cause: { response, json } })); if nothing matched
      
      // In my opinion, both .parse and .safeParse are too cumbersome, cause
      // .parse requires error handling
      // .safeParse requires additional variable to work correctly
      
      // I prefer doing something like this
      
      if (BaseResponse.guard(json)) {
        return right(json.response);
      }
      
      if(ErrorResponse.guard(json)) {
        return left(ExampleApiError.fromJSON(json));
      }
      
      return left(new ExampleApiUnkownError(""..."", { response, json }));
      
    } catch(error) {
      return left(new ExampleApiUnkownError(""..."", { cause: error }));
    }    
  }
}

```",,
1698857296,2411,Incorrect type for `default` value of a piped schema,"This is a zod schema that validates an environment variable that may be set as:
```bash
ENABLE_FEATURE=""1""
ENABLE_FEATURE=1
ENABLE_FEATURE=""0""
ENABLE_FEATURE=0
ENABLE_FEATURE= 
ENABLE_FEATURE=
# ...etc
```

```typescript
import { z } from 'zod';

export const zodEnvBooleanSchema = () =>
	z.coerce.number().pipe(z.coerce.boolean());

const isEnabledSchema = zodEnvBooleanSchema().default(false)
// No overload matches this call.
//   Overload 1 of 2, '(def: number): ZodDefault<ZodPipeline<ZodNumber, ZodBoolean>>', gave the following error.
//     Argument of type 'boolean' is not assignable to parameter of type 'number'.
//   Overload 2 of 2, '(def: () => number): ZodDefault<ZodPipeline<ZodNumber, ZodBoolean>>', gave the following error.
//     Argument of type 'boolean' is not assignable to parameter of type '() => number'. [2769]

const isEnabled = isEnabledSchema.parse(process.env.ENABLE_FEATURE);
```

Since the final product of the schema (`isEnabled`) is type `boolean`, I expected the value passed to `.default()` to also have type `boolean`. But it expects a `number` instead.

Is the type lost when using the `pipe` function? Or am I just misusing it?  Or perhaps there is a better way to do this?",,
1697409437,2408,How to check if the email field is required first,"Hello guys, 
I'm trying to validate the email field, I want to check if the field is required or not first, then I want to trigger the email validation

```ts
    -------- Validator.ts --------
    export const FormDataValidator = z.object({
      email: z.string({required_error: ""Required field""}).email(invalidEmail),
    })

    -------- index.ts ----------
    const result = FormDataValidator.shape.email.safeParse(
        emailReference.value
    );
```

but the problem is that always i get ""Invalid Email"" from the ""email function()"" .
Is there any way to fix this?",,
1697079223,2406,Setting default value breaks extend,"``` typescript
const baseCategorySchema = z.object({
  name: z.string(),
  num: z.number().default(0),
});

type Category = z.infer<typeof baseCategorySchema> & {
  subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
  subcategories: z.lazy(() => categorySchema.array()),
});
```

![image](https://user-images.githubusercontent.com/20667774/236390281-98bf213f-31c8-4ddb-b1d7-b6f29cbab90f.png)
",,
1696130067,2403,use .pick/.omit on ZodType,"Hello, i'm trying to use .pick or .omit on schema which is recursive.

```typescript
type ItemAttribute = keyof Item;

type BaseItem = z.infer<typeof baseItemSchema>;

type Item = BaseItem & {
  parent_item: Item;
  subitems: Item[];
};

const baseItemSchema = z.object({
  id: z.number(),
  name: z.string(),
});

const itemSchema: z.ZodType<Item> = baseItemSchema.extend({
  parent_item: z.lazy(() => itemSchema),
  subitems: z.lazy(() => itemSchema.array()),
});

itemSchema.pick()
```

```typescript
Property 'pick' does not exist on type 'ZodLazy<ZodType<Item, ZodTypeDef, Item>>'.ts(2339)
```

I search to convert a Zodtype to a ZodObject, I don't find any informations about it.
I find that I can cast itemSchema but I lost the type when I parse some data
I don't know what try.

```typescript
const itemSchema: z.ZodObject<any, any, any, Item> = baseItemSchema.extend({
  parent_item: z.lazy(() => itemSchema),
  subitems: z.lazy(() => itemSchema.array()),
});
```

Anyone has an idea ? 

Thank you",,
1691151240,2392,pick and pipe with with subset of property names to create object chains.,"I would really like to be able to take an existing zobject, and work with the object as a whole with pipes rather than working with individual properties via transforms.  In particular, I'd like to pick a subset of properties, and then pipe those properties to another zObject that declares my validations.  Intellisense and typescript should enforce that the name of the picked properties exist at compile time.

I've tried many many different ways to do this and it keeps falling down because of undefined property errors.  

I would like to be able to express this in a single function without having to call separate functions or break this out on a property by property basis.

See here and what I'm trying to do:

https://codesandbox.io/s/dazzling-gwen-mu0fti?file=/src/index.ts

```typescript
const Post = z.object({
  id: z.string(),
  title: z.string(),
});

function pickAndMap<
  TSrc extends z.AnyZodObject,
  TSrcShape extends TSrc['shape'],
  TDestShape extends { [k in keyof TSrcShape]?: z.ZodTypeAny }
>(source: TSrc, dest: TDestShape) {  
  return z.object(dest);
}

//notice the type intentionally changes and I discard all prior validation
const OverrideProperties = pickAndMap(Post, {
  id: z.number(),
  title: z.number().max(100),
})


function pickAndPipe<
  TSrc extends z.AnyZodObject,
  TSrcShape extends TSrc['shape'],
  TDestShape extends { [k in keyof TSrcShape]?: z.ZodTypeAny }
>(source: TSrc, dest: TDestShape) {
  const mask = dest as unknown as { [k in keyof TSrcShape]?: true };
  const picked = source.pick(mask).pipe(z.object(dest));
  return picked;
}

//Here I want any property that I define to be automatically piped from post.
const PipedProperties = pickAndPipe(Post, {
  id: z.string(),
  title: z.string().min(100),
})
```",,
1688548402,2384,ZodIssue docs provides wrong link for discriminated union,"Very tiny thing the link provided [here](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#zodissue) for 
the discriminated union doesn't exist

the correct link is:
https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions",,
1686887496,2376,Not able to assign computed array as Zod enum,"I'm trying to create a Zod object in Astro which takes in `tags` as one of the properties. `tags` can be an array of 0 or more categories.

```ts
const blog = defineCollection({
  schema: () => z.object({
    title: z.string(),
    tags: z
      .array(z.enum(['CSS', 'Reference Docs', 'General', 'Astro']))
      .optional(),
  }),
});
```
The above code works fine (ie when I pass a statically typed array into `Z.enum()`. However, now I'm trying to the tags in an external JSON file and import it and pass a computed array into `Z.enum()`.

```json
[
    {
        ""label"": ""css"",
        ""displayText"": ""CSS"",
        ""coverImage"": ""@assets/unsplash-image.jpg"",
        ""description"": ""Cascading Style Sheets is a language used to describe the visual presentation of web pages.""
    },
    {
        ""label"": ""reference-docs"",
        ""displayText"": ""Reference Docs"",
        ""coverImage"": ""@assets/unsplash-image.jpg"",
        ""description"": ""Reference docs are documents that provide information, instructions, or guidance on how to use a particular product, tool, or technology.""
    },
    {
        ""label"": ""astro"",
        ""displayText"": ""Astro"",
        ""coverImage"": ""@assets/unsplash-image.jpg"",
        ""description"": ""Astro is a static site builder that allows developers to use familiar technologies like JavaScript, CSS, and HTML to build modern websites.""
    },
    {
        ""label"": ""general"",
        ""displayText"": ""General"",
        ""coverImage"": ""@assets/unsplash-image.jpg"",
        ""description"": ""Does not belong to any other categories.""
    }
]
```

```ts
// Import the above JSON data
import tagsJson from '@assets/tags.json'

// Created a computed array
const tagsArray = tagsJson.map(tag=>tag.displayText) as string[]
// Above line equals => ['CSS', 'Reference Docs', 'General', 'Astro']
```

When I pass this `tagsArray` into `Z.enum()`, I get the following error.

```txt
No overload matches this call.
  Overload 1 of 2, '(values: readonly [string, ...string[]], params?: { errorMap?: ZodErrorMap; invalid_type_error?: string; required_error?: string; description?: string; }): ZodEnum<[string, ...string[]]>', gave the following error.
    Argument of type 'string[]' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Source provides no match for required element at position 0 in target.
Overload 2 of 2, '(values: [string, ...string[]], params?: { errorMap?: ZodErrorMap; invalid_type_error?: string; required_error?: string; description?: string; }): ZodEnum<[string, ...string[]]>', gave the following error.
    Argument of type 'string[]' is not assignable to parameter of type '[string, ...string[]]'.
      Source provides no match for required element at position 0 in target.ts(2769)
```

",,
1684885782,2370,Struggling with discriminated union,"I want to have discriminated union of sections for CMS.

So for example:
```ts
const SectionA = {
  type: z.literal(""A""),
  enabled: z.boolean(),
}
const SectionB = {
  type: z.literal(""B""),
  enabled: z.boolean(),
}
```
I can easily do discriminatedUnion with this:
```ts
const Sections = z.discriminatedUnion(""type"", [SectionA, SectionB])
```

The problem begins when I want to disable validation when enabled=false

I've tried something like this:
```ts
type AllSectionUnion =
  | typeof SectionA
  | typeof SectionB
  
const allowDisabled = <S extends AllSectionUnion>(schema: S) => {
  return z.discriminatedUnion('type', [
    schema,
    z
      .object({ enabled: z.literal(false), type: schema.shape.type })
      .passthrough(),
  ]);
};


const Sections = z.discriminatedUnion(""type"", [SectionA, allowDisabled(SectionB)])
```

But I get some weird errors. I guess typescript doesn't understand that allowDisabled will be single instantiation of the union.


Any idea how to solve this problem. I would love if simply there was support to disable validation easily conditionally or express my model somewhat.

It works if I use union instead of discriminatedUnions but then I am getting much worse validation errors.",,
1681970457,2366,Zod don't work well with inferFormattedError and error formatting after version 3.21,"We are having some issues after upgrade zod to version `3.21.4`. The problem is that the type returned from `inferFormattedError` is no more matching with `error.format` from a parser. The code bellow simulates this issue:

```typescript
import { ZodType, ZodIssueCode, ZodTypeDef, z } from ""zod"";

type ErrorType = { message: string; code: ZodIssueCode };
type ParserType<T> = ZodType<T, ZodTypeDef, unknown>;
type PayloadParseError<T> = z.inferFormattedError<ParserType<T>, ErrorType>;

const formatError = async <T>(data: T, parser: ParserType<T>) => {
  const parsed = await parser.safeParseAsync(data);

  if (!parsed.success) {
    // In 3.21.4 version, the PayloadParseError<T> type is breaking the code
    const errorDetails: PayloadParseError<T> = parsed.error.format((issue) => ({
      message: issue.message,
      code: issue.code,
    }));
  }
};
```

The code above works in version **`3.20.6`**, but after **`3.21.X`** the `format` output type is no more being recognized along with the output of `inferFormattedError` function.

Could you guys help us with this issue?",,
1677437945,2355,`function()` incorrect typing for objects in `.args()`,"I'm defining a function as follows:

```typescript
const func = z
  .function()
  .args(
    z.string(),
    z.object({
      temperature: z.number(),
    })
  )
  .returns(z.string())
  .implement((text, options) => {
    return ""Hello, World!"";
  });
```

However, the `options` variable has a TypeScript type of `{ temperature?: number }`.

![image](https://user-images.githubusercontent.com/30580900/233488773-713521d7-ef2c-40cf-823b-6f1ee29f66e1.png)

I believe this should just be `{ temperature: number }`, right?

Related Discussion: https://github.com/colinhacks/zod/discussions/1771
",,
1677038476,2354,Types from type inference should be shown more simplified,"When defining a type with `z.infer` the type does not get recognized as the named, simplified type, but as the more detailed and complex one.
```typescript
const MySchema = z.object({
  foo: z.string(),
});
type MyType = z.infer<typeof MySchema>;

const x: MyType = {
  foo: ""bar"",
};
```
In this code example hovering `x` doesn't show `const x: MyType` but:
```typescript
const x: {
    foo: string;
}
```
Especially for big and complex types showing `MyType` would drastically improve readability.",,
1676374217,2351,`flatten()` broken/useless when doing `new z.ZodError()` with a JSON stringified/parsed ZodError coming from the server,"A ZodError goes from server to client, hence is stringified and parsed on its way, and on the client the flatten() method is ofc gone, so I do `new z.ZodError(sentError)` which works BUT using `.flatten()` on latter yields:

```
TypeError: this.issues is not iterable
    at ZodError.flatten ...
```

Do I miss anything?",,
1675457120,2347,Allow introspection of `issues` in `z.RefinementCtx` to allow early escape from expensive `superRefine`ments,"Hello! In the case of an expensive `superRefine` which follows other non-fatal parsing errors:
```
z.string()
  .min(4, { message: ""Min length 4"" })
  .max(20, { message: ""Max length 4"" })
  .superRefine(async (val, ctx) => expensive1000msServerTrip(val, ctx))
```

It would be valuable to be able to break out before the expensive part of the refinement is called. This becomes particularly apparent when validation is being done on a form, where validation of the above string would _always_ call the expensive server trip, taking > 1000ms, despite the instant non-fatal errors from the clamping validators. 

Breaking out could be done by moving the `min` and `max` validations into the `superRefine` itself, but that comes at the cost of some of the magic and composability of zod.

Suggestion: Add an introspective field: **`issues`** to `z.RefinementCtx`, that way non-fatal errors could prevent subsequent expensive calls:
```
  z.string
    .min(4, { message: ""Min length 4"" })
    .max(20, { message: ""Max length 4"" })
    .superRefine(async (val, ctx) => {
      if (ctx.issues.length > 0) return z.Never
      
      // Alternate with some pickiness
      // if (ctx.issues.some((issue) => issue.type === 'too_small')) return z.Never
      
      expensive1000msServerTrip(val, ctx)
    })
```

Let me know what you think!

Also: I'm sure you're in no need of more _validation_ (heh) but zod has been a pleasure to work with, and its become so deeply rooted in my workflow that I almost can't imagine not having it, so thanks!
",,
1675255089,2345,Add `ZodType#isType` as syntactic sugar for type predicate.,"## Problem
I primarily use Zod as a way to strongly type my API integrations. A scenario I find myself in quite often is one where the server performs logic that results in a response that is a union or has nested keys that are a union.

```ts
const User =  z.object({
    first_name: z.string(),
    last_name: z.string()
})

const Staff = User.extend({
    group: z.string(),
    isAdmin: z.boolean()
})

// this type of scenario
const Response = z.object({
    id: z.string(),
    user: z.union([ User, Staff ])
})
```

When accessing these responses inside my application, I have to perform some sort of type narrowing. My initial solution was a generic predicate whose arguments were the type I want to assert and the data I'm asserting against.

```ts
function isType<T extends ZodTypeAny>(schema: T, datum: unknown): datum is z.infer<T> {
    return schema.safeParse(datum).success
}

response.user.group // can't be accessed here

if( isType(Staff, response.user) ){
    response.user.group // no errors
}
```

The more often I found myself using it, the more I wished that Zod had a native way of doing this, specifically:

```ts
if( Staff.isType(response.user) ){
    response.user.group // no errors
}
```",,
1674979307,2344,Consolidate correct type definitions for dynamically created z.object(),"Hello, i have more of a question than issue. my question is how can i consolidate types for dynamically generated zod object.

if i have:
```
z.object({field: z.string()})
```

compiler understands types.

But if i write:
```
class Example {

  @valdiate(z.string())
  public field: string
}
```

For each class `z.object({})` is created and @validate prop just accumulates all fields and its validation rules into one object (`object.setKey(fieldName, rules)`)

later on i fetch this object, but its types are messed up. Its just any.

Is there are way to consolidate them into correct types? To acknowledge fields and and its types. I could convert them to string and than back to zod types in separate file i thought, but i have code in transform fallbacks as well.

I am new to ts and it seems that if it is written into a file and ts compiler can understand everything correctly, but if i stack them together other way, than compiler can't understand what types there are. Where are macros when they are needed :D",,
1674278196,2342,Error.message returns unexpected value,"Hello,

I found a bug in the types of ZodError.message. It should return a string, but returns an Error-Object. Either the Type or the return-value is wrong.

```
import { z } from 'zod'

const myString = z.string()

const results = myString.safeParse(5)

if (!results.success) {
  const message = results.error.message
  // type said message is a string, but got an Array with an Error-Object
  console.log('message:', message)
}

```

BTW: Thank you for this wonderful library!",,
1672231845,2334,ZodUnion inside ZodObject question,"![image](https://user-images.githubusercontent.com/15936231/232653959-6864b330-9c37-4dda-9ad4-77deee460fbc.png)
![image](https://user-images.githubusercontent.com/15936231/232654378-b0623f04-7e79-40ba-a70d-696fff4cacd4.png)


```ts
import {z} from ""zod"";

const adapter = z.object({
    union: z.union([
        z.object({
            name: z.string(),
            ip: z.string(),
        }),
        z.object({
            name: z.string(),
            subnet: z.string(),
        })
    ]),
});
```

why we got 
```ts
type Adapter = {
    union: ({
        name: string;
        ip: string;
    } | {
        name: string;
        subnet: string;
    }) & ({
        name: string;
        ip: string;
    } | {
        name: string;
        subnet: string;
    } | undefined);
}
```

instead of 

```ts
type Adapter = {
    union: {
        name: string;
        ip: string;
    } | {
        name: string;
        subnet: string;
    };
}
```",,
1668907071,2326,[Feature Request] Tuple type inspection,"<img width=""384"" alt=""image"" src=""https://user-images.githubusercontent.com/457552/232147082-f1ff1f33-0690-4749-9834-4b3de2b10178.png"">

As you can see, we can define a Tuple type with a name. TypeScript will infer them, so we can better understand this tuple type. 
I tried z.Tuple with the field description but seems doesn't work.

 Is there a way to achieve this in zod?

Thank you very much.",,
1668167405,2325,`z.union` type inside `z.object` returns `(UnionType) & (UnionType | undefined)` when `z.array()` is one of the options,"When an array is one of the options in `z.union` inside `z.object`, the inferred type becomes `(UnionType) & (UnionType | undefined)` instead of just `UnionType`.

```ts
const UnionType = z.object({
  test: z.union([z.string(), z.number()])
});
type UnionType = z.infer<typeof UnionType> // { test: string | number }

const UnionTypeBug = z.object({
  test: z.union([z.string(), z.number().array()])
});
type UnionTypeBug = z.infer<typeof UnionTyptBug> // { test: (string | number[]) & (string | number[] | undefined) }, should be { test: string | number[] }",,
1666914630,2324,Support for date-only string field,"Are there plans for implementing in the near future?

I read up on https://github.com/colinhacks/zod/issues/126 and was delighted to hear about the `z.string().datetime()` update, however as @colinhacks mentioned at the end of his [final reply](https://github.com/colinhacks/zod/issues/126#issuecomment-1347806185) in the thread, this does not cover date-only scenarios. Also, something to keep in mind is that while the string regex approach is trivial, it does not account for invalid dates in the right format (ex. 2020-15-01).

I am currently implementing via a custom transform function:
```ts
import { z } from ""zod"";
import moment from ""moment"";

export const date = () =>
  z.string().transform((date, ctx) => {
    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      ctx.addIssue({
        code: ""invalid_date"",
        message: mustBeDateOnlyFormatMsg,
      });
      return z.NEVER;
    } else if (!moment(date).isValid()) {
      ctx.addIssue({
        code: ""invalid_date"",
        message: invalidDate,
      });
      return z.NEVER;
    }

    return new Date(date);
  });
```

However I feel that this should be natively supported as it is a common use case:
```ts
import { z } from ""zod"";

/**
* Valid date only string field.
* Has the same effect as the transform function mentioned previously. 
* Would be nice also to parameterize the format i.e DD/MM/YYYY, MM/DD/YYYY etc.
*/
z.string().date()

/**
* Valid time only string field. 
* Would have to solve the same issue mentioned but w/ invalid times. 
* i.e 12:79 should not be accepted.
*/
z.string().time()
```",,
1661888163,2318,Add z.select (similar to z.enum but accepting anything as options),"### Problem

Imagine I have a schema that validates a value to be one of the predefined integers. Like when a user chooses the length of the secret key to be either 512, 1024 or 2048 bits (just random example). Naturally, I would imagine there was a Zod schema for that... like `z.enum([512, 1024, 2048])`? Unfortunately, that doesn't work, as `z.enum` only accepts string values.

Another scenario is where the list of options is coming from the variable and is only known in runtime:

```ts
const options = await getOptions(); // string[] or number[] or even any[]
const schema = z.enum(options); // doesn't work
```

### Current workaround

One can use `z.union([z.literal(512), z.literal(1024), z.literal(2048)]` but it's cumbersome, it's arguably slow (as it validates each sub-schema independently) and it doesn't work with option values other than strings and numbers.

### Considered solutions

At first, I was thinking that `z.enum` could be extended to allow any list of anything as valid options (#2317). That is not a viable approach as `z.enum(...).enum` will break then (thanks @igalklebanov for pointing to that).

Another suggested approach was to extend `z.union` to accept literals. I don't like that for two reasons:
* `z.union` is advertised as an aggregating schema builder. Mixing unrelated concepts (nested schemas vs. literals) should be avoided.
* If `z.union` were to accept arbitrary options but treat zod schemas separately, then zod schemas themselves would not be valid options to choose from. (Not that it's a huge tragedy but that is a limitation that could be avoided).

### Suggested approach

I propose to add `z.select` which will be basically `z.enum` without `schema.enum` but accepting anything as the list of options (not even necessarily primitives):

```ts
const Select = z.select([1, 5, ""test"", true]) // or: z.select(options) where options extends any[]
type Select = z.infer<typeof Select> // 1 | 5 | ""test"" | true
Select.options // [1, 5, ""test"", true]
const option = Select.parse(...) // one of options
```

In fact, `z.enum` will probably be a subclass of `z.select` in that case (they will share `schema.options` and probably the actual validation implementation).

The resulting type could be derived from the options with [`ElementOf<...>`](https://github.com/ts-essentials/ts-essentials/tree/afccd3550cc1c03b87d1df4bd590b1e1caa0c930/lib/element-of) recipe.
",,
1661371752,2317,z.enum to allow non-string options,"I recently opened the issue #2312 where I elaborated that the typings of `z.enum` were too restrictive as they didn't allow arbitrary list of strings.

This is the extension of the above problem which goes not only about typings but also about implementation. _(I am opening a separate issue as I realise this is all breaking changes and maintainers tend to disregard them... so I give these separate issues more chance to survive :)_

### Problem

Imagine I have a schema that validates a value to be one of the predefined integers. Like when a user chooses the length of the secret key to be either 512, 1024 or 2048 bits (just random example). Naturally, I would imagine there was a Zod schema for that... like `z.enum([512, 1024, 2048])`? Unfortunately, that doesn't work, as `z.enum` only accepts string values.

### Current workaround

One can use `z.union([z.literal(512), z.literal(1024), z.literal(2048)]` but that's cumbersome (and also arguably slow as it validates each sub-schema independently).

### Suggested approach

What if `z.enum` simply allowed any list of anything as valid options?

Like, what if `z.enum([1, 5, ""testing"", true])` simply worked and validated the value to be one of the options (with `options.includes(value)` as the implementation)? The resulting type could be derived from the options with [`ValueOf<Options>`](https://github.com/ts-essentials/ts-essentials/tree/afccd3550cc1c03b87d1df4bd590b1e1caa0c930/lib/value-of) recipe.",,
1660793451,2315,Using `.transform()` stops `z.discriminatedUnion` from working,"Hi there,

May I please have some help I am stuck with an issue which seems to be caused by `SomeZodType.transform(fn=>...)` when `fn` returns a type which is incompatible with the original `SomeZodType`. Whenever I use `.transform()` the types will no longer work in `z.discriminatedUnion`.
Is this intended behavior, or am I missing something?
Please excuse the really long example code below;


```typescript
// === USER CODE ===

class Position extends Component {
    position = new Vector2(0, 0);
    // ...
    static readonly schema = z.object({
        type: z.literal(""Position""),
        position:Vector2.schema
    }).strict().transform(data=>new Position(data.position));
}

class Velocity extends Component {
    velocity = new Vector2(0, 0);
    // ...
    static readonly schema = z.object({
        type: z.literal(""Position""),
        position:Vector2.schema
    }).strict().transform(data=>new Position(data.position));
}

// === LIBRARY CODE ===
export class Vector2{
    //...
    static readonly schema = z.object({
        type: z.literal(""Vector2""),
        x: z.number().default(0),
        y: z.number().default(0),
    }).strict().transform(data=> new Vector2(data.x, data.y));
}

class Entity {
    readonly uid: string;
    label:string;
    private components: Map<string, Component<any>>;
    //...
    static readonly schema = z.object({
        type: z.literal(""Entity""),
        uid: z.string().nonempty(),
        label:z.string().nonempty().optional(),
        components: ????????????????????????????
    }).strict().transform(data=>new Entity(data.uid, new Map(data.components.map(???)), data.label ?? data.uid));
}
```

At this point I am stuck because

1. `Entity` is part of a library; user code is supposed to implement arbitrary Component types and give each implementation its own `static schema=...`, therefore I can't give `Entity.components` static schema inside the Entity class
3. I want to do
   - user creates list `components = [Velocity.schema, Position.schema]`
   - user calls `Entity.register_components(components)`
   - Entity.schema is updated with `z.discriminatedUnion(""type"", components)`
   - User uses the parser as below
   
```typescript 
Entity.schema.parse({
    type:""Entity"",
    uid:""xxxx123"",
    label:""the thing"",
    components:[
        {
            type:""Position"",
            position:{type:""Vector2"", x:10, y:10}
        },
        {
            type:""Velocity"",
            velocity:{type:""Vector2""}
        }
    ]
})
```

Whenever I try to make a function that passes a list of component schemas into `z.discriminatedUnion` I get a massive error which is hard to understand;

```text
Type 'ZodEffects<ZodObject<{ type: ZodLiteral<""Velocity"">; velocity: ZodDefault<ZodOptional<ZodEffects<ZodObject<{ type: ZodLiteral<""Vector2"">; x: ZodDefault<ZodNumber>; y: ZodDefault<ZodNumber>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, Vector2, { ...; }>>>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, Velocity, { ....' is missing the following properties from type 'ZodObject<{ type: ZodTypeAny; } & ZodRawShape, UnknownKeysParam, ZodTypeAny, { [x: string]: any; type?: any; }, { [x: string]: any; type?: any; }>': _cached, _getCached, shape, strict, and 14 more.ts(2740)
(property) Velocity.schema: z.ZodEffects<z.ZodObject<{
    type: z.ZodLiteral<""Velocity"">;
    velocity: z.ZodDefault<z.ZodOptional<z.ZodEffects<z.ZodObject<{
        type: z.ZodLiteral<""Vector2"">;
        x: z.ZodDefault<z.ZodNumber>;
        y: z.ZodDefault<z.ZodNumber>;
    }, ""strict"", z.ZodTypeAny, {
        ...;
    }, {
        ...;
    }>, Vector2, {
        ...;
    }>>>;
}, ""strict"", z.ZodTypeAny, {
    ...;
}, {
    ...;
}>, Velocity, {
    ...;
}>
```

I tried my best to find any existing issues or questions... this one looks related? #2146 . There was a suggestion in that thread to try zod@canary, but that doesn't seem to have helped.",,
1659815434,2312,z.enum typings are too restrictive,"This is related to #2280 but from a different perspective.

Consider a schema with a enum field which is dynamically generated with the database options (a fairly reasonable scenario in my thinking). The current typings simply don't allow this:

```ts
const options = await EnumOptionModel.query().where(...).then(map('option')) // returns string[]
const schema = z.enum(options) // Error: Argument of type 'string[]' is not assignable to parameter of type 'readonly [string, ...string[]]'
```

Granted, the list of options coming from the database could be empty. However, the author might be okay with the schema never validating in that case. Like what if they are developing a form constructor? The form will indeed never validate with no options, but under the circumstances that will be the desired behaviour. Why should Zod disallow that code?

This is happening due to:

https://github.com/colinhacks/zod/blob/51e14beeab2f469fcbf18e3df44653e1643f5487/src/types.ts#L3918

I think this is over-designed (see above why) and the whole type should be removed in favour of simple `string[]`. I realize that doing so will result in a breaking change, so I'd suggest `EnumValues` first to be set to `string[]` and marked as deprecated, then perhaps removed several releases later.",,
1659620031,2311,Very slow autocompletion performance on VSCode.,"Hi there,

I was wondering if anyone else is having similar issues where the TypeScript autocompletion in VSCode is very slow and makes my CPU usage spike? I made [an issue](https://github.com/microsoft/TypeScript/issues/45824#issuecomment-1500959079) before in the official TypeScript repository and just commented on it.

I am not quite sure why this is happening but it is quite frustrating, thanks a lot.

Hope someone is able to help me out, thanks!",,
1659151163,2308,`transform` does not run after previous `refine` returned false,"Hello,

Given this minimal example:
```typescript
const nameToGreeting = z
  .string()
  .transform(val => val.toUpperCase())
  .refine(val => val.length > 15, 'must be longer than 15')
  .transform(val => `Hello ${val}`)
  .refine(val => {
    console.log(val); // val is 'JOHN DOE' here
    return val.indexOf('!') === -1;
  });

console.log(nameToGreeting.safeParse('John Doe'));
```

The second transform is skipped. The refine that follows it receives the once-transformed uppercase string, without the added `""Hello ""`.

I did not find any explanation of this in the docs. The only issue that is related to this is https://github.com/colinhacks/zod/issues/506.

I believe this is a bug. If this behavior is intended, I believe it should be explained in the docs.

The expected behavior would be to
- run the transform regardless of whether the previous refine failed or not

OR
- after returning false in a refine, not run any following refines
",,
1658608725,2306,Monorepo:  The types of '_def.errorMap' are incompatible between these types.,"I have a monorepo with multiple apps which use multiple packages. Some of these packages require the app to pass Zod schemas to the package. However, I keep getting an error when trying to type the parameters to a function. They have the same Zod version and even weirder is that they direct to the same package location. My package function looks like this:

```typescript
const useForm = (schema: z.ZodObject<any>) => {
	const errorStore: ValidationErrors = writable({});
}
```

The call in my boiler:

```typescript
const test = z.object({
	id: z.string().cuid().optional(),
	name: z.string()
})
.strict();
const { validate } = useForm(test);
```

And then I get this error:

```
Argument of type 'ZodType<GroupCreateInput, ZodTypeDef, GroupCreateInput>' is not assignable to parameter of type 'ZodType<any, ZodTypeDef, any>'.
  The types of '_def.errorMap' are incompatible between these types.
    Type 'Zod.ZodErrorMap | undefined' is not assignable to type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodErrorMap | undefined'.
      Type 'Zod.ZodErrorMap' is not assignable to type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodErrorMap'.
        Types of parameters 'issue' and 'issue' are incompatible.
          Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssueOptionalMessage' is not assignable to type 'Zod.ZodIssueOptionalMessage'.
            Type 'ZodInvalidUnionIssue' is not assignable to type 'ZodIssueOptionalMessage'.
              Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodInvalidUnionIssue' is not assignable to type 'Zod.ZodInvalidUnionIssue'.
                Types of property 'unionErrors' are incompatible.
                  Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodError<any>[]' is not assignable to type 'Zod.ZodError<any>[]'.
                    Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodError<any>' is not assignable to type 'Zod.ZodError<any>'.
                      Types of property 'issues' are incompatible.
                        Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssue[]' is not assignable to type 'Zod.ZodIssue[]'.
                          Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssue' is not assignable to type 'Zod.ZodIssue'.
                            Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
                              Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'Zod.ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }'.
                                Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodInvalidUnionIssue'.
                                  Types of property 'unionErrors' are incompatible.
                                    Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodError<any>[]' is not assignable to type 'Zod.ZodError<any>[]'.
                                      Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodError<any>' is not assignable to type 'Zod.ZodError<any>'.
                                        Types of property 'addIssue' are incompatible.
                                          Type '(sub: import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssue) => void' is not assignable to type '(sub: Zod.ZodIssue) => void'.
                                            Types of parameters 'sub' and 'sub' are incompatible.
                                              Type 'Zod.ZodIssue' is not assignable to type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssue'.
                                                Type 'ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
                                                  Type 'Zod.ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }'.
                                                    Property 'received' is missing in type 'ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }' but required in type 'ZodInvalidLiteralIssue'.
```",,
1657857988,2304,Type error with z.object({}).passthrough(),"Hello,

We depend on Zod and have run into an issue which prevents us upgrading from version 3.18.0 -> 3.21.4. We are on Typescript 4.7.4 but I reproduced with Typescript 4.9.5 as well.

We make use of `z.object({}).passthrough()` to generically represent a type containing an object of unknown type. The intent is to be able to parse that field with a more specific schema elsewhere in the code. Most commonly, this aligns with a JSONB column in a Postgres table that can represent many things. 

When upgrading to a newer zod version, we run into type errors preventing compilation. The error states:

```
(property) value: {} & {
    [k: string]: unknown;
}
Type 'SpecificConfig' is not assignable to type '{} & { [k: string]: unknown; }'.
  Type 'SpecificConfig' is not assignable to type '{ [k: string]: unknown; }'.
    Index signature for type 'string' is missing in type 'SpecificConfig'.ts(2322)
Untitled-12(7, 5): The expected type comes from property 'value' which is declared here on type '{ user_id: string; created: Date; key: string; value: {} & { [k: string]: unknown; }; }'
```


Here is an example that reproduces the error--line 40 (`config: configVal,`) contains the type error.

```typescript
import {z} from 'zod'

/**
 * SQL table
 * 
 * config
 * ---------------
 *  CREATE TABLE config (
 *    user_id VARCHAR(255) NOT NULL,
 *    created TIMESTAMP NOT NULL,
 *    key VARCHAR(255) NOT NULL,
 *    value JSONB NOT NULL,
 *    PRIMARY KEY (user_id, key)
 *  );
 */

const configSchema = z.object({
    user_id: z.string(),
    created: z.date(),
    key: z.string(),
    value: z.object({}).passthrough(),
})

type Config = z.infer<typeof configSchema>

interface SpecificConfig {
    foo: string
}

function makeSpecificConfig(): Config {

    const configVal: SpecificConfig = {
        foo: 'bar'
    }

    return {
        user_id: '123',
        created: new Date(),
        key: 'foo',
        value: configVal,
    }
}
```

What can we do to address this? What is the right use of zod to support this use case?

Thank you!",,
1657843607,2303,Create query sintax for feathers api,"I need to do something like this 

$limit: import(""@sinclair/typebox"").TNumber;
$skip: import(""@sinclair/typebox"").TNumber;
$sort: TObject<T[""properties""] extends infer T_2 ? { [K_1 in keyof T_2]: TOptional<TInteger>; } : never>;
$select: import(""@sinclair/typebox"").TUnsafe<(keyof T[""properties""])[]>;

I have problem with $select and $sort operations

const defaultQueries: <T extends z.SomeZodObject | z.ZodIntersection<z.SomeZodObject, T>, K extends string[]>(
  type: T,
  keys: K
) => z.ZodIntersection<
  T,
  z.ZodOptional<
    z.ZodObject<{
      $limit: z.ZodNumber
      $skip: z.ZodNumber
    }>
  >
\> = undefined


Thanks.",,
1657015961,2302,zod@3.21.4 fails on firefox 68 : invalid identity escape in regular expression,"Hi everyone, 

thanks for this awesome project.

Unfortunately I have to report a bug (minor? maybe?). But I'm working on a project that requires a large compatibility spectrum, up to ffx68.

Unfortunatelly ffx68 raises the following error: 
Maybe it's linked to : https://github.com/colinhacks/zod/blob/a263814fc430db8d47430cd2884d2cea6b11c671/src/types.ts#L556 ?

Downgrading to zod@3.20.2 fixed it.

Best
",,
1656132431,2300,`.toLowerCase/UpperCase()` should infer to `Lowercase/Uppercase<string>`,"The [Lowercase](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#lowercasestringtype) and [Uppercase](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uppercasestringtype) types are relatively new to TS and already have [analogs in Zod](https://github.com/colinhacks/zod#strings).

When I do this:
```ts
const MySchema = z.string().toLowerCase();
type MyType = z.infer<typeof MySchema>;
```
I should get this:
```ts
type MyType = Lowercase<string>
```
In zod v3.21.4, I get this:
```ts
type MyType = string
```",,
1654679203,2295,Schema inference - similar to `yup.mixed<Type>()`,"I can't find this anywhere in the documentation or issues on github. 

```ts
import { PaletteOptions } from ""@mui/material/styles"";

type Account = {
  uuid: string;
  name: string;
  palette?: Pick<PaletteOptions, ""primary"" | ""secondary"">;
}

// yup
const Schema = y.object({
  uuid: y.string().required(),
  name: y.string().required(),
  palette: y.mixed<Pick<PaletteOptions, ""primary"" | ""secondary"">>() //     <----
});

// zod
const Schema = z.object({
  uuid: z.string(),
  name: z.string(),
  palette: // ???     <----
});
```

I know that using `z.infer` I can get `type` from `schema` but can I get `schema` from `type` like in `yup`?",,
1654299809,2293,"z.object().passthrough(), z.number().transform(), and z.intersection() causing ""invalid_intersection_types""","Hello, 

Given the following schemas:

```typescript
export const paginated = z.object({
  paging: z
    .object({
      next: z.string(),
    })
    .passthrough(),
}).passthrough();

export const myObject = z.object({
  created: z.number().transform((value) => new Date(value)),
}).passthrough();

export const fullSchema = z.intersection(
  z.object({
      objects: z.array(myObject),
    }).passthrough(),
  paginated,
);
```
which I use to parse the following:
```typescript
const zodResult = fullSchema.safeParse({
  objects: [
    {
      created: 1638767655,
    },
  ],
  paging: { next: '123' },
});
```

I get the following error: 
```typescript
{
  code: 'invalid_intersection_types',
  path: [],
  message: 'Intersection results could not be merged'
}
```

After some testing, I've found that removing the `.passthrough()` calls or removing the `.transform()` stops the issue, but unfortunately in this instance I need to use both of them. Is this known or expected behavior? Is there some workaround?",,
1653520274,2290,Deeply nested schema results in a huge bundle size,"I have a very complex schema, and when I try to build it, it produces a really big bundle size (1.2MB):

```text
zod-explode ❯ pnpm build
> tsup src/index.ts --format esm,cjs --dts --clean

CLI Building entry: src/index.ts
CLI Using tsconfig: tsconfig.json
CLI tsup v6.7.0
CLI Target: es2022
CLI Cleaning output folder
ESM Build start
CJS Build start
ESM dist/index.mjs 2.93 KB
ESM ⚡️ Build success in 43ms
CJS dist/index.js 4.90 KB
CJS ⚡️ Build success in 44ms
DTS Build start
DTS ⚡️ Build success in 942ms
DTS dist/index.d.ts 1.20 MB
```

I created an example repo for that: https://github.com/fehergeri13/zod-explode/blob/bc35120c51f43eed226102fad2341339958506e9/dist/index.d.ts

When I replace the `.object` with a custom implementation, I can reduce the bundle size to a much more sustainable size, but I'm not sure what I risk

```ts
function object<T extends ZodRawShape>(shape: T) {
  return z.object(shape) as ZodType<baseObjectOutputType<T>, ZodTypeDef, any>;
}
```

```text
DTS dist/index.d.ts 78.40 KB
```

https://github.com/fehergeri13/zod-explode/blob/master/dist/index.d.ts

Is there a way, to reduce the output size by default without this ""hack""?",,
1649052124,2281,Modify schema with a closure,"### Problem

From what I see, that is not possible to construct a zod schema conditionally without `let`, temporary local variables, self-executing function and such.

Let's say I have a schema for a user and their address:

```ts
const user_schema = z.object({
  name: z.string(),
  address: z.object({
    city: z.string(),
  }),
})
```

Now let's imagine I create this schema in a context, and based on the context I may want city to be nullable:

```ts
function create_user_schema(ctx: { city_nullable: boolean }) {
  let city_schema = z.string()
  if (ctx.city_nullable) {
    city_schema = city_schema.nullable()
  }

  return z.object({
    name: z.string(),
    address: z.object({
      city: city_schema,
    }),
  })
}
```

Not only this is ugly and lengthy: with duck typing as above, this leads to type error: `Type 'ZodNullable<ZodString>' is missing the following properties from type 'ZodString': _regex, _addCheck, email, url, and 29 more` (I realise that the error could be avoided by an additional intermediate schema variable - that's not the point).

As the logic extends into the tree of variants, this type of code becomes hard to maintain.

### Proposal

Inspired by [Knex modify](https://knexjs.org/guide/query-builder.html#modify), I propose to add a new generic method to `ZodType`, so that the example above could be converted to:

```ts
function create_user_schema(ctx: { city_nullable: boolean }) {
  return z.object({
    name: z.string(),
    address: z.object({
      city: z.string().modify(schema => {
        // Executed once upon schema creation - not when parsing
        return ctx.city_nullable ? schema.nullable() : schema
      }),
    }),
  })
}
```

The code becomes much simpler. The 'modification' is directly attached to the proper position inside the (possibly large) schema tree. The namespace is not polluted needlessly.

If I understand correctly, the actual implementation will be as simple as:

```ts
class ZodType {
  // TODO: add proper typings
  modify(fn) {
    return fn(this)
  }
}
```",,
1648702385,2280,Restrict z.enum options to existing type,"### Problem

I want to restrict options passed to `z.enum` to the existing type.

```ts
type Status = 'new' | 'accepted' | 'closed'

z.enum(['new', 'accepted']) // OK
z.enum(['new', 'approved']) // Invalid choice - should be somehow disallowed
```

Is there an elegant way to statically validate the typings of enum options?

### Solutions tried

```ts
z.enum(['new', 'accepted'] as Status[]) // Argument of type 'Status[]' is not assignable to parameter of type '[string, ...string[]]'.
z.enum(['new', 'accepted'] satisfies Status[]) // Argument of type '(""new"" | ""acepted"")[]' is not assignable to parameter of type '[string, ...string[]]'.
z.enum<Status>(['new', 'accepted']) // Expected 2 type arguments, but got 1
z.enum(['new', 'accepted'] as [Status, ...Status[]]) // works, but ugly
z.enum(['new', 'accepted'] satisfies [Status, ...Status[]]) // works, but ugly
z.enum(['new', 'accepted'] as const satisfies readonly Status[]) // works, but could it be simpler?
```

at least a built-in helper would be useful:

```ts
z.enum(['new', 'accepted'] as z.EnumOptions<Status>) // self explanatory
```",,
1644548220,2264,extending recursive types,"Hi, thanks for the great work!

I'm having an issue with the example on recursive types found in the documentation. Defining recursive types works well, but as soon as I try to extend from a recursive type, TypeScript complains. Here is what TypeScript is saying:
```
Property 'extend' does not exist on type 'ZodType<Category, ZodTypeDef, Category>'
```
Here is my example:
```TypeScript
const baseCategorySchema = z.object({
	name: z.string(),
});

type Category = z.infer<typeof baseCategorySchema> & {
	subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
	subcategories: z.lazy(() => categorySchema.array()),
});

// This is where the issue occurs
const filmCategorySchema = categorySchema.extend({
	director: z.string(),
});
```

I do understand, that `ZodType` could by something that isn't extendable, but I'm not sure how to tell zod that it is.",,
1643548342,2260,Generic schema builder compiles into invalid type definitions,"If you define a function which accepts a generic type parameter and returns a Zod object schema containing a string literal based on that type parameter then the code looks fine and typescript will compile it

The declaration file emitted is invalid though and cannot be imported into another project

### Minimal reproduction:
`./src/index.ts`
```TypeScript
import { z } from 'zod';

export const schemaBuilder = <V extends string>(version: V) => {
  return z.object({
    version: z.literal<V>(version),
  });
};
```

When compiled will emit the following declaration file
`./dist/index.d.ts`
```TypeScript
import { z } from 'zod';
export declare const schemaBuilder: <V extends string>(version: V) => z.ZodObject<{
    version: z.ZodLiteral<V>;
}, ""strip"", z.ZodTypeAny, z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    version: z.ZodLiteral<V>;
}>, undefined extends V ? never : ""version""> extends infer T ? { [k_1 in keyof T]: z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    version: z.ZodLiteral<V>;
}>, undefined extends V ? never : ""version"">[k_1]; } : never, z.baseObjectInputType<{
    version: z.ZodLiteral<V>;
}> extends infer T_1 ? { [k_2 in keyof T_1]: z.baseObjectInputType<{
    version: z.ZodLiteral<V>;
}>[k_2]; } : never>;

```

When imported this throws the errors:
```
./dist/index.d.ts:6:84 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<baseObjectOutputType<{ version: ZodLiteral<V>; }>, undefined extends V ? never : ""version"">'

./dist/index.d.ts:10:46 - error TS2536: Type 'k_2' cannot be used to index type 'baseObjectInputType<{ version: ZodLiteral<V>; }>'.
```

I can't seem to find where the `extends infer T` is coming from on line 6 anywhere in the Zod code. Same goes for the `extends infer T_1` on line 10

### Relevant configuration:
 - Zod version: 3.21.4
 - Typescript version: 4.9.5 (also tested on v5)
 - tsconfig.json:
 ```json
 {
  ""compilerOptions"": {
    ""lib"": [ ""es2015"" ],
    ""sourceMap"": true,
    ""target"": ""es5"",
    ""outDir"": ""./dist"",
    ""baseUrl"": ""./src"",
    ""declaration"": true,
    ""moduleResolution"": ""node"",
    ""esModuleInterop"": true,
    ""strict"": true
  },
  ""include"": [
    ""src/**/*.ts""
  ],
  ""exclude"": [
    ""node_modules""
  ]
}
 ```
- Build pipeline: Just running `tsc`

### Additional information
If the generic function directly returns a Zod literal schema based on the passed generic then everything seems to work fine. Only putting that literal into an object seems to break the definition",,
1643538607,2259,Add Ethereum address option for `z.string()`,"Hi, I've been loving integrating zod into our web3 projects. 

Often we have to verify whether a string is a valid Ethereum address or not, it would be extremely useful to have something like `z.string().ethereumAddress('Not a valid wallet address')`

We are currently doing something like this ([source](https://ethereum.stackexchange.com/a/146766)):
```
import { isAddress } from 'ethers'; // ethers v6

const Address = z.custom<string>(isAddress, ""Invalid Address"")
```
in order to validate addresses, but it would be much better to have native support.

This simple regex would be enough: `/^0x[a-fA-F0-9]{40}$`",,
1643188781,2257,Parsing Returns the Wrong Type,"The type extracted from parse and safe parse are optional on a basic ```z.object({})```.

I put together an codesandbox to demonstrate the issue based on the 2nd basic usage example.

[https://github.com/colinhacks/zod#basic-usage](https://github.com/colinhacks/zod#basic-usage)
[https://codesandbox.io/p/sandbox/angry-shadow-t3ot3s](https://codesandbox.io/p/sandbox/angry-shadow-t3ot3s?file=%2Fsrc%2Findex.ts)

Not sure if this is a bug or if I have something misconfigured. 

btw: the library is awesome",,
1641524735,2249,Unable to work with objects when using `z.ZodType<T>` for circular dependencies,"This is a fantastic library, but I'm very new to it and am confused as to why the following does not work.

Below is part of my schema which follows the example for recursive types, as per the [the documentation](https://github.com/colinhacks/zod#recursive-types).
```ts
const baseProfileSchema = z
  .object({
    id: z.string().uuid(),
    userId: z.string().uuid(),
    groupId: z.string().uuid(),
    fullName: z.string(),
    isAdmin: z.boolean(),
    isSupporter: z.boolean(),
    default: z.boolean(),
    createdAt: z.string().datetime(),
    updatedAt: z.string().datetime(),
  })
  .strict();

type Profile = z.infer<typeof baseProfileSchema> & {
  group?: Group;
};

const baseConversationSchema = z
  .object({
    id: z.string().uuid(),
    groupId: z.string().uuid(),
    messages: z.string().array(),
    createdAt: z.string().datetime(),
    updatedAt: z.string().datetime(),
  })
  .strict();

type Conversation = z.infer<typeof baseConversationSchema>;

export const groupSchema: z.ZodType<Group> = baseGroupSchema
  .extend({
    profiles: z.lazy(() => profileSchema.array().optional()),
    conversations: z.lazy(() => conversationSchema.array().optional()),
  })
  .strict();

export const profileSchema: z.ZodType<Profile> = baseProfileSchema
  .extend({
    group: z.lazy(() => groupSchema),
  })
  .strict();
  ```
  
  I cannot work with any of the objects typed with `z.ZodType<T>` though.
  ```ts
  const newProfile = profileSchema.omit({});
  // Property 'omit' does not exist on type 'ZodType<Profile, ZodTypeDef, Profile>'.
  
  const partialProfile = profileSchema.partial()
  // Property 'partial' does not exist on type 'ZodType<Profile, ZodTypeDef, Profile>'.
  ```
  
  Can anyone provide some insight as to what I may be doing wrong? Thank you!",,
1640977570,2246,TypeScript error since Zod 3.19.1 when using refine ,"Description:
I recently upgraded my project's dependency on the Zod library from version 3.19.0 to 3.19.1, and I encountered a TypeScript error when using the preprocess() and refine() methods together. Here's the code I'm using:

```ts
import * as z from 'zod';

const ZID = z
  .preprocess((val: any) => {
    return val;
  }, z.string())
  .refine(
    (val: any) => {
      return val.toString();
    },
    (val: any) => ({
      message: `The ID provided (${val}) is in an invalid format`,
    })
  );

type ID = z.infer<typeof ZID>;

abstract class Abs<T> {
  zType: z.ZodSchema<T>;

  protected constructor(zType: z.ZodSchema<T>) {
    this.zType = zType;
  }
}

class Abc extends Abs<ID> {
  constructor() {
    super(ZID);
  }
}
```
Expected Behavior:
The TypeScript compiler should not produce any errors, and the Abc class should be able to extend the Abs class with the ZID schema.

Actual Behavior:
Instead, the TypeScript compiler produces an error on the super(ZID) line in the Abc class constructor, with the following message:

```
Argument of type 'ZodEffects<ZodEffects<ZodString, string, unknown>, string, unknown>' is not assignable to parameter of type 'ZodType<string, ZodTypeDef, string>'.
Types of property '_input' are incompatible.
Type 'unknown' is not assignable to type 'string'.
```
Steps to Reproduce:

Install Zod version 3.19.1 in a TypeScript project.
Define a Zod schema with the preprocess() and refine() methods, and use it in an abstract class.
Define a class that extends the abstract class and uses the Zod schema as its generic type parameter.
Environment:

Node.js version: 16.17.1
TypeScript version: 4.9.5
Zod version: 3.19.1
Additional Information:
This error did not occur with Zod version 3.19.0, so I believe it is a regression in version 3.19.1. Please let me know if you need any more information from me. Thank you!



",,
1640820904,2244,How to modify schema using generic typed functions.,"I just want to modify the schema using function and for that, i am using omit/pick functions in a generic typed function but omit/pick functions is not exist in generic typed functions for the schema.
Also, I have watched all functions of ZodType class but there is no omit/pick function.
A simple example is given below.
```ts

export const ProductSchema = z.object({
    id: z.string().uuid(),
    name: z.string(),
    quantity: z.number().int(),
    price: z.number().int(),
    salePrice: z.number().int(),
    description: z.string().nullable(),
    categoryId: z.string(),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date(),
  })

export type Product = z.infer<typeof ProductSchema>

  
export function excludeDBOptionalFields<T extends z.ZodTypeAny>(schema: T){

 //here getting type error
  return schema.omit({
     id: true,
     createdAt: true,
     updatedAt: true
  });
}

const FinalProductSchema = excludeDBOptionalFields<Product>(ProductSchema)

```
Thank you for your time and consideration.",,
1640773220,2243,"when validation fails, transform is skipped but superRefine not","When some validation fails, it looks like transform is skipped but a future superRefine is not skipped, then superRefine tends to fail.
I checked the documentation but I didn't found something related to this behavior :(

```js
const schema = z
  .object({
    foo: z.string().email(),
  })
  .transform((arg, ctx) => {
    console.log(""transform"", arg);
    return { bar: arg.foo };
  })
  .superRefine((arg, ctx) => {
    console.log(""superRefine"", arg); // typescript always expects 'bar' attribute

    // This line tends to fail when transform is skipped
    if (arg.bar.length >= 35) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: ""It hould be less than 35."",
        path: [""bar""],
      });
    }
  });

console.log(schema.safeParse({ foo: ""test@example.com"" }));
console.log(schema.safeParse({ foo: ""averybigemailfortesting@example.com"" }));

// This fails on email validation, transform is skipped but superRefine not
console.log(schema.safeParse({ foo: ""testexample.com"" }));
```

![image](https://user-images.githubusercontent.com/15650777/227756161-70761cbd-6488-427a-b8e0-a3cf0828a155.png)
",,
1640386861,2241,Exporting schemas from package breaks `instanceof`,"When I export a schema from a package and use that schema in another package, the `instanceof` operator doesn't work on `ZodError` or `Schema`. I'm also new to creating packages, so maybe there is something that I miss there!

How I'm using the exported schemas:

```ts
import { mySchema } from 'mylib';
import { z } from 'zod';

console.log(mySchema instanceof z.Schema); // false

try {
  mySchema.parse('');
} catch (error) {
  console.log(error instanceof z.ZodError); // false
}

// -----------------------------

const localSchema = z.object({});

console.log(localSchema instanceof z.Schema); // true

try {
  localSchema.parse('');
} catch (error) {
  console.log(error instanceof z.ZodError); // true
}
```

I have also created a [demo project](https://github.com/ahmafi/zoderror-showcase). 

I call the package that I create schemas in `mylib` and the package that I'm using those, is called `myprogram`. I'm using `npm link` to add `mylib` to `myprogram` package. And also, I'm transpiling the `mylib` with `npx tsc`. Then you can test the code in `myprogram` with `npx tsx index.ts`.

A [maybe related thing](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work) that I read about this. But I also checked that you are addressing this issue on `ZodError` class constructor.
",,
1639542192,2238,How can I access Request during a validation?,"My app will reuse a lot of rules, so I wanted to have those common rules in an external file

For some rules, I want to show more descriptive error messages depending on the user-type. If it's a developer, i want to explain exactly what's wrong, if it's an admin, I want to give them useful information, but if it's a user, I want to conceal the exact reason and just let them know a problem occurred.

I have a workaround that works pretty well. I'm just wondering if its the best way. My code is typescript, but I'll use JS for brevity

```ts
CommonValidations = {
    messages(req) {
        return {
            subjectRule: rule,
            messageKeyRule: ..refine(() => {
                if (!messageKeyRegexTest) {
                    if (req.user.isAdmin()) {
                        return ""Failed to generate key, configuration error probably""
                    } else {
                        return ""Something went wrong""
                    }
                }
            })
        }
    }
}
```",,
1637700873,2235,"How does it possible to make object value optional, in case the other field from the same object has particular value?","```
export const additionalRideParticipantsValidationSchema = (
  isNoParticipantsAdded: boolean = false,
) => {
  const fieldsArray = z.array(
    z.object({
      id: 
      participantPersonType, // In case this one has MINOR_PARTICIPANT_VALUE value
      firstName: stringFieldValidator({ isFirstOrLastNameField: true }), 
      lastName: stringFieldValidator({ isFirstOrLastNameField: true }), 
      email, // I want email to become optional
    })
  )

  return validateViaZod({
    [FIELD_GROUP]: isNoParticipantsAdded
      ? fieldsArray.optional()
      : fieldsArray,
  })
}
```",,
1635424191,2230,Embedded schema containing default value throws compilation error.,"A very obscure compilation error occurs when embedding a schema with a default value into another and then parsing data.
Consider the following code example:
```ts
import { z } from ""zod"";

export function validateInput<TSchema>(schema: z.Schema<TSchema>, inputdata: any) {
  return schema.parse(inputdata);
}

export const Schema1 = z.object({
  myString: z.string().default(""""), // Remove the default and it works
});

export const Schema2 = z.object({
  related: Schema1,
});

const data = {};
export type Dto = z.infer<typeof Schema2>;
const parsedData: Dto = Schema2.parse(data); // This works
const parsedDataWrapped: Dto = validateInput(Schema2, data); // This does not work
```
Throws the error
```
error TS2322: Type '{ related: { myString?: string | undefined; }; }' is not assignable to type '{ related: { myString: string; }; }'.
  The types of 'related.myString' are incompatible between these types.
    Type 'string | undefined' is not assignable to type 'string'.
      Type 'undefined' is not assignable to type 'string'.

18 const parsedDataWrapped: Dto = validateInput(Schema2, data); // This does not work
```

I assume this is a bug? Removing the `.default("""")` makes the compilation works.

Using TSC 4.9.5 and zod 3.20.6

Thanks!",,
1633905098,2223,Generic over ZodObject extend inferred as any,"```ts
const Entity = <E extends AnyZodObject>(base: E) =>
  base.extend({
    _id: z.string(),
    createdAt: z.date(),
    updatedAt: z.date(),
  })

const UserBase = z.object({
  name: z.string(),
  age: z.number()
})

const User = Entity(UserBase)

const res = User.parse({})

// The inferred type does not match User :(
// const res = {
//   [x: string]: any;
//   [x: number]: any;
//   [x: symbol]: any;
// }


```",,
1632972205,2222,Support runtime validating typed values,"Hello! I’d like support for the following simple use case. This is following an [SA question](https://stackoverflow.com/questions/75706537/how-to-get-static-type-checking-and-auto-complete-for-the-parse-method/75716440#75716440) where someone didn't understand what I was trying to do.

# Use case

Let’s say I have two objects - a `Horse` and a `Rider`. I make a schema for each of them like this:

```typescript
const Horse = z.animal(""human"")
const Rider = z.animal(""horse"")
```

There is a part of the code where I get the `horse` and the `rider` from different places, where the value is either an `any` or type asserted with dubious reliability.

```typescript
const horse = horseGetter() // any
const rider = riderGetter() // any
```

Now, I want to validate both of these. One way would be to do it like this:

```typescript
const horse = Horse.parse(horseGetter())
const rider = Rider.parse(riderGetter())
```

But the thing is, `horse` and `rider` appear so often in my code that I want to group them into a `knight`:

```typescript
const Knight = z.object({
    horse: Horse,
    knight: Knight
})
```

And if I do that, I would like to validate everything at the same time like this:

```typescript
const knight = Knight.parse({
    horse: horseGetter(),
    rider: riderGetter()
})
```

This encapsulates the `horse` and `rider` into one object that can be moved around more easily and makes validating them more concise.

Here I find something annoying – `parse` takes an `unknown`, not `z.input<Schema>`, so I don’t have auto-complete when writing that code. It’s also not statically validated, although it easily could be. If it were, a spelling mistake could be caught at compile time instead of runtime:

```typescript
const knight = Knight.parse({
    hosre: horseGetter(), // compiles, fails at runtime
    rider: riderGetter()
})
```

# The `check` method

My idea is to add a simple method called `check` that just calls `parse`, but has a different static type:

```typescript
declare module ""zod"" {
    export interface ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {
        check(value: Input): Output;
    }
}

ZodType.prototype.check = function (value) {
    return this.parse(value);
};
```

This is a bit weird since usually, a `TypeScript` interface makes sense in `JavaScript` as well, but I think it makes sense for this library.

Anyway, the `check` method can be used for the following:

1. Validating type-asserted values, uses of `any`, etc, like what I described above.
2. When the schema has refinements that can’t be translated to the type system. Here having the correct type isn’t enough.
3. Transforming values known to be correctly typed.

I deliberately didn’t add a `safeCheck` method because there should be an exception when a runtime type doesn’t match the compile-time type. 

Here is an example of code using the method:

```typescript
ListRef.check({
        id: probablyId,
        title
    });
```
",,
1630658635,2216,Properties that are inferred Zod types are always dropped from any mapped types that involve key mapping.,"I'm tracking an odd issue with Zod in this StackOverflow thread: https://stackoverflow.com/questions/75778970/why-is-an-inferred-generic-zod-string-type-considered-assignable-to-never/75779088#75779088

It seems that any property with a `z.infer`'d type from a generic type gets dropped whenever participating in a conditional key mapping.

```
export type FilterNothing<T> = { [P in keyof T as T[P] extends T[P] ? P : P]: T[P] }

class Test<Z extends z.ZodString> {
    foo(args: FilterNothing<{ key: number, value: z.infer<Z>, bar: Date }>) {

        const { key, value, bar } = args;
    }
}
```

[Playground here](https://www.typescriptlang.org/play?ts=5.0.2#code/JYWwDg9gTgLgBAbwF4F84DMoRHA5EiAE1wG4AoMgUwA9JY4YBPMSuAMWABsZKoA5CDAAWwAHYBzADwAVAHxwAvIjgBtAApwxcANaVGEdHGlwAhgGcj6gLpwaPUYQvTrcAPxwNALg9XvztTYoFADGnOZOlGYwkgBattT2jnBIAHQxRADKMFBi4vIIZHBFGBAQABQmUOJm3hzcvALCuZIIOnreogCuIABGvAA0cABuJpydlN6pYui8sbKDPZXeACImPHAosgCUiBTF+3DBEKJRyrqMgyNjlAuVG4qmVWbk+0EoQA)

In the above code, the condition is a noop... all keys are always mapped, and yet `value` is still dropped.

Any idea why / how this could be possible? ",,
1630308376,2214,ZodObject fails on writing to readonly cache prop.,"I am working on a flow form where each step is an imported module which exports its own schema. I am using react-hook-form for this.

Not all steps of the form have validation. The form works well until I get to my first step with a zod resolver:

```
export const schema = z
  .object({
    [MONTHLY_WITH_ME]: z.boolean(),
    [MONTHLY_WITH_TEAM]: z.boolean(),
    [CUSTOM_NEEDS]: z.boolean(),
  })
  .partial()
  .refine(
    (options) => Object.values(options).some(Boolean),
    {
      message: 'Please select at least one option to continue',
      path: ['formErrors'],
    }
  )
```

This schema is tested and the tests work great.

Now I've tried having this flow form and having this isolated step in its own form on the same page and the results are getting weird:

- If I validate the isolated step form the schema works
- If I validate the isolated step form FIRST and then process through the flow form, the schema works on the intended step.
- If I validate the flow form first then neither form will have the validation work on the intended step.

I pass a resolver to the Form's config in each case using `zodResolver(currentStep[1].schema)`:

```
<Form config={{resolver: zodResolver(currentStep[1].schema)`}} />
```

The error thrown in the console is not giving much away and is misleading, it comes from a file from another package: https://github.com/react-hook-form/resolvers/blob/master/zod/src/zod.ts#L70.

The actual error being thrown comes from this package:

```
TypeError: Cannot assign to read only property '_cached' of object '#<ZodObject>'
    at ZodObject._getCached (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:14132:30)
    at ZodObject._parse (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:14146:49)
    at ZodObject._parseAsync (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:12599:29)
    at ZodEffects._parse (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:15417:22)
    at ZodEffects.safeParseAsync (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:12644:39)
    at ZodEffects.parseAsync (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:12626:35)
    at _callee$ (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:462:84)
    at tryCatch (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:386:1357)
    at Generator.<anonymous> (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:386:4174)
    at Generator.next (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:386:2208)
```

I've tried using async with the resolver but it didn't do much.

Below is the full code:

```
// FlowForm.tsx
function usePresentationUi({ currentStep }) {
  return { Scene: currentStep?.[1].default }
}

const Container = ({
  currentStep,
  resolver,
  Scene,
  onBack,
  onPass,
  onSubmit,
}) => (
  <Form onSubmit={onSubmit} config={{ resolver }}>
    <h2>
      {'FlowForm'} - {`FormStep - ${currentStep?.[0]}`}
    </h2>
    <Scene onBack={onBack} onPass={onPass} />
    <FormError />
    <FieldError name=""formErrors"" />
  </Form>
)

export default function FlowForm({ steps, withValidation }) {
  const flowFormProps = useFlowForm({ steps, withValidation })

  const ui = usePresentationUi({ currentStep: flowFormProps.currentStep })

  return ui.Scene ? (
    <Container
      key={`FormStep - ${flowFormProps.currentStep?.[0]}`}
      {...flowFormProps}
      Scene={ui.Scene}
    />
  ) : null
}
```

```
// useFlowForm.ts
import { atom, useRecoilState } from 'recoil'
import { v4 as uuidv4 } from 'uuid'

import { UseFlowForm } from './types'
import { zodResolver } from './zodResolver'

const formStore = atom({ key: 'flowForms', default: {} })

function useFlowForm({ steps }) {
  const [storeData, store] = useRecoilState(formStore)

  const form = React.useRef(uuidv4())

  const setStep = (step) => (forms) => ({
    ...forms,
    [form.current]: { ...forms[form.current], step },
  })

  React.useEffect(() => {
    const show = Object.entries(steps)[0]
    store(setStep(show))
    // store((forms) => ({ ...forms, [form.current]: { step: show } }))
  }, [])

  const currentStep = React.useMemo(
    () => storeData[form.current]?.step,
    [storeData]
  )

  const onBack = () => {}

  const onPass = () => {}

  const onSubmit = (data) => {
    console.log('submitting', data)

    const current = storeData[form.current].step[0]

    const next = Object.entries(steps).reduce((Q, [key], N) => {
      if (!Q && key === current) {
        return Object.entries(steps)?.[N + 1]
      }

      return Q
    }, undefined)

    store(setStep(next))
  }

  return {
    currentStep,
    resolver: currentStep?.[1].schema
      ? zodResolver(currentStep[1].schema)
      : undefined,
    onBack,
    onPass,
    onSubmit,
  }
}

export default <UseFlowForm>useFlowForm
```

```
// The step component with its own schema.

import { Button, ButtonGroup, Checkbox, Text, VStack } from '@chakra-ui/react'
import * as z from 'zod'

import { Controller, FieldError } from '@redwoodjs/forms'

import { Step } from './types'

const MONTHLY_WITH_ME = 'monthlyWithMe'

const MONTHLY_WITH_TEAM = 'monthlyWithTeam'

const CUSTOM_NEEDS = 'customNeeds'

export const schema = z
  .object({
    [MONTHLY_WITH_ME]: z.boolean(),
    [MONTHLY_WITH_TEAM]: z.boolean(),
    [CUSTOM_NEEDS]: z.boolean(),
  })
  .partial()
  .refine(
    (options) => {
      alert('red')
      console.log(options, Object.values(options).some(Boolean))
      return Object.values(options).some(Boolean)
    },
    {
      message: 'Please select at least one option to continue',
      path: ['formErrors'],
    }
  )

const ActiveContributionProgram: Step = ({ onPass }) => (
  <>
    <Text>Active Contribution Program</Text>
    <Text m={4}>
      {`""The success of each of us is the success of everyone"", and the Active
        Contribution Program is exactly about that.

        To support you on your road
        to success, we'd like to assign a Core Team member to you. Regular
        meetings with them and you or your team will provide the extra support
        needed to make sure you don't waste precious time exploring beaten
        paths. We don't want you to repeat solutions, we want to scale them with
        you!`}
    </Text>
    <Text m={4}>I&rsqos;d like to enroll with the following preferences:</Text>
    <VStack m={4}>
      <CheckboxControlled
        name={MONTHLY_WITH_ME}
        testid=""input.monthlyWithMe""
        label=""Monthly meeting with me only""
      />
      <CheckboxControlled
        name={MONTHLY_WITH_TEAM}
        testid=""input.monthlyWithTeam""
        label=""Get in touch for custom needs""
      />
      <CheckboxControlled
        name={CUSTOM_NEEDS}
        testid=""input.customNeeds""
        label=""Get in touch for custom needs""
      />
      <FieldError name=""customNeeds"" color=""red"" />
    </VStack>
    <ButtonGroup gap={4} p={4}>
      <Button onClick={onPass} data-testid=""button.onPass"">
        Hard pass
      </Button>
      <Button type=""submit"" data-testid=""button.onSubmit"">
        I&rsquo;m in
      </Button>
    </ButtonGroup>
  </>
)

const CheckboxControlled = ({ label, name, testid }) => (
  <Controller
    name={name}
    render={({ field }) => (
      <Checkbox {...field} data-testid={testid}>
        {label}
      </Checkbox>
    )}
  />
)

export default ActiveContributionProgram
```
",,
1629610909,2209,`Writeable<T>` incompatibility with latest TS nightly,"In the most recent `typescript@next` nightly build (`5.1.0-dev.20230317`), something subtle seems to have changed with mappings over tuple types, resulting in the following error when typechecking a project with Zod in its dependencies.

```
node_modules/zod/lib/types.d.ts:698:129 - error TS2344: Type 'Writeable<T>' does not satisfy the constraint '[string, ...string[]]'.

698 declare function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;
                                                                                                                                    ~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:706:97 - error TS2344: Type 'Writeable<ToExtract>' does not satisfy the constraint '[string, ...string[]]'.

706     extract<ToExtract extends readonly [T[number], ...T[number][]]>(values: ToExtract): ZodEnum<Writeable<ToExtract>>;
```

Anyone hitting this can work around it for now by either:
 - using a stable TypeScript release (this was just flagged by an early-warning CI run in a project I maintain)
 - setting `skipLibCheck: true` to ignore the error (along with any other issues, real or fake, in `.d.ts` files)",,
1629303915,2208,"As a zod beginner, I would like to imporve my ts-to-zod developer experience with LLM's z.prompt() support.","The zod project is the best choice for developers who require accurate LLM prompting using Typescript, thanks to having some of the most proficient developers in the field.

```ts
import ""https://deno.land/std@0.179.0/dotenv/load.ts"";
import { Configuration, OpenAIApi, } from ""npm:openai@3.2.1"";
import { assertEquals, assertStringIncludes, assertThrows } from ""https://deno.land/std@0.179.0/testing/asserts.ts"";
import { z } from ""https://deno.land/x/zod@v3.21.4/mod.ts"";
class SchemaPromptInput {
  static readonly Enum = {
    LargeLanguageModelsChatProider: z.enum([""openai"", ""microsoft-azure"", ""google-cloud"", ""llm404"", ""taichung""]),
    RequestModel: z.enum([""gpt-3.5-turbo-0301"", ""gpt-3.5-turbo"", ""gpt-4"", ""code-davinci-002"", ""gpt-404""])
  }
  static readonly promptArg = z.object({
    provider: SchemaPromptInput.Enum.LargeLanguageModelsChatProider.optional().default(""openai""),
    model: SchemaPromptInput.Enum.RequestModel.optional().default(""gpt-3.5-turbo""),
    message: z.string().min(20).max(100).includes('schema').includes("" named ""),
    tstype: z.string().includes('type'),
  })
  // deno-lint-ignore no-explicit-any
  static readonly isPrompt = (v: any): v is SchemaPromptInput.TypePromptArg => SchemaPromptInput.promptArg.safeParse(v).success
}

// deno-lint-ignore no-namespace
namespace SchemaPromptInput {
  export type TypePromptArg = z.infer<typeof SchemaPromptInput.promptArg>
}

// z.prompt({}) ?
const zPrompt = (arg: SchemaPromptInput.TypePromptArg) => {
  if (SchemaPromptInput.isPrompt(arg)) {
    return `You are a thoughtful assistant that helps the developer do tasks on Typescript. 
Answer as concisely as possible for each response (e.g. don't be verbose). When it makes sense, 
use markdown syntax to output code. If outputting code, include the programming language. 
Use the examples below as a guide.
  
Example 1:
Task: use the type from third-party typescript packages in my schema named ""SchemaPromptInput""
Context:
export type prompt = {
  message: string
}
Output:
\`\`\`ts
export class SchemaPromptInput {
  static readonly prompt = z.object({
    message: z.string().min(20).max(100).includes('schema'),
  })
  static readonly isPrompt = (v: any): v is SchemaPromptInput.TypePrompt => SchemaPromptInput.prompt.safeParse(v).success
}
export namespace SchemaPromptInput {
  export type TypePrompt = z.infer<typeof SchemaPromptInput.prompt>
}
\`\`\`


Example 2:
Task: use the type in my schema named ""SchemaOpenAiMessage""
Context:
export type Role = ""system"" | ""assistant"" | ""user"";
export type Message {
  role: Role;
  content: string;
}

Output:
\`\`\`ts
export class SchemaOpenAiMessage {
  static readonly Enum = {
    Role: z.enum([""system"", ""user"", ""assistant""]),
  }
  static readonly openAiMessage = z.object({
    role: SchemaOpenAiMessage.Enum.Role,
    content: z.string().min(2).max(1000),
  })
  static readonly isOpenAiMessage = (v: any): v is SchemaOpenAiMessage.TypeOpenAiMessage => SchemaOpenAiMessage.openAiMessage.safeParse(v).success
}
export namespace SchemaOpenAiMessage {
  export type TypeOpenAiMessage = z.infer<typeof SchemaOpenAiMessage.openAiMessage>
}
\`\`\`

Example 3:
Task: use the type in my schema named ""SchemaHero""
Context:
export type Hero = {
  id: string;
  name: string;
  age: number;
}

Output:
\`\`\`ts
export class SchemaHero {
  static readonly hero = z.object({
    id: z.string().min(2).max(10).includes('FOO'),
    name: z.string().min(2).max(30),
    age: z.number().min(1).max(1000)
  })
  static readonly isHero = (v: any): v is SchemaHero.TypeHero => SchemaHero.hero.safeParse(v).success
}
export namespace SchemaHero {
  export type TypeHero = z.infer<typeof SchemaHero.hero>
}
\`\`\`
  
Begin.
Task: ${arg.message}
Context:
${arg.tstype}
Output:
\`\`\`ts
`
  } else {
    throw new Error('Prompt error. sample: use the type in my schema named ""SchemaBar""')
  }
}

const prompt101: SchemaPromptInput.TypePromptArg = {
  provider: SchemaPromptInput.Enum.LargeLanguageModelsChatProider.enum.openai,
  model: SchemaPromptInput.Enum.RequestModel.enum[""gpt-3.5-turbo""],
  message: 'use the type in my schema named ""SchemaFoo""',
  tstype: `
export type Role = ""admin"" | ""user"" | ""403"" ;
export type Group = ""Develop"" | ""Dreamer"" | ""404"";
export type Message = {
    group: Group
    content: string
}
export type User = {
  usename: string,
  password: string,
  amount: number,
  role: Role,
  message: Message
}
`}

const chatGpt = async (arg: SchemaPromptInput.TypePromptArg) => {
  if (SchemaPromptInput.isPrompt(arg) && arg.provider === ""openai"") {
    const openai = new OpenAIApi(new Configuration({
      apiKey: Deno.env.get(""OPENAI_API_KEY""),
    }))
    const content = zPrompt(arg)
    const resp = await openai.createChatCompletion({
      model: arg.model,
      messages: [{ role: ""assistant"", content }]
    });
    return resp;
  } else {
    throw new Error(""Parse Error"")
  }
}

Deno.test(""error prompt test"", () => {
  assertThrows(
    () => {
      const _errorPrompt = zPrompt({
        provider: SchemaPromptInput.Enum.LargeLanguageModelsChatProider.enum.taichung,
        model: SchemaPromptInput.Enum.RequestModel.enum[""gpt-404""],
        message: 'crete a zod schema for me',
        tstype: `type blah`
      })
    },
    Error,
    'Prompt error. sample: use the type in my schema named ""SchemaBar""'
  )
  assertStringIncludes(prompt101.message, ""SchemaFoo"")
})

const tseval = (code: string) => {
  const denoImport = `import { z } from ""https://deno.land/x/zod@v3.21.4/mod.ts"";\n${code}`
  return import(""data:application/typescript,"" + encodeURIComponent(denoImport));
};

Deno.test(""ts to zod"", async () => {
  const resp = await chatGpt(prompt101)
  const content = resp.data.choices[0].message?.content
  if (content) {
    // console.log(JSON.stringify(resp.data, null, 2))
    // remove markdown code tail ```
    const script = content.replace(""```"", """").trim();
    console.log(script)
    assertStringIncludes(script, ""class SchemaFoo"")
    const mod = await tseval(script);
    assertEquals(mod.SchemaFoo.isUser({}), false);
    assertEquals(mod.SchemaFoo.isUser({
      username: 'alice',
      password: '**********',
      amount: 10,
      role: ""admin"",
      message: {
        group: ""Develop"",
        content: ""blahblah""
      }
    }), true);
  }
})

/**
 * Please execute the following docker command to test and try to run the given openai example.
 * $ docker run --env OPENAI_API_KEY=blahblah --rm denoland/deno:alpine \
 *     test --allow-read=.env --allow-env=OPENAI_API_KEY --allow-net=api.openai.com \
 *     https://raw.githubusercontent.com/dltdojo/dltdojo-cd/main/cd23/dafu/hack/chatgpt104/zprompt.test.ts
 * 
------- output -------
export class SchemaFoo {
  static readonly Enum = {
    Role: z.enum([""admin"", ""user"", ""403""]),
    Group: z.enum([""Develop"", ""Dreamer"", ""404""]),
  }
  static readonly message = z.object({
    group: SchemaFoo.Enum.Group,
    content: z.string().max(200),
  })
  static readonly user = z.object({
    username: z.string().min(2).max(30),
    password: z.string().min(6).max(20),
    amount: z.number().min(0),
    role: SchemaFoo.Enum.Role,
    message: SchemaFoo.message,
  })
  static readonly isUser = (v: any): v is SchemaFoo.TypeUser => SchemaFoo.user.safeParse(v).success
}
export namespace SchemaFoo {
  export type TypeUser = z.infer<typeof SchemaFoo.user>
  export type TypeMessage = z.infer<typeof SchemaFoo.message>
  export type TypeRole = z.infer<typeof SchemaFoo.Enum.Role>
  export type TypeGroup = z.infer<typeof SchemaFoo.Enum.Group>
}
Check data:application/typescript,import%20%7B%20z%20%7D%20from%20%22https%3A%2F%2Fdeno.land%2Fx%2Fzod%40v3.21.4%2Fmod.ts%22%...
----- output end -----
ts to zod ... ok (16s)

ok | 2 passed | 0 failed (16s)
 */
```

If you have questions related to this schema matter, please see Issue #1917  for further information.",,
1628026591,2204,How to validate a Generator?,"Is there a way to validate a generator?

By this, I mean something that will validate the generator as it's being iterated in the same way as functions are validated when called.

I tried to implement one from the specification but ran into problems:

1. Generators require a `this` context, but the `this` context is lost when validating a function.
2. There doesn't seem to be support for `Symbol` properties, which can be lost unexpectedly after parsing. So `Symbol.iterator` properties seem to be ignored.

What's the status on this?",,
1627774384,2203,Regression in type inference for a union of array types inside an object type,"I have some schema like the following:
```
z.object({
    arrayProp: z.union([z.string().array(), z.number().array()]),
}),
```

this used to produce the following type for the `arrayProp` key:  `string[] | number[]`.

since version 3.21.2 this produces the following type: 
`string[] | (string[] & number[]) | (string[] & undefined) | (number[] & string[]) | number[] | (number[] & undefined)`

this in turn causes many problems when trying to work with `arrayProp`, for example if I try to use an array predicate like `map`, I'm getting the following error: 
```
TS2349: This expression is not callable.   Each member of the union type '(<U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[]) | (<U>(callbackfn: (value: number, index: number, array: number[]) => U, thisArg?: any) => U[]) | ((<U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[]) & (<U>(callbackfn: (value: num...' has signatures, but none of those signatures are compatible with each other.
```

However, if I remove the wrapper `z.object` and use the following schema: `z.union([z.string().array(), z.number().array()])` then I'm getting the correct type inference of `string[] | number[]`

Looking at the code for the 3.21.2 PR (https://github.com/colinhacks/zod/commit/4d016b772b79d566bfa2a0c2fc5bfbd92b776982#diff-a5a27c41f819170124f4fd4cf24b1d71b8ab2966a4bde235a7f8db53dc8ef486) suggests that this has to do with changes made to the internal`DeepPartial` type.

For now we're sticking with 3.21.1 version, but I would be happy to see that fixed as we use this pattern on multiple occasions across our project.",,
1627332424,2202,Discriminated Union error masking other validation errors,"I'm trying to validate a form with react-hook-form and zod/zodResolver. The schema is broadly as follows:

```ts
const SchemaA = z.object({
  fieldA: z.enum(['yes', 'no']),
  fieldB: z.enum(['yes', 'no']),
  fieldC: z.literal('no')
}

const SchemaB = schemaA.extend({
  fieldC: z.literal('yes'),
  subFieldC: z.enum(['yes', 'no'])
}
```

So, `SchemaB` is essentially `SchemaA` plus an extra field _if_ `fieldC` is set to yes. 
`fieldA` and `fieldB` will always be required, no matter which schema is in use.

When validating the schema, and if `fieldC` has not been set, the only error message appearing is 

`Invalid discriminator value. Expected 'no' | 'yes'`

The error messages for `fieldA` and `fieldB` are only showing validation errors once `fieldC` has passed validation.

Is there a way for me to show all validation errors?
",,
1626022248,2200,"`z.object` to be mergeable with `z.record`, or ability to define keys by a custom type","I have a type that's basically like this

```ts
type YKeys = `y${number}`;
type ZKeys = `z${number}`;
type DataKeys = `d${number}`;

type Point = {
  x: string;
  id: string;
} & Record<YKeys, number> & Record<ZKeys, number> & Record<DataKeys, { stuff: string }>

```

I have the schemas for the special keys
```ts 
const yKeysSchema = z.custom<`i${number}`>((val) => /^y(\d+)$/.test(val as string));
const zKeysSchema = z.custom<`i${number}`>((val) => /^z(\d+)$/.test(val as string));
const dataKeysSchema = z.custom<`i${number}`>((val) => /^d(\d+)$/.test(val as string));
```

and I used to be able to get by with just a superRefine call to a `pointValidityRefinement` function that will check the keys, with something like

```ts
const pointSchema = z.object({ x: z.string(), id: z.string() }).passthrough().superRefine(pointValidityRefinement);
```

But since the last update I get errors like 

```
Type 'objectOutputType<{ x: ZodNumber; id: ZodString; }, ZodTypeAny, ""passthrough"">' is not assignable to type 'Point'.
    'string' and '`y${number}`' index signatures are incompatible.
      Type 'unknown' is not assignable to type 'number | undefined'.
```

I tried to change the schema of the point to something like

```ts
const pointSchema = z.object({ x: z.string(), id: z.string() })
  .merge(z.record(yKeysSchema, z.number())
  .merge(z.record(zKeysSchema, z.number())
  .merge(z.record(dataKeysSchema, z.object({ stuff: z.string() }))
```
but that doesn't work.

Is there any way I can do this?

btw, I'm using TypeScript 4.8 and latest zod (3.21.4)",,
1625946806,2199,Schema type returned with .transform(),"Hi, this is my target Type, (look at companyName):
<img width=""331"" alt=""image"" src=""https://user-images.githubusercontent.com/82887830/225385816-d974e147-09ce-4755-ba67-4257c9013687.png"">

I'm creating this Schema to represent the API part and transform data to fit my target Type:
<img width=""856"" alt=""image"" src=""https://user-images.githubusercontent.com/82887830/225386156-842814fe-9086-4b0b-8702-b8e193dc6939.png"">

He understood that companyName is missing compare to target Type.

Now let's add this key, and why not modify the output structure to fit with my Target:

<img width=""471"" alt=""image"" src=""https://user-images.githubusercontent.com/82887830/225389089-157d8411-2892-4832-8dc6-a4a7f511ab01.png"">


Typescript is still complaining of missing companyName key. 

",,
1625086471,2198,Properties become optional in composable schemes (generics),"### Discussed in https://github.com/colinhacks/zod/discussions/2182

<div type='discussions-op-text'>

<sup>Originally posted by **kostysh** March 10, 2023</sup>
Hi,
playing with composable schemas and got unexpected behaviour. As in the example below every particular schema is NOT optional, but for some reason, the resulting schema exposes `container` options and their properties as optional.
What is wrong?
Here is an example of the code that demonstrates the issue (codesandbox): https://codesandbox.io/s/composable-zod-schemes-forked-13wuuc?file=/index.ts

```typescript
import { z } from 'zod';

const GenericQuerySchema = z.object({}).catchall(z.unknown());

type GenericQuery = z.infer<typeof GenericQuerySchema>;

const baseMessageSchema = z.object({
  id: z.string(),
});

const createOptsSchema = <T extends GenericQuery>(querySchema: z.ZodType<T>) =>
  baseMessageSchema.extend({
    query: querySchema,
    querySchema: z.instanceof(z.ZodType<T>),
  });

type OPTS<T extends GenericQuery> =
  z.infer<ReturnType<typeof createOptsSchema<T>>>;

const createExtMessageSchema = <T extends GenericQuery>(querySchema: z.ZodType<T>) =>
  baseMessageSchema.extend({
    query: querySchema,
  });

type ExtMessage<T extends GenericQuery> =
  z.infer<ReturnType<typeof createExtMessageSchema<T>>>;

const test = <T extends GenericQuery>(options: OPTS<T>): ExtMessage<T> => {
  const { id, query } = createOptsSchema<T>(options.querySchema).parse(options);
  // const query: z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
  //     id: z.ZodString;
  //     query: z.ZodType<T, z.ZodTypeDef, T>;
  //     querySchema: z.ZodType<z.ZodType<T, z.ZodTypeDef, T>, z.ZodTypeDef, z.ZodType<T, z.ZodTypeDef, T>>;
  // }>, requiredKeys<...>>[""query""] | undefined
  console.log('--->', id, query); // Why `query` is optional?
  return createExtMessageSchema<T>(options.querySchema).parse({
    id,
    query,
  })
};

const CustomQuerySchema = GenericQuerySchema.extend({
  hello: z.string(),
});

type CustomQuery = z.infer<typeof CustomQuerySchema>;

const result = test<CustomQuery>({
  id: 'aaa',
  query: {
    hello: '123',
  },
  querySchema: CustomQuerySchema,
});

console.log(result)
```

</div>

`zod` version: 3.21.4
`typescript` version: 4.9.5

> `strict` option is `true` in the `tsconfig.json`",,
1624687685,2197,Memoize the schema initialization function passed to z.lazy,"I noticed that `z.lazy` reruns the function passed to it every time you use the schema. Can it be changed to memoize the result instead?

See:
```ts
import { z } from 'zod';

const lazy = z.lazy(() => {
  console.log('initialize');
  return z.string();
});

lazy.parse('hello');
lazy.parse('world');
```
Logs out:
```
initialize
initialize
```",,
1624497852,2196,Change in 3.21.2 breaks assignability of schema created from generics' parsed and inferred type,"I have a need to create a zod object schema that only has one key-value pair. This may not be exactly the best way to do something like this (and this is a contrived example), but in version 3.21.1, it was possible to assign the parsed data to the inferred type of a schema created through generic parameters:

```ts
import { z } from 'zod';

const createSchemaAndParse = <K extends string, VS extends z.ZodString>(key: K, valueSchema: VS, data: unknown) => {
  const schema = z.object({
    [key]: vSchema
  });
  const parsed = schema.parse(data);
  const inferred: z.infer<z.ZodObject<{ [k in K]: VS }>> = parsed; // this line errors in 3.21.2
  return inferred;
};
createSchemaAndParse('foo', z.string(), { foo: '' });
```

Unfortunately, with 3.21.2 (and above), the above line now produces a type error.",,
1624243741,2195,intersection between `object()` and `record()` parsing fails,"I have an intersection between a `z.object()` and a `z.record()` that has a refined key. Parsing an input fails since it seems to require all the input keys to match the record and the object, despite typescript seeing it as valid against the type.

version: 3.20.6

Example:
```ts
type FooKey = `foo.${string}`
const isValidFooKey = (key: string): key is FooKey => key.startsWith(""foo."")
const Foo = z.record(
  z.string().refine(isValidFooKey),
  z.string(),
)
type Foo = z.infer<typeof Foo> // type Foo = { [x: `foo.${string}`]: string | undefined; }

console.log(Foo.parse({
  ""foo.x"": ""some string value"",
})) // succeeds, output: `{ 'foo.x': 'some string value' }`

const Bar = z.object({
  bar: z.string().optional(),
})
type Bar = z.infer<typeof Bar> // type Bar = { bar: string | undefined; }

console.log(Bar.parse({
  bar: ""another string value"",
})) // succeeds, output: `{ bar: 'another string value' }`

const BarAndFoo = Bar.and(Foo)
type BarAndFoo = z.infer<typeof BarAndFoo> // type BarAndFoo = { bar: string | undefined; } & Partial<Record<`foo.${string}`, string>>

console.log(BarAndFoo.parse({
  ""foo.x"": ""some string value"",
})) // succeeds, output: `{ 'foo.x': 'some string value' }`

console.log(BarAndFoo.parse({
  bar: ""another string value"",
})) /* fails with: ```ZodError: [
  {
    ""code"": ""custom"",
    ""message"": ""Invalid input"",
    ""path"": [
      ""bar""
    ]
  }
]``` */

console.log(BarAndFoo.parse({
  ""foo.x"": ""some string value"",
  bar: ""another string value"",
})) /* fails with: ```ZodError: [
  {
    ""code"": ""custom"",
    ""message"": ""Invalid input"",
    ""path"": [
      ""bar""
    ]
  }
]``` */

const x: BarAndFoo = {
  ""foo.x"": ""some string value"",
  bar: ""another string value"",
} // typescript is happy with this
```",,
1623322945,2194,External Types Library using inferred types from Zod Schema not being declared correctly,"**Background:**

I have a TS node service that uses zod schemas for validation, and types inferred from these, ie:

```JS
export type MyType = z.infer<typeof mySchema>;
```

These types are then exported into a private NPM library, so I can use them across other projects making use of the TS node service.

```
tsc --emitDeclarationOnly
```

**Problem:**

The types, within the TS node service (where they are defined) are working correctly and as expected, however the types exported / imported from the NPM package are incorrect.

Consider the example below...

```JS
const mySchema = z.object({
  id: z.string(),
  x: z.number(),
  y: z.number(),
});

export type MyType = z.infer<typeof mySchema>;
```

**Expected:**

_This is how they are being correctly inferred within the Node Service code_

```JS
type MyType = {
  id: string;
  x: number;
  y: number;
}
```

**Actual:**

_This is how they are being imported from the npm package within external code_

```JS
type MyType = z.infer<z.ZodObject<{
  id: z.ZodString;
  x: z.ZodNumber;
  y: z.ZodNumber;
}>>
```

**Bug:**

The exported type definitions should correctly match the inferred types.
",,
1622082472,2192,refine() function gets called even when parser already failed within translate()/refine()/regex(),"This is very similar to this one:
https://github.com/colinhacks/zod/issues/2113

Happening in version 3.21.4

refine() function still runs even though a previous translate has already invalidated it.  It's getting passed some aribtrary object
instead of the string that it expects.
```typescript
const parseResult = z
	.unknown()
	.transform((x, ctx) => {
		if (typeof x === 'string') return x;

		console.log('I fail because input is a number (correct behavior)');
		ctx.addIssue({
			code: 'custom',
		});
		return z.NEVER;
	})
	.transform((x: string) => {
		console.log(""I don't get executed (correct behavior since transform above invalidated the input)"");
		return x;
	})
	.refine((x: string) => {
		//BUG
		console.log(""I shouldn't get called but I do!!!!"");
		console.log(`I should be a string but I am a ${typeof x}!!!`); //'object'
		console.log(x); // some sort of '{status:'aborted'} object (the value underlying z.NEVER?)
	})
	.safeParse(42);

console.log(`succeeded:  ${parseResult.success}`); // false (correct behavior)
```
EDIT:  looks like there are more scenarios that are causing this 'zombie refine' scenario.  Here's two more:
- A failure within a `refine` causing it:
```typescript
import * as z from 'zod';

const parseResult = z
	.string()
	.refine(x => false) // force anything/everything to fail
	.transform(x => {
		console.log(""I don't get called""); // correct
		return x;
	})
	.refine((x: string) => {
		console.log(""I shouldn't get called!!!!!!"");
		console.log(typeof x); // string
		console.log(x); // '123'
	})
	.safeParse('123');

console.log(`succeeded:  ${parseResult.success}`); // false (correct behavior)
```
- a failure within a `regex` causing it:
```typescript
import * as z from 'zod';

const parseResult = z
	.string()
	.regex(/abc/) // fail because input doesn't match regex
	.transform(x => {
		console.log(""I don't get called""); // correct
		return x;
	})
	.refine((x: string) => {
		console.log(""I shouldn't get called!!!!!!"");
		console.log(typeof x); // string
		console.log(x); // '123'
	})
	.safeParse('123');

console.log(`succeeded:  ${parseResult.success}`); // false (correct behavior)
```

These were pretty easy to stumble upon, so there are likely more out there as well.",,
1622043178,2191,New signature for Object.partial to exclude certain keys (opposite mask),"```
partial<Mask extends {
        [k in keyof T]?: true;
    }>(mask: Mask): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
```

Right now it's possible to provide a mask to `Object.partial()` to apply it only to certain keys.
I would like to be able to also do the opposite: make all properties optional except the provided ones.
Basically the additional signature would have `Mask extends { [k in keyof T]?: false }` instead of `true`.
Obviously you can't mix true and false because it would make no sense.",,
1622035747,2190,Object.nullable and Object.nonNullable,"`Object.partial()` is very handy to make properties optional, but sometimes you want to make properties nullable instead (for example when you make SQL unions) and there is no method to do so.

I'm achieving the same result with custom functions but it's very inconvenient:

```
export function toNullableOrOptionalShape(
  shape: ZodRawShape,
  type: ""nullable"" | ""optional""
): ZodRawShape {
  return Object.entries(shape).reduce<ZodRawShape>((acc, [key, value]) => {
    acc[key] = value[type]();
    return acc;
  }, {});
}

export function toNullableObject<
  T extends ZodRawShape,
  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
  Catchall extends ZodTypeAny = ZodTypeAny
>(
  object: ZodObject<T>
): ZodObject<
  {
    [k in keyof T]: ZodNullable<T[k]>;
  },
  UnknownKeys,
  Catchall
> {
  return new ZodObject({
    ...object._def,
    shape: () => toNullableOrOptionalShape(object.shape, ""nullable""),
  }) as any;
}
```

I would love to have an `Object.nullable()` method and I could PR it if you are interested in having such feature.

We also need the equivalent of `Object.required` (`Object.nonNullable`?) to mark fileds as non-nullable.",,
1619984370,2186,Property 'ulid' does not exist on type 'ZodString'.,"Not sure if this is a known issue, but on the latest version of zod (3.21.4*) throws a typescript error on ulids ...

<img width=""548"" alt=""Screenshot 2023-03-11 at 12 08 09"" src=""https://user-images.githubusercontent.com/84131395/224483519-53ac6b92-d566-4255-b0d7-2ac491dc29ae.png"">

*at the time of writing ",,
1619628676,2184,Prisma XOR with Zod  > 3.21.1 not working,"We encounterd a bug when using generated prisma types with versions greater than `3.21.1`. 

You can reproduce the issue in the following repo:  https://github.com/chrishoermann/zod-prisma-types-bug

As you can read in the following discussion we first thought it was an issue with prisma, but after digging around and finding that the suspected type has been this way for a long time now @njdowdy found that this is a zod issue that happend somwhere in `3.21.2`

### Discussed in https://github.com/colinhacks/zod/discussions/2171

<div type='discussions-op-text'>

<sup>Originally posted by **chrishoermann** March  9, 2023</sup>
I've built a generator for prisma ([zod-prisma-types](https://github.com/chrishoermann/zod-prisma-types)) that throws a type error since prisma updated their `XOR` type in 4.11:

```ts
  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T
```

before this type update the following zod schema worked without problems:

```ts
export const UserCreateInputSchema: z.ZodType<Prisma.UserCreateInput> = z.object({
  id: z.string().cuid().optional(),
  email: z.string().email({ message: ""Invalid email address"" }),
  name: z.string().min(1).max(100).optional().nullable(),
  role: z.union([ z.lazy(() => UserCreateroleInputSchema),z.lazy(() => RoleSchema).array() ]).optional(),
  enum: z.lazy(() => AnotherEnumSchema).optional(),
  scalarList: z.union([ z.lazy(() => UserCreatescalarListInputSchema),z.string().array() ]).optional(),
  posts: z.lazy(() => PostCreateNestedManyWithoutAuthorInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  location: z.lazy(() => LocationCreateNestedOneWithoutUserInputSchema).optional(),
}).strict();

export const UserUncheckedCreateInputSchema: z.ZodType<Prisma.UserUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  email: z.string().email({ message: ""Invalid email address"" }),
  name: z.string().min(1).max(100).optional().nullable(),
  role: z.union([ z.lazy(() => UserCreateroleInputSchema),z.lazy(() => RoleSchema).array() ]).optional(),
  enum: z.lazy(() => AnotherEnumSchema).optional(),
  scalarList: z.union([ z.lazy(() => UserCreatescalarListInputSchema),z.string().array() ]).optional(),
  lat: z.number(),
  lng: z.number(),
  posts: z.lazy(() => PostUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
}).strict();

export const UserCreateArgsSchema: z.ZodType<Prisma.UserCreateArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  data: z.union([ UserCreateInputSchema,UserUncheckedCreateInputSchema ]),
}).strict()
```

so a simple union was sufficient to satisfy typescript. in Prisma 4.11 typescript now throws the following error because, as I see it, the `Without<...>` type can not be satisfied with a union anymore:
```
Type 'ZodObject<{ select: ZodOptional<ZodType<UserSelect, ZodTypeDef, UserSelect>>; include: ZodOptional<ZodType<UserInclude, ZodTypeDef, UserInclude>>; data: ZodUnion<...>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<UserCreateArgs, ZodTypeDef, UserCreateArgs>'.
  The types of '_type.data' are incompatible between these types.
    Type '(UserCreateInput | UserUncheckedCreateInput) & (UserCreateInput | UserUncheckedCreateInput | undefined)' is not assignable to type '(Without<UserCreateInput, UserUncheckedCreateInput> & UserUncheckedCreateInput) | (Without<...> & UserCreateInput)'.
      Type 'UserCreateInput & UserUncheckedCreateInput' is not assignable to type '(Without<UserCreateInput, UserUncheckedCreateInput> & UserUncheckedCreateInput) | (Without<...> & UserCreateInput)'.
        Type 'UserCreateInput & UserUncheckedCreateInput' is not assignable to type 'Without<UserUncheckedCreateInput, UserCreateInput> & UserCreateInput'.
          Type 'UserCreateInput & UserUncheckedCreateInput' is not assignable to type 'Without<UserUncheckedCreateInput, UserCreateInput>'.
            Types of property 'lat' are incompatible.
              Type 'number' is not assignable to type 'undefined'.
```

I'm currently a bit stuck on how to solve this issue because I don't really know how to implement the `Without<...>` type especially because the `z.ZodType<...>` does not provide the object helper methods that would have been my first guess on how to approach this. Any help is appreciated.
</div>",,
1619421131,2183,`z.inferFlattenedErrors` does not account for transforms/effects,"Originally reported in `zod-form-data`: https://github.com/airjp73/remix-validated-form/issues/250#issuecomment-1454827269

[Playground reproduction](https://www.typescriptlang.org/play?ssl=5&ssc=47&pln=5&pc=25#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8EARgFZwC8KAdK2wFNqMABRJMECAC5eTKMDoBzEQEp0KnjCgBDRhKggRELgD44YuC21QZEHhONoVKqjACeYAXABq2gDbAxNowwPQAolA4UAxcvAqYAlAAYn7BMAJ0AsQRUQwAPO6eEJhw-CaUNPRMcFACMdz8PAzaCQAK1gwCYk5UwCUiAIS1DE0ArtTUdQxqCBRwcLSM8Jip8NzDPIlR9qvpdKqU8wD0R-PzAHoA-FTzi9Vb0AwyvgFBIeGRj7ErwZRoQA)

I'm not entirely clear on the details, but it appears that when using a `transform` (that seems to use `z.Effect` under the hood) `z.inferFlattenedErrors` does not match the type of `error.flatten()`

---

_Example from @airjp73_

```ts
import { z } from ""zod"";

const obj = z.object({ foo: z.string() }).transform(o => ({ bar: o.foo }))

type ValidationErrors = z.inferFlattenedErrors<typeof obj>;

const res = obj.safeParse({})

if (!res.success) {
  const flat = res.error.flatten();
  const errors: ValidationErrors = flat;
  // ^ type error here
}
```",,
1617479597,2176,"Json, prisma, passthrough - since 3.21.0","Hello,

maybe this is my misuse, but since 3.21.0 I am having the following issue:

I am using prisma - JSON field:

```prisma
model MyModel {
  // ...
  json JSON
}
```

and then the following zod schema:

```typescript
const schema = z.object({
  name: z.string(),
}).passthrough()

const data = schema.parse({
  name: 'hello',
  extra: 'something',
})
```

and trying to insert it into the DB:

```typescript
ctx.prisma.my_model.create({
  data: {
    json: data,
  }
})
```

Then since 3.21.0 I am getting the following:

```
TS2322: Type 'objectOutputType<{ name: ZodString; }, ZodTypeAny, ""passthrough"">' is not assignable to type 'JsonNull | InputJsonValue'.   Type 'objectOutputType<{ name: ZodString; }, ZodTypeAny, ""passthrough"">' is missing the following properties from type 'readonly (InputJsonValue | null)[]': length, concat, join, slice, and 19 more.
```

Basically I want to store in the db whole json object, even if it contains some extra fields.
Maybe I was just misusing passthrough... Thanks


",,
1617014053,2172,Inferring type with `zod.input` when using `zod.coerce`,"```ts
const exampleObject = zod.object({
    date: zod.coerce.date()
});

export type exampleTypeInput = zod.input<typeof exampleObject>;
```

In this `exampleTypeInput` inferred for the attribute `date` has type `Date` Can this either be 'Any' or an option to add a type? Current issue means that we are unable to see this work with passing in a non `Date` value for example a `String`

",,
1616738517,2170,Discriminated union of another discriminated union,"Consider this use case where I have a requirement to make a validation schema for a complex form. User can either choose to fill the details of the form manually or upload a csv instead of filling the form.

```typescript
import { z } from ""zod"";

const SolarEnergySchema = z.object({
  type: z.literal(""Solar""),
  solarField1: z.string(),
  solarField2: z.string(),
  uploadCsv: z.literal(false)
});

const WindEnergySchema = z.object({
  type: z.literal(""Wind""),
  windField1: z.string(),
  windField2: z.string(),
  uploadCsv: z.literal(false)
});

const WaterEnergySchema = z.object({
  type: z.literal(""Water""),
  waterField1: z.string(),
  waterField2: z.string(),
  uploadCsv: z.literal(false)
});

const EnergyUnionSchema = z.discriminatedUnion(""type"", [
  SolarEnergySchema,
  WindEnergySchema,
  WaterEnergySchema
]);

const CSVSchema = z.object({
  uploadCsv: z.literal(true),
  csvFile: z.instanceof(File)
});

// Form Fields can be either of type EnergyUnionSchema or CSVSchema
const FormSchema = z.discriminatedUnion(""uploadCsv"", [
  EnergyUnionSchema, // type error
  CSVSchema
]);
```

The form itself is complex and has dependent fields based on a `Select` input for which I can make a discriminated union with the value of `Select` being the discriminator. Now I have a discriminated zod union which I want to combine with a schema for uploading the csv file but I when trying to do that I get these type errors. How do I achieve my required schema for this use case? I have attached a sandbox link with a simplified version of my schema requirements 

Sandbox link: https://codesandbox.io/s/weathered-darkness-6okw7n?file=/src/index.ts

I have tried using union instead of discriminated union but that doesn't work for my use case because I have using react-hook-form with zod as resolver. If I mark `upload` option to be true, I still get errors reported for the form details even though the user doesn't need to fill them. Ideally, if the `upload` option is true, other form fields should not be validated at all",,
1615740091,2168,"`z.enum().extract()`, and `z.enum().exclude()` should take variadic args","Before:
```ts
z.enum( [ 'foo', 'bar', 'baz' ] ).extract( [ 'foo', 'bar' ] )
```

After:
```ts
z.enum( [ 'foo', 'bar', 'baz' ] ).extract( 'foo', 'bar' )
```

I think this looks a lot cleaner, but I'm not sure of the implications for typescript. Any thoughts?",,
1615299282,2165,Zod incorrectly throws schema validation error when correct input passed.,"I am running zod on a production api, I have a global catch that if the application experiences an unrecoverable error it sends me an email. This morning I got an email with a zod error, however when I pulled google's stack driver logging I can see that the 'string' zod is complaining about is indeed a number. 99% of the calls to this api go through. This is concerning as this presents some unpredictable behavior from zod.


Input:
```ts
{
    dealUrl: 'https://access.booksi.com/bilmar-beach-resort',
    destination: 'St Pete Beach, Florida',
    guest: {
        address: 'Redacted',
        city: 'Lexington',
        country: 'United States',
        countryCode: 1,
        dateOfBirth: 'Redacted',
        email: 'Redacted',
        firstName: 'Sandra',
        lastName: 'Redactd',
        maritalStatus: 'Co-Hab',
        phone: 'Redacted',
        postalCode: 'Redacted',
        resID: {
            number: 509902,
        },
        spouseName: 'Redacted',
        stateSlashRegion: 'Redacted',
        street1: 'Redacted',
    },
    hotel: 'Bilmar Beach Resorts',
    requestedDates: {
        checkin: '04/24/2023',
        checkout: '04/28/2023',
    },
    roomType: 'Standard Room, Deluxe Studio',
}
```

schema: 

```ts
export const dateRequestSchema = z.object({
  hotel: z.string(),
  destination: z.string(),
  roomType: z.string(),
  requestedDates: z.object({
    checkin: z.string().regex(/\d\d\/\d\d\/\d\d\d\d/),
    checkout: z.string().regex(/\d\d\/\d\d\/\d\d\d\d/),
  }),
  dealUrl: z.string(),
  guest: z.object({
    resID: z.object({
      number: z.number(),
    }),
    phone: z.number(),
    email: z.string().email().optional(),
    address: z.string().optional(),
    firstName: z.string(),
    lastName: z.string(),
    spouseName: z.string().optional(),
    countryCode: z.number(),
    dateOfBirth:z.string().regex(/\d\d\/\d\d\/\d\d\d\d/), 
    maritalStatus: z.string(),
    street1: z.string().optional(),
    city: z.string().optional(),
    stateSlashRegion: z.string().optional(),
    postalCode: z.string().optional(),
    country: z.string().optional(),
  }),
})
```


output:

```ts
[
  {
    ""code"": ""invalid_type"",
    ""expected"": ""number"",
    ""received"": ""string"",
    ""path"": [
      ""guest"",
      ""resID"",
      ""number""
    ],
    ""message"": ""Expected number, received string""
  }
]
```",,
1614334825,2163,"Typecheck causes ""heap out of memory"" error ","`zod: 3.21.4`
`typescript: 4.9.5`

Running `tsc --noEmit` on a project that uses `zod` causes a ""JavaScript heap out of memory"" error.

This seems to only be an issue with zod `3.21.4`. Downgrading to `3.21.3` resolves it.

Sorry I don't have time to create a reproduction at the moment.",,
1614141017,2162,`z.input` is lost with `.catch(someValue)`,"When using `.catch`, I can no longer infer input value.
[reproduction](https://codesandbox.io/s/zod-catch-input-infer-yb0wo6) 

```ts
const schema = z.string().catch('String value')
// type is `undefined`, it should be `string`
type Input = z.input<typeof schema>
```",,
1613014619,2158,strictNullChecks=false makes z.object() properties optional,"Hi!

Turning off strictNullChecks in compilerOptions makes all object properties optional.

tsc -v: 4.9.5

tsconfig:
```ts
{
  ""compilerOptions"": {
    ""strictNullChecks"": false,
    ""strict"": true,
  }
}
```
**Example:**

```ts
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});

type Dog = z.infer<typeof Dog>;
```

**Expected result:**
// equivalent to:
```ts
type Dog = {
  name: string;
  age: number;
};
```

**Actual result:**
// equivalent to:
```ts
type Dog = {
  name?: string;
  age?: number;
};
```",,
1612695002,2155,custom error message causes typeError,"using zod v3.21.3

this code causes typeError, which is not wrong with previous version(v3.20.6).
```ts
const px =
  z.custom <
  `${number}px` >
  ((val) => /^\d+px$/.test(val as string), ""custom error message"");
```

error message
```
Argument of type 'string' is not assignable to parameter of type 'CustomParams | ((input: any) => CustomParams)'
```

here is my code sandbox link.
https://codesandbox.io/s/upbeat-williams-scfj81?file=/src/index.ts",,
1612595326,2154,False positive for .email() validation with sub-domain present?,"I've come across what I believe to be some false positives with the string `.email()` validation, where it doesn't appear to like subdomains. Here is a simple repro:
```
import { z } from 'zod';

const data = [
  'me@z.com',
  'me@y.z.com',
  'me@z.co.jp',
  'me@y.z.co.jp',
];

for (const email of data) {
  console.log(z.string().email().safeParse(email));
}
```
which produces:
```
{ success: true, data: 'me@z.com' }
{ success: false, error: [Getter] }
{ success: true, data: 'me@z.co.jp' }
{ success: false, error: [Getter] }
```
This is flagging up validation errors in my project for real email addresses resembling the 4th entry in the above repro.
I can see from the code that this behavior is driven by a rather formidable looking regexp; please could you clarify - is a validation failure on an address such as `me@y.z.co.jp` intentional? Thanks!",,
1612460247,2153,Inconsistent typing of `parse` result when using generic schema types,"Following on from https://github.com/colinhacks/zod/issues/2146
I'm still having issues getting return values of functions that accept generic schemas to work right.

It now works perfectly if I'm nesting the schema inside a new schema. But if I'm simply using the schema as-is, the result type doesn't get inferred and gets typed as `any`.

https://tsplay.dev/mZ1zJN

```ts
import { z } from 'zod'

const zSchema = z.object({
  name: z.string()
})

function validate<TSchema extends z.ZodTypeAny>(
  thing: any,
  schema: TSchema,
) {
  return schema.parse(thing)
}

// typed as any
const result = validate({ name: ""zoddy"" }, zSchema)

function validate2<TSchema extends z.ZodTypeAny>(
  thing: any,
  schema: TSchema,
) {
  const nested = z.object({
    nested: schema
  })
  return nested.parse(thing)
}

// typed as { nested: { name: string; } }
const result2 = validate2({ nested: { name: ""zoddy"" }}, zSchema)
```",,
1612240833,2151,Use _id with own string,"Sorry to ask here but wondered how to setup my User object with my own string as the _id using TS:
**users.model.ts**
```ts
import { db } from './../../../db';
import * as z from 'zod';
import { WithId } from 'mongodb';

export const User = z.object({
    email: z.string().email(),
    forename: z.string().min(3),
    surname: z.string().min(3),
    picture: z.string(),
    createdAt: z.date(),
    updatedAt: z.date(),
    _id: z.string(),
    role: z.string().default('user')
});

export type User = z.infer<typeof User>;
export type UserWithId = WithId<User>;
export const Users = db.collection<User>('users');
```
Seems fine but when I use FindOne on the _id field it wants an ObjectId

**user.controller.ts**
```ts
import { User, Users, UserWithId } from ""./users.model"";
const user = await Users.findOne({ _id: new ObjectId(req.params.id) });
```
Which obviously it can't do to a rrq.param.id string like ""MyUserIDIsAString""

Any help appreciated",,
1610393390,2146,Can't generically compose + transform schema without type error,"Say I want to do something like this:

https://tsplay.dev/mq9bjm
```ts
import { z } from 'zod'

async function stripOuter<TData extends z.ZodTypeAny>(schema: TData, url: string): Promise<TData> {
  const zStrippedResponse = z
    .object({
      topLevelKey: schema,
    })
    .transform(data => {
      return data.topLevelKey
      //     ^?
    })
  
  return fetch(url)
    .then(response => response.json())
    .then(data => zStrippedResponse.parse(data))
}
```
I get the following type error:
```ts
Property 'topLevelKey' does not exist on type '{ [k in keyof baseObjectOutputType<{ topLevelKey: TData; }>]: baseObjectOutputType<{ topLevelKey: TData; }>[k]; }'.
```

Is this something I should be able to do? Any pointers where I'm going wrong?",,
1609879080,2142,Zod 3.20 and TS 4.5+ Causes tsserver High CPU,"The combination of Zod 3.20 and TS 4.5+ is causing my project tsserver to have considerable slow down and degrades the developer experience.

Other seem to be having the same issues: https://stackoverflow.com/questions/74881472/slow-typescript-autocompletion-in-vs-code-for-zod",,
1608986726,2135,Make `z.object().passthrough()` transform infered type,"When you are using the `passthrough` function on an object schema, you are effectively affecting the result of the `parse function and allow it to return additional keys.
However, the `z.infer` type utils doesn't reflect it

Indeed, the 2 following schemas return the same infered type

```ts

const schema1 = z.object({ foo: z.string() });
const schema2 = z.object({ foo: z.string() }).passthrough();

type Schema1 = z.infer<typeof schema1>
// Schema1 = { foo: string; }

type Schema2 = z.infer<typeof schema2>
// Schema2 = { foo: string; }

```

While there is a difference in the return of `parse`

```ts

const result1 = schema1.parse({ foo: 'test', bar: 'test' })
// result1 = { foo: 'test' };

const result2 = schema2.parse({ foo: 'test', bar: 'test' })
// result2 = { foo: 'test',  bar: 'test };

```

I think it would be useful to change the behaviour of `z.infer` (and thus the return type of the `parse` function) to reflect this difference.
For example:

```ts

const schema = z.object({ foo: z.string() }).passthrough();

type Schema = z.infer<typeof schema>
// Schema = { foo: string; [key: string | number | symbol]?: unknown; }

```",,
1608794872,2133,Strict `z.tuple(...)`,"Can we have the equivalent of `z.object(...).strict()` but for tuples? Currently the tuple type is inferred as `[A, B, ...unknown[]]` which does not match `[A, B]`(TypeScript  4.9.4). Using `z.tuple([zodA, zodB]).rest(z.never())` does not solve the problem.",,
1607630877,2131,Inverse of `z.infer`?,"I am not looking to generate dynamic code from static code like in #53. `z.infer` goes from `z.ZodType` to ""unwrapped"" TypeScript types. How do you implement the inverse? I tried the following but does not seem to work:

```
X extends z.infer<infer Y> ? Y : never
```",,
1607600893,2129,"Convenience refinements for ZodEnum, ZodNativeEnum","I have a Zod native enum:
```ts
enum HttpMethod {
  DELETE = 'DELETE'
  GET = 'GET'
  HEAD = 'HEAD'
  OPTIONS = 'OPTIONS'
  POST = 'POST'
  PUT = 'PUT'
}

const httpMethod = z.nativeEnum(HttpMethod)
```

And then I use that in another zod parser:
```ts
const getRequest = z.object({
  method: z.literal(HttpMethod.GET)
})
```

This works fine, but it would be nice to be able to get a version of the `httpMethod` parser that only accepts `'GET'`. I can do it with a refinement:
```ts
const getRequest = z.object({
  method: httpMethod.refine(m => m === HttpMethod.GET)
})
```

I was just hoping for something shorter and more expressive, like
```ts
const getRequest = z.object({
  method: httpMethod.GET
})
```
",,
1607486244,2128,Suggestion: Alternate name alias for .catch(),"For those of us using strict linting, `.catch()` on anything means a promise catch clause... except for when it comes to `zod`. This can result in a lot of false-positive linting results.

It would be useful if there was also an unambiguously non-promise-related alternate name to use for this method, like `.fallbackValue()`.",,
1605663247,2124,`z.enum()` breaks if you pass it an actual enum or array created by destructuring enum using Object.values()`,"This can't possibly be how Zod is designed to handle enum validation...

I would have thought this would work:

```ts
import { z } from 'zod';

enum PizzaType {
  Canadian = 'Canadian',
  Cheese = 'Cheese',
  Hawaiian = 'Hawaiian',
  MeatLovers = 'Meat Lovers',
  Pepperoni = 'Pepperoni',
  Vegetarian = 'Vegetarian',
}

const orderSchema = z.object({
  id: z.number(),
  type: z.enum(PizzaType)
})

const order = {
  id: 1,
  type: 'Canadian'
}

orderSchema.safeParse(order)
```

Looks good to me. Logical. Simple. Should definitely work. Right?

```bash
error TS2769: No overload matches this call.
      Overload 1 of 2, '(values: readonly [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Overload 2 of 2, '(values: [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type '[string, ...string[]]'.

    34     .enum(PizzaType)
                  ~~~~~~~
```

Okay, well that's weird. I guess I'll just do `Object.values(PizzaType)`?

```ts
const orderSchema = z.object({
  id: z.number(),
  type: z.enum(Object.values(PizzaType))
})
```

```bash
error TS2769: No overload matches this call.
      Overload 1 of 2, '(values: readonly [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Overload 2 of 2, '(values: [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type '[string, ...string[]]'.

    34     .enum(Object.values(PizzaType))
                  ~~~~~~~~~~~~~~~~~
```

Uh, okay... How about destructuring into a new array of strings.

```ts
const orderSchema = z.object({
  id: z.number(),
  type: z.enum([...Object.values(PizzaType)])
})
```

```bash
error TS2769: No overload matches this call.
      Overload 1 of 2, '(values: readonly [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Overload 2 of 2, '(values: [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type '[string, ...string[]]'.

    34     .enum([...Object.values(PizzaType)])
                  ~~~~~~~~~~~~~~~~~
```

Okay, well, I don't know how much uglier I need to get... I mean this would be even uglier, but I guess I could try:

```ts
const orderSchema = z.object({
  id: z.number(),
  type: z.enum([
      PizzaType.Canadian,
      PizzaType.Cheese,
      PizzaType.Hawaiian,
      PizzaType.MeatLovers,
      PizzaType.Pepperoni,
      PizzaType.Vegetarian,
    ]
})
```

```bash
✅ Yup! Looks good to me!
```

WHY, ZOD!? WHY!? 😭",,
1605326764,2122,UUID validation fails,"Using Zod 3.20.6.

I have a guid that doesn't pass validation. Unit tests:

```
import { z } from 'zod';

describe('Validation Tests', () => {
  // f4405c78-1a39-4d59-9d8a-7e56d5e13294
  // 852e395d-693e-ed11-809a-c971856d9437

  it('should succeed, correctly', async () => {
    const schema = z.object({
      value: z.string().trim().uuid(),
    });
    const parsed = schema.safeParse({ value: 'f4405c78-1a39-4d59-9d8a-7e56d5e13294' });
    expect(parsed.success).toStrictEqual(true);
  });

  it('should succeed, but does not', async () => {
    const schema = z.object({
      value: z.string().trim().uuid(),
    });
    const parsed = schema.safeParse({ value: '852e395d-693e-ed11-809a-c971856d9437' });
    expect(parsed.success).toStrictEqual(true);
  });
});
```
",,
1605170684,2121,z.discriminatordUnion can't handle Unions,"`z.discriminatordUnion()` can't handle `z.union()`

```ts
const baseAttribute = const baseAttribute = z.object({
  name: nameSchema,
  code: z.string(),
});
const linkAttribute = baseAttribute.extend({
  type: z.literal('Link'),
  options: z.object({
    code: z.string(),
  }),
});
const otherAttribute = baseAttribute.extend({
  type: z.union([
    z.literal('Time'),
    z.literal('GeoJson'),
    z.literal('Boolean'),
  ]),
});

export const attributeSchema = z.discriminatedUnion('type', [linkAttribute, otherAttribute]);
```

I've just seen that you want to deprecate discriminatedUnion from #2109 

But I was hoping this would be a super quick fix.
```ts
else if (type instanceof ZodUnion) {
  const accumulator = [];
  for ( const option of type.options ) {
    const types = getDiscriminator(option);
    if (types === null) {
      return null; // nested is of unknown type.
    }
    accumulator.push(...types);
  }
  return accumulator;
}
```",,
1601888293,2113,refine() function gets called even when parser already failed,"Using version 3.20.6

In certain scenarios, refine gets called even when the parser has already failed.   It seems like including a z.custom() can trigger this.

What's worse is that the type flowing into the refine's function (x) is different than what typescript thinks it is

Here's a minimal example:
```Typescript
const example1 = z
	.custom<number>(x => typeof x === 'number')
	.transform(x => String(x))
	.refine(x => {
		console.log(typeof x); // prints 'Object'
		console.log(""I get called even though I shouldn't!!!"");
		return true;
	})
	.safeParse({}); //will fail because it is not a number

console.log(example1.success); // false (like it should be)
```
And here's a more complex example with the same issue
```Typescript
const example2 = z
	.union([z.number(), z.string(), z.custom<number>(x => typeof x === 'number')])
	.refine(() => true)
	.pipe(z.any())
	.or(z.date())
	.pipe(z.any())
	.refine(x => {
		console.log(""I get called even though I shouldn't!!!!!!!!!"");
		return true;
	})
	.safeParse(true); // will fail immediately because it's a bool
```

As a work-around, using `.transform(x,ctx)=>...) ` approach to validate seems to work.",,
1601707025,2110,Recursive type with fixed and arbitrary keys causes type error.,"I looked through the old issues and the closest I could find was [this](https://github.com/colinhacks/zod/issues/1436), but I confirmed that the fix does not apply here because I'm already in strict mode.

Version info:
**Typescript**: ""^4.9.4""
**Zod**: ""^3.20.2""

Verified that `""strict"": true` is set in my tsconfig.json.

# The issue

I am trying to make a nested tree of arbitrary string keys where only the _leaf_ nodes have a defined structure.

```typescript
const DataFieldSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  required: z.boolean().optional().default(false),
  type: z.string().optional().default(""string""),
});
type DataField = z.infer<typeof DataFieldSchema>;

type Nested = DataField | { [key: string]: Nested };
const NestedDataFieldSchema: z.ZodType<Nested> = z.lazy(() =>
  z.union([DataFieldSchema, z.record(NestedDataFieldSchema)])
);
```
I verified that the `Nested` type permits the structure I'm looking for.
```typescript
const x: Nested = {
  ANY: {
    FIELD: {
      description: ""foo"",
      name: ""bar"",
      type: ""baz"",
      required: true,
    },
  },
};
// satisfies the type
```

However, NestedDataFieldSchema throws the following compilation error:
```
Type 'ZodLazy<ZodUnion<[ZodObject<{ name: ZodString; description: ZodOptional<ZodString>; required: ZodDefault<ZodOptional<ZodBoolean>>; type: ZodDefault<...>; enumValues: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodRecord<...>]>>' is not assignable to type 'ZodType<Nested, ZodTypeDef, Nested>'.
  Types of property '_input' are incompatible.
    Type '{ description?: string | undefined; type?: string | undefined; required?: boolean | undefined; enumValues?: { value: string; description: string; }[] | undefined; name: string; } | Record<string, Nested>' is not assignable to type 'Nested'.
      Type '{ description?: string | undefined; type?: string | undefined; required?: boolean | undefined; enumValues?: { value: string; description: string; }[] | undefined; name: string; }' is not assignable to type 'Nested'.
        Type '{ description?: string | undefined; type?: string | undefined; required?: boolean | undefined; enumValues?: { value: string; description: string; }[] | undefined; name: string; }' is not assignable to type '{ [key: string]: Nested; }'.
          Property 'description' is incompatible with index signature.
            Type 'string' is not assignable to type 'Nested'.
```

It seems to be an issue with the fact that DataField is a complex type, since when you use only primitive values at the leaf, it works fine (such as in the JSON example in the readme). My best guess is that there's an issue with it parsing arbitrary keys alongside well-defined keys.

The only workaround I've been able to find is to change the Nested type to 
```typescript 
type Nested = DataField | { [key: string]: Nested | string | boolean}
```
but this means losing the type guards around the defined keys, at which point I might as well just permit arbitrary JSON.

Am I just implementing this incorrectly? Any help on this would be appreciated, as it's a pretty serious hindrance to being able to rewrite some of the configuration JSON in our project.
",,
1600929378,2106,Deprecating `z.discriminatedUnion`?,"Superceded by https://github.com/colinhacks/zod/issues/3407

---

I'm planning to deprecate `z.discriminatedUnion` in favor of a ""switch"" API that's cleaner and more generalizable. You can dynamically ""switch"" between multiple schemas at parse-time based on the input.

```ts
const schema = z.switch(()=>{
  return Math.random() ? z.string() : z.number()
});
```

I expand more on the `z.switch` API later. Let's talk about `z.discriminatedUnion`.

## Why

 `z.union` naively tries each union element until parsing succeeds. That's slow and bad. Zod needed some solution.

`z.discriminatedUnion` was a mistake. The API was good but I had reservations about the implementation. It required fiddly recursive logic to exrtract a literal discriminator key from each union element.

<img width=""584"" alt=""Screenshot 2023-02-27 at 2 07 02 AM"" src=""https://user-images.githubusercontent.com/3084745/221534750-4652a10c-0c6d-4c62-a06b-918ca112c250.png"">

It's a bad sign when a method or class requires weird recursive traversal of other schemas. For starters, Zod is designed to be *subclassable*. Users can theoretically subclass `ZodType` to implement custom schema types. But logic like this `instanceof` switch statement don't and can't account for any user-land schema types. 

But the main problem is just that this kind of pattern is bad and introduces a lot of edge cases. It means that only certain kinds of schemas are allowed as discriminators, and others will fail in unexpected ways. There are now dozens of issues that have been opened regarding these various edge cases. The PRs attempting to solve this problem are irredeemably complex and introduce even more edge cases.

- https://github.com/colinhacks/zod/issues/1773
- https://github.com/colinhacks/zod/issues/1667
- https://github.com/colinhacks/zod/issues/1384
- https://github.com/colinhacks/zod/issues/1757
- https://github.com/colinhacks/zod/issues/1504
- https://github.com/colinhacks/zod/issues/1136
- https://github.com/colinhacks/zod/issues/1477
- https://github.com/colinhacks/zod/issues/1424
- https://github.com/colinhacks/zod/pull/1213
- https://github.com/colinhacks/zod/issues/1490
- https://github.com/colinhacks/zod/issues/1181
- https://github.com/colinhacks/zod/issues/1075
- https://github.com/colinhacks/zod/issues/1444
- https://github.com/colinhacks/zod/issues/1868
- https://github.com/colinhacks/zod/issues/1878


> The `.deepPartial` API has this same problem. I'm deprecating it for the same reason.

Many of those issues are asking for non-literal discriminator types:

```ts
type MyUnion = 
  | { type: ""a"", value: string }
  | { type: ""b"", value: string }
  | { type: ""c"", value: string }
  | { type: string, value: string }
  | { type: null, value: string }
  | { type: undefined, value: string }
  | { type: MyEnum, value: string }
  | { type: { nested: string }, value: string }
  | { type: number[], value: string };
```

Imagine each of those elements are represented with Zod schemas. Zod would need to extract the `type` field from each of these elements and find a way to match the incoming `input.type` against those options. In the general case, Zod would extract the `type` field from the shape of each component `ZodObject` and check `input.type` against those schemas until a match is found. At that point, we're back to doing a parse operation for each element of the union, which is what `z.discriminatedUnion` is supposed to avoid doing. (It's still doing less work than the naive `z.union` but still.)

Another issue is composability. The existing API expects the second argument to be an array of `ZodObject` schemas.

```ts
z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""a""), value: z.string() }),
  z.object({ type: z.literal(""b""), value: z.string() }),
])
```

This isn't composable, in that you can't nest discriminated unions or add additional members. 

```ts
const ab = z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""a""), value: z.string() }),
  z.object({ type: z.literal(""b""), value: z.string() }),
]);

const abc = z.discriminatedUnion(""type"", [
  ab,
  z.object({ type: z.literal(""c""), value: z.string() }),
]);
```

- https://github.com/colinhacks/zod/issues/1618
- https://github.com/colinhacks/zod/issues/1610
- https://github.com/colinhacks/zod/issues/1884

Yes, Zod could support both `(ZodObject | ZodDiscriminatedUnion)[]` as union members, but that requires additional messy logic that reflects a more fundamental problem with the API. It also makes increasingly difficult to enforce typesafety on the union - it's important that all union elements have a `type` property, otherwise the union is no longer discriminable.

## Replacement: `z.switch`

```ts
const schema = z.switch(input => {
  return (typeof input) === ""string"" ? z.string() : z.number();
})

schema.parse(""whatever""); // string | number
```

A discriminated union looks like this:

```ts
const schema = z.switch((input) => {
  switch(input.key){
    case ""a"":
      return z.object({ key: z.literal(""a""), value: z.string() })
    case ""b"":
      return z.object({ key: z.literal(""b""), value: z.number() })
    default:
      return z.never()
  }
});
schema.parse({ /* data */ });
// { key: 'a', value: 'asdf' } | { key: 'b', value: number }
```

Ultimately the `z.switch` API is a far more explicit and generalizable API. Zod doesn't do any special handling. The user specifies exactly how the `input` will be used to select the schema. `z.switch()` accepts a function. The `ResultType` of that function is inferred. It will be the union of the schema types returned along all code paths in the function. For instance:

```ts
const schema = z.switch(()=>{
  return Math.random() ? z.string() : z.number()
});
```

Zod sees that the return type of the switcher function is `ZodString | ZodNumber`. The result of the `z.switch` is `ZodSwitch<ZodString | ZodNumber>`. The result of `schema.parse(...)` is `string | number`.

You can represent discriminated unions explicitly like this:

```ts
const schema = z.switch((input) => {
  switch(input.key){
    case ""a"":
      return z.object({ key: z.literal(""a""), value: z.string() })
    case ""b"":
      return z.object({ key: z.literal(""b""), value: z.number() })
    default:
      return z.never()
  }
});
schema.parse({ /* data */ });
// { key: 'a', value: 'asdf' } | { key: 'b', value: number }
```

This can be written in a more condensed form like so:

```ts
const schema = z.switch((input) => ({
  a: z.object({ key: z.literal(""a""), value: z.string() }),
  b: z.object({ key: z.literal(""b""), value: z.number() }),
}[input.key as string]));
  
schema.parse({ key: 'a', value: 'asdf' });
// { key: 'a', value: 'asdf' } | { key: 'b', value: number }
```

It's marginally more verbose. It's also explicit, closes 30+ issues, eliminates a lot of hairy logic, and lets Zod represent the full scope of TypeScript's type system. `z.discrimininatedUnion` is too fragile and causes too much confusion so it needs to go.",,
1599965691,2104,Zod + React-hook-form + lingui,"Wondering if anyone has come across the following issue:
I am using `zod` & `react-hook-form` & `lingui`.

I would like to display a translated error message to the user and not sure what is the best approach.
I would like to keep the schema outside of React if possible, but would still like to be able to supply detailed error messages.
The issue is, once react-hook-form takes in the information from `zod`. A lot of the information disappears.
Example:
```tsx
const myFormSchema = z.object({
  name: z.string().min(3)
})

function MyForm(){
  const formMethods = useForm({ resolver: zodResolver(myFormSchema) })
  ...
}
```

The error  I would get from react-hook-form here is the following:
```{ type: ""too_short"", message: ""ZOD's DEFAULT ERROR MESSAGE HERE"", ref: (THE INPUT REF HERE) }```
Which is not enough detail to generate the translated message.

So I end up doing this:
```tsx
function MyForm(){
  const t = useTrans()
  const myFormSchema = z.object({
    name: z.string().min(3, t(""form_errors.min_length"", { label: t(`name`), min: 3 }))
  })
  const formMethods = useForm({ resolver: zodResolver(myFormSchema) })
  ...
}
```

Which I feel, defeats the purpose of `zod` because I would like to auto-infer the type of the schema and also reuse it. 
But in this state, it doesn't exist outside of React.

Any advice? Is there something I'm doing wrong?",,
1599851035,2101,Typescript Errors for flattened error object,"I am using SvelteKit and it's form actions. When my server.ts file returns a fail, SvelteKit puts the result into the `ActionData` object, which it assigns for you

<img width=""315"" alt=""image"" src=""https://user-images.githubusercontent.com/52610563/221380911-9576c072-d512-40f6-bddd-9db56bf7d487.png"">

I'm kicking back Zod validation errors:
<img width=""469"" alt=""image"" src=""https://user-images.githubusercontent.com/52610563/221380864-acbda672-d926-49ae-bffa-450b6cab9d65.png"">

Everything actually works, so this could be deemed minor, but Typescript doesn't like the form.errors object
<img width=""1291"" alt=""image"" src=""https://user-images.githubusercontent.com/52610563/221380813-6009339c-4677-4ebe-90ef-8a9d93178283.png"">

Reading the docs, I see the Extract type signature section, but not being a native TS guy, I'm getting a touch lost with it. Can anyone assist with how to get TS happy?
",,
1597452582,2093,Can I use Zod in TypeScript Older versions?,"I'm working in a project running in `node 12.22` and `TypeScript ^3.7.4`

in the readme it has specified `TypeScript 4.5+`, but I assume that is for the current version of Zod. Is there any release where I can use the tool in this version of typescript?",,
1596013720,2088,Min and max use spaces and characters.,"I have recently found out that When `z.string().max()` is used it also counts the Characters and spaces within each string. This is not good at all. Spaces are not characters they are just nothing. This is not a good idea I thought it would just count the actual characters only. This should not be done at all. The length of a string and how many characters are written are different things. Please make it so that spaces are ignored when the string is being evaluated or at least create an ignore spaces method.   


To prove that this is true I have decided to create a repo to showcase this problem https://stackblitz.com/edit/typescript-urjdak. It's a repo that uses random text to write up to 300 words. 

In order to test out my thesis all you have to do is remove one of the spaces and the test that I have created will just pass. 

If you want to understand what I'm talking about even more go to this site [Word Count Jet](https://www.wordcountjet.com/)
Then paste the below text in there

```
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Eu turpis egestas pretium aenean pharetra magna ac. Nisi vitae suscipit tellus mauris a. Vel risus commodo viverra maecenas accumsan lacus vel. NKEDnasjns aaeldm3ewo;sn ypkqw lie. 
```


 ",,
1595795464,2086,Implement TypeScript generic functions.,"Since zod tries to resemble TypeScripts API and its types, I think it would be awesome if some built in utility typescript functions were available in zod too

Here are a few examples how these generic functions would work

```ts
const eventSchema = z.union([
  z.object({
    type: ""success"",
    data: z.any(),
  }),
  z.object({
    type: ""error"",
    message: z.string(),
  }),
]);

z.extract(eventSchema, z.object({ type: z.literal(""error"") })); // result: z.object({ type: ""error"", message: z.string() });
```

```ts
z.required(
  z.object({
    foo: z.string().optional(),
    bar: z.string().optional(),
  })
);

/**
 * result:
 *
 * z.object({
 *   foo: z.string(),
 *   bar: z.string()
 * })
 */
```",,
1595599358,2085,export 'z' (imported as 'z') was not found in 'zod' (module has no exports),"With webpack. All I'm doing is:

```ts
import { z } from 'zod'
```

and webpack is not able to import it

```
WARNING in ./myFile.ts 56:10-18
export 'z' (imported as 'z') was not found in 'zod' (module has no exports)
```",,
1595396401,2084,"Feature Request : A ""create a schema according to this type"" helper","Hello there,

What do you think about this discussion?

If this is something you are interested in, what's the direction to add this feature?


### Discussed in https://github.com/colinhacks/zod/discussions/1928

<div type='discussions-op-text'>

<sup>Originally posted by **rphlmr** January 24, 2023</sup>
Hello,

What about adding a helper that takes a type and ""forces"" you to create a schema according to this type?

Can be useful, for example, to create a schema derived from a Prisma Model.

```ts
type Implements<Model> = {
  [key in keyof Model]-?: undefined extends Model[key]
    ? null extends Model[key]
      ? z.ZodNullableType<z.ZodOptionalType<z.ZodType<Model[key]>>>
      : z.ZodOptionalType<z.ZodType<Model[key]>>
    : null extends Model[key]
    ? z.ZodNullableType<z.ZodType<Model[key]>>
    : z.ZodType<Model[key]>;
};

export function implement<Model = never>() {
  return {
    with: <
      Schema extends Implements<Model> & {
        [unknownKey in Exclude<keyof Schema, keyof Model>]: never;
      }
    >(
      schema: Schema
    ) => z.object(schema),
  };
}

// usage
export type UserModel = {
  id: string
  email: string | null
  name: string
  firstName: string
  createdAt: Date
}

export const UserCreateSchema = implement<Omit<UserModel, ""createdAt"" | ""id"">>().with({
  email: z.string().email().nullable(),
  name: z.string(),
  firstName: z.string(),
});

export type UserCreatePayload = z.infer<typeof UserCreateSchema>
```

This is maybe not perfect, but I use this on my projects and I'm pretty happy with It.

Force to put `nullable` `optional` or `nullish` when Model requires it.
Unknown properties are forbidden and cause a TS error.

Discussed here : https://github.com/colinhacks/zod/issues/372#issuecomment-830094773</div>",,
1593935551,2077,`z.enum` with generic array is breaking `z.object` inference ,"Source:
https://stackoverflow.com/questions/75523855/zod-enum-with-generic-array

I changed the source code to use the exact generics `z.enum` uses and it still didn't work.
```typescript
import { z } from 'zod';

function objectWithGenericEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
    options: T
) {
    const enumValidator = z.enum(options);
    const a =  z.object({
        data: enumValidator,
    });
    return a.transform((v) => v.data); // Property 'data' does not exist on type '{ [k in keyof baseObjectOutputType<{ data: ZodEnum<Writeable<T>>; }>]: baseObjectOutputType<{ data: ZodEnum<Writeable<T>>; }>[k]; }'.(2339)
}
```

If we instead use this line, the data property is present.

```typescript
...
    const enumValidator = z.enum(['fish', 'sushi']);
...
// data is now defined
```
",,
1593800508,2076,Recursive types doc example stop working with .brand(),"If there is a branded schema in the shape, [the recursive types doc example](https://zod.dev/?id=recursive-types) stop working.
``` ts
const baseCategorySchema = z.object({
  - name: z.string(),
  + name: z.string().brand(""CategoryName""),
});

type Category = z.infer<typeof baseCategorySchema> & {
  subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
  subcategories: z.lazy(() => categorySchema.array()),
});
```
categorySchema has TS error:
TS2322: Type 'ZodObject<extendShape<{ name: ZodBranded<ZodString, ""CategoryName"">; }, { subcategories: ZodLazy<ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">>; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'.
   Types of property '_input' are incompatible.
     Type '{ name: string; subcategories: Category[]; }' is not assignable to type 'Category'. 
      Type '{ name: string; subcategories: Category[]; }' is not assignable to type '{ name: string & BRAND<""CategoryName"">; }'.         Types of property 'name' are incompatible.
           Type 'string' is not assignable to type 'string & BRAND<""CategoryName"">'.
             Type 'string' is not assignable to type 'BRAND<""CategoryName"">'.

Thanks.",,
1593616125,2075,Typing generic functions (like a transformer) correctly,"Given the following function type: 
ChunkTransformFunc<P, R> = (chunk: P) => R

I want to be able to express: 

1. The Param should be of type P 
2. The Return Type should be of type R (normally unrelated to P) 

ChatGPT Gives me something like this: 

```ts
const ChunkTransformFuncSchema = z
  .function(z.zodTuple([z.unknown() as any]), z.unknown())
  .args(z.zodTuple([z.unknown() as any] as const))
  .transform((func) => {
    const [inputSchema, outputSchema] = z.getParsedType(func);
    return z.function(inputSchema[0], outputSchema);
  });
```

But this has some problems: 
1. z.zodTuple does not exist => rewriting to z.tuple() 
2. Then this line does not work anymore, due to readonly something somewhere: `.args(z.tuple([z.unknown() as any] as const));`

I would like to have something like a `z.generic()` function which allows a generic to be defined as input and to be retrieved as an output type for example. 
Maybe like this: 

```ts
z
.function(z.generic('P'), z.generic('R'))
.args(z.generic('P))
.returns(z.generic('R'))
```",,
1592620543,2074,Custom schema example for template literals gives type error,"In the [Custom schemas](https://github.com/colinhacks/zod#custom-schemas) section of the docs, this example is given for creating a template literal schema:
```ts
const px = z.custom<`${number}px`>((val) => /^\d+px$/.test(val));
px.parse(""100px""); // pass
px.parse(""100vw""); // fail
```

As is, this example shows an error on val being passed into test:

> `Argument of type 'unknown' is not assignable to parameter of type 'string'.`

`z.custom()` takes parameter `check?: ((data: unknown) => any) | undefined`, while `test.()` takes parameter `string: string`.

I think ideally, there should be a way to annotate  or infer the type of `data`, but that section is pretty empty.
I found two ways around the type error, one of which would be good to update the docs with:
```ts
const pxWithAs = z.custom<`${number}px`>((val) => /^\d+px$/.test(val as string));
const pxWithTemplate = z.custom<`${number}px`>((val) => /^\d+px$/.test(`${val}`));
```

[Playground link showing the error and ways around](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFA9NXAKIAeAhuADYCmWOeAFjDDABnAFy0A5sBi8ArgCMAdAGNc1FW2AA7XsyUBrIdSLFqAYiUyhMXAFohS3hxDMhFFZqtwwjOAF4UypbWIAA8AAYAJAiaMiByHFBo3mEAfAAUaQBuzGwAlH4pcNQAegA6xADU3hHUCjAcVlk5ubmU3gpgzFBCHGkARACMAAxD3n2tRXSdQq7tnd29gyOZAO7jZJNYzMBsVLRwACorEHArzACeQnBdEDKaxHDSXAk4UG4QHvDeAOpSvACCV38yECVlw4SiMTiCSSjFSGWyeQKRTKlWqtXqjUR1yuVigWnELUo7k8Pz+BycYDYzHqfgCFjBoUi0Vi8USyXSTSRvkKJXKVUYNTqDRgaWZiLQYSJQA)

I don't like either of these that much, and I'll probably be using `z.templateLiteral()` after #1786 is merged, but the docs example should be updated with whatever method is recommended to avoid the error.",,
1590963851,2070,Built-in way to coerce null to undefined,"Right now I'm doing something like this:

```typescript
const coerceNullToUndefined = <Type>(value : Type | null | undefined) : Type | undefined => {
    return value === null ? undefined : value;
};

const apiResponseSchema = z.object({
    name: z.string().nullish().transform(coerceNullToUndefined)
});
```

That makes the resulting value a little more sane; I don't have to worry about dealing with both null and undefined.

It would be awesome if it was possible to have a built-in way to do this, like:

```typescript
const apiResponseSchema = z.object({
    name: z.string().nullish().coerceNullToUndefined()
});
```",,
1590775832,2065,"When `z.infer` a `Record` with `Brand` as a key, it becomes a Partial Record.","When `z.infer` a `Record` with `Brand` as a key, it becomes a Partial Record.

With defining a Record type normally:
```ts
import { z } from ""zod"";
const zodKey = z.string().brand(""zodKey"");
type ZodKey = z.infer<typeof zodKey>;

type ZodRecord = Record<ZodKey, number>;
// type ZodRecord = {
//   [x: string & z.BRAND<""zodKey"">]: number;
// }
```

With defining a Record type with `z.infer`:
```ts
import { z } from ""zod"";
const zodKey = z.string().brand(""zodKey"");
const zodRecord = z.record(zodKey, z.number());

type ZodRecord = z.infer<typeof zodRecord>;
// type ZodRecord = {
//   [x: string & z.BRAND<""zodKey"">]: number | undefined;
// }
```

It has `undefined`.",,
1590525150,2061,"Unexpected ""Invalid literal value"" error in z.union()","Hi, First of all, thank you for creating very useful validation library.
I've faced wired(?) behavior while using z.union().
Is this bug? or if this is expected behavior how can I avoid it to show wrong errors?

# Problem
zod shows invalid literal value though it has correct value.

# Reproduction Repo
I've made a simple reproduction repo [here](https://github.com/tomohirohiratsuka/zod-union-debug)

# Reproduction Step
In the reproduction repo above...

```terminal
npm i 
```

```terminal
npm run dev
```
 1. Open [http://localhost:3000](http://localhost:3000).
 2. Click submit.
 3. It shows Invalid URL error as expected.
 4. Select ""Designer"" in Job select box.
 5. It shows, Invalid literal value, expected ""engineer""

<img width=""288"" alt=""スクリーンショット 2023-02-19 10 30 10"" src=""https://user-images.githubusercontent.com/32760882/219907250-7bd9169f-8173-40be-ba15-73adc61d1afc.png"">
<img width=""229"" alt=""スクリーンショット 2023-02-19 10 30 26"" src=""https://user-images.githubusercontent.com/32760882/219907257-d5a4b092-6095-4643-aea1-0cce1f11e4d0.png"">
<img width=""345"" alt=""スクリーンショット 2023-02-19 10 30 44"" src=""https://user-images.githubusercontent.com/32760882/219907260-40430039-a70b-4529-9173-ffda8fbf7523.png"">

# Schema
```typescript
const developmentLanguageSchema = z.union([z.literal('typescript'), z.literal('go'), z.literal('rust')])
const toolSchema = z.union([z.literal('Adobe XD'), z.literal('Figma'), z.literal('Sketch')])
const schema = z.union([
    z.object({
        job: z.literal('engineer'),
        language: developmentLanguageSchema,
        graduate: z.literal('bachelor'),
    }),
    z.object({
        job: z.literal('engineer'),
        language: developmentLanguageSchema,
        graduate: z.literal('master'),
        url: z.string().url()
    }),
    z.object({
        job: z.literal('designer'),
        tool: toolSchema,
        graduate: z.literal('bachelor'),
    }),
    z.object({
        job: z.literal('designer'),
        tool: toolSchema,
        graduate: z.literal('master'),
        url: z.string().url()
    })
])
```",,
1590517989,2060,Lazy Parsing (Feature request),"This is something I've often felt would be useful in zod.

### Use case

- I'm calling an external api
- I want to parse the data I get back, to ensure nothing unexpected happens when I consume the data
- Certain properties I need 100% of the time, others I only need in special cases.

### Example

Here's a contrived example:

```typescript
const productSchema = z.object({
  id: z.string(),
  name: z.string(),
  isAvailableInBlue: z.boolean()
});

const offerProduct = async () => {
    const res = await fetch('https://some-api/product');
    const json = await res.json();
    const product = productSchema.parse(json);
    
    if (customerRequestedProductInBlue()) {
        if (!product.isAvailableInBlue) {
          console.log(`Sorry, ${ product.name } is not available in blue`);
          return;
        }
    }
    
    console.log(`Would you like a ${ product.name } today?`)
}
```

In this case:
- I need to be 100% sure `product.name` is present, and is a string
- I only care about `product.isAvailableInBlue` if the customer actually requested a blue product

So far so good. But let's say the api maintainer changes `isAvailableInBlue` to be an integer `0` or `1` -- which is obviously a backwards-incompatible change, but that happens.

Now: my code will error out 100% of the time when I call `productSchema.parse(json)`

### The problem

In cases like this, where I have no control over the external API, obviously it's annoying when a type changes like this, and I want my code to fail rather than assuming `product.isAvailableInBlue` is a boolean.

BUT, ideally I'd like it to only fail at runtime when I try to access `product.isAvailableInBlue`. That way so long as the customer is not requesting a blue product, my code will continue to run.

That way, I still have a bug I need to go fix, but the damage is much more minimal than `productSchema.parse(json)` failing 100% of the time. Most of my customers can still complete a checkout.

### A proposed solution

What I'd love to see is something like `productSchema.lazyParse()`:

```typescript
const productSchema = z.object({
  id: z.string(),
  name: z.string(),
  isAvailableInBlue: z.boolean()
});

const offerProduct = async () => {
    const res = await fetch('https://some-api/product');
    const json = await res.json();
    const product = productSchema.lazyParse(json);
    
    if (customerRequestedProductInBlue()) {
        if (!product.isAvailableInBlue) {
          console.log(`Sorry, ${ product.name } is not available in blue`);
          return;
        }
    }
    
    console.log(`Would you like a ${ product.name } today?`)
}
```

In this model, zod will only parse the top-level `product` object to make sure it has the right shape, but it will not validate any specific value types until I actually access the property and try to use it at runtime.

This change means I get the best of both worlds: my code keeps working when it's possible to keep working, and fails with an obvious type-error when I try to access a property which could not be parsed.

Obviously this doesn't make sense to do all the time; for example if I'm parsing an api request to my own api server, I want to be able to parse it all in one go and return a 4xx error if something is incorrect. But when I'm consuming data from an external source like this, it's often helpful to only error out at the point where my code definitely can not continue to run safely.

Thoughts on this?",,
1590298092,2056,It looks like `.refine()` removes `.shape`,"Here's my example:

```typescript
const fooSchema = z.object({foo: z.string()})
type Foo = z.infer<typeof fooSchema.shape.foo>
const barSchema = z.object({bar: z.string()}).refine(({bar}) => bar.length > 0)
type Bar = z.infer<typeof barSchema.shape.bar>
```

In this case, `barSchema.shape` TypeScript complains:

```
Property 'shape' does not exist on type 'ZodEffects<ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { bar: string; }, { bar: string; }>, { bar: string; }, { bar: string; }>'.ts(2339)
```

Is this intended behaviour? Or maybe I'm using `.refine()` incorrectly?

Thanks a lot for zod, I've been a loyal fan for many years and the project has only continued to improve. It's a real treat to define schemas once and use them for both types and at runtime. 🧡 ",,
1589528693,2052,.omit() inoperative with .passthrough(),"`.omit()` doesn't do anything when using `.passthrough()`: the omitted keys are still there.

```ts
import { z } from 'zod'; // zod@3.20.6

// Our schema, just two known keys `a` and `b`
const schema = z.object({ a: z.number(), b: z.number() });

// We want to omit `b`, but preserve unknown keys
// No luck here: we get { a: 1, b: 2, x: 654 }
console.log(schema.omit({ b: true }).passthrough().parse({ a: 1, b: 2, x: 654 }));

// Still not what we want: { a: 1, b: 2, y: 286 }
console.log(schema.passthrough().omit({ b: true }).parse({ a: 1, b: 2, y: 286 }));

// Workaround for expected result: { a: 1, z: 123 }
console.log(schema.passthrough().transform(({ b, ...res }) => res).parse({ a: 1, b: 2, z: 123 }));
```

Am I doing something wrong? Am I not supposed to chain those two methods?

I understood that `.passthrough()` would just pass unknown keys, not omitted ones:
> https://www.npmjs.com/package/zod#passthrough
> By default Zod object schemas strip out unrecognized keys during parsing.
> Instead, if you want to pass through unknown keys, use `.passthrough()`.",,
1589162451,2051,using required() on an object with a nullish() attribute breaks validation and typing,"Please take a look at this code sample:
```typescript
const testCase = z
  .object({
    attributeOne: z.string(),
    attributeTwo: z.string().nullish(),
  })
  .required();

const test = testCase.parse({ attributeOne: ""Test"" });
```
`testCase.parse({ attributeOne: ""Test"" })` does not throw an error, even though I would expect it to because of the `required()` function.

These two code samples do however throw the expected error:
```typescript
const testCase = z
  .object({
    attributeOne: z.string(),
    attributeTwo: z.string().optional(),
  })
  .required();

const test = testCase.parse({ attributeOne: ""Test"" });
```
```typescript
const testCase = z
  .object({
    attributeOne: z.string(),
    attributeTwo: z.string().nullable(),
  })
  .required();

const test = testCase.parse({ attributeOne: ""Test"" });
```

Using `.optional().nullable()` in place of `.nullish()` also does not produce the expected error.

This not only breaks the validation logic of `.parse()` and `.safeParse()`, the resulting type is also incorrect.
The type of `test` in my first code sample is
```typescript
{
  attributeOne: string;
  attributeTwo: string | null;
}
```
even though `attributeTwo` is `undefined`.

Is this the correct behaviour?
 ",,
1583045314,2036,Many methods have massive compiler performance drawbacks,"I spent much of last week investigating why my work's codebase was taking 2-3 seconds to populate autocomplete or refresh code-intelligence during code changes, and after a lot of tsc tracing and replacing Zod types with `any`, I found that basically the entire time is being taken up processing Zod types - specifically those using masking (Extend, Omit, Pick) methods.

After removing all uses of masking and dropping back to Zod 3.19 on the suggestion of some comments in the issues, the codebase is now down to 1.5 seconds for autocomplete which is still a lot of time.

I've written this up in a little more detail [here](https://dev.to/nicklucas/typescript-runtime-validators-and-dx-a-type-checking-performance-analysis-of-zodsuperstructyuptypebox-5416) and have a small-scale reproduction [here](https://github.com/Nick-Lucas/gapstack/tree/main/packages/light-type-benchmarks) which was used in the benchmarks.

Eventually I do plan on a more in-depth benchmarking across a larger variety of methods, as these benchmarks are a somewhat blunt instrument, but it would be great to see type inference performance improved across the board as Zod is lagging behind the competition even in the most basic situations.",,
1580684208,2025,Support validation of relative URLs,"Using a schema of
`urlLocal: z.string().url().optional(),`

will fail validation for a relative URL such as
`/blog/blog-post-1/`

I see this in the [Zod source code](https://github.com/colinhacks/zod/blob/master/src/types.ts#L686):

```ts
} else if (check.kind === ""url"") {
  try {
    new URL(input.data);
  } catch {
```

So without a `base` parameter `URL()` will throw an exception for relative urls. The [URL()](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) documentation explains:

> If `url` is a relative URL, `base` is required, and will be used as the base URL. 
> 
> TypeError | `url` (in the case of absolute URLs) or `base + url` (in the case of relative URLs) is not a valid URL.


I'm able to work around this issue using custom validation logic via refinements:

`urlLocal: z.string().refine((val) => new URL(val, 'http://localhost')).optional(),`

But maybe this should be built-in?",,
1580640149,2024,Invalid Url when validating a MSSQLServer connection string,"I'm using zod with the t3 stack. 

The server runs the following validation on schemas.
```ts
export const serverSchema = z.object({
  DATABASE_URL: z.string().url(),
  NODE_ENV: z.enum([""development"", ""test"", ""production""]),
  NEXTAUTH_SECRET:
    process.env.NODE_ENV === ""production""
      ? z.string().min(1)
      : z.string().min(1).optional(),
  NEXTAUTH_URL: z.preprocess(
    // This makes Vercel deployments not fail if you don't set NEXTAUTH_URL
    // Since NextAuth.js automatically uses the VERCEL_URL if present.
    (str) => process.env.VERCEL_URL ?? str,
    // VERCEL_URL doesn't include `https` so it cant be validated as a URL
    process.env.VERCEL ? z.string() : z.string().url(),
  ),
  CLIENT_ID: z.string(),
});
```

My database url looks like the following:
```ts
DATABASE_URL=""sqlserver://localhost:1433;initialCatalog={MyDatabase};integratedSecurity=true;trustServerCertificate=true;""
```

This is the error that's occurring: 
❌ Invalid environment variables:
 DATABASE_URL: Invalid url

I see the code is using the new URL constructor and when I plug it in to dev tools, I get the following which may cause the error:
![image](https://user-images.githubusercontent.com/17712276/218238469-a5eaa744-3f84-4bf9-9155-2d34f2e2e009.png)

Is this intentional and should I be using some other form of validation or is this a bug?

Thank you",,
1578535256,2020,Unable to pass a zod schema to a function and have it be typed correctly by typescript,"Suppose I have a function that accepts a zod schema and runs the parse function on some data like:

```typescript
import { z, ZodTypeAny } from 'zod'

type Opts<Z extends ZodTypeAny> = {
  // ...other db opts
  schema: Z
}
export const findOne<T = any, Z extends ZodTypeAny = never> = async (opts: Opts<Z>) => {
  // ...logic to read db

  const item = await dbQuery()

  if (!item) return
  if (opts.schema) return schema.parse(item)
  return item as T
}

const User = z.object({
  id: z.string(),
  username: z.string(),
  createdAt: z.string()
})

// expect user to be of type `typeof User`
const user = await findOne({ /** opts */, schema: User })
```
I would expect all zod schemas to extend the `ZodTypeAny` type, but I get the error `Property 'received' is missing in type 'ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }' but required in type 'ZodInvalidLiteralIssue'.` when I pass the `User` schema into the function.
",,
1577907406,2017,All members in every type of a discriminated union are optional,"```typescript
const myUnion = z.discriminatedUnion(""status"", [
  z.object({ status: z.literal(""success""), data: z.string() }),
  z.object({ status: z.literal(""failed""), error: z.instanceof(Error) }),
]);


type myUnion = z.infer<typeof myUnion>
// This evaluates to
type myUnion = {
    status?: ""success"";
// ****** ^ - all members are optional
    data?: string;
} | {
    status?: ""failed"";
    error?: Error;
}
```

Tried explicitly forcing the members to be required results in the same type (i.e., all members for each discriminated union type are optional)

```typescript
const myOtherUnion = z.discriminatedUnion(""status"", [
  z.object({
    status: z.literal(""success""), data: z.string()
  }).required(),
//  ^ this doesn't seem to make any difference in the output type
  z.object({ status: z.literal(""failed""), error: z.instanceof(Error) }).required(),
]);

type myOtherUnion = z.infer<typeof myOtherUnion>
// This evaluates to the same type as before
type myOtherUnion = {
    status?: ""success"";
    data?: string;
} | {
    status?: ""failed"";
    error?: Error;
}
```

This is a major issue when trying to fold the discriminated union using ts-adt `match` as it expects the discriminant to be required (not optional). If there's a better way to work with the resulting discriminated union, please share.

Thanks",,
1577291450,2016,[BUG] `extend()` remove the '?' from optional type after upgrading 3.20.3 -> 3.20.4/3.20.5,"[Playground](https://www.typescriptlang.org/play?ts=4.9.5#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgFBkDGEAdgM7wCudAplHALwoB0EARgCsWlGAAoEwYgC4eNRiD5tRASgA0cGgEMQLGcm4MowGgHMVvMDGC1NAGxVplZOHG4sAHjBY1i4miwB3AGkWAE89bj4ICFsWTRpzCEtrLXtlRwoYULAWOABVVnYufWNMNgAeLJyITDhmNgA+CgB6ZrgANzY6FJkAZm4AJgAGbgAWOGg4fuHuAFYyKtyCtgB9SkYoKG8YFc6obtpORGcXSRk5BTYAbjgTjW1dOENjEzgAHzqfFkxjFmIbuCtODlAC0BAA-Pg4FsQBBOsQ4HxQgQPF4fCpyC4NIEQuFEdFYvF3p9iN9fv9AW1QRCoTC4X9Ecj8KjvL5lOQ0C02nsDjQ+oMRr0FtkloUVmAtu1rMxdl0UkcEHczhp5IooDc7lodOCZM9TMTGF8fv4KZqcWEdfiYnEaAajeSrmQ0EA)

```typescript
import { z } from 'zod'

const user = z.object({id: z.number(), name: z.string().optional()})
  .extend({newKey: z.boolean().optional()})

type User = z.infer<typeof user>

// version: 3.20.4 or 3.20.5
type User_current_version = {
   id: number; 
   name: string | undefined;  // <- '?' removed by 'extend()'
   newKey: boolean | undefined; // <- '?' removed by 'extend()'
}

// version: 3.20.3
type User_previous_version = {
   id: number; 
   name?: string | undefined; 
   newKey?: boolean | undefined;
}
```
",,
1576629723,2014,Allow superRefine to use async callback,"I have a use case in which I need to run asynchronous code with `await` inside of the superRefine callback, but it fails typesafety since this function cannot be asynchronous. Is it possible to switch this so that `async` functions are allowed?
Example:
```ts
const CreateUserSchema = z
  .object({
    username: z.string(),
    email: z
      .string()
      .email(""Enter a real email please."")
      .optional(),
    name: z.string().optional(),
    password: z
      .string()
      .min(1, ""Please enter a password."")
      .min(8, ""Password must be at least 8 characters.""),
    roles: z.string(),
  })
  .superRefine(async (values, ctx) => {
    const user = await getUser(values)
    if (user.user !== null) {
      ctx.addIssue({
        code: ""custom"",
        message: ""Username already taken."",
        path: [""username""],
      });
    }
  }
```",,
1575925157,2012,ZodObject second generic arg is required after upgrading 3.20.2 -> 3.20.3,"Hi, after upgrading from `3.20.2` to `3.20.3`, my code is broken, because `ZodObject` now requires at least 2 generic params, eg
```
ERROR in ./apps/api/src/app/utils/misc.ts:81:5
TS2707: Generic type 'ZodObject<T, UnknownKeys, Catchall, Output, Input>' requires between 2 and 5 type arguments.
    79 |   prefix?: P,
    80 | ): P extends ''
  > 81 |   ? z.ZodObject<T> | z.ZodObject<{ [key in keyof T]: z.ZodNull }>
       |     ^^^^^^^^^^^^^^
    82 |   :
    83 |       | z.ZodObject<CapitalizeAndPrefixProps<T, P>>
    84 |       | z.ZodObject<{
```
If this change was intended could someone help me fixing the code?
```typescript
export function outerJoinSchema<T extends z.ZodRawShape, P extends string = ''>(
  shape: T,
  prefix?: P,
): P extends ''
  ? z.ZodObject<T> | z.ZodObject<{ [key in keyof T]: z.ZodNull }>
  :
      | z.ZodObject<CapitalizeAndPrefixProps<T, P>>
      | z.ZodObject<{
          [key in keyof CapitalizeAndPrefixProps<T, P>]: z.ZodNull;
        }> {
  const prefixedSchema = prefix
    ? prefixPropsSchema(capitalizePropsSchema(shape).shape, prefix)
    : z.object(shape);
  const nullSchema = Object.keys(prefixedSchema.shape).reduce(
    (result, key) => {
      result[key] = z.null();
      return result;
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    {} as any,
  ) as z.ZodObject<{ [key in keyof typeof prefixedSchema.shape]: z.ZodNull }>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return z.union([prefixedSchema, nullSchema]) as any;
}
```
The function takes zod shape and generates a union of the original shape and same shape where all props are null. Optionally the props are prefixed. Eg:
`outerJoinSchema({ foo: z.string() }, 'prefix')` 
=>
```ts
z.union([
  z.object({ prefixFoo: z.string() }),
  z.object({ prefixFoo: z.null() }),
])
```
Originally it was supposed to take schema instead of shape, but I couldn't make it work type-wise.",,
1575873229,2011,type error,"in type.d.ts file, Some type errors occur here： Writeable<FilterEnum<T, ToExclude[number]>>
version: '3.20.3'
![image](https://user-images.githubusercontent.com/44263381/217505000-f6dd7310-410f-40e9-b1e7-5e3b02490d09.png)
",,
1575163360,2008,"Creating a recursive, generic schema gives a type error","Consider the following code (which is in my knowledge correct):
```ts
import { z } from ""zod"";

const ASchema = z.object({
  foo: z.string(),
});

type NestedSchema<T> = {
  item: T;
  children: NestedSchema<T>[];
};

const createNestedSchema = <T>(schema: z.Schema<T>) => {
  const b: z.ZodType<NestedSchema<T>> = z.lazy(() =>
    z.object({
      item: schema,
      children: createNestedSchema(schema).array(),
    })
  );

  return b;
};

const b = createNestedSchema(ASchema);

type B = z.infer<typeof b>;
```

However, the code above fails with a type error here:
```ts
const b: z.ZodType<NestedSchema<T>> = z.lazy(() =>
```

With the error:
```
Type 'ZodLazy<ZodObject<{ item: ZodType<T, ZodTypeDef, T>; children: ZodArray<ZodType<NestedSchema<T>, ZodTypeDef, NestedSchema<T>>, ""many"">; }, ""strip"", ZodTypeAny, { [k_1 in keyof addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>]: addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>[k_1]; }, { [k_3 in keyof addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>]: addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>[k_3]; }>>' is not assignable to type 'ZodType<NestedSchema<T>, ZodTypeDef, NestedSchema<T>>'.
  Types of property '_type' are incompatible.
    Property 'item' is missing in type '{ [k_1 in keyof addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>]: addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>[k_1]; }' but required in type 'NestedSchema<T>'
```

Am I doing something wrong or is this a bug?",,
1574873845,2005,Schema narrowing,"Hi,

I'm trying to define a base schema and have a function which takes in a narrowing schema and returns the parsed narrowed value.  Is this possible using this library?

```ts
import { z } from ""zod"";

const baseSchema = z.object({
  name: z.string(),
});

function getName<T extends z.infer<typeof baseSchema>>(
  schema: z.Schema<T>
): T[""name""] {
  const data = ""John"";

  // Error:
  // Element implicitly has an 'any' type because expression of type '""shape""' can't be used to index type 'ZodType<T, ZodTypeDef, T>'.
  // Property 'shape' does not exist on type 'ZodType<T, ZodTypeDef, T>'
  return schema[""shape""][""name""].parse(data);
}

const narrowedSchema = z.object({
  name: z.literal(""John""),
});

// Type of name should be 'John' instead of 'string'
const name = getName(narrowedSchema);
```",,
1574689740,2003,Access to the string email regex,"Could the string email [regex pattern](https://github.com/colinhacks/zod/blob/master/src/types.ts#L523) be exported?
Or accessed somehow by passing `zod.string().email()` as param?
### Motivation:
html input of `type=""email""` is more permissive than `zod email`, alloing for example `a@b`, which zod does not allow.

Html input has the `pattern` [attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern).

We would like thus to be able to then pass the zod email regex pattern to the html pattern attribute, so then the browser can be in charge of not submitting the form if invalid, showing the appropriate error, etc. Otherwise, we have to call `onSubmit`, with `zod.SafeParse` and if not success manually set/show the error on the input.

Thank you.",,
1573582687,1998,Can there be better typescript inference for z.string().startsWith and endsWith?,"When using z.string().startsWith() or endsWith() the typescript inferred type is simply string. Can there instead be a way to convert strings that have startsWith or endsWith declarations to typescript interpolated literals?

If not, is there any way to control what typescript type zod will infer to?

![image](https://user-images.githubusercontent.com/49543791/217133560-e2c027bd-12ee-4543-aacb-7044e57f4df9.png)
",,
1572979469,1996,Coerce makes the schema 'nullable' by default,"## Description
[Description of the issue, including context and why it's a problem]
When using coercion for any value, the resulting schema is nullable by default. This is a problem because I couldn't find a way to revert the 'nullable' status.

## Steps to Reproduce
1. Create a schema using the `coerce` attribute, like `const stringSchema = z.coerce.string()`

## Expected Behavior
`stringSchema.isNullable() === false`

## Actual Behavior
`stringSchema.isNullable() === true`

## Additional Information
Here is a [demo](https://codesandbox.io/s/zod-demo-forked-ymootx?file=/src/index.ts) to demonstrate the issue",,
1572206531,1992,Ability to provide warnings,"I'm very much unsure if this belongs in zod - probably not - but I'm similarly unsure of how to approach this. 

I'd like to validate with zod but also provide warnings or hints to users in certain situations.

```typescript
const MyNumberSchema = z.number().min(0).max(1)
const MyNumberWarningSchema = z.number().min(0).max(0.1)

const MyNumberWithWarning = MyNumberSchema.warn(MyNumberWarningSchema)
```

I can imagine `.warn()` taking a normal zod schema, but handling it differently:
- If a value is *valid* when parsed against the warning schema, it generates a warning
- Warnings are nearly identical to errors in how they work, except `warning` is used instead of `error` in the types and objects generated.

The only way I can think of to do this now is to generate a second ""inverse"" schema, then change the error messages to be more warning-like. 

Thoughts? ",,
1571557017,1990,Extended use of .extend and .merge cause TS instantiation failures,"I'm creating a migration tool for versioned data from a backend service, and I'm using Zod for both compile- and run-time type checks. My hope was to be able to express the types changing over time with `.extend` (eg. `const v2Type = v1Type.extend({ ... })`) so that it was more concise and consumable, but it quickly hits the ""Type instantiation is excessively deep and possibly infinite.(2589)"" error. (Probably related, https://github.com/colinhacks/zod/issues/1879)

The following are greatly simplified examples — in the actual use-case, I have schema factory functions and many properties defined on each version. But even with no properties defined, both `.extend` and `.merge` fail at the 15th version.

[Typescript Play for `.extend`](https://www.typescriptlang.org/play?ts=4.9.5#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgFBkDGEAdgM7wAqAnmAKYCMcAvCgHQQARgCs2lGAAoEaAJRkANm3gw2DDgC5+wGpjZQAPDFZsImOC3YcAfBWr0mxgEw9zxjnzYAPFTWJTZCkpwKgyOmsh82roGRuymruyONlS0DAlsAMwuFmyOHt5svv5yisqqMBnhkTp6hsbxORnJdmk5ACzZxhn5Pn7SJUEhMG1VUbWxJmbtzakO7ACsnextPYV9AaXB5fOjNTH1U8bzM-bpAGxLbPOrRf2BZQxnu9F1cYfsZyetxgDsl2c3dYDB4wH7PcYHdI-L5zNgADkuP0BxXuWwYcPB+ze6ThMPSAE5LnDkXdNkN8ZjXpMCXichwAAyXfEkjaDcoMykTBpuem0txcXh0+ks4FomAcDRaPZU7mWay2WbpDjOQX8kWoobKzmQulJBWnOlZVWWPJeXoosnsypSl5c96cJr676WDrGh3qy1qEY2iHYultPmWRZujgrM1rC1stQ7H1Y6l045AA)
[Typescript Play for `.merge`](https://www.typescriptlang.org/play?ts=4.9.5#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgFBkDGEAdgM7wAqAnmAKYCMcAvCgHQQARgCs2lGAAoEaAJRkANm3gw2DDgC5+wGpjZQAPDFZsImOC3YcAfBWr0mxgEw9zxjnxB6A5mwnIBImKS0jJyisqqMI6a-tq6Bkbspq7sjjZUtAwpbADMLhZsjh7evv5CouJSsmFKcCoMOTF8cXqGxskFOel2WQUALPnGOcVQPn4BFcHVCrX1MH1NLQntZv3dmQ7sAKyD7H0jY2WBlSE1EQxbizqtiSarxlvr9tkAbLtsWwelE0FVoTPnGAvK7xNpJe7sF5PXrGADs7xeX3G5V+pwBdUisJBNxW2Vh0M2bAAHO9YUijpM-mcMQwidjluDskSCdkAJzvInkn4nabhGkwVn0sF3NksgocAAM71ZXJRPP+fLmkqFtw6bglYrcXF44olsuOUwVs0iHA0WmuDJF4ustg22Q4zh1Wv1lLRipN0XNoNVEM4aVtz3FeSdliKnlG3zlhupSsaXpxjKDmssAxDnGG4cO3Oj6KVC3jlrVKeTnB2aY4+0zkYNVNzJsuBeFRdLViAA)

Any suggestions for workarounds or alternatives are greatly appreciated — I've started looking into the source, but I wanted to reach out before digging too deep.",,
1570888140,1986,TSC generates wrong typedefs from zod ,"The other day I needed to use a zod schema which defined either all of the properties in an object or none of them. Basically something like 
```ts
const ExampleSchema = z.object(
  { openingHours: z.date(), closingHours: z.date() }
);
type Example = z.infer<typeof ExampleSchema>;

// we want this to be correct
const example: Example = { 
    openingHours: new Date(),
    closingHours: new Date(),
};

// we want this to be correct
const example: Example = {};

// we want this to be incorrect
const example: Example = { 
    closingHours: new Date(),
};
```
Just creating a schema like that was not enough for me, so I jumped ahead and created a factory that generates such schemas based on the object with required properties. The code turned out to be pretty short and easy, the type definitions were correct, I was happy.

```ts
export function defineAllOrNothingSchema<T extends Record<string, ZodType>>(
  objectWithAllProperties: T
) {
  const allProperties = z.object(objectWithAllProperties);
  const objectWithNoneOfTheProperties = Object.keys(
    objectWithAllProperties
  ).reduce(
    (prev, key) => ({ ...prev, [key]: z.undefined() }),
    {} as {
      [Key in keyof T]: z.ZodUndefined;
    }
  );
  const noneOfTheProperties = z.object(objectWithNoneOfTheProperties);

  return allProperties.or(noneOfTheProperties);
}

const ExampleSchema = defineAllOrNothingSchema(
  { openingHours: z.date(), closingHours: z.date() }
);

type Example = z.infer<typeof ExampleSchema>;

// correct
const example: Example = { 
    openingHours: new Date(),
    closingHours: new Date(),
};

// correct
const example: Example = {};

// incorrect
const example: Example = { 
    closingHours: new Date(),
};
```  

The problem comes when I tried to compile it with `tsc`.  
<details><summary><b>tsconfig.json</b></summary>

```json
{
  ""include"": [""./define-all-or-nothing-schema.ts""],
  ""compilerOptions"": {
    ""noUncheckedIndexedAccess"": true,
    ""allowSyntheticDefaultImports"": true,
    ""esModuleInterop"": true,
    ""forceConsistentCasingInFileNames"": true,
    ""moduleResolution"": ""node"",
    ""noFallthroughCasesInSwitch"": true,
    ""noImplicitAny"": true,
    ""noImplicitReturns"": true,
    ""noUnusedLocals"": false,
    ""noUnusedParameters"": false,
    ""strict"": true,
    ""target"": ""es2021"",
    ""sourceMap"": false,
    ""lib"": [""es2017""],
    ""removeComments"": false,
    ""composite"": true,
    ""incremental"": true,
    ""module"": ""commonjs"",
    ""declaration"": true,
    ""outDir"": ""./lib/cjs"",
    ""declarationDir"": ""./lib/typedefs/""
  },
}
```

</details>

 `lib/typedefs/define-all-or-nothing-schema.d.ts`

```ts
import { z, ZodType } from ""zod"";
export declare function defineAllOrNothingSchema<
  T extends Record<string, ZodType>
>(
  objectWithAllProperties: T
): z.ZodUnion<
  [
    z.ZodObject<
      T,
      ""strip"",
      z.ZodTypeAny,
      z.objectUtil.addQuestionMarks<{
        [k_2 in keyof T]: T[k_2][""_output""];
      }> extends infer T_1
        ? {
            [k_1 in keyof T_1]: z.objectUtil.addQuestionMarks<{
              [k in keyof T]: T[k][""_output""];
            }>[k_1];
          }
        : never,
      z.objectUtil.addQuestionMarks<{
        [k_2_1 in keyof T]: T[k_2_1][""_input""];
      }> extends infer T_2
        ? {
            [k_3 in keyof T_2]: z.objectUtil.addQuestionMarks<{
              [k_2 in keyof T]: T[k_2][""_input""];
            }>[k_3];
          }
        : never
    >,
    z.ZodObject<
      { [Key in keyof T]: z.ZodUndefined },
      ""strip"",
      z.ZodTypeAny,
      z.objectUtil.addQuestionMarks<
        {
          [Key in keyof T]: z.ZodUndefined;
        } extends infer T_5 extends z.ZodRawShape
          ? {
              [k_5 in keyof T_5]: {
                [Key in keyof T]: z.ZodUndefined;
              }[k_5][""_output""];
            }
          : never
      > extends infer T_3
        ? {
            [k_1_1 in keyof T_3]: z.objectUtil.addQuestionMarks<
              {
                [Key in keyof T]: z.ZodUndefined;
              } extends infer T_4 extends z.ZodRawShape
                ? {
                    [k_4 in keyof T_4]: {
                      [Key in keyof T]: z.ZodUndefined;
                    }[k_4][""_output""];
                  }
                : never
            >[k_1_1];
          }
        : never,
      z.objectUtil.addQuestionMarks<
        {
          [Key in keyof T]: z.ZodUndefined;
        } extends infer T_8 extends z.ZodRawShape
          ? {
              [k_2_3 in keyof T_8]: {
                [Key in keyof T]: z.ZodUndefined;
              }[k_2_3][""_input""];
            }
          : never
      > extends infer T_6
        ? {
            [k_3_1 in keyof T_6]: z.objectUtil.addQuestionMarks<
              {
                [Key in keyof T]: z.ZodUndefined;
              } extends infer T_7 extends z.ZodRawShape
                ? {
                    [k_2_2 in keyof T_7]: {
                      [Key in keyof T]: z.ZodUndefined;
                    }[k_2_2][""_input""];
                  }
                : never
            >[k_3_1];
          }
        : never
    >
  ]
>;
export declare function defineSchemaWithRequiredTuplesOfProperties<
  T extends Record<string, ZodType>,
  U extends Record<string, ZodType>
>(
  allOrNothingProperties: T,
  otherProperties: U
): z.ZodIntersection<
  z.ZodObject<
    U,
    ""strip"",
    z.ZodTypeAny,
    z.objectUtil.addQuestionMarks<{
      [k_2 in keyof U]: U[k_2][""_output""];
    }> extends infer T_1
      ? {
          [k_1 in keyof T_1]: z.objectUtil.addQuestionMarks<{
            [k in keyof U]: U[k][""_output""];
          }>[k_1];
        }
      : never,
    z.objectUtil.addQuestionMarks<{
      [k_2_1 in keyof U]: U[k_2_1][""_input""];
    }> extends infer T_2
      ? {
          [k_3 in keyof T_2]: z.objectUtil.addQuestionMarks<{
            [k_2 in keyof U]: U[k_2][""_input""];
          }>[k_3];
        }
      : never
  >,
  z.ZodUnion<
    [
      z.ZodObject<
        T,
        ""strip"",
        z.ZodTypeAny,
        z.objectUtil.addQuestionMarks<{
          [k_5 in keyof T]: T[k_5][""_output""];
        }> extends infer T_3
          ? {
              [k_1_1 in keyof T_3]: z.objectUtil.addQuestionMarks<{
                [k_4 in keyof T]: T[k_4][""_output""];
              }>[k_1_1];
            }
          : never,
        z.objectUtil.addQuestionMarks<{
          [k_2_3 in keyof T]: T[k_2_3][""_input""];
        }> extends infer T_4
          ? {
              [k_3_1 in keyof T_4]: z.objectUtil.addQuestionMarks<{
                [k_2_2 in keyof T]: T[k_2_2][""_input""];
              }>[k_3_1];
            }
          : never
      >,
      z.ZodObject<
        { [Key in keyof T]: z.ZodUndefined },
        ""strip"",
        z.ZodTypeAny,
        z.objectUtil.addQuestionMarks<
          {
            [Key in keyof T]: z.ZodUndefined;
          } extends infer T_7 extends z.ZodRawShape
            ? {
                [k_7 in keyof T_7]: {
                  [Key in keyof T]: z.ZodUndefined;
                }[k_7][""_output""];
              }
            : never
        > extends infer T_5
          ? {
              [k_1_2 in keyof T_5]: z.objectUtil.addQuestionMarks<
                {
                  [Key in keyof T]: z.ZodUndefined;
                } extends infer T_6 extends z.ZodRawShape
                  ? {
                      [k_6 in keyof T_6]: {
                        [Key in keyof T]: z.ZodUndefined;
                      }[k_6][""_output""];
                    }
                  : never
              >[k_1_2];
            }
          : never,
        z.objectUtil.addQuestionMarks<
          {
            [Key in keyof T]: z.ZodUndefined;
          } extends infer T_10 extends z.ZodRawShape
            ? {
                [k_2_5 in keyof T_10]: {
                  [Key in keyof T]: z.ZodUndefined;
                }[k_2_5][""_input""];
              }
            : never
        > extends infer T_8
          ? {
              [k_3_2 in keyof T_8]: z.objectUtil.addQuestionMarks<
                {
                  [Key in keyof T]: z.ZodUndefined;
                } extends infer T_9 extends z.ZodRawShape
                  ? {
                      [k_2_4 in keyof T_9]: {
                        [Key in keyof T]: z.ZodUndefined;
                      }[k_2_4][""_input""];
                    }
                  : never
              >[k_3_2];
            }
          : never
      >
    ]
  >
>;
```

and the errors:

`Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>'.` at line 17

`Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>'.` line 26 
and so on.

The generated type uses zod's complex types and after being compiled they seem incorrect and full of error messages. I took a look myself and began to understand why they are wrong but can't seem to work out why they are generated in such a way that they are now wrong although no indication of errors is present in the code. Maybe it's some incompatibility between my tsconfig and zod? I also setup a minimal working example in a git repo so you can reproduce the problem and check out everything in piece and quiet. Here's the repo: https://github.com/18ivan18/zod-create-all-or-nothing-schema. 

Every piece of advice is welcome. ",,
1570811318,1984,z.object generated types.,"Let's say I have an object

```ts
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});
```
that I want to create a version of it with all properties optional.

```ts
const OptionalDog = z.object({
  name: z.string().optional(),
  age: z.number().optional(),
});
```

or change each property's value
```ts
const SelectableDog = z.object({
  name: z.enum([""0"", ""1""]),
  age: z.enum([""0"", ""1""]),
});
```
How would I go about generating `OptionalDog` and `SelectableDog` from `Dog`?",,
1570369831,1983,.deepPartial with union support,"Given the following example comparing `.deepPartial` to `PartialDeep` from type-fest.

```ts
import { z } from 'zod'
import type { PartialDeep } from 'type-fest'

const ZodFoo = z.object({
  bar: z.object({
    zed: z.union([
      z.object({
        a: z.string(),
      }),
      z.object({
        b: z.string(),
      }),
    ]),
  }),
})

type Foo = z.infer<typeof ZodFoo>

const ZodPartialFoo = ZodFoo.deepPartial()
type PartialFoo = z.infer<typeof ZodPartialFoo>

let f: PartialFoo
// f.bar?.zed // a and b are not optional

let g: PartialDeep<Foo>
// g.bar?.zed // a and b are optional
```

Is it possible zod `deepPartial` can handle unions making all properties of each type in the union optional as well?",,
1568393546,1977,Problems with `.transform` and generics,"### Discussed in https://github.com/colinhacks/zod/discussions/1972

<div type='discussions-op-text'>

<sup>Originally posted by **stuartkeith** February  1, 2023</sup>
Hi, I'm having trouble using `.transform` inside a function where Zod is using a generic passed into that function. For example (note this is a contrived example, not my actual use case):

```ts
function helper<Type extends string>(type: Type) {
    return z
        .object({
            type: z.literal(type),
            foo: z.number(),
        })
        .transform((obj) => {
            return {
                // does not work - obj.type does not exist on `obj`
                type: obj.type,
                // this is fine
                fooDoubled: obj.foo * 2,
            };
        });
}

const Hello = helper(""hello"");
const Goodbye = helper(""goodbye"");
```


The type of `obj` inside `transform` is:

```ts
obj: { [k_1 in keyof z.objectUtil.addQuestionMarks<{
    type: Type;
    foo: number;
}>]: z.objectUtil.addQuestionMarks<{
    type: Type;
    foo: number;
}>[k_1]; }
```

`obj.type` is not accessible on the object at all. I can see the expected `type: Type` generic is there but it appears that the `addQuestionMarks` type is losing the generic.

This also happens if I use `Type extends z.ZodLiteral<string>` and pass that in directly.

I'm not sure if this is a known limitation of zod or a bug/missing feature. Is there any way of getting around this? Thanks.</div>",,
1568196050,1974,Can't use an imported string array as parameter for `z.enum()`,"Hi! 

I'm my applications I like to create constant files which will be use a lot between files, keeping easier to maintain. 

In a project, I have the following constant:

```typescript
// in constants.ts
export const allowedLanguages = ['de', 'fr', 'en']
```

And when I tried to use that constant as parameter, to validate a contract using `zod.enum()` I have the following error:
<img width=""264"" alt=""image"" src=""https://user-images.githubusercontent.com/44659603/216356558-297fe9b9-447c-4f37-92a8-207b17592fea.png"">

<img width=""978"" alt=""image"" src=""https://user-images.githubusercontent.com/44659603/216356511-0e61af90-3142-4c9c-af10-6648fc56ed01.png"">

Is this a bug or intended? Why can't I use an exported array here? Feels bad having to edit all my schemas that will use language, as my supported languages grows...

Thanks for the time, and I'd be happy to help to allow this if possible ;) 
",,
1566694994,1971,Type 'ZodString' is not assignable to type 'string'.,"I've tried to define scheme, it looks like this:

```js
import { z, defineCollection } from 'astro:content'

const blog = defineCollection({
  schema: {
    title: z.string(),
    description: z.string(),
    date: z.string().transform((str) => new Date(str)),
    image: z.object({
      src: z.string(),
      alt: z.string(),
    }),
    tags: z.array(z.string()),
    updated: z.string(),
    draft: z.boolean(),
  },
  slug: ({ defaultSlug }) => {
    return defaultSlug
  },
}) ...
```

I think this `description: z.string()` trigger the getter `get description(): string | undefined;`, 

but I don't know why the code still run as supposed to do.",,
1564934619,1965,Indexed type access with Zod,"Consider the following typescript code, which represents some data entry inside a database and the update command that is sent over the network (untrusted) 
```ts
interface Data {
    id: string;
    prop1: number;
    prop2: string;
    prop3: boolean;
}

interface DataUpdate<T extends keyof Data> {
    target: string; // the id
    prop: T;
    val: Data[T];
}
```

In this situation, it would be ideal to be able to use `zod` to validate the data, since it's transmitted over the network. However, it does not seem like there is a way currently to do an indexed type access with `zod`. While we can currently do the rest of the objects using the following code, we can't really do the `val` property with zod. 

```ts
const Data = z.object({
    id: z.string(),
    prop1: z.number(),
    prop2: z.string(),
    prop3: z.boolean(),
});

const DataUpdate = z.object({
    id: z.string(),
    prop: Data.keyof(),
});
```

Is this a new feature that can be added? Or am I missing something here?


",,
1563348805,1960,ZodObject not assignable to ZodTypeAny,"I've encountered this issue since updating to 3.20.2 (have also tried going down to 3.20.1 and 3.20.0, but it only disappears in 3.19), where I get ```""Argument of type ZodObject<....> is not assignable to parameter of type ZodTypeAny. Type ZodObject<...> is missing the following properties from 'ZodType<any, any, any>': catch, pipe.```

I've tried searching for a solution to the issue but cannot seem to find anything.

Reproduction steps:
- Create a file `1.ts`
- Add some sort of zod object to this file. `export const a = z.object({ ... });`
- Then import said zod object into another file `2.ts`, where you try to use it in another zod object (so basically nesting them).
- `const b = z.object({ someName: a })`

This worked in previous versions but I just cannot seem to get it working in this update. I'd love to hear any feedback on this, and maybe hear if I'm doing anything wrong or if it's a known issue.

Thanks!",,
1563329628,1959,ZodIssueCode type is an interface rather than enum,"I really love zod and thank you to everyone for their work on it 🙏 

I am working with zod in GraphQL and I noticed that the `ZodIssueCode` type is an interface rather than an enum. The code [here](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts#L18) suggests that it is intended to be an enum, but the `arrayToEnum` function [here](https://github.com/colinhacks/zod/blob/master/src/helpers/util.ts#L19) seems to return an object rather than an enum.

In the module's build code I see the following in zod/lib/ZodError.dts:

```ts
export declare const ZodIssueCode: {
    invalid_type: ""invalid_type"";
    invalid_literal: ""invalid_literal"";
    custom: ""custom"";
    invalid_union: ""invalid_union"";
    invalid_union_discriminator: ""invalid_union_discriminator"";
    invalid_enum_value: ""invalid_enum_value"";
    unrecognized_keys: ""unrecognized_keys"";
    invalid_arguments: ""invalid_arguments"";
    invalid_return_type: ""invalid_return_type"";
    invalid_date: ""invalid_date"";
    invalid_string: ""invalid_string"";
    too_small: ""too_small"";
    too_big: ""too_big"";
    invalid_intersection_types: ""invalid_intersection_types"";
    not_multiple_of: ""not_multiple_of"";
    not_finite: ""not_finite"";
};
```

It seems an enum would be a better type. Is there a reason why it is done this way? Would you be open to a pull request changing the ZodIssueCode to an enum?

Thank you!",,
1562863603,1958,"all properties are inferred as optional, even if strict and strictNullChecks are set to true","I have a simple validator and i am exporting the types like this
```
import type { z } from 'zod';
import type { cardValidator, imageBlockValidator, textBlockValidator } from 'validators';

export type ValidatedCard = z.infer<typeof cardValidator>;
export type ValidatedTextBlock = z.infer<typeof textBlockValidator>;
export type ValidatedImageBlock = z.infer<typeof imageBlockValidator>;
```

when I import the type into another package I am getting typescript errors along the lines of `object.property is possibly 'undefined'` i have seen some bugs here regarding this and usually the answer is to set `strict` to `true` in `tsconfig.json` but I've done that already and it still doesn't work
here is my `base.json` which is imported in all other packages
```
{
	""$schema"": ""https://json.schemastore.org/tsconfig"",
	""display"": ""Default"",
	""compilerOptions"": {
		""composite"": false,
		""declaration"": true,
		""declarationMap"": true,
		""esModuleInterop"": true,
		""forceConsistentCasingInFileNames"": true,
		""inlineSources"": false,
		""isolatedModules"": true,
		""moduleResolution"": ""node"",
		""noUnusedLocals"": false,
		""noUnusedParameters"": false,
		""preserveWatchOutput"": true,
		""strict"": true,
		""target"": ""ES6"",
		""outDir"": ""dist"",
		""strictNullChecks"": true
	},
	""exclude"": [""node_modules""]
}
```
I have added the `strict` and `strictNullChecks` to `true` in the local configs as well just to make sure it wasn't an import issue and I still got the same error, after each step I reinstalled everything and restarted vscode just in case that was the issue but it didn't work",,
1562586519,1956,issues with customizing error messages,"Hi,

I'm using Zod with SvelteKit and [typesafe/i18n](https://github.com/ivanhofer/typesafe-i18n) to create a multilingual site.

One of the main requirements is to display localized error messages according to the selected locale.

At the moment, I have the following code blocks:

```ts
import { z } from ""zod"";
import { get } from ""svelte/store"";
import LL from ""$i18n/i18n-svelte"";

const contactSchema = z.object({
	name: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).name() }),
			invalid_type_error: get(LL).formInvalidError({ field: get(LL).name(), type: get(LL).text() }),
		})
		.min(3)
		.max(20),
	surname: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).surname() }),
			invalid_type_error: get(LL).formInvalidError({
				field: get(LL).surname(),
				type: get(LL).text(),
			}),
		})
		.min(3)
		.max(20),
	email: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).email() }),
			invalid_type_error: get(LL).formInvalidError({
				field: get(LL).email(),
				type: get(LL).email(),
			}),
		})
		.email(),
	company: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).company() }),
			invalid_type_error: get(LL).formInvalidError({
				field: get(LL).company(),
				type: get(LL).text(),
			}),
		})
		.min(3)
		.max(20),
	phone: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).phone() }),
			invalid_type_error: get(LL).formInvalidError({
				field: get(LL).phone(),
				type: get(LL).text(),
			}),
		})
		.min(3)
		.max(20),
	message: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).message() }),
			invalid_type_error: get(LL).formInvalidError({ field: get(LL).message(), type: get(LL).text() }),
		})
		.min(20)
		.max(3000),
});

export { contactSchema };
```

Right now, Zod is bypassing the locale consideration and just displaying the messages in whatever language is selected as the base.

Am I doing something wrong with Zod?",,
1561545264,1955,Generating type definitions for a library with zod and i get an error,"I am getting this error when running build command
```
[vite:dts] Start generate declaration files...
src/cards.ts:3:27 - error TS2589: Type instantiation is excessively deep and possibly infinite.

  3 const categoryValidator = z.object({
                              ~~~~~~~~~~
  4  label: z.string(),
    ~~~~~~~~~~~~~~~~~~~
... 
  6  group: z.string()
    ~~~~~~~~~~~~~~~~~~
  7 });
    ~~

```
the `categoryValidator` is only referenced once in the same file so I am sure it's not a circular dependency, what could be causing this? It's annoying to debug this because it takes vite over 30 minutes to give up which means I have to wait 30 minutes before I get the error

Edit: I removed this validator and added it inline but I was still getting the same error, I didn't get to see the error because as mentioned it takes forever but it was there",,
1561103283,1949,Interaction between zod and TypeScript handling of .catchall,"zod seems to handle `.catchall` on an object differently than the corresponding TypeScript type it generates. Given the following schema:

```typescript
const schema = z.object({
  foo: z.string(),
})
  .catchall(z.number());
```

zod will happily validate it:

```typescript
schema.parse({ foo: 'hi', bar: 0 });

// ✅ no error
```

However, if you look at the corresponding inferred type:

```typescript
type Schema = z.infer<typeof schema>;

// type Schema = {
//   [x: string]: number;
//   foo: string
// }
```

that type seems unsatisfiable directly in TypeScript:

```typescript
const x: Schema = { foo: 'hi', bar: 0 };

// Type '{ foo: string; bar: number; }' is not assignable to type '{ [x: string]: number; foo: string; }'.
//   Property 'foo' is incompatible with index signature.
//     Type 'string' is not assignable to type 'number'.
```

I'm not entirely sure what the right behavior here is - should `catchall` require that all values on the shape be assignable to the catchall type? Is there some other way to declare what the output type is? (Is there some way to declare a constant of type `Schema` that TypeScript is happy with?)",,
1559196031,1944,Retrieve default values from schema,"I am trying to build a form abstraction around Zod. Currently it works as follows:
```ts
const  = useForm({
  schema: z.object({
    name: z.string(),
    demo: z.number(),
  }),
  // This object is of type `Partial<z.infer<S>>` where `S` is the schema above.
  defaultValues: {
    name: ""todo""
  }
});
```

Now I would like to remove the `defaultValues` argument and use Zod's built-in defaults for better DX. Like the following:
```ts
const  = useForm({
  schema: z.object({
    name: z.string().default(""todo""),
    demo: z.number(),
  }),
});
```

The way `useForm` works internally is that it needs the default values so it can set them to the HTML `input` elements. I was hoping Zod would give me all of the default values similar to the manually written `defaultValues` argument I was previously using.

I saw in issue #201 it was recommended to use `schema.parse({})`. This does not work for my use case because I don't want to be required to set a default value on every field.

In issue #213 there was another workaround but it would greatly comprise DX so it doesn't work for me either.

I think this could be fixed by either:
 - Providing a method to get the default values from the schema. `schema.getDefaults()`
 - Providing a way to parse a schema which instead of failing on errors would return a partial object of all fields it could successfully parse. This would make `schema.parse({})` work and it would just not include all fields without a default set.

Thanks for any help that can be provided and I have been loving using Zod in my projects!",,
1557830560,1937,Need Help: Not found in the doc,"Hello all,
I need your help because I didn't find in the documentation how to convert this example into Zod.

```typescript
interface SomeArray {
  id: string; // uuid
  createdAt: number; // timestamp
}

interface TestItem {
  id: string;
  name: string;
  someArray: SomeArray[];
  date: number;
}

export class Test {
  constructor(
    public id: string = '', // uuid
    public name: string = '',
    public someArray: SomeArray[] = [],
    public date: number // timestamp
  ) {}

  static fromJson(data: TestItem): Test {
    return new Test(data.id, data.name, data.someArray, data.date * 1000);
  }
}

const MOCK: Test = {
  id: 'uuid',
  name: 'test',
  someArray: [{ id: 'uuid', createdAt: 190000 }],
  date: 19000,
};

const getData = Test.fromJson(MOCK);

console.log(getData)

```",,
1557619500,1935,Boolean schema is incorrectly typed as z.number ,"```javascript
// schemas.ts

export const schemas = {
  string: z.string,
  number: z.number,
  boolean: z.number /* --> should be z.boolean */,
  unknown: z.unknown,
  null: z.null,
  undefined: z.undefined,
  date: dateSchema,
  literal: z.literal,
  union: z.union,
  array: z.array,
  object: z.object,
};
```

This leads to always triggering the invalid type error when using `q.boolean()`",,
1557187827,1934,Default on ZodObject behaviour,"I might be misusing or misunderstanding the `default()` function on a ZodObject, but I would have expected these implementations to behave similarly:


```typescript
const MySchema = z.object({
  a: z.string().default('a'),
  b: z.number().default(1),
  c: z.boolean().default(true),
})

const MySchema2 = z
  .object({
    a: z.string(),
    b: z.number(),
    c: z.boolean(),
  })
  .default({ a: 'a', b: 1, c: true })

console.log(MySchema.parse({})) // { a: 'a', b: 1, c: true }
console.log(MySchema2.parse({})) // throws ZodError
```

Is this expected behavior or a bug? I'd be more then happy to make a contribution :)",,
1557049563,1933,Access to value in `.catch` that failed to parse.,"I'd like to be able to access the value that failed parsing in `.catch` and do something with it. For example:

```typescript
const schema = z
  .discriminatedUnion(""type"", [
    z.object({ type: z.literal(""type1"") }),
    z.object({ type: z.literal(""unknown""), value: z.unknown() })
  ])
  .catch((val: unknown) => ({ type: ""unknown"" as const, value: val }));

const result = schema.parse({ type: ""some-other-type"" });
// result would look like
// {type: ""unknown"", original: { type: ""some-other-type"" }}
```

Then in other places I can maybe log what the original value was, or try to do some more parsing in the `.catch` callback itself",,
1556054801,1929,`z.coerce.date().parse(null)` validates successfully,"This is a bit of a gotcha:
```typescript
z.coerce.date().safeParse(null).success // true
```

It's not technically unexpected, though:
```typescript
new Date(null) // Thu Jan 01 1970 10:00:00 GMT+1000 (Australian Eastern Standard Time)
```

I'm happy to PR a docs update briefly describing this gotcha, unless the project wants to address this by changing how `z.coerce.date()` works internally.

(IMO it should _not_ change `z.coerce.date()` as just calling `new Date()` without any other logic is very tidy.)",,
1551834969,1917,Schema from TypeScript type,"Right now Zod is useful when used from the start of a project, no doubt. 

However, I have some issues when it comes to the real-world usage of Zod when it comes to third-party libraries and existing codebases.

For example, it's currently impossible to use types from third-party packages in your schemas without first redefining those types in your own code as Zod schemas. This makes for a horrible developer experience in the first instance as now I have to inspect the types in the third-party package in much more detail than I otherwise would and I have to write a bunch of additional boilerplate.

However, it gets worse if/when that third-party package changes the type definition. Maybe they add new properties. Maybe they rename or remove something. Either way, even if I wasn't using/relying on those properties I now have to change my code to match.

My ideal developer experience here would be something like this:

```ts
import { z } from 'zod'
import { SomeType } from 'some-third-party-package'

const MySchema = z.object({
  myProperty: z.string(),
  otherProperty: z.deduce<typeof SomeType>() // Zod would inspect the type and deduce a schema or object shape automatically
})

export type MyType = z.infer<typeof MySchema>
```

There is also the issue of retrofitting Zod into existing TypeScript projects. Typically dev teams will find it difficult to get buy-in for additional work that the people holding the purse strings will perceive as ""rework"" that's not going to produce any tangible benefit to the value of the software or the revenue the company makes. Basically, why would they pay for that when they could be paying for new features to be added that they can charge their customers more money for?

From the suggestion above, the same idea could then also be used to give true TypeScript first capabilities to Zod **and** allow a much easier uptake on older projects with little to no additional developer overhead:

```ts
import { z } from 'zod' // added in retrofit

// Existing type in the project
export type User {
  name: string
  age: number
}

// To retrofit Zod into an older project the developer could use the `deduce<T>()` function 
// to produce schemas directly from their existing types
export const UserSchema = z.deduce<typeof User>()
```

Now the developer can use the Schema to achieve the runtime type protection they want, and the bosses are happy because the developer didn't take time to rewrite old code rather than build new features.

",,
1551252534,1915,Allow cancellation through AbortSignal,"Add a second parameter to parseAsync to pass a `AbortSignal` for aborting the parsing.

That `AbortSignal` would be passed then to `refine` and `superRefine` to stop any asynchronous validation.

Example:
```ts
const schema = z.object({
  username: z.string.refine(async (value, {signal})=> {
    const { isValid } = await fetch('/api/validate-user?username='+value, {signal})
                              .then(response => response.json())
    return isValid
  }, { message: ""The username you choose is not valid"" }
})",,
1550505140,1913,`z.enum` does not allow adding a custom error for `invalid_enum_value`,"When. I define a `z.enum` I'm only able to define custom errors for `invalid_type_error` and `required_error` but not for `invalid_enum_value`.

When the user for example choose the ""empty"" option from the Select, the form will choose the `invalid_enum_value` but I cannot personalize the error.

Am I using it in the wrong way, or should `enum` expose that property to be customized?",,
1549936329,1912,Custom error messages with variables,"In `yup` you can pass the error message as a second argument, the same as in `zod`.
The difference is that in `yup` it can be a `string` or a `function` that returns a `string`.
Here's an example:

```typescript
// Passing a string (same as zod)
string().max(64, ""Max: 64"");

// Passing a function
string().max(64, ({ max }) => `Max: ${max}`)
string().min(2, ({ min }) => `Min: ${min}`)
string().length(64, ({ length}) => `Length: ${length}`)
```

_Originally posted by @bulicmatko in https://github.com/colinhacks/zod/discussions/1909#discussioncomment-4731518_
    ",,
1548265752,1908,Question: Custom error messages with variables?,"Is there a way to set custom error messages with variables?
Here's an example to better explain my question:

 ```typescript
// An example with react hook
// useIntl comes from `react-intl`

function useValidationSchema() {
  const intl = useIntl()

  return string()
    .max(64, {
      message: intl.formatMessage({
        id: ""s3BfNQ"",
        defaultMessage: ""Max length is 64"",
      }),
    })
}
```

The problem with this example is the duplication of the max value `64` in the validator and in the translation.

Ideally, I would want something like this:

 ```typescript
// An example with react hook
// useIntl comes from `react-intl`

function useValidationSchema() {
  const intl = useIntl()

  return string()
    .max(64, {
      message: ({ max }) =>
        intl.formatMessage(
          {
            id: ""s3BfNQ"",
            defaultMessage: ""Max length is {max}"",
          },
          { max }),
    })
}
```

This way, if the max value changes, there's no need to update all translations.
This is the way `yup` does it.

I checked the docs and opened issues and could not find anything like this.

PS: Big Thanks to the author and all the contributors for this great lib. Amazing work!





",,
1537969872,1901,Better Recursive type's example and method,"The current example required user to declare the types twice
```typescript
interface Category {
  name: string;
  subcategories: Category[];
}

// cast to z.ZodType<Category>
const Category: z.ZodType<Category> = z.lazy(() =>
  z.object({
    name: z.string(),
    subcategories: z.array(Category),
  })
);

Category.parse({
  name: ""People"",
  subcategories: [
    {
      name: ""Politicians"",
      subcategories: [{ name: ""Presidents"", subcategories: [] }],
    },
  ],
}); // passes
```
Instead we could use `z.infer` and Typescript's type union to reduce duplicative code
```typescript
const _Category = z.object({
  name: z.string(),
})
type CategoryType = z.infer<typeof _Category> & {
  subcategories: CategoryType[]
}
const Category: z.ZodType<CategoryType> = z.lazy<any>(() =>
_Category.extend({
  subcategories: z.array(Category),
}));

Category.parse({
  name: ""People"",
  subcategories: [
    {
      name: ""Politicians"",
      subcategories: [{ name: ""Presidents"", subcategories: [] }],
    },
  ],
}); // passes
```

This way, we could write most of our definition under `_Category` and save the need to write an interface.
",,
1535303055,1895,"When using `.catch` with default value, it can return invalid type","Since catch value allows us to pass `z.input` value, it won't fallback to default value.
`.catch` should either require `z.output` value, or zod should also parse value provided to catch.

[reproduction](https://codesandbox.io/s/musing-rumple-6iq8f9?file=/src/index.ts)

```ts
import { z } from ""zod"";
// this allows `.catch(undefined)` since `z.input` is `string | undefined`, but it should require `string`, since 
// default value will not be applied in case of an error
const stringSchema = z.string().default(""hello"").catch(undefined);
const stringResult = stringSchema.parse(111);
// ts says stringResult type is string, but value is undefined
console.log(""stringResult"", stringResult);
```",,
1534690643,1893,`z.ZodType` and `refine` not working as expected,"Consider the following code:
```ts
const stringIsValid = (value: string): value is ""a"" | ""b"" =>
  [""a"", ""b""].includes(value);

const ASchema = z.object({
  type: z.string().refine(stringIsValid),
});

type A = z.infer<typeof ASchema>;

interface B {
  id: string;
  children: (z.infer<typeof ASchema> | B)[];
}

const BSchema: z.ZodType<B> = z.lazy(() =>
  z.object({
    id: z.string(),
    children: z.array(z.union([ASchema, BSchema])),
  })
);
```
type `A` is correctly inferred as:
```ts
{
    type: ""a"" | ""b"";
}
```

But when creating the `BSchema`, and assigning it to `z.ZodType<B>` I get the following error:
```ts
Type 'ZodLazy<ZodObject<{ id: ZodString; children: ZodArray<ZodUnion<[ZodObject<{ type: ZodEffects<ZodString, ""a"" | ""b"", string>; }, ""strip"", ZodTypeAny, { type: ""a"" | ""b""; }, { ...; }>, ZodType<...>]>, ""many"">; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<B, ZodTypeDef, B>'.
  The types of '_input.children' are incompatible between these types.
    Type '({ type: string; } | B)[]' is not assignable to type '({ type: ""a"" | ""b""; } | B)[]'.
      Type '{ type: string; } | B' is not assignable to type '{ type: ""a"" | ""b""; } | B'.
        Type '{ type: string; }' is not assignable to type '{ type: ""a"" | ""b""; } | B'.
          Type '{ type: string; }' is not assignable to type '{ type: ""a"" | ""b""; }'.
            Types of property 'type' are incompatible.
              Type 'string' is not assignable to type '""a"" | ""b""'
```

Is this a bug or am I doing something weird? Zod-version is `3.20.2` and typescript version is `4.8.4`",,
1534662895,1892,"`.parse()` Typescript linter accepts anything (string, number...)","Hi,

I didn't find someone having my issue so I'm probably doing something wrong but... I can't figure the solution out.

Let's say I have:
```ts
const TestSchema = z.object({
  email: z.string(),
});

TestSchema.parse('hello');
```

The last line will not throw an error with the Typescript whereas when hovering the parse function I can see:
```ts
(method) ZodType<{ email: string; }, ZodObjectDef<{ email: ZodString; }, ""strip"", ZodTypeAny>, { email: string; }>.parse(data: unknown, params?: Partial<z.ParseParams> | undefined): {
    email: string;
}
```

**Note that I use `strict: true` in my `tsconfig.json` (and at runtime, `zod` throws an error obviously).**

A ""workaround"" would be to always do this:
```ts
const TestSchema = z.object({
  email: z.string(),
});
type TestSchemaType = z.infer<typeof TestSchema>;

TestSchema.parse(<TestSchemaType>'hello');
```
... but it's pretty verbose and annoying.

Any idea what's the issue to get the linter working normally?

Thank you,

EDIT: it seems a solution would be to use
```ts
const typedParse = <Schema extends z.ZodSchema> (
  schema: Schema, data: z.infer<Schema>
): z.infer<Schema> => schema.parse( data )

typedParse(ATest, 'hello');
```
(ref: https://github.com/colinhacks/zod/issues/1748#issuecomment-1364572126)

... but I don't get why this is not used by default?",,
1533761098,1889,Add a getter for `multipleOf` on `ZodNumber`,"While creating [`uniforms-bridge-zod`](https://www.npmjs.com/package/uniforms-bridge-zod), I had a need to get the resulting `multipleOf` to use it in a `<input type""number"">`'s `step` attribute. Right now, I have to work around it a little:
```ts
type ZodNumberCheck = ZodNumberDef['checks'][number];
const step = field._def.checks.find(
  (check): check is Extract<ZodNumberCheck, { kind: 'multipleOf' }> =>
    check.kind === 'multipleOf',
);
```

_([source](https://github.com/vazco/uniforms/blob/6353c831673adc9a786932c4ab60483c59de3d9c/packages/uniforms-bridge-zod/src/ZodBridge.ts#L173-L181))_, but I thought that exposing it similarly to `maxValue` for `max` and `minValue` for `min` would be a nice feature.

I have to problems with that, though:
1. What if there are multiple `multipleOf`s? Ideally we'd need to calculate least common multiple of them, but maybe using the first one is enough?
2. What should be the name? `multipleOfValue` or `stepValue` stay in-align with `max`/`maxValue`, but aren't ideal.

I can file a PR for that.",,
1532933476,1884,discriminated union cant be nested,"Currently it is impossible to allow discriminated unions as argument to another discriminated union.
Typescript however allows that so it should be allowed in zod as well

Example Typescript and zod:
https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgLABQlMAnmAKZwCCcAvIpXHMcAM4DGUUMAB2AQxjQAjAC44MKAFd6Abk5wQvAOZzeC0VrUU0lanUYAhFuwTqwYqGJCy4IxSABG9KEa48BQiCiEtAATHKYYgA2vKrq-oLC4pJQLpEx9JQmVBS0DHAWFmwcFH58iUHJYXIKyr5w9o4g4a7uXj7x5YHBKWnRsVmmueYFxQAUVnAAPgUWAJRDeYwAwsUsMxZDlPwQInpYIuNgcstzbAB8JerAmHBjAIRgAHQJ3VWpZ7alXHA3d48vLpJEJQUKfdQ-OA7PYQKL0J5RCBaMbPRpOKQLb5cDD0DIlSFcaG8WHwxHI1EOJxgiHodQ4vFfSFEkkIpEop6aLSY7GDHJE+AAfWsKCeEA8ACt6PwYGNGXAoPRJdL6MQ5MgEcAYN5omNavQ5gAadSctVPPRCETIzFoTHbXb7AWTdjqsVKmVynj0ZaKGDLCB6XimtyebxjQ3qBWKWKqkVRTXaqJjdKxcPfBVulWmuNaxyJ5P6rK2ij8uCOorO0USqXu9QAdwAFhIg21Q6muJHo1n47ndUp9Ua04rq5nY92dfnrUWS47iurXsCtcQAKoiYC7Mb4Dsq-AGuAAbUdTF3ZYAukWAPTnuDeHBQXh2vaC1YV+eVCQqldrkQb9PD0i7g8j1LCwzyGS9fhETBvGAuBa2gABre9hnyAAtFDZyeUQoKgAAeJYIFuR1zkoIA

Here is the code for reference:

```ts
import { z } from 'zod'

type A = {
  discriminator1: true;
  msg: string;
}

type BA = {
  param1: number;
  discriminator2: false;
  discriminator1: false
}

type BB = {
  discriminator2: true;
  param2: number;
  discriminator1: false
}

type B = (BA | BB)

type C = A | B


const fn = (p: C) => {

  if (!p.discriminator1) {
    if (!p.discriminator2) {
      console.log(p.param1)
    } else {
      console.log(p.param2)
    }
  } else {
    console.log(p.msg)
  }
}

const _A = z.object({
  rejected: z.literal(true),
  msg: z.string()
})

const _BA = z.object({
  dieCutCosts: z.number(),
  reused: z.literal(false),
  rejected: z.literal(false)
})

const _BB = z.object({
  what: z.number(),
  reused: z.literal(true),
  rejected: z.literal(false)
})

const _B = z.discriminatedUnion('reused', [_BA, _BB])

// errors
const _C = z.discriminatedUnion('rejected', [_A, _B])

// infer _B works
type ZZ = z.infer<typeof _B>
```",,
1532276911,1879,Typescript function return type error when creating new schema with ZodObject.merge() and ZodObject.partial(),"Not sure if I'm doing something wrong or it's an issue with zod. I'm trying to create a factory function to make a new ZodObject schema from two existing schemas. However I'm having trouble creating a return type for the function to match the new schema it returns. When I do this:

```typescript
function createSchemaWithMergeAndPartial2<
  BaseShape extends ZodRawShape,
  CommonShape extends ZodRawShape
>(
  baseSchema: ZodObject<BaseShape>,
  commonSchema: ZodObject<CommonShape>
): z.ZodObject<
  z.extendShape<
    BaseShape,
    {
      [k in keyof CommonShape]: z.ZodOptional<CommonShape[k]>;
    }
  >
> {
  return baseSchema.merge(commonSchema.partial());
}
```
typescript will complain about the returned value, saying `Two different types with this name exist, but they are unrelated`. I've made a [CodeSandbox](https://codesandbox.io/s/zod-merge-and-partial-typescript-issue-xil6we) to demonstrate the issue.

I could leave the return type off and let typescript figure it out itself but unfortunately this is just a stripped down example. In my actual project I have many factory functions creating new schema, many of which are composed of several nested factory functions and when I don't provide return types for these functions typescript complaining that `Type instantiation is excessively deep and possibly infinite.` so I'm hoping providing the return types will fix that issue.",,
1531464675,1873,"Can't provide custom error message for enum ""invalid_enum_value"" error","Here is my schema:
```ts
export const testSchema = z.object({
  privacy: z.enum([""public"", ""unlisted"", ""private""], {
    required_error: ""Privacy setting is required"",
    invalid_type_error: ""Privacy setting must be a string"",
    invalid_enum_value: ""Privacy setting must be public, unlisted, or private"",
  }),
});
```
Here are my tests:


```ts
// privacy setting is undefined
testSchema.parse({});

// resulting error
{
  expected: ""'public' | 'unlisted' | 'private'"",
  received: 'undefined',
  code: 'invalid_type',
  path: [Array],
  message: 'Privacy setting is required'
}

// privacy setting is invalid type
testSchema.parse({ privacy: 123 });

// resulting error
{
  expected: ""'public' | 'unlisted' | 'private'"",
  received: 'number',
  code: 'invalid_type',
  path: [Array],
  message: 'Privacy setting must be a string'
}

// privacy setting value is invalid
testSchema.parse({ privacy: ""test"" });

// resulting error
{
  received: 'test',
  code: 'invalid_enum_value',
  options: [Array],
  path: [Array],
  message: ""Invalid enum value. Expected 'public' | 'unlisted' | 'private', received 'test'""
}
```
As you can see I overrode the error message for `required_error` and `invalid_type_error` and both messages correctly showed up in the errors. However, I also overrode `invalid_enum_value` error message but the error is still displaying the default message.
",,
1530455056,1864,How to use string array values as object keys?,"I have a list of strings: `const filenames = z.enum(['one', 'two', 'three']);`

..and want use those values as the possible keys of an object: 

```ts
const hashes = z.object({
    [filenames]: z.string().length(40)
});
```

Is something like that possible is Zod? Any suggestions?",,
1528647157,1854,Method `.pick` / `.omit` might be misleading,"Hi there,

I was using zod with some great methods and found out `.pick/ .omit` might be a bit misleading.

[According to the document](https://zod.dev/?id=pickomit), both of the methods accept a object that contains a key with a value which looks like this:
```ts
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
});

const JustTheName = Recipe.pick({ name: true });
const NoIDRecipe = Recipe.omit({ id: true });
```

but the [actual behavior](https://github.com/colinhacks/zod/blob/master/src/types.ts#L2152) (not sure was intended or a logic error) is just looping through the given object's key. No matter the value is there or not (truthy or falsy), as long as the key exist in the object it will just effect the schema which seems a bit pointless to having the value with it.

I suggest the value should be also consider, for example:
```ts
const shouldOmit = true

Schema.omit({
   name: shouldOmit, //true
   age: !shouldOmit //false
})

Schema.parse({ 
  name: 'Charlie',
  age: 20
})  // { age: 20 }
```


Any thoughts? ",,
1526466504,1839,Caught errors are not distinguishable from uncaught errors,"In v3.20.x errors handled via the `catch` operator are logged along with errors that actually cause the parsing to fail. This makes it difficult to differentiate ""fatal"", uncaught errors from non-fatal, caught/handled errors. This isn't a huge deal in smaller schemas, but becomes very tedious with larger ones.

Is there a way to suppress caught errors from `parse` and `safeParse`, or perhaps mark them as caught?

### Example
See the [interactive example on Stackblitz](https://stackblitz.com/edit/typescript-oxmrfa?file=index.ts), but here's the code for a minimal reproduction:
```typescript
const schema = z.object({
  stringProp: z.string(),
  numberPropWithCatch: z.number().catch(0),
});

schema.parse({
  // This value is of incorrect type and causes the parsing to fail
  stringProp: {},
  // This value is of incorrect type as well, but DOESN'T
  // cause parsing to fail as it's caught in the schema.
  // However, the error is reported in the overall list
  // of parsing errors.
  numberPropWithCatch: '',
});
```

Running this code results in an error **as expected**, but notice how both the fatal and caught errors are displayed:
![image](https://user-images.githubusercontent.com/13987407/211425161-6358df95-eeb2-45c1-bfff-b2555a0e7295.png)
",,
1526466035,1838,Retrieve the resolving schema from a ZodPromise,"Hey all -- I was playing around with ZodPromise and hoping to add this functionality in a PR. I checked out the [CONTRIBUTING.md](https://github.com/colinhacks/zod/blob/master/CONTRIBUTING.md) first and it asked I open an issue. So here I am....

ZodPromise is created with a second Zod type that is checked when the promise resolves. I'd like to be able to access the schema the ZodPromise was created with. For example

```ts
import { z } from 'zod';

const Foo = z.literal('foo')
const MyPromise = z.promise(Foo)

MyPromise.resolves() // should be a method that returns the Foo schema declared above
```
I'm not sure there is a way to do this at the moment and I'm open to suggestions on variable naming and such. If this is something that makes sense to PR I can draft something but looking for some feedback first. Thanks.",,
1525419766,1836,TypeScript integration?,"I can't find this section in the docs.

For example, the corresponding section of the Yup docs:
https://github.com/jquense/yup#typescript-integration

```ts
import { object, number, string, ObjectSchema } from 'yup';

interface Person {
  name: string;
  age?: number;
  sex: 'male' | 'female' | 'other' | null;
}

const schema: ObjectSchema<Person> = object({
  name: string().defined(),
  age: number().optional(),
  sex: string<'male' | 'female' | 'other'>().nullable().defined();
});
```

How to do the same with Zod?",,
1525339320,1835,`refine()` breaks `deepPartial()`,"`deepPartial()` is not actually deep, if nested object has `refine()` on it.
Example 1, works:
```ts
const test1 = z
  .object({
    inner: z.object({
      data: z.string(),
    }),
  })
  .deepPartial();

type Test1 = z.infer<typeof test1>;

/*
type Test1 = {
    inner?: {
        data?: string | undefined;
    } | undefined;
}
*/
```
Example 2, doesn't work, `innerWithRefine` is not partial:
```ts
const test2 = z
  .object({
    innerWithRefine: z
      .object({
        data: z.string(),
      })
      .refine((value) => true),
  })
  .deepPartial();

type Test2 = z.infer<typeof test2>;

/*
type Test2 = {
    innerWithRefine?: {
        data: string; // is not optional, but it is supposed to be
    } | undefined;
}
*/
```",,
1524446805,1834,Error [ERR_PACKAGE_PATH_NOT_EXPORTED],"I am trying to add a new function as follows:

```js
import { z } from 'zod';
import { errorUtil } from 'zod/lib/helpers/errorUtil';

// ...
z.ZodString.prototype.numeric = function (
    message = 'Invalid numeric string',
) {
  return this._addCheck({
    kind:  'regex',
    regex: /^\d+$/,
    ...errorUtil.errToObj(message),
  });
};
```

This works with webpack etc, but not in Nodejs, I get the following error:

```
Error [ERR_PACKAGE_PATH_NOT_EXPORTED]: Package subpath './lib/helpers/errorUtil.js' is not defined by ""exports"" in node_modules/zod/package.json
```

The solution maybe to add that `helpers` path to `exports` in zod's `package.json`",,
1522193287,1829,Schema and ZodSchema undocumented,"Looking at the code, I can see that `ZodType` is aliased as `ZodSchema` and `Schema`: https://github.com/colinhacks/zod/blob/master/src/types.ts#L4309

```ts
export { ZodType as Schema, ZodType as ZodSchema };
```

But I see no mention of this in the documentation. Are those aliases meant to be used? If so, should the documentation reflect that?",,
1520900443,1823,Declaration for Generic Function Returning a ZodObject ,"Hello,

## The Issue

I'm currently facing errors in the declaration generated for a generic function returning a `ZodObject` in which the generic, a `T extends ZodTypeAny`, is used. It follows the pattern laid out [in the readme](https://github.com/colinhacks/zod#writing-generic-functions).

The actual function works fine, it's just the declaration causing me problems when using this project in another (see below for details)

## Minimal Reproducible Example

```ts
// test.ts
import { z } from 'zod';
export const a = <T extends z.ZodTypeAny>(b: T) => z.object({ someKey: b });
```

```ts
// package.json
{
  ""scripts"": { ""build"": ""rm -rf dist && tsc -b tsconfig.json"" },
  ""dependencies"": { ""zod"": ""^3.20.2"" },
  ""devDependencies"": { ""typescript"": ""^4.9.4"" }
}
```

```ts
// tsconfig.json
{
  ""compilerOptions"": {
    ""target"": ""es2016"",
    ""module"": ""commonjs"",
    ""declaration"": true,
    ""outDir"": ""dist"",
    ""esModuleInterop"": true,
    ""forceConsistentCasingInFileNames"": true,
    ""strict"": true,
    ""skipLibCheck"": true
  }
}
```

Then `npm run build` generates `./dist/test.d.ts`

## The Error

```ts
// ./dist/test.d.ts
import { z } from 'zod';
export declare function a<T extends z.ZodTypeAny>(b: T): z.ZodObject<{
    someKey: T;
}, ""strip"", z.ZodTypeAny, z.objectUtil.addQuestionMarks<{
    someKey: T[""_output""];
}> extends infer T_1 ? { [k_1 in keyof T_1]: z.objectUtil.addQuestionMarks<{
    someKey: T[""_output""];
}>[k_1]; } : never, z.objectUtil.addQuestionMarks<{
    someKey: T[""_input""];
}> extends infer T_2 ? { [k_3 in keyof T_2]: z.objectUtil.addQuestionMarks<{
    someKey: T[""_input""];
}>[k_3]; } : never>;
```

Both `extends infer...` lines give the error:

`Type 'k_x' cannot be used to index type 'addQuestionMarks<{ someKey: T[""_output""]; }>'. [2536]`

## Finally

Its thoroughly possible I've missed something obvious so please let me know if that's the case

If not, then any workaround you can think of would be appreciated",,
1517549514,1807,Bug: `.catch` causes `undefined` types inside `z.object`,"### Bug: `.catch` causes `undefined` types inside `z.object`.

This issue appears to be different to https://github.com/colinhacks/zod/issues/1737 (fixed by PR https://github.com/colinhacks/zod/pull/1733)

🚀 Example outside `z.object`:
```ts
import { z } from 'zod';

const schema = z.string().catch('asdf');

const result = schema.parse(undefined);
//      ^? string

console.log(result); // ""asdf""
```

🚧 Example inside `z.object`:
```ts
import { z } from 'zod';

const schema = z.object({
  value: z.string().catch('asdf'),
});

const result = schema.parse({});
//      ^? { value?: string }

console.log(result); // { value: ""asdf"" }

// Why is `result.value` possibly undefined?
```


Reproduction:
https://stackblitz.com/edit/typescript-sucpqa?devToolsHeight=100&file=index.ts",,
1517258377,1805,Fix zod enum `.option` property documentation in Readme,"> You can also retrieve the list of options as a tuple with the `.options` property:

According to the doc in the Readme, the `.option` property is supposed to return a tuple, but in the actual implementation, it returns an array. This is also illustrated by the example juste bellow in the doc:

> FishEnum.options; // [""Salmon"", ""Tuna"", ""Trout""]);

The doc should be updated to state that the `.options` properties return an array instead of a tuple",,
1514766769,1783,Add `sensitive` to `ZodSchema`,"I noticed in #595 the discussion regarding sensitive values. It would be great to add the `ZodError` to structured logging like through `pino` so that things like `path` can be directly searched to find / deduplicate issues in logs, but sensitive values can get logged due to the `received` field as well as some of the localized messages:

https://github.com/colinhacks/zod/blob/9828837fb94f1500ef362b20ca5fe35eed1b6d0e/src/locales/en.ts#L7-L13

Perhaps one could write code like the following to make sure `received` is `undefined` by adding a `sensitive: boolean` to the appropriate Zod types, as well as the localized messages appropriately not interpolating the sensitive value:

```typescript
const databasePassword = z.sensitive.string().min(1).safeParse(process.env.MY_DATABASE_PASSWORD);
if (!databasePassword.success) {
  log.error({
    err: databasePassword.error // all `received` fields are not set
  }, 'Invalid database password: %s', databasePassword.error.message);
  return null;
}
```

Useful for credentials like passwords, and PII like email. Redaction in `pino` cannot be used in a workaround in all cases due to https://github.com/pinojs/pino/issues/1612.",,
1513731234,1773,Enumerated discriminator,"Is there a way to let me specify a discriminator value from a set of possible values?

For example here I want to have three possible values for the discriminator but I can pass in anything in a `z.literal` for the discriminator value. I tried to put the discriminator in a base object and parse it as an enum but it looks like it's being overridden completely when I use the `and()` which prevents me from:
- Enumerating and type check that all discriminator values exists(as I've hardcoded it in my code base).
- Not having to include ""fortress"" in the discriminatedUnion, since there's no special about a fortress other than the base structure attributes I want to exclude it from the discriminated union, but then it can't parse fortress.

```ts
const structureIds = [""farm"", ""fortress"", ""barracks""] as const;

const baseStructureSchema = z.object({
  level: z.number(),
  position: z.number(),
  health: z.number(),
  id: z.enum(structureIds),
});

const structureSchema = baseStructureSchema.and(
  z.discriminatedUnion(""id"", [ // this overrides id: z.enum(structureIds)
    z.object({ id: z.literal(""farm""), peasants: z.number() }),
    z.object({ id: z.literal(""barracks""), trainers: z.number() }),
  ])
);
```",,
1511010630,1760,3.20: Input type of a schema with a coercion,"I believe there is a confusion with the way how the new `coerce` feature works together with the inferring of the input type.

Here is the example with the `ZodString` having `coerce` enabled:

```ts
const schema = z.coerce.string(); // ZodString
console.log(schema.parse(123)); // ""123"", no errors
type SchemaInput = z.input<typeof schema>; // string
const input: SchemaInput = 123; // TS2322: Type 'number' is not assignable to type 'string'.
```

Under the hood, as per my understanding, the schema actually accepts `any` type of the input, making a `String` out of them.
However, inferring the input type of such schema returns `string`, so the `coerce` feature is not taken in account on the typescript level.

I believe, the `z.coerce.string()` should create `ZodType<string, ZodStringDef, any>` (input type — `any`, not equal to the output type — `string`).

what do you think, @colinhacks ?",,
1510435234,1757,Invalid type error with discriminatedUnion and or,"I have the following type:

```ts
const productItemBase = z.object({
  type: z.literal(""product""),
  title: z.string(),
});

const productItem = productItemBase
  .extend({ url: z.string() })
  .or(productItemBase.extend({ description: z.string() }));

const contentItem = z.object({
  type: z.literal(""content""),
  title: z.string(),
  url: z.string(),
  imageUrl: z.string(),
});

const documentItem = z.object({
  type: z.literal(""document""),
  title: z.string(),
  url: z.string(),
  documentType: z.string(),
});

export const schema = z.object({
  items: z.array(
    z.discriminatedUnion(""type"", [productItem, contentItem, documentItem])
  ),
});
```

Expected:
No type error

Actual:
Type error on the `productItem` inside the discriminatedUnion. (The type error disappears if I replace it with productItemBase, of course)",,
1509546625,1748,`parse.typed(...)` or some kind of typed parse method,"It'd be nice to have zod help the developer max out their chances of parsing a valid object, when it's manually constructed. Example:

```ts
const User = z.object({
  name: z.string().regex(/^\w+ \w+$/),
  age: z.number(),
})

User.parse({
  name: 'Bob',
  birthdate: new Date('1970-01-01'),
})
```

The above code compiles, but we have enough information to _know_ that it'll throw a ZodError at runtime. It'd be nice if there was a method like

```ts
User.parse.typed({
  name: 'Bob',
  birthdate: new Date('1970-01-01'),
})
```

Where the expected input type was `Input` (from the `ZodType<Output, Def, Input>`) rather than `unknown`. So the above code would error because the developer used `birthdate` instead of `age`.

This would be especially useful for types with a custom `.refine` or `.regex` method or similar where it could be misleading to use _just_ a type declaration:

```ts
const user: z.infer<typeof User> = {
  name: ""Robert'; -- DROP TABLE Students; --""
  age: 40,
}
```

The above will compile, and implies that the `const user` is a validated `User` instance, but it isn't because `name` doesn't match the regex. The current options are to do the above, which is safe-looking at compile time, but unsafe at runtime, or to use `.parse(...)` which is unsafe at compile time and safe-ish at runtime (but will throw errors).",,
1509384760,1747,String `.endsWith` & `.startsWith` could perhaps be typed more strongly,"If the passed value was a literal, we could have a generic in ZodString that will include a prefix / suffix.

Use case:
At the moment, I am using the code below to validate that a value is a specific ID format that has a constant prefix

```ts
export function id<P extends IdPrefixes>(prefix: P) {
	return z
		.string()
		.refine((value): value is `${P}_${string}` => pika.validate(value, prefix));
}
```

Imagine if this could be done with just `.startsWith` and `.endsWith` — ZodString could then have a single generic of the output, which would default to just a string and can be made more specific with these two methods.

<img width=""785"" alt=""CleanShot 2022-12-23 at 14 02 47@2x"" src=""https://user-images.githubusercontent.com/25351731/209348315-61d308e4-6581-4210-91ed-b02398adb85c.png"">

Should note that I am not sure if this is a good idea or not, but I wanted to just throw the idea out either way — it's a use case I have very frequently and always use `.refine` to solve.
",,
1508549533,1744,No `.endsWith` or `.startsWith` string methods on Deno,"I'm using Zod 3.16.1 with Deno and I'm not able to use the `.endsWith` or `.startsWith` string methods. As far as I can tell, all of the other string methods are supported, like `.regex`, `.url`, `.uuid`.

```
$ deno --version
deno 1.29.1 (release, x86_64-unknown-linux-gnu)
v8 10.9.194.5
typescript 4.9.4
```",,
1507518878,1740,ZodType not working as expected with branded schemas,"When passing a branded string to the `ZodType` generic, the type being returned is more strict than the original schema.

For example:

```ts
const SomeBrandedString = z.string().brand<""some-brand"">();

type SomeBrandedString = z.infer<typeof SomeBrandedString>;

const test: z.ZodType<SomeBrandedString> = SomeBrandedString;
```

Would give the following error:


```
Type 'ZodBranded<ZodString, ""some-brand"">' is not assignable to type 'ZodType<string & BRAND<""some-brand"">, ZodTypeDef, string & BRAND<""some-brand"">>'.
  Types of property '_input' are incompatible.
    Type 'string' is not assignable to type 'string & BRAND<""some-brand"">'.
      Type 'string' is not assignable to type 'BRAND<""some-brand"">'.ts(2322)
```

Zod v3.20.2
",,
1507285584,1737,.catch() does not preserve type with .optional(),"zod version: `3.20.2`
issue: `z.string().optional().catch(undefined)` comes out as `string` instead of `string | undefined`

```
const someSchema = z.object( {
  optionalCatch: z.string().optional().catch(undefined)
})
type Some = z.infer<typeof someSchema>

type WrongType = Some[""optionalCatch""]
```

the type of `WrongType` comes out as `string` instead of `string | undefined` however the argument to `catch` does test for undefined.
",,
1505108681,1732,Feature Request: Pass more data to catch to simplify error reporting and fallbacks,"# Level 1 - pass error and input
```ts
export const schemaWithErrorCapture = <
  O,
  D extends ZodTypeDef,
  S extends Schema<O, D, unknown>,
>(
  schema: S,
): ZodCatch<ZodNullable<S>> => {
  return schema.nullable().catch((cause, input) => {
    captureException(
      new Error(`parse failed for ${schema.description || 'UnnamedSchema'}`, {
        cause,
      }),
      { extra: { dataRaw } },
    );
    return null;
  });
};

const dataOrNull = schemaWithErrorCapture($Response).parse(dataRaw);
```

# Level 2 - enable transformations in catch - avoids nullable in my case:
```ts
export const schemaWithErrorCapture = <
  O,
  D extends ZodTypeDef,
  S extends Schema<O, D, unknown>,
>(
  schema: S,
): ZodCatch<S, null> => {
  return schema.catch((cause, input) => {
    captureException(
      new Error(`parse failed for ${schema.description || 'UnnamedSchema'}`, {
        cause,
      }),
      { extra: { dataRaw } },
    );
    return null;
  });
};

const dataOrNull = schemaWithErrorCapture($Response).parse(dataRaw);
```

# Level 3 - pass also the schema - enables a generic function to be used in catch:
```ts
const handleParseError = (
  error: ZodError,
  input: unknown,
  schema: Schema,
): null => {
  captureException(
    new Error(
      `parse failed for ${schema.description || 'UnnamedSchema'}`,
      { cause: error },
    ),
    { extra: { input } },
  );
  return null;
};

const dataOrNull = $Response.catch(handleParseError).parse(dataRaw);
```

---
# What I have currently - safeParse:
```ts
const parseSchemaHard = <
  O,
  D extends ZodTypeDef,
  S extends Schema<O, D, unknown>,
>(
  schema: S,
  dataRaw: unknown,
): z.infer<S> | null => {
  const result = schema.safeParse(dataRaw);

  if (!result.success) {
    captureException(
      new Error(`parse failed for ${schema.description || 'UnnamedSchema'}`, {
        cause: result.error,
      }),
      { extra: { dataRaw } },
    );
    return null;
  }
  return result.data;
};

const dataOrNull = parseSchemaHard($Response, dataRaw);
```
",,
1504885585,1731,"Zod is really really slow once he detect an error during validation, why ?","Hi,

I was searching a better way to control my user input in my API. So I try to compare some libraries to select the faster that match with my needs. For that I write this code :
```Typescript
import { z } from ""zod"";

const UserZod = z.object({
    name: z.string().min(3).max(20),
    age: z.number().min(0).max(120),
    address: z.object({
        street: z.string().min(3).max(200),
        number: z.number().min(0).max(120),
        city: z.string().min(3).max(200),
        country: z.string().min(3).max(200),
        zip: z.string().min(3).max(200),
    })
});

setTimeout(async () => {
    console.log(""Start comparison on 1_000_000 iterations"");

    const startZod = Date.now();
    for (let i = 0; i < 1_000_000; i++) {
        UserZod.safeParse(data);
    }
    console.log(""zod: "" + (Date.now() - startZod) + ""ms"");
})
```

However, the time used to perform the validation goes from simple to sixfold... Let's take the example of the following data, the first one is good but the second one has an error in the name since it is 1 character too short
```
// 947ms for 1_000_000 iterations
const data = {
    name: ""Joe"",
    age: 13,
    address: {
        street: ""Main Street"",
        number: 12,
        city: ""New York"",
        country: ""USA"",
        zip: ""12345""
    }
}

// 5724ms for 1_000_000 iterations
const data = {
    name: ""Jo"",
    age: 13,
    address: {
        street: ""Main Street"",
        number: 12,
        city: ""New York"",
        country: ""USA"",
        zip: ""12345""
    }
}
```

I don't understand why it's so slow as soon as an error exists... In my opinion, there are some things in the code that slow things down a lot with an error.
Moreover, the more errors there are, the more the execution time is increased (with 5 errors, the time is almost multiplied by 13)

Do you have any ideas where this could come from?
(in my opinion there are also some things that could be done to improve performance such as an option in the parse function to stop at the first error, etc.)",,
1502037051,1721,How to transform empty strings into null? `z.emptyStringToNull()`,"
How to support  empty strings for `z.string().datetime({ offset: true }).nullish()` schema 
if the string value is **empty**, I want it converted to `null` or keep the original value ie., `""""`

the following code throw error
```ts
import { afterAll, beforeAll } from 'vitest';
import { z } from 'zod';


describe('Test zod validations', () => {

	it('should correctly handles a valid ISO date-string', () => {
		const valid_from = '2022-12-14T22:07:10.430805+00:00';
		const valid_to = undefined; <-- this works
                 const valid_to = null; <-- this works
                 const valid_to =""""; <-- this is not working


		const schema = z.string().datetime({ offset: true }).nullish();

		expect(schema.parse(valid_from)).toStrictEqual(valid_from);
		expect(schema.parse(valid_to)).toStrictEqual(valid_to);
	});
});
```
ERROR
```
ZodError: [
  {
    ""code"": ""invalid_string"",
    ""validation"": ""datetime"",
    ""message"": ""Invalid datetime"",
    ""path"": []
  }
]


Serialized Error: {
  ""addIssue"": ""Function<>"",
  ""addIssues"": ""Function<>"",
  ""errors"": [
    {
      ""code"": ""invalid_string"",
      ""message"": ""Invalid datetime"",
      ""path"": [],
      ""validation"": ""datetime"",
    },
  ],
  ""flatten"": ""Function<flatten>"",
  ""formErrors"": {
    ""fieldErrors"": {},
    ""formErrors"": [
      ""Invalid datetime"",
    ],
  },
  ""format"": ""Function<format>"",
  ""isEmpty"": false,
  ""issues"": [
    {
      ""code"": ""invalid_string"",
      ""message"": ""Invalid datetime"",
      ""path"": [],
      ""validation"": ""datetime"",
    },
  ],
}
```
",,
1501625633,1718,Add `.meta()` to zod types,"Inspecting zod objects directly can be really useful for developing certain types of libraries. Of course tons of libs are already doing it - everything in the `zod-to-x` section of the documentation for example. Zod already supports some forms of meta data (custom error messages are a sort of metadata), which is extremely useful for things like building forms.

What if it were possible to attach arbitrary information, (or even just a string) via a `meta` function call? Having an explicit ""meta"" field could allow library developers to have their code react to zod schemas with much higher levels of customization, which could in turn allow us to improve developer experience in new ways. 

The example I have in mind is this - Lets look at a tRPC procedure with a zod schema as an input validator:

```ts
getPosts: t.procedure.input(z.object({
  id: z.string().meta(""The id of the post.""),
  search: z.string().meta(""Returns posts with this term in the body"").
})).query(() => {
  //...
}),
```

Here we're attaching a description to each input parameter. Now we can do things like generating documentation directly from our validation schemas. Anyone who's developing a library that inspects zod schemas would have much more flexibility in the types of APIs they'd be able to develop.

It doesn't have to be a string, it could be any other typed object. One solution could be `.meta<MetaType>()`, or maybe an optional interface for generating a meta enabled client (probably a lot more difficult to create?) `export const z = createZodClient<Meta>()`

Selfishly, I'm developing a tool that inspects TRPC router and generates a manual testing / documentation UI automatically, which generates forms based on input zod schemas. With a `meta` function like this, it would allow developers to create documentation per input field with a minimal amount of effort. For me I'd just want a string but IDK if there are use cases for more complex objects or not

Would really love to add something like this, thoughts?",,
1498756131,1705,Type inference doesn't work when spreading shapes,"Hello,

I frequently deal with schemas like this :

    {
        enabled: false
    } | {
        enalbed: true;
        // a whole bunch of stuff in here
    }

so I wrote a little utility function :

    const withEnabled = <T extends ZodRawShape>(shape?: T) =>
        z.union([
            z.object({
                enabled: z.literal(false),
            }),
            z.object({
                enabled: z.literal(true),
                ...shape,
            }),
        ]);

However when I infer the type of a schema which includes properties defined using this 

    const MySchema = z.object({
        filters: withEnabled({
            something: z.string()
        })
    })
    type MySchema = z.infer<typeof MySchema>

The added shape is not taken into account. Here I see only the enabled true|false

I'm obviously missing something, but what ?

Many Thanks!",,
1498327100,1704,[Suggestion] Instruct users to return `z.NEVER` in `.superRefine()` when providing a type predicate,"As the validation result **solely depends on whether `ctx.addIssue()` is called**,

https://github.com/colinhacks/zod/blob/ad4385439d7c0d7a584052dee5aa578fde5a6efd/README.md?plain=1#L1891

and the return value is only used to satisfy the type predicate and is **always thrown away**,

https://github.com/colinhacks/zod/blob/c9e4ed4095d77f5b43a5ba11d8f76b56ea48e5c6/src/types.ts#L3821-L3822

to prevent users from **accidentally forgetting to call `ctx.addIssue()` while returning a boolean value** as described in the example,

https://github.com/colinhacks/zod/blob/ad4385439d7c0d7a584052dee5aa578fde5a6efd/README.md?plain=1#L1931-L1945

instructing users to **return `z.NEVER` instead of a boolean** at the end (indicating the value is ***never*** used) just like the **early return** case when providing a type predicate may be a good idea.

```ts
  .superRefine((arg, ctx): arg is { first: string; second: number } => {
    if (!arg) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom, // customize your issue
        message: ""object should exist"",
      });
    }

    return z.NEVER;  // this should satisfy the typing
  })
```",,
1498114215,1701,How to write a tuple with spread type?,"In TypeScript, you would write:

```typescript
type A = [""A"", ...string[]];
```

How would you define that type definition using Zod?

[Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBALzgMyhEcBECIBNMDcAUDAJ5gCmcAggM60WwCiAjgK4CGANgDzUA0cAEIA+OAF4acCgA8YFAHa5awuAH44ACiHS5i5VI0wobKgC4U3BgEo4F5FYrEiAehdxcFWsCgVcJcipqCTgAbUxqTEEAOljaY2AFAHNQgF1U5zc4AGM2KF8FGCJsiAV4xGDJBGiYNjAuCk1Q6q5geShuTQjMa0Fq+KhEpM1raI58jlIR1OtM91z8xXhfWjYuIrJKOAAlLzX4KujE5EYeTYoIZAqRYjg4LIA9NSIX87gAYQALCmyAaxC6AxmOxuHxBLtVusbkQ7rDHmogA)",,
1497415417,1697,Proper introspection APIs for handy utils?,"I'd like to be able to parse searchParams with Zod. Here's a utility I built for that:

```ts
import { z } from 'zod'

export function parseSearchParams<SchemaType extends z.ZodRawShape>(
	sp: URLSearchParams,
	schema: z.ZodObject<SchemaType>,
) {
	const rawValues: Record<string, Array<string> | string> = {}
	const schemaProps = schema._def.shape()
	for (const key of sp.keys()) {
		const values = sp.getAll(key)
		const propSchema = schemaProps[key]
		if (propSchema && values.length === 1 && !isExpectingArray(propSchema)) {
			rawValues[key] = values[0]
		} else {
			rawValues[key] = values
		}
	}

	return schema.parse(rawValues)
}

function isExpectingArray(schema?: z.ZodTypeAny): boolean {
	if (!schema?._def) return false

	const { typeName } = schema._def
	if (typeName === 'ZodArray') return true
	if (['ZodUnion', 'ZodIntersection'].includes(typeName)) {
		return schema._def.options.some(isExpectingArray)
	}
	if (['ZodOptional', 'ZodNullable', 'ZodDefault'].includes(typeName)) {
		return isExpectingArray(schema._def.innerType)
	}
	if (typeName === 'ZodLazy') {
		return isExpectingArray(schema._def.getter())
	}
	return false
}

const searchParams = new URLSearchParams()
searchParams.append('starportIds', '123')
searchParams.append('starportIds', '456')
searchParams.append('cityIds', '789')
searchParams.append('cityIds', '101112')
searchParams.append('brandIds', '131415')
searchParams.append('brandIds', '161718')
searchParams.append('modelIds', '192021')
searchParams.append('modelIds', '222324')
searchParams.append('hostIds', '252627')
searchParams.append('hostIds', '282930')
searchParams.append('capacityMin', '31')
searchParams.append('capacityMax', '32')
searchParams.append('dailyChargeMin', '33')
searchParams.append('dailyChargeMax', '34')
searchParams.append('hostRatingMin', '5')
searchParams.append('shipRatingMin', '4')
searchParams.append('availabilityStartDate', '2021-01-01')
searchParams.append('availabilityEndDate', '2021-01-02')

const result = parseSearchParams(
	searchParams,
	z.object({
		starportIds: z.array(z.string()),
		cityIds: z.array(z.string()),
		brandIds: z.array(z.string()),
		modelIds: z.array(z.string()),
		hostIds: z.array(z.string()),
		capacityMin: z.coerce.number().positive(),
		capacityMax: z.coerce.number().positive(),
		dailyChargeMin: z.coerce.number().positive(),
		dailyChargeMax: z.coerce.number().positive(),
		hostRatingMin: z.coerce.number().min(0).max(5),
		shipRatingMin: z.coerce.number().min(0).max(5),
		availabilityStartDate: z.string().refine(
			v => /\d{4}-\d{2}-\d{2}/.test(v),
			val => ({ message: `Invalid date: ${val}` }),
		),
		availabilityEndDate: z.string().refine(
			v => /\d{4}-\d{2}-\d{2}/.test(v),
			val => ({ message: `Invalid date: ${val}` }),
		),
	}),
)

console.log(result)

/*
Logs:

{
  starportIds: [ '123', '456' ],
  cityIds: [ '789', '101112' ],
  brandIds: [ '131415', '161718' ],
  modelIds: [ '192021', '222324' ],
  hostIds: [ '252627', '282930' ],
  capacityMin: 31,
  capacityMax: 32,
  dailyChargeMin: 33,
  dailyChargeMax: 34,
  hostRatingMin: 5,
  shipRatingMin: 4,
  availabilityStartDate: '2021-01-01',
  availabilityEndDate: '2021-01-02'
}
*/
```

The tricky bit is the fact that searchParams can have multiple of the same key (so you can't just do `searchParams.entries()`). So what my utility does is to first get all the properties on searchParams with `getAll`, then determines whether you were hoping for an array of values and if you are it will double check there's only one value and then add only one value to the resulting object. If you're hoping for an array then it leaves it as an array. If you were not hoping for an array but there's more than one value it leaves it as an array and the later `parse` call will result in an error (as desired).

My problem is that to determine whether you want an array I need to inspect the schema you've provided and it looks like I'm using a pseudo-private API for that (and TypeScript isn't happy with that). Specifically the `_def` property.

Is there a better way to do what I'm doing?

EDIT: I changed from `schema: z.ZodSchema<SchemaType>` to `schema: z.ZodObject<SchemaType>` and that made TypeScript much happier. But I still want to make sure that there's no better way to do this since I'm using a pseudo-private property 😅

EDIT 2: I handled other zod types that wrap the array type so you can use `default`, `optional`, `union` etc.",,
1496230889,1693,Is it normal that a Tuple is valid if a value is empty ? ,"[Zod v.3.20.2]

Hello, I'm a in use case where I can have tuple like that: `[<1 empty>, ""toto""]`
In this case the safeParse method return a success with `[""toto""]` in `result.data`. Is this the expected behavior ?
I found no ""simple"" way to make the parser return an error. (Maybe by using .refine or by creating a custom rule)


Code to reproduce in RunKit
```ts
  var z = require(""zod"")
  
  const test = []
  
  test[1] = ""toto""
  
  const ZodTupleTest = z.tuple([z.number(), z.string()]);
  
  ZodTupleTest.safeParse(test)
```

That said, it's a very usefull lib ;) ",,
1496027394,1692,Feature Request: pattern properties in `z.object({})`,"JSON schema provides the possibility to define a regex that is tested against property names. If it matches, the respective property needs to fit the defined schema.

If I understand correctly, such functionality could already be implemented in `zod` using a refinement. However, I think, it would be beneficial to have this kind of functionality without the need for custom logic. That is, because then tooling built on top of `zod` could translate these requirements in a standardized way, e.g. JSON schema as mentioned above.

Proposal:
```typescript
const CustomProperty = z.string()

const objectWithPatternProperties = z.object({}).setKeyPattern(/^x-[a-z-]+$/, CustomProperty)
```

Haven't contributed to `sod` yet, but I'd be happy to give it a try myself :)",,
1495294803,1689,Inferred recursive types,"I'm working on a library that needs type definitions at runtime, and I wanted to use Zod as it's the _“lingua franca”_ of runtime type definitions. However, my library will make heavy use of recursive types, and working with these is currently very cumbersome in Zod. The [Recursive types section](https://zod.dev/?id=recursive-types) of the documentation reads:
> You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a ""type hint"".
> Unfortunately this code is a bit duplicative, since you're declaring the types twice: once in the interface and again in the Zod definition.

I wonder if such a limitation is necessary, since TypeScript supports recursion even on anonymous types. For example, if we define the following helper types...
```typescript
const TAG = Symbol('TAG');
type Tag<N extends string> = { [TAG]: N };
type RecursiveType<Name extends string, Self extends object, O = Self>
    = O extends Tag<Name> ? RecursiveType<Name, Self>
    : O extends Array<infer V> ? Array<RecursiveType<Name, Self, V>>
    : O extends object ? { [K in keyof O]: RecursiveType<Name, Self, O[K]> }
    : O;
```
... we can create the `Category` type without having its definition reference itself:
```typescript
type Category = RecursiveType<'Cat', {
  name: string;
  subcategories: Tag<'Cat'>[];
}>;

const x: Category = { name: ""foo"", subcategories: [42] }; // error
const y: Category = {
  name: ""bar"",
  subcategories: [
    { name: ""qux"", subcategories: [] }
  ]
}; // ok
```
[Link to TS Playground.](https://www.typescriptlang.org/play?#code/FAehAIAsFMBsAdoCcDOxgGMD2A7FAXcAFQEEBxcAXnAGUBPAWwCMtYAKAclLI4EoBuYPjqJiAQwDmAHgBy4aAA980HABMU4AkgCWOCQD4q4AN7gA2twC6ALnByAvoOGiAStAwBXVNoBu0IiLQsmIM0PJKKuqa+Dp6ADS0cABm4cpqGlhMAFbu+AkA8kY0yfrA4OVGhYppUUSSwaGGAPzgbp7efgGIDdAJxbBJpRXgtlUR6eAkSEhidFK6ScjgAGrNk9OzUm1eKL7+gT19yQmrQxWjqZEZ2bngLaZmANLguuAA1tB0WCn5Nq3uOz2XSCMhCvUSAwKT0shnsZXO4HygnQYHASABHTCzjCqmgSV02nw2lw6Gx4AAwmJlBIsEg6EZtpjgVIOJT8BwEsZ4TgwbYtLoJIJyigPEwMFToDSdNAULY6tJWVSOPozJZBPZ9MjQBBFCF4LAZehsHhCApbGzJbT6dRTDzQrYAERJLBYB0JEViiVS7Qy2xmAAsACZLOBHOBUcgkLTMLgCOA6OavVajFzynboI6mGIkG74R7xdTaT7ZeZ4eVbbzwA6AI4eBRuzSiguW6Ul1Wh+GWYBh1FYN7AIA)

It is then hard to imagine that Zod couldn't support recursive types with full static inference using an API like this:
```typescript
const Category = z.label('Cat', z.object({
  name: z.string(),
  subcategories: z.ref('Cat').array(),
}));
```

Is there a good reason why this isn't a part of Zod already? Or should I try to make a PR for this?

----

**EDIT:** Changed the last code snippet, so that it uses methods `z.label` and `z.ref` instead of `z.recursiveType` and `z.tag`, becaue I think the new methods are easier to understand.",,
1492860132,1682,Preprocess breaks relationship between TypeOf<T>/infer<T> and ZodType<T>,"Given a generic T, I'm trying to type the result of a function as the schema which can create T. This breaks however if the schema has a preprocessed field. I've broken the issue down to:

```Typescript
import { z, ZodType, ZodtypeDef } from 'zod'

const noPreprocessObjSchema = z.object({
  date: z.date(),
});
type NoPreprocessObj = z.infer<typeof noPreprocessObjSchema>;

const preprocessObjSchema = z.object({
  date: z.preprocess(
    (arg) => (typeof arg === 'string' ? new Date(arg) : arg),
    z.date(),
  ),
});
type PreprocessObj = z.infer<typeof preprocessObjSchema>;

const noPreprocessParser: z.ZodType<NoPreprocessObj> = noPreprocessObjSchema;
const preprocessParser: z.ZodType<PreprocessObj> = preprocessObjSchema; // Error: The types of '_input.date' are incompatible between these types. Type 'unknown' is not assignable to type 'Date'
```

Is the recommend solution that I type the prepocessor as `ZodType<Date, ZodTypeDef, Date>`?",,
1492222007,1673,.catch callback method runs even if parsing succeeds,"Example:

```js
const q = require('zod').number().catch(() => { console.log('run') })
q.parse(10); // returns 10

// but this logs ""run""
```

In this example, I wouldn't expect the callback to `catch` to run - that would match the behavior of `Promise#catch`.",,
1491713155,1668,Safari Unsupported Email Regex,"The email regex defined here https://github.com/colinhacks/zod/blob/master/src/types.ts#L518 is not supported on Safari.
```TypeScript
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
// eslint-disable-next-line
const emailRegex =
  /^(([^<>()[\].,;:\s@""]+(\.[^<>()[\].,;:\s@""]+)*)|("".+""))@((?!-)([^<>()[\].,;:\s@""]+\.)+[^<>()[\].,;:\s@""]{2,})(?<!-)$/i;
```

This is the problematic capture group: `(?<!-)`. This is a negative lookbehind, which isn't supported on Safari https://caniuse.com/js-regexp-lookbehind. Sorry, I'm not sure what it should be re-written to, but I find that https://regexr.com/ is fantastic for testing regular expressions (and highlights the issue with the negative lookbehind too).",,
1491021677,1667,[BETA 3.20] Using transforms with discriminatedUnion,"### Issue
I'd like to use Zod to label my parsed data and use it in a discriminatedUnion

Example:
```javascript
import { z } from ""zod"";

const NotFoundSchema = z
  .undefined()
  .transform(() => ({ _tag: ""not_found"" as const }));
const SuccessSchema = z.object({ status: z.number().min(200).max(299) }).transform(x=> ({...x, _tag: ""success"" as const}));
const InternalErrorSchema = z.object({ status: z.number().min(500).max(599) }).transform(x=> ({...x, _tag: ""internal_error"" as const}));

// Type 'ZodEffects<ZodObject<{ status: ZodNumber; }, ""strip"", ZodTypeAny, { status: number; }, { status: number; }>, { _tag: ""internal_error""; status: number; }, { status: number; }>' is missing the following properties from type 'ZodObject<{ _tag: ZodTypeAny; } & ZodRawShape, any, any, { [x: string]: any; }, { [x: string]: any; }>': _cached, _getCached, shape, strict, and 14 more.ts(2740)ZodTypeAny; } & ZodRawShape, any, any, { [x: string]: any; }, { [x: string]: any; }>': _cached, _getCached, shape, strict, and 14 more.ts(2740)
const ResponseStatusSchema = z.discriminatedUnion(""_tag"", [
  InternalErrorSchema,
  SuccessSchema,
  NotFoundSchema
]);

ResponseStatusSchema.parse({status:500})
```

https://codesandbox.io/s/confident-stallman-l1ej5p?file=/src/index.tsx

I thought 3.20 addressed this with #1290

If this is something Zod does not intend to cover, any recommendations on a working alternative?  I currently use ts-pattern to pattern match out the correct item after using Zod to parse, but it's twice the work as Zod could give me the pattern match for free while parsing.

Thanks!",,
1489242527,1664,adding generics to an inferred type,"Is there a way to add generics to a type that is generated using z.infer? Here's what I am trying to achieve:
```
const Schema = z.object({
    run: z.function().args(z.any({description: 'this is the value i want to make as generic'})).returns(z.number())
})
type Schema = z.infer<typeof Schema>

// pseudo code i want to achieve
const userSchema: ColumnSchema<{name: string}> = {
    run: (user) => {
        return user.name.length
    }
}
```",,
1488302723,1661,Getting maxLength,"Hi.
I want to check if a property of a schema has a maxLength.
If I try the following I get an error because unwrap() either does NOT exist because it's not optional OR because .maxLength does not exist on on it if it IS optional
ERROR IS - Property 'maxLength' does not exist on type 'ZodOptional<ZodString>'.

```ts
const maxLen = PatientDetails.shape.familyName.isOptional()
    ? PatientDetails.shape.familyName.unwrap().maxLength || undefined
    : PatientDetails.shape.familyName.maxLength || undefined
```
I just want to reliable check if it has a maxLength or not no matter if it optional or not.

Anybody know how to do this ??? I am sing TypeScript if that make any difference i.e the above failure.",,
1482671428,1649,Recursive Tuple not working as expected,"Hey all, sorry to bother you! I have a bit of a head scratcher here (this could just be a lack of typescript foo) I've been trying to do a recursive tuple using Zod and when I run my script I am getting the following error:
```
 return new TSError(diagnosticText, diagnosticCodes, diagnostics);
           ^
{ TSError: ⨯ Unable to compile TypeScript:
examples/Markdown.ts:87:14 - error TS2322: Type 'ZodLazy<ZodTuple<[ZodUnion<[ZodNativeEnum<{ readonly A: ""a""; readonly ABBR: ""abbr""; readonly ACRONYM: ""acronym""; readonly B: ""b""; readonly BDO: ""bdo""; readonly BI: ""big""; readonly BR: ""br""; readonly BUTTON: ""button""; ... 24 more ...; readonly VAR: ""var""; }>, ZodNativeEnum<...>]>, ZodObject<...>, ZodNullable<...>], n...' is not assignable to type 'ZodType<Markdown, ZodTypeDef, Markdown>'.
  Types of property '_type' are incompatible.
    Type '[""object"" | ""map"" | ""code"" | ""address"" | ""article"" | ""aside"" | ""blockquote"" | ""canvas"" | ""dd"" | ""div"" | ""dl"" | ""dt"" | ""fieldset"" | ""figcaption"" | ""figure"" | ""footer"" | ""form"" | ... 49 more ... | ""var"", {}, Markdown[], ...unknown[]]' is not assignable to type 'Markdown'.
      Target allows only 3 element(s) but source may have more.

87 export const Markdown: z.ZodType<Markdown> = z.lazy(() =
```
This is my actual code implementation: **Markdown.ts**
```typescript
// TAGS has been simplified here for readability
const TAGS = { BR: ""br"", P: ""p"", SPAN: ""span"" } as const

type Children = string | Markdown

type Markdown = [
  typeof TAGS[keyof typeof TAGS],
  {},
  Children[] | null
]


export const Markdown: z.ZodType<Markdown> = z.lazy(() =>
  z.tuple([
    z.nativeEnum(TAGS),
    z.object({}),
    z.nullable(z.array(Markdown))
  ])
)

// This typing works:
const sample: Markdown = [
  ""p"",
  {},
  [
    ""Let us know how we can help!"",
    [
      ""br"",
      {},
      null
    ],
    [
      ""span"",
      {},
      [
        ""Hello Jim!""
      ]
    ]
  ]
]
```

I then have a little node script that I run to take the schemas and generate JSON Schemas from this and that is where the error is thrown, but it appears to be an actual Typescript error. The Markdown.ts file doesn't show any Typescript errors, the type that I use with the `sample` data seems to work a okay, and this error appears at run time. I'm not sure if this is maybe me not groking Typescript tuples well enough or if this should theoretically be working and there is something not aligning on the zod side of things.

",,
1480430145,1647,Inner discriminated union,"**Issue statement:**

As developer, I want to be able to create sub-unions under union without requirement to change parent-union key or within

[Playground](https://codesandbox.io/s/recursing-ully-i2286z)

**Expected behaviour:**

- All tests are passed

**Current behaviour:**

```
/sandbox/node_modules/zod/lib/types.js:1457
            throw new Error(""The discriminator value could not be extracted from all the provided schemas"");
                  ^
Error: The discriminator value could not be extracted from all the provided schemas
    at Object.create (/sandbox/node_modules/zod/lib/types.js:1457:19)
    at Object.<anonymous> (/sandbox/src/index.ts:7:15)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Module.m._compile (/sandbox/node_modules/ts-node/src/index.ts:1597:23)
    at Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Object.require.extensions.<computed> [as .ts] (/sandbox/node_modules/ts-node/src/index.ts:1600:12)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at phase4 (/sandbox/node_modules/ts-node/src/bin.ts:579:12)
```

**Repro code:**

```typescript
import test from ""tape"";
import { z } from ""zod"";

const carScheme = z.object({
  name: z.string(),
  settings: z.discriminatedUnion<""model"", string, any>(""model"", [
    z.object({ model: z.literal(""AI-controlled""), copilot: z.boolean() }),
    z.object({
      model: z.literal(""Human-controlled""),
      copilot: z.literal(false)
    }),
    z.discriminatedUnion<""network"", string, any>(""network"", [
      z.object({
        model: z.literal(""Human-controlled-2""),
        network: z.literal(""Wi-Fi"")
      }),
      z.object({
        model: z.literal(""Human-controlled-2""),
        network: z.literal(""Bluetooth"")
      })
    ])
  ])
});

test(""valid for 1"", (t) => {
  t.true(
    carScheme.safeParse({
      name: ""valid"",
      settings: {
        model: ""AI-controlled"",
        copilot: true
      }
    }).success
  );
  t.end();
});

test(""valid for 2"", (t) => {
  t.false(
    carScheme.safeParse({
      name: ""valid"",
      settings: {
        model: ""Human-controlled"",
        copilot: false
      }
    }).success
  );
  t.end();
});

test(""valid for 3"", (t) => {
  t.false(
    carScheme.safeParse({
      name: ""valid"",
      settings: {
        model: ""Human-controlled-2"",
        network: ""Bluetooth""
      }
    }).success
  );
  t.end();
});

test(""valid for 4"", (t) => {
  t.false(
    carScheme.safeParse({
      name: ""valid"",
      settings: {
        model: ""Human-controlled-2"",
        network: ""Wi-fi""
      }
    }).success
  );
  t.end();
});
```

",,
1479645902,1644,Recursive type with discriminated union,"Hey 👋

How to transform this recursive discriminated union to zod?

```ts
interface TextInput {
  type: 'text-input';
}

interface Group {
  type: 'group';
  components: AppComponent[];
}

type AppComponent = TextInput | Group;
```

what would the zod version look like?

My attempt:

```ts
import { z } from 'zod';

const TextInputSchema = z.object({
    type: z.literal('text-input'),
});

const GroupSchema = z.object({
    type: z.literal('group'),
    components: z.array(ComponentSchema),
});

const ComponentSchema = z.discriminatedUnion('type', [TextInputSchema, GroupSchema]);

```

but that doesn't work due to the error that `[...] type is referenced directly or indirectly in its own initializer`.",,
1479516836,1643,Schema introspection of optional or required fields,"Hello to everybody,
I am building my forms with zod as a validation solution. Currently I am struggling with finding out, if a field inside an object is required or not. I use this, to display the red asterisk next to a form field so that my schema definition from zod is used for the display and always in sync with the user interface. I have been using the following snippet which has worked out so far:

```ts
const isRequired = (name, schema) => !schema._def.shape()[name]?.isOptional(),
```

This introspects the schema deeper in the tree of my components and checks if inside the `_def.shape()` object there is a field with `name` that is not optional. 

Right now I have a more complex form approach where I am using `superRefine` to manually add issues for a field to be required so this approach doesn't work:

```ts
const schema = z.object({
  attendeeType: z.nativeEnum(AttendeeType),
  company: z.string().optional(),
}).superRefine(({ attendeeType, company }, { addIssue }) => {
  if (attendeeType === AttendeeType.BUSINESS && !company) {
    addIssue({
      code: TOO_SMALL, 
      inclusive: true,
      minimum: 1,
      path: ['company'], 
      type: 'string' 
    })
  }
})
```

Has someone an idea how I get this information for all cases?",,
1478767883,1639,Encapsulates the response logic of safeParse and return a discriminated union,"Hi,

how can I do a reusable generic function to encapsulate the logic of the `safeParse` discriminated response?, something like
```typescript
function zodParse<T>(schema: ZodSchema, fetchResult: any): {
  success: false,
  error: ZodError,
  message: string
} | {
  success: true,
  data: T,
} {
  const parsedResult = schema.safeParse(await fetchResult.json())
  if (!parsedResult.success) {
    return { success: false, error: parsedResult.error, message: parsedResult.error.message }
  }
  return { success: true, data: parsedResult.data } // how to return the type passed on schema?
}

```

I would like to be able to call this function in a return and capture the types where I call the function. I am trying to do it but I get only the field that is in both results objects `success`

![image](https://user-images.githubusercontent.com/4810013/205883669-3e776a5f-d5bb-4731-ae7c-28059f8e6472.png)


Any help appreciated,
Thanks

",,
1477981961,1638,[Bug]Error validate email,"- I use zod and react-hook-form when I validate emails but adding a dash at the end doesn't trigger the error

- I tried using emailRegex in zod doc but no error trigger

- I'm wondering if the problem is there or not?

- I tried with yup and got the trigger error

```
import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import * as z from ""zod"";

const auth = z.object({
  email: z
    .string()
    .email(""正しいメールアドレスの形式で入力してください""),
  password: z.string()
});


const user = z.object({
  firstName: z
    .string()
    .min(1, { message: ""1文字以上入力してください"" })
    .max(10, { message: ""10文字以下で入力してください"" }),
  lastName: z
    .string()
    .min(1, { message: ""1文字以上入力してください"" })
    .max(10, { message: ""10文字以下で入力してください"" }),
  phoneNumber: z.string().regex(/^0\d{9,10}$/, {
    message: ""正しい電話番号の形式で入力してください""
  }),
  role: z.enum([""admin"", ""user""])
});
```
![image](https://user-images.githubusercontent.com/39109300/205795003-f7fcd40f-0524-4714-9226-e664d4e4a938.png)

![image](https://user-images.githubusercontent.com/39109300/205794262-5b0b6c51-6ecf-4bfe-a500-a443cbc4ce8d.png)

![image](https://user-images.githubusercontent.com/39109300/205794327-b13a71ff-e8f0-4df6-8fae-7238d4b54a6e.png)




",,
1476852578,1636,"[Bug] Different result for infer and parse using ""and"" and ""passthrough""","The type from `z.infer<typeof schema>` does not allow `a.z`, but the result from `schema.parse` returns it. See example below:

```typescript
import * as z from 'zod'

const a = z.object({
  a: z.object({
    x: z.string(),
  }),
})

const b = z.object({
  b: z.object({
    y: z.string(),
  }),
}).passthrough()

const schema = a.and(b)

type Test = z.infer<typeof schema>

const test: Test = {
  a: { x: 'foo', z: 'bar' }, // ts complains about ""z"" here
  b: { y: 'foobar' },
}

const parsed = schema.parse(test)

console.log(parsed)
// { a: { x: 'foo', z: 'bar' }, b: { y: 'foobar' } }
```

Btw, thanks for a fantastic library. If there's anything I can help with, let me know.",,
1476441121,1634,`z.custom<T>()` documentation missing.,"Sometimes we just want the type inferences, but not checking them.

The `z.as<T>()` can give you the ability to still use the Type inference but you don't need to change the `T` also to a Zod object.

For example, we can use it like this:
```ts
const HandleFuncZod = z.any().as<(
	req: IncomingMessage,
	res: ServerResponse
) => void>()
type HandleFunc = z.infer<typeof HandleFuncZod>
```

Because we are not able to transform the IncomingMessage and ServerResponse into zod objects and we actually don't need to do that. This is nice hook in many cases. 

The checking process is still available. For example:
```ts
const TaskZod = z.object({
	id: z.string()
}).as<{
	content: TaskContent,
	id: string
}>()
type Task = z.infer<typeof TaskZod>
```

Zod will still check the object being passed to the `.parse()` function by this: `z.object({
	id: z.string()
})`. But the type `Task` is being inferred as `{
	content: TaskContent,
	id: string
}`.

This feature is providing a nice flexibility. Before this, we can probably only use Zod in some data checks because there are many datas that don't need to be checked and types that can't be used in Zod (e.g. the IncomingMessage in the http module) (or using them for the entire app with a bunch of trivial tricks). But after this, Zod can be used in the whole app.",,
1476301342,1633,Type inference with `.default()` isn't telling the right thing,"If we have a Zod type:
```ts
const ExampleZod = z.number().default(0)
type Example = z.infer<typeof ExampleZod>
```

The type of Example is `number` but not `number | undefined`.

It already has a default value, why is it still required?",,
1474210267,1628,Field becomes optional when value is any or unknown,"```ts
const s = z.object({ x: z.unknown() })
type s = z.infer<typeof s>
// s has { x?: unknown } but should be { x: unknown }
```

",,
1470209599,1622,Better localisation support,"The ability to localize error messages should be made easier. For example, the default mapping make use of `util` in `../helpers/util` which does not seem to be exported.

Are localised errors a planned feature? If so, then `src/errors.ts` will have to export them externally (i.e. make them available). There is also the question of using [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) with or without region names? ",,
1469103177,1616,ZodFormattedError does not propagate the custom error format to recursive fields,"`ZodFormattedError` accepts two type params. 

```ts
export type ZodFormattedError<T, U = string>
```

`T` is the type of the input schema and `U` is the type of each error entry. `U` is important when [providing a custom issue mapper](https://github.com/colinhacks/zod/blob/0c4fc53239e89b4349559c7cdb4bc50c5442ab49/src/ZodError.ts#L204). `ZodFormattedError` uses `T` to define the shape of the formatted error object, but it does not propagate `U` to the fields of this object. E.g.:

```ts
... ZodFormattedError<NonNullable<T>[K]>
```

This means that typing fails when trying to access custom error types of a `ZodFormattedError.

Example: the following code should pass typechecking [sandbox](https://codesandbox.io/s/typescript-playground-export-forked-f7llzb?file=/index.ts:0-310):

```ts
import { z } from ""zod"";

const Thing = z.object({
  name: z.string().min(2)
});

const result = Thing.safeParse({ name: ""a"" });
if (!result.success) {
  const formatted = result.error.format((issue) => ({
    code: issue.code,
    message: issue.message
  }));
  console.log(formatted.name?._errors?.code);
}
```

But instead it fails with `Property 'code' does not exist on type 'string[]'.ts(2339)'",,
1468306756,1614,How to implement a generic fetch function that validates the query parameter and json result,"I'm trying to implement a generic fetch function that abstracts away the validation of the query parameters and the json return using `zod` schemas.
I came up with the following prototype but cannot seem to figure out how to type the zod schema parameter:

```typescript
import {z} from 'zod';

const zodFetch = async <TQuerySchema, TResponseSchema>(url: string, querySchema: TQuerySchema, query: z.infer<typeof TQuerySchema>, responseSchema: TResponseSchema): Promise<z.infer<typeof TResponseSchema>> => {
	const response = await fetch(url, {
		method: 'POST',
		headers: {
			'content-type': 'application/json;charset=UTF-8',
		},
		body: JSON.stringify({
			query: querySchema.parse(query),
		}),
	});

	return responseSchema.parse(await response.json());
};


const test = async () => {
	const fooSchema = z.number();
	const barSchema = z.string();

	const response = await zodFetch('https://foobar', fooSchema, 1, barSchema);

	console.log(response);
};

void test();
```",,
1466417805,1610,Nested discriminated unions,"I've got an object that has discriminated unions within discriminated unions:

```json
[
  {
    ""_id"": ""98439752-0cd4-406b-982f-1bbf1df5480d"",
    ""type"": ""data"",
    ""subtype"": ""subtype-1"",
    ""data"": {
      ""id"": ""a8d44d3f-c18a-4178-990c-f543ab8f3a8d"",
      ""url"": ""https://www.google.com"",
      ""title"": {
        ""en"": ""English title""
      }
    }
  },
  {
    ""_id"": ""4f674fe7-368f-4b15-924b-7e61dd982961"",
    ""type"": ""data"",
    ""subtype"": ""subtype-2"",
    ""data"": {
      ""id"": ""160a6427-ec74-4488-bceb-8cebac86b55f"",
      ""path"": ""/"",
      ""description"": ""this is another subtype""
    }
  },
  {
    ""_id"": ""aba34b25-8a33-4046-a62f-c5ff9a6befef"",
    ""type"": ""reference"",
    ""referent"": {
      ""id"": ""b940a1e8-3733-425f-b1ef-667c2ecdab04"",
      ""type"": ""document""
    }
  },
  {
    ""_id"": ""aba34b25-8a33-4046-a62f-c5ff9a6befef"",
    ""type"": ""reference"",
    ""referent"": {
      ""id"": ""b940a1e8-3733-425f-b1ef-667c2ecdab04"",
      ""type"": ""file""
    }
  }
]
```

On the first level the type discriminator is the field `type`. For `type: 'data'`, we can further discriminate the type by the field `subtype`.

When I try to do this with nested usage of `discriminatedUnion` like this:

```ts
import { z } from 'zod';

import data from './data.json';

const ReferenceSchema = z.object({
  _id: z.string(),
  type: z.literal('reference'),
  referent: z.object({
    id: z.string(),
    type: z.enum(['document', 'file']),
  }),
});

const Subtype1Schema = z.object({
  _id: z.string(),
  type: z.literal('data'),
  subtype: z.literal('subtype-1'),
  data: z.object({
    id: z.string(),
    url: z.string().url(),
    title: z.object({
      en: z.string(),
    }),
  }),
});

const Subtype2Schema = z.object({
  _id: z.string(),
  type: z.literal('data'),
  subtype: z.literal('subtype-2'),
  data: z.object({
    id: z.string(),
    path: z.string(),
    description: z.string(),
  }),
});

const DataSchemma = z.discriminatedUnion('subtype', [
  Subtype1Schema,
  Subtype2Schema,
]);

export const Schema = z.array(
  z.discriminatedUnion('type', [ReferenceSchema, DataSchemma])
);

const rc = Schema.parse(data);
```

I get an error saying:

> Error: The discriminator value could not be extracted from all the provided schemas

How can I achieve that once my code checks if `type === 'data'` TypeScript knows that now, there's a field `subtype` and an object called `data`?

_You can play with this example here: https://stackblitz.com/edit/typescript-piewve?devToolsHeight=33&file=index.ts_",,
1465115850,1606,"Add an option to all checks (.min(), .url(), .regex(), ...) to abort early","In some cases, it might be desirable to abort early in any of the type specific validations - checks - like `.min`, `.url`, `.regex` and so on.
An example of this being useful is when they validate a parameter later used in an async refine (#1605), so without aborting early, the async refine is executed with an invalid input.
Currently, you can work around this by implementing these checks yourself using `superRefine`, but it's unnecessarily tedious and verbose. A much simpler way would be to add a `fatal` field to the checks' `message` parameter.",,
1464776242,1602,Add a way for .superRefine() to narrow down the output type,"Currently, `refine` has a type guard which is used to narrow down the output type.

```js
refine<RefinedOutput extends Output>(
  check: (arg: Output) => arg is RefinedOutput,
  message?: /* ... */
): ZodEffects<this, RefinedOutput, RefinedOutput>;

superRefine: (
  refinement: RefinementEffect<Output>[""refinement""]
) => ZodEffects<this, Output, Input>;
```
I propose adding this functionality to `superRefine` as well.",,
1463577316,1598,Chaining refinements which narrow down types gives them inconsistent runtime/static types,"Validation continues after an unsuccessful refine(), which gives it an incorrect return type and can make subsequent effects unexpectedly throw.

Code:
```ts
import { z } from 'zod';

const isNotNull = <T>(val: T | null): val is T => val !== null;

const userSchema = z
  .object({
    type: z.literal('Staff'),
    age: z.number(),
  })
  .nullable()
  // Type guard, I would expect validation to halt here if value is null
  .refine(isNotNull, { message: 'Choose a user type.', path: ['type'] })
  // User is infered as non-null
  .superRefine((user, ctx) => {
    // This should always return false (even according to TS), but it doesn't
    console.log(`superRefine: Is user null: ${user === null}`);
    // If user is null, we get an exception here
    if (user.age < 18) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
      });
    }
  });

const goodResult = userSchema.safeParse({
  type: 'Staff',
  age: 20,
});
console.log({
  success: goodResult.success,
  output: goodResult.success ? goodResult.data : goodResult.error.issues,
});
const issueResult = userSchema.safeParse({
  type: 'Staff',
  age: 15,
});
console.log({
  success: issueResult.success,
  output: issueResult.success ? issueResult.data : issueResult.error.issues,
});
const bugResult = userSchema.safeParse(null); // Exception
console.log({
  success: bugResult.success,
  output: bugResult.success ? bugResult.data : bugResult.error.issues,
});
```
Output:
```
superRefine: Is user null: false
{ success: true, output: { type: 'Staff', age: 20 } }
superRefine: Is user null: false
{
  success: false,
  output: [ { code: 'custom', path: [], message: 'Invalid input' } ]
}
superRefine: Is user null: true
[TypeError: Cannot read properties of null (reading 'age')]
```
Expected output (last line):
```
{
  success: false,
  output: [ { code: 'custom', message: 'Choose a user type.', path: [Array] } ]
}
```

Yes, there is an easy workaround by adding an `if (user !== null) return;` (which I have used for now). But the exception comes out of nowhere and the runtime type is different from the static type (TS tells us user can't be null) which can be very confusing and make the issue hard to find.",,
1463139017,1597,How to dinamically enable/disable optional parts of a schema?,"I have quite a regular situation when one edits more than one group of fields on a form. And depending on some conditions (f.e. checkbox states), those groups can be displayed/hidden and correspondingly - should be validated/skipped.

Consider this simple form:

![image](https://user-images.githubusercontent.com/114060/203760600-5b1fce41-c15e-4d01-96ed-0f20eac4151f.png)

So we enter first and last names, and if we check ""More information"", a new part appears with two additional fields: email and address.

Here is a sandbox:
https://codesandbox.io/s/zod-problem-forked-r7xmcm?file=/src/index.ts

There are two base schemas:

```ts
const group1Schema = z.object({
  firstName: z.string(),
  lastName: z.string()
});

const group2Schema = z.object({
  email: z.string().email(),
  address: z.string()
});
```

And one with their combination for the form:

```ts
const schema = z.object({
  group1: group1Schema,
  group2: group2Schema.optional(),
  needGroup2: z.boolean()
});
```

The problem is that now it's not possible to submit this form w/o the second (optional) part.

There is no form in this sandbox (to keep it minimal) but there is the `defaultValues` const which imitates the corresponding property of the ReactHookForm `useForm()` hook.

As you see, you cannot even initialize such a form with empty values because they get validated and validation doesn't pass. Of course, this is expected behaviour, granted how I declared the schemas. 

Hence my question: **how to conditionally enable/disable parts of the schema**?

This form should pass to its submit handler the following:

1) if only first and last name entered and the checkbox is off:

```json5
{
 group1: {
   firstName: ""value"",
    lastName: ""value""
  },
  needGroup2: false // or underfined
}
```

2) if all values are entered and the checkbox is on:

```json5
{
 group1: {
    firstName: ""value"",
    lastName: ""value""
  },
  group2: {
    email: ""value@domain.com"",
    address: ""Some address...""
  },
  needGroup2: true
}
```

3) **IMPORTANT** if all values are entered, but the checkbox is OFF, the group2 should be discarded, and the result should be equal to the 1st reply:

```json5
{
 group1: {
    firstName: ""value"",
    lastName: ""value""
  },
  needGroup2: true
}
```

If you have any other ideas on how to solve such tasks, please share.

",,
1463083764,1595,Allows enum to be upper and lowercase,"Example
```ts
enum TERRITORIES {
US = 'US'
}

const territory = [TERRITORIES.US, TERRITORIES.US.toLowercase()] as const;

export const obj = z.object({
  territory: z.enum(territory).transform((value) => value?.toUpperCase()),
});
export type OBJType = z.infer<typeof obj>;

const t: OBJType = {
  territory: 'DE', // this is valid ts which shouldnt be :(
};
```

This makes the output be a of type string as the transform changes its type.

We could have a `z.fussyEnum` property that could allows us to pass a enum value and the output would be transformed to the enum value but also accepts the input in lowecase

Example
```ts
enum TERRITORIES {
US = 'US'
}

const territory = [TERRITORIES.US, TERRITORIES.US.toLowercase()] as const;

export const obj = z.object({
  territory: z.fussyEnum(territory)
});
export type OBJType = z.infer<typeof obj>;

const t : OBJType = {
territory: 'us' // valid but when parsed would be transformed to 'US'
}
```",,
1462172398,1590,Typescript widening object properties of Zod enum type to string,"If I define `enum` and use it in the object, the object property still has the type of the `enum`:
```ts
enum A { a = ""a"" }

const a = { a: A.a }
// type of a is { a: A }
```

However, if I define the same enum using zod, the type of object property is `string` and not narrowed to enum anymore.
```ts
const A = z.enum([""a""])

const a = { a: A.a }
// type of a is { a: string }
```
",,
1460511242,1583,docs: CONTRIBUTING.md has stale links,Currently the `CONTRIBUTING.md` file points to the `playground.ts` file under `src/`. Just some small housekeeping.,,
1460299386,1582,intersect mapped enum record and object,"How would I create the equivalent to this with `zod`?
```
enum Status {
  NotStarted = 'not-started',
  InProgress = 'in-progress',
  CompletedSuccesfully = 'completed-succesfully',
  CompletedWithFailures = 'completed-with-failures',
  Failed = 'failed',
}
type StatusReports = {
  [k in Status]: number;
};

type StatusReport = StatusReports & {
  total: number;
};
const sr: StatusReport = {
  total: 5,
  [Status.NotStarted]: 1,
  [Status.InProgress]: 1,
  [Status.CompletedSuccesfully]: 1,
  [Status.CompletedWithFailures]: 1,
  [Status.Failed]: 1,
};
```
## problems I've encountered so far

defining the mapped key type  for `StatusReports` with `z.record()` and `z.nativeEnum(}` yields `Partial<Record<Status, number>>;`,  with the mapped properties incorrectly being optional
```
enum Status {
  NotStarted = 'not-started',
  InProgress = 'in-progress',
  CompletedSuccesfully = 'completed-succesfully',
  CompletedWithFailures = 'completed-with-failures',
  Failed = 'failed',
}
const StatusReports = z.record(z.nativeEnum(Status), z.number());
const sr: z.infer<typeof StatusReports> = {}; // const sr : Partial<Record<Status, number>>
```
even if the mapped key properties were correctly inferred as required, I haven't figured out a way to merge `z.record()` with `z.object({total: number})`
using `z.intersection()` like so complies but throws the following error when parsed at runtime
```
const StatusReportSchema = z.intersection(
  z.record(StatusReports, z.number().min(0)),
  z.object({ total: z.number().min(0) }),
);
```
`""Invalid enum value. Expected 'not-started' | 'in-progress' | 'completed-succesfully' | 'completed-with-failures' | 'failed', received 'total'""`
",,
1459548825,1578,How to get the latest shape of a schema?,"Given the following schema, fetching the `literal` value is quite trivial:

```ts
const schema = z.object({ x: z.literal(""asd"") }).shape.x.value;
  // ^? ""asd""
```

But if I apply any effect, I no longer have to `shape`, since the schema is no ZodEffects rather than ZodObject:

```ts
const schema = z
  .object({ x: z.literal(""asd"") })
  .transform((prev) => ({ ...prev, x: ""asd2"" }))
  .transform((prev) => ({ ...prev, x: ""asd3"" }));
```

Is there a way I could do something like `schema.getFinalShape().x.value`?

I was able to write something like:

```ts
const schema = z
  .object({ x: z.literal(""asd"") })
  .transform((prev) => ({ ...prev, x: ""asd2"" }))
  .transform((prev) => ({ ...prev, x: ""asd3"" }))
  // .refine((prev) => prev.x === ""asd3""); // <-- this would break the function

function getFinalShapeOfZodObjectOrZodEffects<
  T extends z.ZodObject<any> | z.ZodEffects<any, any, any>
>(schema: T): z.infer<T> {
  if (schema instanceof z.ZodObject) {
    return schema.shape;
  }

  if (schema instanceof z.ZodEffects && schema._def.effect.type === ""transform"") {
    return schema._def.effect.transform(null, { addIssue: () => {}, path: [] }); // <-- It's a bit awkward
  }
}
```

but it would fail if the last ""effect"" would be a ""refinement"".",,
1456292482,1573,Union behaves differently depending on order,"Used `v3.19.1`.

`Union` seems to behave differently depending on the order.

```typescript
const Foo = z
  .object({
    a: z.number(),
    b: z.number(),
  })
  .partial();

const Bar = z
  .object({
    x: z.number(),
    y: z.number(),
  })
  .partial();

// the order of Foo and Bar is reversed
const Baz = z.union([Foo, Bar]);
const Qux = z.union([Bar, Foo]);

const onlyA = { a: 1 };
const onlyX = { x: 8 };
const all = { a: 1, b: 2, x: 8, y: 9 };

console.log(Baz.parse(onlyA)); // { a: 1 }
console.log(Qux.parse(onlyA)); // {}

console.log(Baz.parse(onlyX)); // {}
console.log(Qux.parse(onlyX)); // { x: 8 }

console.log(Baz.parse(all)); // { a: 1, b: 2 }
console.log(Qux.parse(all)); // { x: 8, y: 9 }
```

Is this expected behavior?
If so, I would appreciate it if you could tell me what I should do to achieve what I want to do.

**I want to express the following**
Object with optional properties `a` and `b`
or
Object with optional properties `x` and `y`

So I would expect a result like below.

```typescript
ExpectedSchema.parse({ a: 1, b: 2 }) // { a: 1, b: 2 }
ExpectedSchema.parse({ a: 1 }) // { a: 1 }
ExpectedSchema.parse({ x: 8, y: 9 }) // { x: 8, y: 9 }
ExpectedSchema.parse({ x: 8 }) // { x: 8 }
ExpectedSchema.parse({ c: 3 }) // {}

ExpectedSchema.parse({ a: 1, x: 8 }) // Error
ExpectedSchema.parse({ a: 1, b: 2, x: 8 }) // Error
```
",,
1455851160,1572,In the case of use `union` or `or` with an object it only parse to the first schema,"I have the following code:

```typescript
import { z } from 'zod';

export const todoSchema = z.object({
  id: z.string().uuid(),
  title: z.string().trim().min(1),
  completed: z.boolean().default(false),
  order: z.number().positive().default(1),
});

export const updateTodoSchema = z.union([
  todoSchema.pick({ completed: true }),
  todoSchema.pick({ order: true }),
  todoSchema.pick({ title: true }),
]);
```

I expect to receive an object with only one property to update `{ completed: boolean }` or `{ order: number }` or `{ title: string }`

But only the object with `completed` gets parsed, in the other cases the property is deleted and set `completed` to its default value

```typescript
updateTodoSchema.parse({ order: 2 });
// { completed: false }
```

## How to reproduce

Open https://stackblitz.com/edit/zod-union?file=src/schemas.spec.ts

In the console run:
```
npm run build; npm test
```",,
1455557621,1571,Pass schema to function and it returns infer-ed type of schema,"Hey, thank you so much for this library, it is awesome!!

I try to achieve validation function for http responses, that could:

1. accept  response schema as argument
2. validate response against schema
3. return validated response or throw an error

Below is my maximum I could create :sweat_smile:  and it works in simple cases.

```ts
async function requestWithValidate<T>(
	httpCall: () => Promise<unknown>,
	schema: z.ZodSchema<T>
): Promise<T> {
	try {
		const response = await httpCall();
		return schema.parse(response);
	} catch (e) {
		if (e instanceof ZodError) {
			e = e.format();
		}
		throw e;
	}
};
```

However, when I pass schema that contains `ZodEffect`(schema field with pre-processor for example) I have type incompatibility.
I have it for `Date` fields and for them I get `Type 'unknown' is not assignable to type 'Date'`

Pre-processor:
``` ts
const stringToDateConvert = z.preprocess((arg) => {
    if (typeof arg === 'string' || arg instanceof Date) {
        return new Date(arg);
    }
}, z.date());
```
Example schema:
``` typescript
z.object({
    id: z.number(),
    date: stringToDateConvert.nullable(),
}).nullable();
```

Could you please help with setup of generics for this function that could work even with any Zod type?",,
1454372602,1569,ZodObject.pick() looses shape type when schema is created via a function,"This is a similar issue to #1453 but relates to the pick function instead of the merge function and the workaround which @elmeister suggested of proving an explicit return type for the factory function does not appear to work here.

<hr />

Given a schema like:
```typescript
const baseSchema = z.object({
  foo: z.string(),
  bar: z.string()
});
```

If a subset of keys are picked from it like so:
```typescript
const schemaSubset = baseSchema.pick({ foo: true });
```

Then the infered type preduced by the schema should be an object with just that subset of keys, which it does:
![Screen Shot 2022-11-18 at 14 09 13](https://user-images.githubusercontent.com/346340/202608113-b747e365-519f-45af-bc41-cf5432005bb7.png)

However if a factory pattern is used to construct that subset schema like so:
```typescript
type ZodGetShape<Schema extends z.AnyZodObject> = ReturnType<
  Schema[""_def""][""shape""]
>;

function createSchema<
  BaseSchema extends z.ZodObject<ZodRawShape>,
  KeysSubsetObject extends { [k in keyof ZodGetShape<BaseSchema>]?: true }
>(baseSchema: BaseSchema, keysSubsetObject: KeysSubsetObject) {
  return baseSchema.pick(keysSubsetObject);
}
```
And a new schema is created using that function:
```typescript
  const schemaSubset = createSchema(baseSchema, { foo: true });
```

Then the type of resulting schema is just an empty object which is not very helpful:
![image](https://user-images.githubusercontent.com/346340/202608368-43d3c8bd-00d1-4f43-bdd9-fb52a1b18655.png)

I attempted to work around this by providing an explicit return type based on the [return type of ZodObject's pick function](https://github.com/colinhacks/zod/blob/6ce18f3de2ce29c3c3eb35ac08983d181311b40e/src/types.ts#L2018):

```typescript
type ZodGetShape<Schema extends z.AnyZodObject> = ReturnType<
  Schema[""_def""][""shape""]
>;

type ZodPick<
  BaseSchema extends z.AnyZodObject,
  Mask extends { [k in keyof ZodGetShape<BaseSchema>]?: true }
> = z.ZodObject<
  Pick<
    ZodGetShape<BaseSchema>,
    Extract<keyof ZodGetShape<BaseSchema>, keyof Mask>
  >,
  BaseSchema[""_def""][""unknownKeys""],
  BaseSchema[""_def""][""catchall""]
>;
```

This this ment the factory function now returns the correct type, however instead an error is given when attempting to return the new schema:
```typescript
function createSchema<
  BaseSchema extends z.ZodObject<ZodRawShape>,
  KeysSubsetObject extends { [k in keyof ZodGetShape<BaseSchema>]?: true }
>(
  baseSchema: BaseSchema,
  keysSubsetObject: KeysSubsetObject
): ZodPick<BaseSchema, KeysSubsetObject> {
  // If the return type for this function is correct then this should not fail but it does
  return baseSchema.pick(keysSubsetObject);
}
```
```
Type 'ZodObject<Pick<ZodRawShape, Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>>, ""strip"", ZodTypeAny, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }>' is not assignable to type 'ZodPick<BaseSchema, KeysSubsetObject>'.
  Type 'Pick<ZodRawShape, Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>>' is not assignable to type 'Pick<ReturnType<BaseSchema[""_def""][""shape""]>, Extract<keyof ReturnType<BaseSchema[""_def""][""shape""]>, keyof KeysSubsetObject>>'.
    Type 'Extract<keyof ReturnType<BaseSchema[""_def""][""shape""]>, keyof KeysSubsetObject>' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
      Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
        Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
          Type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject> | Extract<symbol, keyof KeysSubsetObject>' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
            Type 'Extract<symbol, keyof KeysSubsetObject>' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
              Type 'keyof KeysSubsetObject & symbol' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
                Type 'keyof KeysSubsetObject & symbol' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                  Type 'Extract<symbol, keyof KeysSubsetObject>' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                    Type 'keyof KeysSubsetObject & symbol' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                      Type 'Extract<keyof ReturnType<BaseSchema[""_def""][""shape""]>, keyof KeysSubsetObject>' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                        Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                          Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'keyof KeysSubsetObject & number'.
                            Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'number'.ts(2322)
```

I've created a live example here and you can observe the constructed types by hovering over the relevant sections of code: https://codesandbox.io/s/zod-pick-typescript-issue-oskpx8",,
1452958750,1566,Intersection does not work with Date and Error,"I found two different cases where intersection does not work.

First with Date:
```typescript
const Schema = z.instanceof(Date).and(z.object({ foo: z.string().optional() }));
const date: z.infer<typeof Schema> = new Date();
date.foo = ""bar"";

const t = Schema.parse(date);
```
should work but it throws an error
```
Uncaught ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""object"",
    ""received"": ""date"",
    ""path"": [],
    ""message"": ""Expected object, received date""
  }
]
```


Then with Error:
```typescript
const Schema = z.instanceof(Error).and(z.object({ foo: z.string().optional() }));
const error: z.infer<typeof Schema> = new Error();
error.foo = ""bar"";

const parsed = Schema.parse(error); // { foo: 'bar' }
parsed instanceof Error; // false
```
the object returned by parse() does not match the type of the schema.

I might create two separated issues if you prefer.

This issue might be related to https://github.com/colinhacks/zod/issues/1471",,
1452172268,1563,"`pick`, `omit`, `require` & `partial` should use arrays instead of objects","I was wondering what the rationale behind `pick`, `omit`, `require` and `partial` expecting objects is?

Each value is optional and can only be true, so using
```ts
.pick(['foo', 'bar'])
```
feels more sensible than
```ts
.pick({ foo: true, bar: true })
```

There is another reason than convenience:  
Currently you can (accidentally) add properties, which do not exist on the original object.  
With an array you could ensure type safety.  

The signature would look like this
```ts
pick<Mask extends Array<keyof T>>(mask: Mask): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;
```

If you agree I could offer to implement this.
Either in a backwards compatible way (also accepting objects, using overloads) or as a breaking change.",,
1451014858,1562,Deep Pick/Omit,"It would be cool if we could extend the existing pick/omit utilities to pick/omit deeply where possible.

eg.

```ts
const DeepSchema = z.object({
    a: z.object({
      b: z.string(),
      c: z.string(),
    }),
  });
  
const DeepPickSchema = DeepSchema.pick({
  a: { b: true }
});

// Equivalent of:
z.object({
  a: DeepSchema.shape.a.pick( { b: true } )
});
```

I'm trying to work on this now but it's difficult to tame the types! 

This seems to work for the input of mask:

```ts
type DeepMask<T> = T extends ZodObject<infer Shape>
  ? DeepMask<Shape>
  : T extends ZodRawShape
  ? {
      [k in keyof T]?: true | DeepMask<T[k]>;
    }
  : never;
```",,
1450669504,1561,Property 'catch' does not exist on type 'ZodNumber'.,"Sorry for bothering you guys. I ran an example from the `README.md` and it's not compiling. Am I doing something wrong?

**Code:**

```typescript
import { z } from ""zod"";

const numberWithCatch = z.number().catch(42);

numberWithCatch.parse(5); // => 5
numberWithCatch.parse(""tuna""); // => 42
```
**Error:**

```
/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/index.ts:859
    return new TSError(diagnosticText, diagnosticCodes, diagnostics);
           ^
TSError: ⨯ Unable to compile TypeScript:
trash/zod.ts:3:36 - error TS2339: Property 'catch' does not exist on type 'ZodNumber'.

3 const numberWithCatch = z.number().catch(42);
                                     ~~~~~

    at createTSError (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/in
dex.ts:859:12)
    at reportTSError (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/in
dex.ts:863:19)
    at getOutput (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/index.
ts:1077:36)
    at Object.compile (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/i
ndex.ts:1433:41)
    at Module.m._compile (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/sr
c/index.ts:1617:30)
    at Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Object.require.extensions.<computed> [as .ts] (/home/<user>/.nvm/versions/node/v16.16.0
/lib/node_modules/ts-node/src/index.ts:1621:12)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12) {
  diagnosticCodes: [ 2339 ]
}
```",,
1448151324,1559,Any Zod middleware validator?,"Hi there 👋 

First of all, I'm amazed at how easy it is to work with Zod compared to my previous experience with Joi/Yup. Great job! 👌 

We decide to go with Zod as it was a breezy experience to integrate into our TypeScript codebase (frontend/backend) and we are somewhat happy with our decision so far.

We are now using a custom middleware for validating payloads on Express which is the web framework we choose to go with years ago, but we couldn't find a decent alternative to [`celebrate`](https://github.com/arb/celebrate) at the moment, and [`express-zod-api`](https://github.com/RobinTail/express-zod-api) seems to be too much for us right now, but maybe in the following months, we'll find something or even refining our current in-house solution to an OSS. 👀 

We hope to see Zod being the next big thing by improving its performance and adoption. 🚀 ",,
1446317422,1554,Zod complaining non empty field is empty with SolidJS,"I am using the latest version of solid js with zod.
I have set up a schema and am using the ```extend: [ validator({ schema })]```. The problem is when I reactively update a Signal, the form inputs are updated with the latest input values, but for some reason Zod cannot see them and keeps throwing errors because it thinks the inputs are empty when they are not. Copy/pasting the values back into the inputs fixes the error messages.

 ```ts
const [profile, setProfile] = createSignal<Profile | null>();

function fetch(uuid: string): Promise<Profile> {
    return Client.get(id);
}

const { errors, form, isValid } = createForm({
    extend: [
        validator({ schema }),
    ],
    onSubmit: (formValues: any) => {
      // do update 	
    },
    onError: (e) => Logger(e),
});

function getprofile(uuid: string) {
        fetch(uuid)
            .then((res) => {
                if (res.success) {
                    if (res.data) {
                        setProfile(res.data);
                    }
                }
            });
}

export default (props: { id: string }) => {
    return (
        <>
            <Switch>
                <Match when={profile()}>
                    <StoreProvider store={profile}>
                        <ProfileForm
                            errors={errors}
                            form={form}
                            isValid={isValid()}
                        />
                    </StoreProvider>
                </Match>
            </Switch>
        </>
    );
};

```

ProfileForm:
```ts
export default (props: Props) => {
    const [profile] = useStore()!;
    const { form } = props;
    return (
    <form use:form>
        <section>
            <input text=""name"" value={profile().name} />
        </section>
    </form> 
    ); 
});
```

Schema:
```ts
export default z.object({
    name: z.string().min(1, 'Enter a profile name'),
});

```",,
1444640737,1552,Typesafe way to re map tuple,"I would like to write a function that can transform the elements of a zod tuple in a typesafe way. the goal is to make all elements in a tuple optional i.e `z.tuple([z.string(), z.number()])` => `z.tuple([z.string().optional(), z.number().optional()])`. so far I've written `z.tuple(inputSchema.items.map((schema) => schema.optional()))` which seems to work at runtime, but causes typescript errors and doesn't preserve the types/order of the tuple items when using `z.infer`. any ideas?",,
1444583247,1551,Addition of ZodIssueCode.invalid_literal custom error message broken. ,"Reference commit: [Add invalid_literal issue](https://github.com/colinhacks/zod/commit/823dda93193ab23f07b7e4625e54b1e8528cc530#diff-c54113cf61ec99691748a3890bfbeb00e10efb3f0a76f03a0fd9ec49072e410a)

ZodLiteral takes a `RawCreateParams`object that allow to customize error message.

That object is passed through `processCreateParams()`, but that function has not been updated to support the ìnvalid_literal` type.

Before the commit in reference, it was possible to customize the error message using the 'invalid_type_error' property. But since the issue code is now **invalid_literal** instead of **invalid_type**, the default error message is returned every time. ([types.ts#L118](https://github.com/colinhacks/zod/blob/c617ad3edbaf42971485f00042751771c335f9aa/src/types.ts#L118))

It still possible to customize the ZodLiteral error message by passing a custom ZodErrorMap, but I wonder if the current behavior brought by the change was really intended.",,
1442526430,1550,".required({requiredProperty: true}) expects 0 arguments, but got 1","```ts
const optionalObject = z
    .object({
        name: z.string({ required_error: r.name.required }).min(3, r.name.min).max(20, r.name.max).trim(),
        email: z.string({ required_error: r.email.required }).email(r.email.email).trim(),
        confEmail: z.string({ required_error: r.email.required }).email(r.email.email).trim(),
        request: z.string({ required_error: r.request.required }).min(3, r.request.min).trim(),
        acceptedTerms: z.literal(true, { required_error: r.acceptedTerms.oneOf }),
    })
    .partial()
const requiredObject = optionalObject.required({name: true})
```
When calling optionalObject.required({name: true}), typescript complains that it's expecting 0 arguments, but got 1.
Indeed, when checking the source code, there is only required().
But the docs are saying that:
""You can also specify which properties to make required:

```ts
const requiredEmail = user.required({
  email: true,
});
```
""
How can I make only a property required from the whole schema which was turned into optional by .partial()?
",,
1435064664,1540,How can I make a property optional without adding `undefined` to its type?,"I'm trying to parse values into this type:

```ts
type FormattedText = { text: string; bold?: true; };
```

The `bold` flag, if present, is always the value `true`. Example test cases:

```js
// Valid values include
{ text: ""foo"" }
{ text: ""foo"", bold: true }

// Invalid values include
{ text: ""foo"", bold: false }
{ text: ""foo"", bold: undefined }
```

(This schema is designed to work with [Slate](slatejs.org), and the values are in a database. The design is therefore non-negotiable.)

I can't figure out how to configure zod to make the `bold` property optional, without also adding `undefined` to the type of the property. The `.optional()` method seems to do conflate the two: it makes the property optional, but also allows the value `undefined` if present. For example, `zod.parse` allows the value `{ text: ""foo"", bold: undefined }`.

I realize I could do this with `.refine()`, but then the constraint is not represented in the type system. I want the type of `.parse()` to be `{ text: string; bold?: true; }`.",,
1434551517,1539,When merging two zod objects (using .extend) they are deemed not equal,"Apologies in advance if this is a problem with `@type-challenges/utils` but I've never known it to be wrong before. 

I need to get two separate types to align as I'm (annoyingly) working with two separate type systems; one pre-built the other inferred from a Zod schema. 

This works well other than using  `STest1.extend(STest2.shape)` where `STest1` & `STest2` are Zod schemas. Minimum viable example below

```ts
import type { Equal, Expect } from '@type-challenges/utils'
import { z } from 'zod'

const STest1 = z.object({ a: z.string() })
const STest2 = z.object({ b: z.boolean() })
const STest = STest1.extend(STest2.shape)

type TISTest1 = z.infer<typeof STest1> // irrelevant
type TISTest2 = z.infer<typeof STest2> // irrelevant
type TISTest = z.infer<typeof STest>

type TTest1 = { a: string }
type TTest2 = { b: boolean }
type TTest = TTest1 & TTest2

export type Cases = [Expect<Equal<TISTest, TTest>>]
```",,
1433203491,1536,Anyway to do forbidden properties that have a default?,"I would like to have an object like so:

```ts
export const register = z.object({
  email: z.string().email(),
  password: z.string().superRefine(password),
  first_name: z.string(),
  last_name: z.string(),
  role: z.literal('user'),
  is_email_verified: z.literal(false)
});
```

But in this object I don't want the role or user to be parsed in but I would like default values if this makes sense. In Joi I would do:

`role: Joi.forbidden().default('user')`

This way I can add values to the object that weren't there initially.

Is there any way to do this in zod?",,
1425916728,1527,Recursive type with promise - Recursive property returns a unresolved promise,"Hello all,

I just came across a case that confuses me.

The APIs response has a recursive structure. The object returned from the function call to the API is a promise.

I'm somewhat following the docs having an interface and then calling 

```
[...]z.ZodType<Something> =
	z.lazy(() =>
		z.promise(
			z.object({[...]
```

The non-recursive attributes are resolved, but the attributes of the recursive property are now a promise (even though they are contained in the object I get back). Somehow I seem to be missing how I should explain that the outer object is a promise, not every recursive element in it.

Would appreciate it if someone could jump in with an explanation 👍
",,
1425321326,1526,z.date() does not pick custom error messages,"Using latest `""zod"": ""^3.19.1""`
```ts
import { z } from ""zod"";
...
      dateOfBirth: z
        .date({
          required_error: ""Please select a date and time"",
          invalid_type_error: ""That's not a date!""
        })
...
```
![Screenshot from 2022-10-27 12-22-23](https://user-images.githubusercontent.com/115006985/198247467-3b9bf5f6-1f3c-4467-9cd2-b51bb33ace07.png)

",,
1424242706,1523,Add support to conditional typings ,"Hi there,

I've been working on a feature with dynamic schemas that I need to validate some rules, but I'm having trouble with typescript errors in `refine` or `superRefine`.

```ts
import { z } from 'zod';

// Dynamic condition that the user can change, for example
let isForm1Active = false;

// Basic schema
const form1Schema = z.object({
  name: z.string(),
  age: z.number(),
});

// Dynamic schema
const schema = z
  .object({
    form1: isForm1Active ? form1Schema : z.unknown(),
  })
  .refine((args) => {
    // args.form1.name is not accessible, ok

    if (isForm1Active) {
      // args.form1.name is still not accessible
      // maybe here, like in union types in typescript, this should work?
    }
  });

```

Is there another way to work with dynamic items without losing the type safety of zod?

Live preview:
https://stackblitz.com/edit/typescript-kaf78i?file=index.ts

Thanks in advance and congratulations on this lib, the syntax to validate everything is so neat! 
",,
1423851712,1522,Feature Requests - Codec-like behavior and derivative schemas,"Hello! Once again I am finding myself with the same dragons I did a few months back (maybe you remember?)
I am now older and wiser, and can more accurately present what specific feature I'm missing!

I wish there was a way to make zod act as a codec / iso, so that given `unknown`, `A` output and `B` input, I can do the following
```ts
// encode has the signature of (value: number) => string, or maybe theres a type error if the chain of encodes doesn't end up with the original type
const Dto = z.string().transform(Number).transform(n => n * 2).encode(n => String(n/2)) // ZodCodec<number,string>

declare const someInput: unknown
const a = Dto.parse(someInput) // type number
const b = Dto.unparse(someInput) // type error, unknown is not number
const b = Dto.unparse(a) // type string
```
it can be sorta done manually right now, but requires 2 separate schemas instead of a schema and mapper
```ts
const Dto = z.string().transform(Number)
const ParsedDto = z.number().transform(String)

const a = Dto.parse(someInput) // number
const b = ParsedDto.parse(someInput) // string
const b = ParsedDto.parse(a) // string
```
------------------

Taking the previous idea further,
I wish something like a derivative schema is possible, currently this is what is required for a similar functionality
```ts
export const None = z.object({
  _tag: z.literal(""None""),
})

export const Some = <T extends z.ZodTypeAny>(schema: T) =>
  z.object({
    _tag: z.literal(""Some""),
    value: schema,
  })

export const Option = <T extends z.ZodTypeAny>(schema: T) =>
  z.discriminatedUnion(""_tag"", [None, Some(schema)])

declare const fromNullable: <A>(value: A | null | undefined) => Option<A>
declare const isSome: <A>(value: Option<A> ) => value is Some<A>

const Dragon = z.object({
  dragonName: z.string().array().transform(s => s.join(' ')), // string[] -> string
  humanName: z.string().nullish().transform(fromNullable) // string? -> Option<string>
})

const DragonFriend = z.object({
  dragonName: z.string(),
  humanName: Option(z.string())
})
```
But it could be much more succinct and less error-prone if I could do something like this:
```ts
declare const fromNullable: <A>(value: A | null | undefined) => Option<A>
declare const isSome: <A>(value: Option<A> ) => value is Some<A>


const Dragon = z.object({
  dragonName: z.string().array().transform(s => s.join(' ')), // string[] -> string
  humanName: z.string().nullish().transform(fromNullable) // string? -> Option<string>
})

const DragonFriend = z.derive(Dragon, {
  dragonName: schema => schema.transform(s => `${s} the kind-hearted`),
  humanName: schema => schema.transform(o => isSome(o) ? o.value : ""Colin"")
})
```
-----------

these 2 features are iterative over each other, since my implementation idea for deriving the schema was leveraging codecs giving me type-safety for ""reverse getting"" inputs from parsed values. Basically as long as the input of the derived schema (`DragonFriend`) is typesafe to the `unparse` of the the source schema (`Dragon`), you can basically unparse and re-parse to ensure that the input for the derived schema is legal for both the source and the iteration.

```ts

const Dragon = z.object({
  dragonName: z.string()
    .min(4)
    .array()
    .min(2)
    .transform(s => s.join(' '))
    .encode(a => a.split("" "")), // ZodCodec<string, string[]>
  humanName: z.string()
    .nullish()
    .transform(fromNullable)
    .encode(o => o.value) // ZodCodec<Option<string>, string | null | undefined>
})

// hopefully possible
const DragonFriend = z.derive(Dragon, {
  dragonName: schema => schema.transform(s => `${s} the kind-hearted`),
  humanName: schema => schema.transform(o => isSome(o) ? o.value : ""Colin"")
})
```
and abstractly under the hood of dragonName schema:
```ts
// idk it comes from somewhere 
declare const originalCodec: ZodCodec<string, string[]>

// the `schema => schema.transform(...)` from above
declare const newSchema: <Z extends ZodTypeAny, N extends ZodTypeAny>(schema: Z) => N

// DragonFriend.parse implementation
// unlike regular schemas, does not parse `unknown` to `Dragon`, it parses `Dragon` to `DragonFriend`
const derivedParse = (toParse: z.CodecOutput<typeof originalCodec>) /* string */ => {
    const codecInput = originalCodec.encode(toParse) // string[]
    return newSchema(originalCodec).parse(codecInput) // string
}
```
The above suggestion unparses the input to the `derivedParse` and then re-parses it, making sure that the given object is not just of type `Dragon`, it's also a _valid_ `Dragon` before it declares it to be a `DragonFriend`



",,
1423198836,1518,ZOD [Error]: Schema with id 'Schema' already declared,"I am new to Fastify and Typescript. I am working on adding Zod schemas for validation and I am getting this error:

```
/app/node_modules/fastify/lib/schemas.js:32
    throw new FST_ERR_SCH_ALREADY_PRESENT(id)
          ^
FastifyError [Error]: Schema with id 'Schema' already declared!
    at Schemas.add (/app/node_modules/fastify/lib/schemas.js:32:11)
    at SchemaController.add (/app/node_modules/fastify/lib/schema-controller.js:58:30)
    at Object.addSchema (/app/node_modules/fastify/fastify.js:601:29)
    at /app/src/index.ts:23:12
    at Generator.next (<anonymous>)
    at /app/src/index.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/app/src/index.ts:4:12)
    at main (/app/src/index.ts:32:12)
    at Object.<anonymous> (/app/src/index.ts:63:1) {
  code: 'FST_ERR_SCH_ALREADY_PRESENT',
  statusCode: 500
```
From Fastify docs:

```
FST_ERR_SCH_ALREADY_PRESENT
A schema with the same $id already exists.
```
I am not sure where eaxctly is this $id being set

When I just had one schema and was adding it to fastify in index.ts it was working:

```
for (const schema of userSchemas) {
   server.addSchema(schema);
}
```

But adding another schema, throws the above error:

```
for (const schema of [...userSchemas, ...teamSchemas]) {
   server.addSchema(schema);
}
```
`package.json` versions

```
 ""fastify"": ""^4.6.0"",
 ""fastify-cors"": ""^6.1.0"",
 ""fastify-zod"": ""^1.2.0"",
 ""zod"": ""3.19.1"",
 ""zod-to-json-schema"": ""^3.18.1""
```

`user schema:`

```
import { z } from 'zod';
import { buildJsonSchemas } from 'fastify-zod';
import {
  CreateUserRequest,
  UpdateUserRequest,
  UserResponse
} from '../../services/user/interface';

const createUserSchema: z.ZodSchema<CreateUserRequest> = CreateUserRequest;

const updateUserSchema: z.ZodSchema<UpdateUserRequest> = UpdateUserRequest;

const responseUserSchema: z.ZodSchema<UserResponse> = UserResponse;

export const { schemas: userSchemas, $ref } = buildJsonSchemas({
  createUserSchema,
  updateUserSchema,
  responseUserSchema
});
```

`team schema`

```
import { buildJsonSchemas } from 'fastify-zod';
import { z } from 'zod';
import {
  CreateTeamRequest,
  TeamResponse,
  UpdateTeamRequest
} from '../../services/team/interface';

const createTeamSchema: z.ZodSchema<CreateTeamRequest> = CreateTeamRequest;

const updateTeamSchema: z.ZodSchema<UpdateTeamRequest> = UpdateTeamRequest;

const responseTeamSchema: z.ZodSchema<TeamResponse> = TeamResponse;

export const { schemas: teamSchemas, $ref } = buildJsonSchemas({
  createTeamSchema,
  updateTeamSchema,
  responseTeamSchema
});
```
Any idea what I maybe missing here.

Here is the complete SO question:
https://stackoverflow.com/questions/73980097/zod-error-schema-with-id-schema-already-declared",,
1418141153,1510,Support `exactOptionalPropertyTypes` for `partial` and `optional` helpers,"Hi!

Zod is adding the `undefined` type to all keys that are optional when using the different `.partial()` modifiers.

How about differentiating them by being present and undefined or just not present at all like typescript does with `exactOptionalPropertyTypes: true`.

Would it be possible to implement in zod? I guess it could be the default since if you don't care you don't care. Also just using the typescript `Partial` type will actually honor `exactOptionalPropertyTypes` by default (on the type level that is).",,
1416848720,1508,what's the best way to deep merge objects ?,"Hi,
Here's an example of the `.merge` behaviour : 

```ts
const childA = z.object({
  childA: z.string(),
});

const parentA = z.object({
  a: z.string(),
  child: childA,
});

const childB = z.object({
  childB: z.string(),
});

const parentB = z.object({
  b: z.string(),
  child: childB,
});

const notWorking = parentA.merge(parentB);
type NotWorking = z.infer<typeof notWorking>;
//type NotWorking = {
//  a: string;
//  child: {
//      childB: string;
//  };
//  b: string;
//}

const working = parentA
  .merge(parentB)
  .merge(z.object({ child: parentA.shape.child.merge(parentB.shape.child) }));
type Working = z.infer<typeof working>;
//type Working = {
//  a: string;
//  child: {
//      childA: string;
//      childB: string;
//  };
//  b: string;
//}
```

the working / not working is a poorly chosen way to express that I was expecting the `merge` function behaviour to propagate to children.

is there a recommended way to get the ""working"" one easily ? (maybe I didn't find the function in the doc).

looks like the `.and` / `intersection` do pretty much that but can't be extended so it's a dead-end in my situation.",,
1413528674,1504,Is there a way to combine `discriminatedUnion` with `lazy`?,"Hello,

I stumbled on this problem.

When using lazy (recursive types) I cannot use discriminatedUnion anymore.

```ts
import z from ""zod"";

type SomeOtherObject = {
  type: ""some-other-type"";
  randomProperty: string;
};

const someOtherObjectWithADiscriminatingType = z.object({
  type: z.literal(""some-other-type""),
  randomProperty: z.string()
});

type RecursiveElement = {
  type: ""recursive-element"";
  children: MyUnion[];
};

const recursiveElement: z.ZodType<RecursiveElement> = z.lazy(() =>
  z.object({
    type: z.literal(""recursive-element""),
    children: myUnion.array()
  })
);

type MyUnion = RecursiveElement | SomeOtherObject;
```


What works is
```ts
const myUnion = z.union([
  recursiveElement,
  someOtherObjectWithADiscriminatingType
]);
```

But I would love to use `discriminatedUnion` here.

```ts
const myUnion = z.discriminatedUnion(""type"",[
  recursiveElement,
  someOtherObjectWithADiscriminatingType
]);
```

Any way I can type lazy object recursiveElement somehow that it does not throw an error?

Here is this problem in CodeSandBox: https://codesandbox.io/s/lucid-wilson-k5x1pu?file=/src/App.tsx:682-792",,
1411631576,1500,Cannot use branding and flavoring with Lazy,"Hello,
I'm using flavoring concept while working with zod, and I stumbled upon typing the recursive pattern.
That is the case:
```ts
import {z} from 'zod';

type Flavored<
  T extends string,
> = string & {
  __flavor: T;
};

const flavored = <T extends string>(x: string): x is Flavored<T> => true;

const flavoredType = z.string().refine<Flavored<'flavor1'>>(flavored);

const fooSchema = z.strictObject({
  kind: z.literal('foo'),
  data: flavoredType,
});

type ComplexSchema =
  | z.infer<typeof fooSchema>
  | {
      kind: 'complex';
      schemas: ComplexSchema[];
    };

const complexSchema: z.ZodType<ComplexSchema> = z.lazy(() =>
  z.union([
    fooSchema,
    z.strictObject({
      kind: z.literal('complex'),
      schemas: z.array(complexSchema),
    }),
  ]),
);
```

It ends up with an error:
```
Type 'ZodLazy<ZodUnion<[ZodObject<{ kind: ZodLiteral<""foo"">; data: ZodEffects<ZodString, Flavored<""flavor1"">, string>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>' is not assignable to type 'ZodType<ComplexSchema, ZodTypeDef, ComplexSchema>'.
  Types of property '_input' are incompatible.
    Type '{ kind: ""foo""; data: string; } | { kind: ""complex""; schemas: ComplexSchema[]; }' is not assignable to type 'ComplexSchema'.
      Type '{ kind: ""foo""; data: string; }' is not assignable to type 'ComplexSchema'.
        Type '{ kind: ""foo""; data: string; }' is not assignable to type '{ kind: ""foo""; data: Flavored<""flavor1"">; }'.
          Types of property 'data' are incompatible.
            Type 'string' is not assignable to type 'Flavored<""flavor1"">'.
              Type 'string' is not assignable to type '{ __flavor: ""flavor1""; }'.
```

It seems like `data` loses its refinement in this case. If I change `data` to be `z.string()` everything works perfectly.",,
1410627698,1499,Zod Structure,"I am trying to add more validation's types, but this structure is so hard to understand because all types are in same file `types.ts` 

Sugestion:
at the moment `types.ts` has 4000 lines, what do you guys think to split it in one folder `types` and create files by type, ex:
```md
src/types
src/types/string.ts
src/types/number.ts
```",,
1410567279,1498,[Question] How to give type to Zod Arrays,"So I have a type 

e.g. `type QualityTypes = 'thing1' | 'thing2' |  'thing3' |  'thing4' |  'thing5'`

Now I want a zod array with `QualityTypes` as the type of the array when I infer the value of the zod object.

e.g.

```typescript
const personSchema = z.object({
    name: z.string().required(),
    qualities: z.array(z.string()).optional()
})

type Person = z.infer<typeof personSchema>;

/*
Person = {
    name: string;
    qualities: string[]
}
*/
```  

I wanna make it so that the qualities property says, `qualities: QualityTypes[]`
",,
1409741874,1493,Handling multiple forms with discriminated union,"ValidationSchema = z.object({
  ParentBlock: z.object({    
    **choiceOfForm** : z.enum
    DataBlock: z.discriminatedUnion(**choiceOfForm**, [
                 z.object({ choiceOfForm = 1, empty fields})   //corresponds to the basic form
                 z.object({ choiceOfForm = 2, just username/pw fields)   //corresponds to less basic form
                 z.object({ choiceOfForm = 3, user/pw + many fields})   //corresponds to advanced form
          ])
      })
})

**choiceOfForm** is an ENUM corresponding to 3 radio buttons. The corresponding form depending on selection. 
I would like to use ZOD's discriminatedUnion function to enable the correct form validation block depending on which **choiceOfForm** is selected (1,2 or 3). Is there a way to pass the **choiceOfForm** variable to the discriminatedUnion (enumHere, ...) to do this?

Thank you
    ",,
1407932991,1490,`discriminatedUnion` produces TS error when `.default` or `.preprocess` are applied,"[Playground link.](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFAxhAHYDO8AYhBAMrUAWApiAIZwAvCgB0EAEYArHtRgAKBBThwYATzA8AXGIA2wGDyj9d8-Jjb4AlKOI9M-AK66F5y1YA0yuPx3JRTFDAdADm8p4UaFaUNPRMcABC-FCcvALCYpIycore6pp+ovqGxqb41I5MuNZeKiA8MFwkhYHBYRFRMbSM8EnIqXyCIv7EwAzUQSDB-IbEAKp0wPRm+Tz4HnAA2qwc3IMbSSl7AgC60bGMELo8RRBhfQMComDJDDyKPjpuEPjoVudAA)

Given this snippet:

```ts
import { z } from 'zod';

const FooSchema = z.object({
  type: z.literal('foo').default('foo'),
  a: z.string(),
});

const BarSchema = z.object({
  type: z.literal('custom'),
  method: z.string(),
});

const BazSchema = z.discriminatedUnion('type', [FooSchema, BarSchema]);
console.log(BazSchema.parse({ a: 'foo' }));
```

TypeScript produces this error:

```
$ tsc tmp.ts
tmp.ts:13:49 - error TS2322: Type 'ZodObject<{ type: ZodDefault<ZodLiteral<""foo"">>; a: ZodString; }, ""strip"", ZodTypeAny, { type?: ""foo""; a?: string; }, { type?: ""foo""; a?: string; }>' is not assignable to type 'ZodDiscriminatedUnionOption<""type"", Primitive>'.
  Type '{ type: z.ZodDefault<z.ZodLiteral<""foo"">>; a: z.ZodString; }' is not assignable to type '{ type: ZodLiteral<Primitive>; } & ZodRawShape'.
    Type '{ type: z.ZodDefault<z.ZodLiteral<""foo"">>; a: z.ZodString; }' is not assignable to type '{ type: ZodLiteral<Primitive>; }'.
      Types of property 'type' are incompatible.
        Property 'value' is missing in type 'ZodDefault<ZodLiteral<""foo"">>' but required in type 'ZodLiteral<Primitive>'.

13 const BazSchema = z.discriminatedUnion('type', [FooSchema, BarSchema]);
                                                   ~~~~~~~~~

  node_modules/zod/lib/types.d.ts:531:9
    531     get value(): T;
                ~~~~~
    'value' is declared here.


Found 1 error in tmp.ts:13
```

This code works at runtime however and Zod correctly parses the object:

```
{ type: 'foo', a: 'foo' }
```

Previously opened as #1263 but was closed as stale.",,
1404980059,1478,README: doesn't Zod support branded types?,"Noticed this, from the README (https://github.com/colinhacks/zod#runtypes):

> They DO support branded and readonly types, which Zod does not.

Is the branded bit no longer true? (readonly should also be supported in #1432, which I'm very much looking forward to.)",,
1403200287,1477,`discriminatedUnion` errors with `z.object().transform()`,"[Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFAxhAHYDO8AWiQGIQRwC8KAdBABGAKwCm1GAAoEMAJ5hRALn4AbYDFFQAhisn5MnfAEoANFk7LkfJlGB0A5pKNojfGNsYGoISdLkKzAwgXHgA+OD95UTMANx0AVyVzYKMjSlpGFhIAIS0oHn4hMQlIhUs+NQ1tXXxBPOMzOqhymztHZ1d3LU9oH1LouCaQ7nD+2ISkodT0+iY4VmJc1F4rYmAGalsQOy0NYgBVOmB6PX9RfDMAbQWOCDMF3KgAXTSKIA)

```ts
import { z } from 'zod';

const ZodFoo = z.object({type: z.literal('foo'), foo: z.string()})
  .transform(({type, foo}) => ({type, value: foo}));
const ZodBar = z.object({type: z.literal('bar'), bar: z.string()})
  .transform(({type, bar}) => ({type, value: bar}));

const ZodBaz = z.discriminatedUnion('type', [ZodFoo, ZodBar]);
```

I am not sure if this is even possible.

If not, is there a recommended workaround?",,
1401535455,1473,zod.preprocess causes compilation error starting from 3.19.1,"After the recent release v3.19.1, the following code started to fail [compiling](https://codesandbox.io/s/beautiful-khayyam-kx97bw?file=/src/index.ts:0-282):
```ts
import * as zod from ""zod"";

const schema = zod.object({
  failureReasons: zod.preprocess(
    rel => [rel],
    zod.array(zod.object({})),
  )
});

export class Editor<
  S extends zod.ZodType<zod.TypeOf<typeof schema>>
    = typeof schema                    // <-- the error pops here
> {
  constructor(public schema: S) {}
}

```
This is the error from sandbox:
```
Type 'ZodObject<{ failureReasons: ZodEffects<ZodArray<ZodObject<{}, ""strip"", ZodTypeAny, {}, {}>, ""many"">, {}[], unknown>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' does not satisfy the constraint 'ZodType<{ failureReasons?: {}[]; }, ZodTypeDef, { failureReasons?: {}[]; }>'.
  The types of '_input.failureReasons' are incompatible between these types.
    Type '{}' is missing the following properties from type '{}[]': length, pop, push, concat, and 26 more.ts(2344)
```
@colinhacks The error is not reproduced with zod v3.19.0, I guess the root cause is this [commit](https://github.com/colinhacks/zod/commit/2893e1659875944198aff28a3ba404858f834ed8).

PS When I replicate the same setup in VSCode locally, the error is slightly different:
```
Type 'ZodObject<{ failureReasons: ZodEffects<ZodObject<{}, ""strip"", ZodTypeAny, {}, {}>, {}, unknown>; }, ""strip"", ZodTypeAny, { failureReasons: {}; }, { ...; }>' does not satisfy the constraint 'ZodType<{ failureReasons: {}; }, ZodTypeDef, { failureReasons: {}; }>'.
  The types of '_input.failureReasons' are incompatible between these types.
    Type 'unknown' is not assignable to type '{}'.ts(2344)
```
I couldn't locate the difference, but the general behaviour is still reflecting the error, so I post the issue as is.
",,
1401329776,1471,intersection of records differs from typescript,"```ts
const type = z.intersection(
  z.object({ a: z.null() }),
  z.record(z.string().refine((s): s is ""b"" => s === ""b""), z.undefined()),
)
const input: z.infer<typeof type> = { a: null, b: undefined }
type.parse(input)
```
should work according to the types but throws
```
ZodError: [
  {
    ""code"": ""custom"",
    ""message"": ""Invalid input"",
    ""path"": [
      ""a""
    ]
  },
  {
    ""code"": ""invalid_type"",
    ""expected"": ""undefined"",
    ""received"": ""null"",
    ""path"": [
      ""a""
    ],
    ""message"": ""Expected undefined, received null""
  }
]
```
A key is not required to match the index signature but if it does its value should match the intersection of value types.",,
1400760269,1470,Validating dynamically named object keys,"Hi there,

I'm running into a blocker with my use case. I have to validate an object with an arbitrary number of properties and dynamic key names:

```typescript
{ [key: string]: string }
```

I need to validate both `key` and `value` for each property. Is there a way to describe that in a zod Schema?

Cheers!",,
1398477811,1465,Bug?: Optional Tuple Values,"I'm in a situation where I'd like to send an optional number of arguments in an array:

```ts
const schema = tuple([
	string(),
	number().optional()
])

type ZodType = z.infer< typeof schema >

// Conversion of type '[string]' to type '[string, number | undefined]' may be a mistake
// because neither type sufficiently overlaps with the other.
const ar = [ ""foo"" ] as ZodType
```

Is it possible to infer to `[ string, number? ]` instead of `[ string, number | undefined ]` ?",,
1396611921,1461,Fails to load from https://www.skypack.dev/,"Can you please fix the compatibility with skypack cdn, right now loading https://cdn.skypack.dev/zod produces following issues

```
/*
 * [Package Error] ""zod@v3.19.1"" could not be built. 
 *
 *   [1/5] Verifying package is valid…
 *   [2/5] Installing dependencies from npm…
 *   [3/5] Building package using esinstall…
 *   Running esinstall...
 *   Cannot find module 'zod/locales/en.d.ts'
 *
 * How to fix:
 *   - If you believe this to be an error in Skypack, file an issue here: https://github.com/skypackjs/skypack-cdn/issues
 *   - If you believe this to be an issue in the package, share this URL with the package authors to help them debug & fix.
 *   - Use https://skypack.dev/ to find a web-friendly alternative to find another package.
 */

console.warn(""[Package Error] \""zod@v3.19.1\"" could not be built. \n[1/5] Verifying package is valid…\n[2/5] Installing dependencies from npm…\n[3/5] Building package using esinstall…\nRunning esinstall...\nCannot find module 'zod/locales/en.d.ts'"");
throw new Error(""[Package Error] \""zod@v3.19.1\"" could not be built. "");
export default null;
```

It is very convenient way to load modules in https://observablehq.com/",,
1396285800,1460,Calling `isOptional` triggers preprocess callback,"Calling `isOptional` triggers preprocess callback.

Related to https://github.com/StefanTerdell/zod-to-json-schema/issues/23.

Here's a failing test case:

```typescript
test(""calling isOptional should not trigger preprocess function"", () => {
  let wasCalled = false;

  const pre = z.preprocess(() => {
    wasCalled = true;
  }, z.string());

  pre.isOptional();

  expect(wasCalled).toBe(false);
});
```",,
1395469255,1458,"Any way to avoid casting preprocess return type, normally returns unknown","When using preprocess the return type is ""unknown"":

schema:
```
export const Size = zod.object({
  width: z.preprocess((input) => {
    if (isNil(input)) return undefined;

    return parseInt(input as string, 10);
  }, z.number()),
});
```

type:
```
zod.ZodEffects<zod.ZodNumber, number, unknown>
```

casting it works:
```
export const Size = zod.object({
  width: z.preprocess((input) => {
    if (isNil(input)) return undefined;

    return parseInt(input as string, 10);
  }, z.number()) as zod.ZodEffects<zod.ZodNumber, number, number>
});
```

I did create a helper function:
```
function prepocessNumber() {
  return z.preprocess((input) => {
    try {
      if (isNil(input)) return undefined;

      return parseInt(input as string, 10);
    } catch (ex) {
      return input;
    }
  }, z.number()) as zod.ZodEffects<zod.ZodNumber, number, number>
}

export const Size = zod.object({
  width: prepocessNumber()
});
```

which gives me the expected return type (number).

Isn't clear to me if there is an alternative but maybe this is correct?
",,
1394569982,1454,Derived arguments (computed props) within a schema,"Hey everyone!

Firstly – Zod is awesome. Picked it up recently and I've been having a blast working with it. 
In recent weeks I've encountered a situation which I thought might benefit from a discussion here. 

We're currently in the process of refactoring an old codebase that used `mobx-state-tree` to manage it's state. MST has a really similar approach to Zod's runtime type system, with a nice API for adding computed properties to a schema:

```ts
const UserStore = types
  .model({
    users: types.array(User)
  })
  .views(self => ({
    get numberOfAdults() {
      return self.users.filter(user => user.age > 18).length
    }
  }))
```

Now, I came across [a good suggestion](https://github.com/colinhacks/zod/issues/641) to wrap Zod's `schema.parse({})` call in a factory function and add the computed functions in before returning:

```ts
const UserSchema = z.object({ name: z.string(), age: z.number() })

const UserCollectionSchema = z.object({
  users: z.array(UserSchema),
})

const createUserModel = (input: Partial<z.infer<typeof UserCollectionSchema>>) => {
  const model = UserCollectionSchema.parse(input)
  return {
    ...model,
    get numberOfAdults() {
      return model.users.filter((user) => user.age > 18).length
    },
  }
}

createUserModel({ users: [{ name: 'Jon', age: 29 }] }).numberOfAdults // => 1
```

This is a really clean suggestion, and would definitely be the route I'd look to take. However... consider the following change to the user schema: 

```ts
const UserSchema = z.object({ name: z.string(), dateOfBirth: z.date() })
```

Ideally I'd be able to expose `age` as a computed property, deriving its value from the date of birth field. This is difficult to achieve without nesting factories here - the consumer of `UserCollectionSchema` shouldn't care whether `age` is a derived property or not. The power here is in nested object schema's each adding their own computed properties that can be carried around alongside the validation logic.

I'm pretty new to using Zod - this might be entirely outside the scope of the project, or something Zod supports now/in the future. There seems to be a few outstanding discussions that relate to this subject but all seem either incomplete or stale, so I thought it was worth asking!

(Possibly related: https://github.com/colinhacks/zod/issues/38)",,
1394147341,1453,ZodObject.merge() looses base shape type when schema is created via a function,"Given two schemas like:
```typescript
const baseSchema = z.object({
  foo: z.string()
});

const extentionSchema = z.object({
  bar: z.string()
});
```

If they are merged together like so:
```typescript
const mergedSchema = baseSchema.merge(extentionSchema);
```
The resulting schema should produce a type that combines both existing schema, which it does:
![Screen Shot 2022-10-03 at 16 04 42](https://user-images.githubusercontent.com/346340/193505076-b397807c-af02-4953-be2a-730647d40342.png)


However if a factory pattern is used to construct that merged schema like so:
```typescript
function createSchema<
  BaseSchema extends z.ZodObject<ZodRawShape>,
  ExtentionSchema extends z.ZodObject<ZodRawShape>
>(baseSchema: BaseSchema, extentionSchema: ExtentionSchema) {
  return baseSchema.merge(extentionSchema);
}
```
And a new schema is created using that function:
```typescript
const mergedSchema = createSchema(baseSchema, extentionSchema);
```

Then the type of resulting schema extends an any object which is not very helpful:
![Screen Shot 2022-10-03 at 16 08 49](https://user-images.githubusercontent.com/346340/193505361-dab2266d-94c6-4f4f-be27-ffadfc45920a.png)

I've created a live example here and you can observe the constructed types by hovering over `objectBasedOnMergedSchema` on line 22 and 31: https://codesandbox.io/s/zod-merge-typescript-issue-ohz657?file=/src/index.ts",,
1392567443,1444,feature request: combining/nesting/extending discriminated unions,"In our app we have some data coming from an external service that's modelled as a combination of 2 discriminated unions, e.g.
```ts
[
  { type: ""quote"", attribution: ""..."" },
  { type: ""textAndMedia"", mediaType: ""image"", image: {...} }
  { type: ""textAndMedia"", mediaType: ""video"", video: {...} }
]
```

But attempting to model it with zod fails with the error:  
`The discriminator value could not be extracted from all the provided schemas`
```ts
const t = z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""one""), foo: z.string() }),
  z.object({ type: z.literal(""two""), bar: z.string() }),
  z.discriminatedUnion(""secondType"", [
    { type: z.literal(""three""), secondType: z.literal(""a"") },
  ]),
]);
```

An extra problem we've ran into is the nested discriminator is defined elsewhere, but unlike objects it doesn't have a `.extend` method, and a `ZodDiscriminatedUnion` isn't a valid arg for `ZodObject.merge`
```ts
const otherDiscriminator = z.discriminatedUnion(""secondType"", [
  z.object({ secondType: z.literal(""a"") }),
  z.object({ secondType: z.literal(""b"") }),
]);
z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""one""), foo: z.string() }),
  z.object({ type: z.literal(""two""), bar: z.string() }),
  otherDiscriminator.extend({ type: z.literal(""three"") }),
]);
```
<details>
  <summary>Instead of extending I considered extracting the discriminator options and mapping over them, but zod can't infer that correctly. Code sample in toggle</summary>
<p>

```ts
const otherDiscriminatorOptions = [
  z.object({ secondType: z.literal(""a"") }),
  z.object({ secondType: z.literal(""b"") }),
] as const;

const otherDiscriminator = z.discriminatedUnion(""secondType"", [
  ...otherDiscriminatorOptions,
]);

z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""one""), foo: z.string() }),
  z.object({ type: z.literal(""two""), bar: z.string() }),

  z.discriminatedUnion(""secondType"", [
    ...otherDiscriminatorOptions.map((option) => ({
      type: z.literal(""three""),
      ...option,
    })),
  ]),
]);
```

</p>
</details>
",,
1388579067,1436,Issue with recurisve parsing and typescript,"So I have the following setup for parsing a recursive rules tree 

```
interface RuleNode {
    ruleId: string;
    description?: string[];
    children: RuleNode[];
    ruleOperation: RuleOperation;
    ruleField?: string;
    ruleValue?: string;
    ruleValueType?: RuleValueType;
}
export type RuleSyntaxTree = RuleNode;

export const RuleNode: z.ZodType<RuleNode> = z.lazy(() =>
    z.object({
        ruleId: z.string(),
        description: z.array(z.string()).optional(),
        children: z.array(RuleNode),
        ruleOperation: z.nativeEnum(RuleOperationInternal),
        ruleValue: z.string().optional(),
        ruleField: z.string().optional(),
        ruleValueType: z.string().optional(),
    }),
);
``` 

This gives me the following error on the validator. 

```
Type 'ZodLazy<ZodObject<{ ruleId: ZodString; description: ZodOptional<ZodArray<ZodString, ""many"">>; children: ZodArray<ZodType<RuleNode, ZodTypeDef, RuleNode>, ""many"">; ruleOperation: ZodNativeEnum<...>; ruleValue: ZodOptional<...>; ruleField: ZodOptional<...>; ruleValueType: ZodOptional<...>; }, ""strip"", ZodTypeAny, { .....' is not assignable to type 'ZodType<RuleNode, ZodTypeDef, RuleNode>'.
  Types of property '_type' are incompatible.
    Type '{ ruleId?: string; description?: string[]; children?: RuleNode[]; ruleOperation?: RuleOperation; ruleValue?: string; ruleField?: string; ruleValueType?: string; }' is not assignable to type 'RuleNode'.
      Property 'ruleId' is optional in type '{ ruleId?: string; description?: string[]; children?: RuleNode[]; ruleOperation?: RuleOperation; ruleValue?: string; ruleField?: string; ruleValueType?: string; }' but required in type 'RuleNode'.t
``` 

is there something im doing wrong? Can this code be simplified. ",,
1384688429,1425,[Date] Runtime branded date looses brand by parsing,"I made a branded date.  And used `z.date().refine` to check for brand. and it does not work.

```ts
import { z } from ""zod"";

const DATE_ONLY_SYMBOL = Symbol(""DATE_ONLY_SYMBOL"");
export type DateOnly = Date & { [DATE_ONLY_SYMBOL]: true };

export function isDateOnly(d: Date): d is DateOnly {
  return DATE_ONLY_SYMBOL in d;
}
export function asDateOnly(d: Date): DateOnly{
  const dateOnly = new Date(d) as DateOnly;
  dateOnly[DATE_ONLY_SYMBOL] = true;
  return dateOnly;
}

type ZodDateOnly = z.ZodType<DateOnly, z.ZodTypeDef, Date>;
export const DateOnlySchema: ZodDateOnly = z.date().refine(
  (d): d is DateOnly => isDateOnly(d) // here is always false
);

const dateOnly = asDateOnly(new Date());
isDateOnly(dateOnly); // true
DateOnlySchema.parse(dateOnly); // fails
```

[sandbox with code above](https://codesandbox.io/s/zod-branded-date-0cbmyf)

-----

I found a reason of this beahavior:
https://github.com/colinhacks/zod/blob/3b75ae584e31d8bd06f7298247cd3d27520cf881/src/types.ts#L1111-L1114

it also means the following behavior:
```ts
const dateOnly = asDateOnly(new Date());
isDateOnly(dateOnly); // true
const parsed = z.date().parse(dateOnly); // lost brand
isDateOnly(parsed); // false
```

I wondering if I should use another approach (not `z.date().refine`) to achieve my goal",,
1383512174,1423,"change export from ""import { z } from 'zod'"" to ""import { zod } from 'zod'""","Letter ""Z"" becomes a symbol of russian military in Ukraine - russian war. Zod - is a really useful and awesome package and we are really thankful to have such an open-source project. However, the letter ""Z"" become a symbol of evil, dictatorship, occupation, genocide ... and a lot of bad things, that shouldn't happen in our world

If you will consider changing it - we as consumers of this package will really appreciate it 

Thank you ",,
1382610043,1421,Validation of arguments via ts decorator,"It would be nice if function arguments could be automatically validated via typescript decorators. For example, something like this:
```ts
const schema = z.object({
  name: z.string().min(3).max(10),
  age: z.number().min(18),
})

class Test {
  @validation(schema)
  hello(input: { name: string; age: number }) {
    return 'test'
  }

  helloAgain(@validation(schema) input: { name: string; age: number }) {
    return 'test'
  }
}

// This throws
new Test().hello({name: 'something', age: 17})
```

A first POI of the function decorator can be found at 
https://github.com/JabRef/JabRefOnline/blob/3ccf2642888776507b87a2c46b7229f163628ae3/server/utils/validation.ts#L11-L34
 with test at https://github.com/JabRef/JabRefOnline/blob/main/server/utils/validation.spec.ts. I sadly don't have the time right now to complete this to a finished PR but I thought I'd share the idea.",,
1380765094,1420,Field does not exist on infered object if it's generic,"I'm trying to create a schema with a generic field where the specific validation doesn't matter, and I just want to infer the type correctly. Using `typescript@4.8.3` and `zod@3.19.1`, I get this weird error where `rawData` is stripped from the object completely if I'm using it as a generic:

```ts
import {z} from ""zod""

export type PlainObject = {[key: string]: unknown}

export function TransactionPropsSchema<T extends PlainObject>() {
	return z.object({
		id: z.string(),
		rawData: z.custom<T>((data) => z.object({}).safeParse(data)),
	})
}

export type TransactionProps<RawData extends PlainObject = PlainObject> =
	z.infer<ReturnType<typeof TransactionPropsSchema<RawData>>>

export class Transaction<RawData extends PlainObject = PlainObject> {
	constructor(public props: TransactionProps<RawData>) {}

	get id() {
		return this.props.id
	}

	get rawData() {
		return this.props.rawData // Property 'rawData' does not exist on type '{ [k_1 in keyof addQuestionMarks<{ id: string; rawData: RawData; }>]: addQuestionMarks<{ id: string; rawData: RawData; }>[k_1]; }'.
	}
}

// Creating a transaction works as expected
const tx = new Transaction({
	id: ""0"",
	rawData: {},
})
const tx2 = new Transaction<{foo: ""bar""}>({
	id: ""1"",
	rawData: {
		foo: ""bar"",
	},
})
```

I can fix the error with a type assertion in the getter or on the schema level, but I'm confused about why this error happens at all. 

How to reproduce: https://github.com/bkiac/generic-zod-object-field",,
1380116146,1419,Unexpected parse failure,"First off, thank you for Zod. It's indispensable.

I've created the below schema that should yield `type NameAndVitals = { name: string } & ({ age: number; } | {})`
```typescript
const vitalsSchema = z.object({ age: z.number() }).or(z.object({}).strict());
const nameAndVitalsSchema = z.object({ name: z.string() }).and(vitalsSchema);
```
Unfortunately, `{ name: ""trey"" }` fails to parse with `{""_errors"":[""Unrecognized key(s) in object: 'name'""]}`.

I debugged it and determined that it works as expected if I omit the `.strict()` from `vitalsSchema`. I don't understand why that would fix the issue. Is this a bug, or is this expected behavior?

Here's a [CodeSandbox](https://codesandbox.io/s/practical-silence-91983y?file=/src/index.ts:45-390) that exhibits the issue.

Also, my real-world scenario is much more complex. This is the minimal/contrived repro schema.
",,
1375366265,1413,.optional().default() should infer type as optional,"## Background

This issue is making a case that when an object is defined with optional, but default values - the underlying type should still be optional. When default is not chained to optional, the type should be required. The use case is for usage of schemas as input as well as an interface.

### Example

```ts
const captureOptionsSchema = z.object({
  url: z.string().url(),
  settings: z.object({
    width: z.number().min(320).optional().default(1280),
    height: z.number().min(320).optional().default(720),
  }).optional().default({}),
})

type CaptureOptions = z.infer<typeof captureOptionsSchema>;

/**
  type = {
    url: string;
    settings: {
      width: number;
      height: number;
    }
  }
*/
```

While technically the type above is correct for explaining what the input params look like, in something like the following, you'll need to define a second type:

```ts
function capture(options: CaptureOptions /* <-- this needs to be a different type */) {
  const params = captureOptionsSchema.parse(options);
  // ...
}
```

`CaptureOptions` in this case is not the correct type, Since there are defaults on width & height and settings sets defaults, passing these options should not be required. The catch is that `params` needs to have those props as required for correct typing.

IMHO I think a `optional().default()` chain should set the property's type as optional and it should be the dev's responsibility to use e.g. `params.settings!.width!` in the usage, instead of having to define another interface or type for the input options with Omits and Picks and Partials etc.

I hope this makes sense. I have checked through the docs and issues first in hopes of not duplicating or missing something, but if I am - please close this, but if possible advise me on a best practice here. 😄 Thanks!",,
1372359533,1408,Wrong type inference for required properties,"The code example from the [Object documentation](https://github.com/colinhacks/zod#objects) shows this example:

```ts
// all properties are required by default
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});

// extract the inferred type like this
type Dog = z.infer<typeof Dog>;

// equivalent to:
type Dog = {
  name: string;
  age: number;
};
```

When that same example is used in my code, I get a different type inference:

```ts
// all properties are required by default
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});

// extract the inferred type like this
type Dog = z.infer<typeof Dog>;

// equivalent to:
type Dog = {
  name?: string;
  age?: number;
};
```

None of the object properties seem required, and are marked as optional in the type inference.

Tested in zod versions 3.16.*-3.18.*",,
1371026964,1406,`fatal` missing from issue-type,"From [my question asked on Discord](https://discord.com/channels/893487829802418277/893488038477434881/1018893492342226994):

When adding an issue (e.g. via `ctx.addIssue` in `superRefine`), you can set whether the issue is `fatal` or not:

```ts
    ctx.addIssue({
      code: 'custom',
      fatal: true, // Allowed
      params: {
        foo: 'bar',
      },
      path: [],
      message: 'Some message',
    });
```
But when manually creating a new `ZodError` with a matching issue, Typescript complains that `fatal` does not exist:
```
    const err = new z.ZodError([
      {
        code: 'custom',
        fatal: true, // Not allowed, with typescript-error below
        params: {
          foo: 'bar',
        },
        path: [],
        message: 'Some message',
      },
    ]);
```
> Object literal may only specify known properties, and 'fatal' does not exist in type 'ZodCustomIssue & { message: string; }'

As mentioned in the reply to my question on Discord, there seems to be an oversight here. Is `fatal` is missing on `ZodCustomIssue` or `ZodIssueBase`, or is it ""correct"" that it doesn't exist there? I'm guessing not, since the `fatal` field does come back out on an issue when a fatal issue is created. Typewise, it seems to only be added to `IssueData`, which is the type `ctx.addIssue` accepts?

---

The reason why I ran into this, is because I have written a few ""custom schemas"" for often used ""types"", for re-use throughout my code-base, and to make sure they're done correctly, I've written some unit-tests for them:

```ts
    it('invalid should generate expected issue', () => {
      expect(AccountNumberSchema.safeParse('1234 56 78907')).toEqual({
        success: false,
        error: new z.ZodError([
          {
            code: 'custom',
            fatal: true, // Gives TS error, as mentioned
            params: {
              code: 'invalid_type',
              expected: 'account_number',
            },
            path: [],
            message: 'must be a valid account number',
          },
        ]),
      });
    });
```",,
1368727739,1399,Feature Request: Less strict enum / oneOf,"Right now `z.enum` only works when you have a constant/static array of strings:

```ts
const FishEnum = z.enum([""Salmon"", ""Tuna"", ""Trout""]);
type FishEnum = z.infer<typeof FishEnum>;
```

But this doesn't work for dynamic arrays:

```ts
declare const fish: string[];
const Fish = z.enum(fish);
// ts-error: Argument of type 'string[]' is not assignable to parameter of type '[string, ...string[]]'.
```

It also doesn't work for arrays of other primitive types:

```ts
const months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] as const;
const Month = z.enum(months);
// ts-error: Argument of type 'readonly [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]' is not assignable to parameter of type '[string, ...string[]]'.
```

It's possible to solve this with `refine`:

```ts
const Fish = z.string().refine((value) => fish.includes(value));
const Month = z.number().refine((value): value is typeof months[number] => months.includes(value));
```

However other libraries like Yup provide a convenient `oneOf` method for these cases:

```ts
const Fish = yup.string().oneOf(fish);
const Month = yup.number().oneOf(months);
const Mixed = yup.mixed().oneOf(['foo', 42, true]);
```

Is there any appetite to add a less strict version of `enum` / `oneOf` to Zod?",,
1367765113,1397,Strange Error with AngularV9 and Ionic,"I get the following errors with zod@3.17.3 and the latest Zod release when compiling a Ionic project which uses AngularV9. downgrading to zod@1.11 fixes it

`[ng] ERROR in node_modules/zod/lib/helpers/enumUtil.d.ts:4:10 - error TS2456: Type alias 'UnionToTuple' circularly references itself.
[ng] 4     type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
[ng]            ~~~~~~~~~~~~
[ng] node_modules/zod/lib/helpers/enumUtil.d.ts:4:88 - error TS2315: Type 'UnionToTuple' is not generic.
[ng] 4     type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
[ng]                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/helpers/enumUtil.d.ts:4:148 - error TS2574: A rest element type must be an array type.
[ng] 4     type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
[ng]
        ~~~~~~~~
[ng] node_modules/zod/lib/helpers/enumUtil.d.ts:6:59 - error TS2315: Type 'UnionToTuple' is not generic.
[ng] 6     export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;
[ng]                                                             ~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/helpers/partialUtil.d.ts:4:29 - error TS2589: Type instantiation is excessively deep and possibly infinite.
[ng] 4         [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>>;
[ng]                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:354:14 - error TS2456: Type alias 'deoptional' circularly references itself.
[ng] 354 declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T;
[ng]                  ~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:354:82 - error TS2315: Type 'deoptional' is not generic.
[ng] 354 declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T;
[ng]                                                                                      ~~~~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:400:25 - error TS2315: Type 'deoptional' is not generic.
[ng] 400         [k in keyof T]: deoptional<T[k]>;
[ng]                             ~~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:463:145 - error TS1256: A rest element must be last in a tuple type.
[ng] 463 export declare type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]] : OutputTypeOfTuple<T>;
[ng]
       ~~~~~~~~~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:467:144 - error TS1256: A rest element must be last in a tuple type.
[ng] 467 export declare type InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]] : InputTypeOfTuple<T>;
[ng]
      ~~~~~~~~~~~~~~~~~~~~~~`",,
1366931572,1394,Feature: Conditional Validation Similar to yup.when(),"Similar to this Yup issue: https://github.com/jquense/yup/issues/176 and creating a new issue out of #61.

Many users of zod would like to do conditional requirement or validation of fields based on either fields passed as context to zod, or based off of the value of another schema property. This is common to do in form validations.

The closed issue #61 addresses how to do conditional validation with `superRefine`. This works well enough in small cases, but many folks have large complex schemas and we would like to _keep_ the existing validation on an object i.e. not have to make the entire object partial in order for conditional requirement to work.

This issue stems from the reaction to my comment https://github.com/colinhacks/zod/issues/61#issuecomment-1171958123

Pasting from the comment as my case is the same:
I have large schema that needs to require one or another field. A nested partial Zod object with `superRefine` works for this.

What I want to be able to do however, is to do conditional requirement on 1 or 2 fields without making the entire object partial and while having access to all of the fields in the object.

Ex:
I have a required enum that has two values: ""ValueA"" and ""ValueB""

Upon ""ValueA"" then someOtherFieldA is required. Upon ""ValueB"" then someOtherFieldB is required.

There are also other required fields within the schema that should remain required without explicitly checking them in something like `superRefine`.

The reason I chose zod over yup was TypeScript support, but in yup's beta versions TS support has improved a lot. Not having a functionality like this is a big blocker for me wanting to keep using zod. Thanks!

",,
1365237632,1392,Branded object types loose `z.ZodObject` functionalities,"When branding an object all the `z.ZodObject` functionalities are lost, is that the expected behavior or is there something that can be fixed in the types when using `z.brand()`?

This happens on the latest version `3.19.0`.

Here's a minimal reproduction:
```ts
export const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  age: z.number().int().positive().min(18).max(99),
  email: z.string().email(),
}).brand<'User'>();

const age = UserSchema.shape.age.parse(28) // Cannot read properties of undefined (reading 'age')

export const UserDomain = UserSchema.strict() // UserSchema.strict() is not a function
  .merge( // UserSchema.merge() is not a function
    z.strictObject({
      id: UserId,
    })
  );
```",,
1365230704,1391,Feature Request: Parse on output schemas,"### Summary

TL;DR - I'd love to be able to take the output of a zod pipeline (esp. including `.transform()`) and have the ability to call `.parse()` on it.

Or to think about it a slightly different way, I'd like something like `z.infer()`, except a real function I can call `.parse()` on instead of just a type utility.

For me, this is going to be most useful when reading previously parsed JSON data back from a JSON column in the database.

### Use Case

I'm using zod to parse data I receive from an api, transform it, and then store it in a db using prisma.

On the way in, I can use a schema like this, no problem:

`z.object({...}.transform({...}`

The problem is reading that data from the db later. If I try to call schema.parse on it, it will fail because the data matches the _output_ schema as opposed to the _input_ schema.

I know about `z.infer()` - it does what I want, except it's only a type utility rather than a real schema I can call.  Because the data is a JSON column in the db, I'd really prefer to use schema.parse() instead of just typecasting so I can get the runtime safety and not just suppress the compiler errors.

The obvious workaround for now is to track the input and output schemas separately. But then I'm effectively duplicating code between the transform and output schema. Not the end of the world, but not ideal.

I think I'm basically asking to replicate the whole `z.input` / `z.output` / `z.infer` paradigm, except with real classes that essentially clone the output of the pipeline for parsing.

### Appreciation / Next Steps

Thank you for your consideration and the wonderful library!  I've been blown away by how useful everything is.

Also, I could perhaps take a crack on the implementation of this if y'all feel it's a good idea that's worth doing.",,
1365028842,1390,"Request: Introduce ZodTransformError type, to allow for transforms that fail","When attempting a transform, it's possible that the transform may fail. In this case, there is no value to return, so it's necessary to return a typecast dummy value. Returning a typecast dummy value violates Zod's type-safety. 

Allowing a transform function to throw a special error type, e.g. `ZodTransformError`, to signal a controlled transform failure, would make for nicer DX.

The error type would contain an array of issues, which would be added to the parse result, and the issues would be considered fatal.

The following serves as an example:

```ts
import { ZodTransformError } from ""zod"";

const user = z.string().transform(async (id) => {
  try {
    const user = await getUserById(id);
    return user;
  } catch (e) {
    throw new ZodTransformError([{
      code: ""custom"",
      message: ""User not found"",
    }]);
  }
});
```



See https://github.com/colinhacks/zod/pull/1389 for a potential implementation",,
1364847905,1388,Allow optional() typings to work also for non-optional but possibily undefined fields,"Hello everyone, Zod is awesome!

While working with Zod I ended up in a particular situation, I didn't find any other reference to this problem except [this StackOverflow question](https://stackoverflow.com/questions/71477015/specify-a-zod-schema-with-a-non-optional-but-possibly-undefined-field) with no useful answer.

I prepared a [Code Sandbox](https://codesandbox.io/s/admiring-sara-7k0f70?file=/src/index.ts:0-575) to show the issue.

```ts
interface IFoo1 {
  somefield: string | undefined;
}

const schema1a: ZodSchema<IFoo1> = z.object({
  somefield: z.string().optional()
});

const schema1b: ZodSchema<IFoo1> = z.object({
  somefield: z.union([z.string(), z.undefined()])
});
```
When I declare a Typescript interface (`IFoo1`) with a required field, which can be both of a certain type and `undefined` I would expect that Zod would be fine with declaring that field as `optional()`. That didn't work, also using a `union()` type didn't work.

Do you have any idea how to solve it? IMHO I would allow `optional()` to accept a type that is required but could be `undefined` since from JS perspective they should be the same, but I'd like to hear more from you!

Thank you!",,
1363650232,1387,"VSCode Intellisense shows raw structure instead of type name, resulting in very long popups","I have these following types and function in which I tested this with:

```ts
export const IRFIDTag = z.object({
    id: z.number(),
    epc: z.string(),
    location: z.string(),
    createdAt: z.instanceof<new () => Dayjs>(dayjs as any),
    relatedJob: z.lazy(() => z.optional(IProductionJob)), // imported from elsewhere
});
export type IRFIDTag = z.infer<typeof IRFIDTag>;

export const IRFIDTagLocation = z.object({
    location: z.string(),
    from: z.instanceof<new () => Dayjs>(dayjs as any),
    to: z.instanceof<new () => Dayjs>(dayjs as any).optional(),
});
export type IRFIDTagLocation = z.infer<typeof IRFIDTagLocation>;

export const IRFIDTagWithLocation = IRFIDTag.extend({
    locationRelationship: z.object({
        currentLocation: IRFIDTagLocation,
        previousLocations: IRFIDTagLocation.array(),
    }),
});
export type IRFIDTagWithLocation = z.infer<typeof IRFIDTagWithLocation>;

const output: IRFIDTag = getTag();
const res: IRFIDTagWithLocation = {
  ...output, // The following error happens when I comment this line, Missing id, epc, location, createdAt
  ...rest // abstracts actual implementation
}
```

When using these types and I encounter an error, the Intellisense popup is extremely long and hard to read. These are the outputs from the same error:
```
// Using Zod infer types
Type '{ locationRelationship: { currentLocation: { to?: Dayjs | undefined; location: string; from: Dayjs; }; previousLocations: { to?: Dayjs | undefined; location: string; from: Dayjs; }[]; }; relatedJob: { ...; } | undefined; }' is not assignable to type 'IRFIDTagWithLocation'.
  Type '{ locationRelationship: { currentLocation: { to?: Dayjs | undefined; location: string; from: Dayjs; }; previousLocations: { to?: Dayjs | undefined; location: string; from: Dayjs; }[]; }; relatedJob: { ...; } | undefined; }' is missing the following properties from type '{ relatedJob?: { name?: string | undefined; dueDate?: Dayjs | undefined; completedDate?: Dayjs | undefined; assignedTo?: string | undefined; assignedAt?: Dayjs | undefined; ... 4 more ...; isRFIDTracked: boolean; } | undefined; location: string; id: number; epc: string; createdAt: Dayjs; }': location, id, epc, createdAt ts(2322)

// Hardcoding types (i.e. creating types with the same key/pair types as the Zod object instead of z.infer)
Type '{ locationRelationship: { currentLocation: IRFIDTagLocation; previousLocations: IRFIDTagLocation[]; }; relatedJob: { name?: string | undefined; ... 8 more ...; isRFIDTracked: boolean; } | undefined; }' is not assignable to type 'IRFIDTagWithLocation'.
  Type '{ locationRelationship: { currentLocation: IRFIDTagLocation; previousLocations: IRFIDTagLocation[]; }; relatedJob: { name?: string | undefined; ... 8 more ...; isRFIDTracked: boolean; } | undefined; }' is missing the following properties from type 'IRFIDTag': id, epc, location, createdAt ts(2322)
```

Is there any way for Intellisense to recognize type names made with Zod infer?",,
1362872071,1384,discriminatedUnion with recursive type results in ts error,"I have a situation where I want to use a recursive type inside discriminated union type.

It results into this error:

```
 Argument of type '[ZodObject<{ type: ZodLiteral<""a"">; a: ZodString; }, ""strip"", ZodTypeAny, { type: ""a""; a: string; }, { type: ""a""
 ; a: string; }>, ZodObject<{ type: ZodLiteral<...>; b: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodType<...>]' is n
 ot assignable to parameter of type '[ZodDiscriminatedUnionOption<""type"", Primitive>, ZodDiscriminatedUnionOption<""type"", Primitive
 >, ...ZodDiscriminatedUnionOption<...>[]]'.
   Type at position 2 in source is not compatible with type at position 2 in target.
     Type 'ZodType<Category, ZodTypeDef, Category>' is missing the following properties from type 'ZodObject<{ type: ZodLiteral<Pri
 mitive>; } & ZodRawShape, any, any, { [x: string]: any; }, { [x: string]: any; }>': _cached, _getCached, shape, strict, and 14 mor
 e.
```

There seems to be a conflict between `ZodType` and `ZodDiscriminatedUnionOption`. 

Here the example I used:

```ts
interface Category {
  type: ""c"";
  c: Category[];
}

// cast to z.ZodType<Category>
const category: z.ZodType<Category> = z.lazy(() =>
  z.object({
    type: z.literal(""c""),
    c: z.array(category),
  })
);

const item = z
  .discriminatedUnion(""type"", [
    z.object({ type: z.literal(""a""), a: z.string() }),
    z.object({ type: z.literal(""b""), b: z.string() }),
    category,
  ])
  .parse({ type: ""a"", a: ""abc"" });

```",,
1361051376,1376,Schema parse function accepts additional param for data validation,"Hi. Thank you for an awesome library.

I want to know if zod can give options to parse function of schema.
I want to make similar type and validation using zod for this F# example (https://github.com/swlaschin/DomainModelingMadeFunctional/blob/master/src/OrderTaking/Common.SimpleTypes.fs)

```F#
module OrderQuantity  =

    /// Return the value inside a OrderQuantity
    let value qty =
        match qty with
        | Unit uq ->
            uq |> UnitQuantity.value |> decimal
        | Kilogram kq ->
            kq |> KilogramQuantity.value

    /// Create a OrderQuantity from a productCode and quantity
    let create fieldName productCode quantity  =
        match productCode with
        | Widget _ ->
            UnitQuantity.create fieldName (int quantity) // convert float to int
            |> Result.map OrderQuantity.Unit             // lift to OrderQuantity type
        | Gizmo _ ->
            KilogramQuantity.create fieldName quantity
            |> Result.map OrderQuantity.Kilogram         // lift to OrderQuantity type
```

It needs additional param ""**productCode**"" for quantity validation for like this.

```TypeScript
export const UnitQuantity = z
  .number()
  .int()
  .min(1)
  .max(1000)
  .brand<""UnitQuantity"">();
export type UnitQuantity = z.infer<typeof UnitQuantity>;

export const KilogramQuantity = z
  .number()
  .min(0.05)
  .max(100)
  .brand<""KilogramQuantity"">();
export type KilogramQuantity = z.infer<typeof KilogramQuantity>;

export const OrderQuantity = z
  .union([UnitQuantity, KilogramQuantity]).refine((val, productCode) => {
    if (productCode.startsWidth('W')) {
      return UnitQuantity.safeParse(val).success;
    } else if (productCode.startsWidth('G')) {
      return KilogramQuantity.safeParse(val).success;
    } else {
      return false;
    }
  })
  
const validatedOrderQuantity = OrderQuantity.parse(10, 'Widget');
```
  
  I don't know how to make this work.
  Thank you. Any comment would be appreciated!",,
1360739815,1375,"Unable to do .partial and getting ""TypeError: Cannot read properties of undefined (reading 'partial')""","I'm using zod in my NextJS project, and when trying to a .partial on a schema I get the a ""TypeError: Cannot read properties of undefined (reading 'partial')""

Here is my setup.

Models.tsx

```
const TripSchema = z.object({
    id: z.string(),
    user_id: z.string(),
    name: z.string(),
})

type Trip = z.infer<typeof TripSchema>

export type { Trip, TripSchema }
```

I'm trying to validate the shape of form input (in a modal) as follows:

AddTripModal.tsx

```
import { useState } from 'react'
import { Button, Modal } from 'react-daisyui'
import { TripSchema } from './Models'

type ModalProps = {
    open: boolean
    onClose: () => void
}

const AddTripModal = (props: ModalProps) => {
    const [trip, setTrip] = useState({
        user_id: '',
        name: '',
    })

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { name, value } = e.target
        setTrip((prev) => {
            console.log(prev)
            return { ...prev, [name]: value }
        })
    }

    const handleSubmit = (e: React.ChangeEvent) => {
    
        e.preventDefault()

        console.log(trip)

        const optionalId = TripSchema.partial({
            id: true,
        })

        if (optionalId.safeParse(trip).success) {
            console.log('zod success')
        }
    }

    return (
        // jsx for form
    )
}

export default AddTripModal
```

In VSCode, it seems like eslint does not like my using TripSchema but does not give me any reason why:

![image](https://user-images.githubusercontent.com/9031145/188253770-7359172d-08a9-41ca-8c4d-8a58fb411a7a.png)

And when I visit the page and tap submit on my form, it does have an object with data from the form fields:

![image](https://user-images.githubusercontent.com/9031145/188253807-5e9a4f12-7350-4ea3-889a-0e998ac6ba9f.png)

But I get this error:

![image](https://user-images.githubusercontent.com/9031145/188253872-0f2c44c3-fb4f-4d28-aa9f-c412d897f4eb.png)

Any idea how to resolve this?


",,
1360179978,1374,Type inference problem with extending generic ZodObject,"First of all, thanks for the great library! 🙏

I have a small problem with inferencing the type of a generic ZodObject's shape.

#### Problem description

I have a CMS API that sends localizations of different entities in a certain format. Simplified example of an article entity:
```json
{
  ""title"": ""English title"",
  ""locale"": ""en"",
  ""localizations"": [
    {
      ""title"": ""French title"",
      ""locale"": ""fr""
    }
  ] 
}
```

This is the Zod-schema used for the articles:

```typescript
const Article = z.object({
  title: z.string(),
  locale: z.string(),
})
```

I wanted to make a helper function which takes a ZodObject as an input and extends it with localizations field:

```typescript
const withLocalizations = <T extends z.ZodObject<any>>(zodObject: T) => zodObject.extend({
  localizations: zodObject.array()
})
```

Then I would use it like so:

```typescript
const ArticleWithLocalizations = withLocalizations(Article)
```

Unfortunately, with this setup the TS compiler loses track of the original fields and thinks that `ArticleWithLocalizations` has only `localizations` field. Supposedly that's because of the any-type used in `withLocalizations`.

#### Partial solution

I found a solution by passing the shape to `withLocalizations` but I think this is quite verbose:

```typescript
const withLocalizations = <S extends z.ZodRawShape, T extends z.ZodObject<S>>(zodObject: T) => zodObject.extend({
  localizations: zodObject.array()
})

const Article = z.object({
  title: z.string(),
  locale: z.string(),
})

type ArticleType = typeof Article

const ArticleWithLocalizations = withLocalizations<ArticleType[""shape""], ArticleType>(Article)
```

#### Question
Is there a way to infer the type of the shape inside `withLocalizations` without passing it explicitly?


",,
1359640913,1372,How to compare schemas?,"Looking for some help and guidance on comparing two Zod schemas. 
More specifically, I would like to assert whether a schema contains another schema. For example,
```
const u = z.object({ a: z.string(), b: z.number() })
const v =  z.object({ a: z:string() })
u.contains(v) // pseudo code, expect true
```

more details on my somewhat unusual use case. 
For example, with the following type definition
``` typescript
function a(): { x: string, y: string };
function b({ x: string }): void;
function c({ y: string }): void;
```

- functions a is compatible with b and c. because both b(a()) and c(a()) are valid. 
- while b and c are not compatible with each other, doing a(b('')) will result in a type error. 

Typescript works well in handling this if how the functions are combined is predetermined at compile time. However, in my use case,  how the functions are chained together is determined at runtime. 

So I thought maybe I can leverage Zod to define the function's interfaces and use that to the compatibility at runtime. 
``` typescript
const a = z.function().args().returns({ x: z.string(), y: z.string() });
const b = z.function().args({ x: z.string() });
const c = z.function().args({ y: z.string() });

// how do I do something like this? using chai expect as an example below
expect(a.returnTypes()).deep.includes(b.parameters()) // true
expect(a.returnTypes()).deep.includes(c.parameters()) // true
expect(b.returnTypes()).deep.includes(c.parameters()) // false
```
Well, this doesn't work. Running the following 
```typescript
expect(z.string()).deep.include(z.string());
```
gives
```
AssertionError: expected ZodString{ …(24) } to have deep property 'spa' of [Function bound safeParseAsync], but got [Function bound safeParseAsync]
```
How should I go about comparing two Zod schemas? 
Any pointer is much appreciated. Thanks
",,
1359450739,1370,Feature request: `.deepStrict`,"Like `.deepPartial` is to `.partial` it would be beneficial to have a `.deepStrict` function that ensures every level in an object, array, or tuple hierarchy is `.strict`.

For example, this code does _not_ generate a ZodError:
```
const person = z
  .object({
    name: z.string(),
    meta: z.object({
      born: z.string(),
    }),
  })
  .strict();

person.parse({
  name: ""bob dylan"",
  meta: {
    born: ""a place"",
    extraKey: 61,
  },
});
```

With `.deepStrict` it would work like this:
```
const person = z
  .object({
    name: z.string(),
    meta: z.object({
      born: z.string(),
    }),
  })
  .deepStrict();

person.parse({
  name: ""bob dylan"",
  meta: {
    born: ""a place"",
    extraKey: 61,
  },
});
// => throws ZodError
```",,
1357183210,1368,"Ability to ""name"" an enum","Consider this Zod-to-Nexus function:

```ts
export const enumType = <
  S extends
    | z.ZodNativeEnum<any>
    | z.ZodEnum<[string, ...string[]]>
    | z.ZodUnion<[z.ZodLiteral<string>, ...z.ZodLiteral<string>[]]>
>(
  schema: S,
  config?: { name: string; case?: 'camel' | 'snake' }
) => {
  const name = config?.name ?? schema._def.typeName
  const enumifyThis = enumify(config?.case ?? 'snake')
  const members =
    'options' in schema._def
      ? // union case
        schema._def.options.map((_) => _._def.value).map(enumifyThis)
      : // enum case
      Array.isArray(schema._def.values)
      ? schema._def.values.map(enumifyThis)
      : values(schema._def.values)
          .map((_) => String(_))
          .map(enumifyThis)
  return Nexus.enumType({
    name,
    members,
  })
}
```


When using it today it is not possible to capture the enum name so we get code like this:

```ts
const ExternalErrorDatabaseKind = z.enum([
   'IntrospectionFailure',
   'NotEmpty',
   'PushSchemaFailure',
   'SeedFailure',
])

NexusZod.enumType(ExternalErrorDatabaseKindEnum, {
   name: 'ExternalErrorDatabaseKind',
})
```

What I wish we could do is just:

```ts
NexusZod.enumType(ExternalErrorDatabaseKindEnum)
```

Which would I guess be powered by a new Zod method on enums like this:

```ts
const ExternalErrorDatabaseKind = z.enum([
   'IntrospectionFailure',
   'NotEmpty',
   'PushSchemaFailure',
   'SeedFailure',
]).name(`ExternalErrorDatabaseKind`)
```

Or maybe unify name and description under the concept of ""metadata"":


```ts
const ExternalErrorDatabaseKind = z.enum([
   'IntrospectionFailure',
   'NotEmpty',
   'PushSchemaFailure',
   'SeedFailure',
]).metadata({ name: `ExternalErrorDatabaseKind`, description: 'foobar' })
```",,
1356741230,1367,Strip unknown types in a discriminated union when parsing,"## Summary
Is it possible for a discriminated union to optionally ignore unknown values when parsing?

## Detail
Let say I have the following models:

```ts
export const BaseProviderResponseModel = z.object({
    type: z.string(),
    name: z.string(),
});

export const LocalProviderResponseModel = BaseProviderResponseModel.extend({
    type: z.literal(""local""),
});

export const OAuthProviderResponseModel = BaseProviderResponseModel.extend({
    type: z.literal(""oauth""),
    url: z.string().url(),
});

export const ProviderResponseModel = z.discriminatedUnion(""type"", [
    LocalProviderResponseModel,
    OAuthProviderResponseModel,
]);
```

When parsing a response using `ProviderResponseModel` I'm expecting to receive either a `type=""local""` or `type=""oauth""` and this works fine.

At some point in the future the data I parse may present other types I do not yet know about but I would like for them to just be stripped rather than throwing an error about an unknown discriminator value.

Am I missing an obvious way to do this?",,
1354689510,1362,"Using `z.function(z.tuple([...]), ...).implement()` form results in TS2345 in TypeScript 4.8",zod was listed in microsoft/TypeScript#50060 with several issues. I've actually encountered the issue listed for [src/tests/function.test.ts#L115](https://github.com/colinhacks/zod/blob/master/src/__tests__/function.test.ts#L115) in the zod tests.,,
1353253174,1359,Module parse failed error from Zod enum. ,"Update - figured out this is a problem with symlink/babel and not Zod

I'm getting this error, I believe from this zod enum. At the very least the error goes away if I changes the options prop on Autocomplete. Any idea what's causing this? Let me know if there's any other info needed.

Zod: 3.18.0
Material UI: 5.10.2
React: 18.2.0

```
export const countries = z.enum([
  ""United States"",
  ""Canada"",
  ""Afghanistan"",
  ""Albania"",
  ""Algeria"",
  ""American Samoa"",
  ... every other country
])
export type Countries = z.infer<typeof countries>

<Autocomplete 
options={[schema.countries.options]}
renderInput={(params) => (<></>)
/>
```
`Module parse failed: Unexpected token (9:7)
File was processed with these loaders:
 * ./node_modules/@pmmmwh/react-refresh-webpack-plugin/loader/index.js
 * ./node_modules/source-map-loader/dist/cjs.js
You may need an additional loader to handle the result of these loaders.`",,
1350835413,1356,special case: union types with omit and extended schema throws TS error,"We have the following case:

a base type:

![image](https://user-images.githubusercontent.com/827205/186662736-d5c13df1-355f-45e2-b33e-c9c0a07c7d24.png)

multiple extended types, one of them omits the `background_variant` field:

![image](https://user-images.githubusercontent.com/827205/186662838-d242d7d9-781d-42e0-8cab-f67bb038f265.png)

one union type for all of them:

![image](https://user-images.githubusercontent.com/827205/186663054-f5f62660-4654-4d3f-a30c-a454b728d871.png)

usage of some fields:

![image](https://user-images.githubusercontent.com/827205/186663267-e7cc0a03-e083-45ff-ba47-a58ec6851911.png)

Which results in this error:

```
error TS2339: Property 'background_variant' does not exist on type '{ type: ESuluContentBlockTypes.TEXT; settings: { hidden: boolean; schedules_enabled: boolean; schedules: ({ type: ESuluSettingsScheduleTypes.FIXED; start: string; end: string; } | { ...; })[]; } | {} | string[]; background_variant: ESuluContentBlockBackgroundVariants | null; title: string; description: string; } | ....'.
```

What is the correct approach to resolve this?",,
1348162179,1353,Recursive type does not have same types after transforms,"I must be doing something wrong or I'm thinking of a solution in a wrong way.

I have this schema and type

```ts
function transformInvalidArrayValues<T>(
  value: (string | T)[],
): T[] {
  return value.filter((val): val is T => !!val && isReferenced(val));
}

function isReferenced<T>(ref: string | T): ref is T {
  return typeof ref !== 'string';
}

const CountryTargetableSchema = z.object({
  countries: z
    .array(z.union([z.string(), CountrySchema]))
    .transform(transformInvalidArrayValues),
});

type CountryTargetable = z.infer<
  typeof CountryTargetableSchema
>;
```

The CountryTargetable type is, as expected, now an array of valid objects that respect the CountrySchema (not relevant since it's just other fields).

But now, I need to define a recursive type that extends this structure.

```ts
interface Node extends CountryTargetable {
  testing: string;
}

export const NodeSchema: z.ZodType<Node> = z.lazy(() =>
  CountryTargetableSchema.extend({
    testing: z.string()
  })
);
```

but this is giving a Type error:

```
The types of '_input.countries' are incompatible between these types.
Type '(string | { uid: string; title: string; locale: string; country_code: string; })[]' is not assignable to type '{ uid: string; title: string; locale: string; country_code: string; }[]'
```

seemingly ignoring the transforms that were performed by the schema.

I have a feeling I might be doing something wrong or thinking about things wrong or confusing something.

Does anyone have any idea what might be the issue here? ",,
1346531288,1350,Is it possible to custom validate the allowed keys when. using .passthrough or .strip?,"I first want to congratulate you to a very well designed and implemented library!

I'm currently evaluating the use of zod in my application and have a small problem when having to parse an object that can contain optional keys. I'm using .passthrough to allow the keys to stay in the object but would like to custom validate the keys or at least make sure that the key names and types are valid. The .catchall only allows to specify a type of all optional keys but I would require to custom validate each optional key.

```typescript
import {z} from 'zod';

// mandatory user information
const user = z.object({
    id: z.number(),
    name: z.string(),
});

// additional keys like:
// string: key in the format /^add_\d{3}_s$/
// number: key in the format /^add_\d{3}_n$/ 

add_001_s: z.string()
add_002_s: z.string()
add_003_n: z.number()
add_004_n: z.number()
```",,
1340865011,1340,Support passthrough on z.record,"Although zod support `passthrough` automatically on `z.instanceof`, and with explicit use of of the `passthrough` method on `z.object`; there seems to be no way to replicate this functionality with `z.record`. When writing a class decorator for Vue, I ran info this problem where parsing the existing property options for correctness resulted in a different object that the one on the component options. This prevented attaching new property options correctly.",,
1338509949,1333,Can not merge a record type into an object type,"Hi 👋 
I want to rebuild the following types from ts type to zod type:
```typescript
type myType = {
  ""204"": never
  [t: string]: Record<string, {
    foo: string,
    bar: number
  }>,
} 
```
When I write the zod types like this, it shows me an error that `Argument of type 'ZodRecord<ZodString, ZodRecord<ZodString, ZodObject<{ foo: ZodString; bar: ZodNumber; }, ""strip"", ZodTypeAny, { foo: string; bar: number; }, { foo: string; bar: number; }>>>' is not assignable to parameter of type 'AnyZodObject'.`:
```typescript
const myTypeZod = z.object({
  '204': z.never(),
}).merge(
  z.record(
    z.record(
      z.object({
        foo: z.string(),
        bar: z.number(),
      }),
    ),
  ),
)
```
How can I merge a record type with `key: string` into an object type?",,
1338319188,1332,`z.instanceof` does not accept abstract classes,"In #1065, `z.instanceof` rejects classes with a private constructor. This can be resolved by using `z.custom`, but this syntax isn't ideal and repeats itself between the type param and the right hand side of `instanceof` operator.

A similar issue appears when using an abstract class, is there anything that could be done about that?
```ts
abstract class foo {
  constructor() {}
}

z.instanceof(foo);
// Argument of type 'typeof foo' is not assignable to parameter of type 'new (...args: any[]) => any'.
//  Cannot assign an abstract constructor type to a non-abstract constructor type. ts(2345)
```
This can be worked around using the above, but typescript does allow for parameter type `abstract new (...args: any[]) => any`, which could be used either in place of or in union to the existing parameter type on `z.instanceof`

Failing that, a class is just a different syntax for defining a function, and classes can be passed to parameter type `Function`. This allows for incorrect usage by passing a normal, non-class function, but I expect most users of Zod to understand the difference on the basis of a) they're competent enough to be using TypeScript and b) they're using Zod, a schema-base parser/validator.
```ts
// this has no issues with very strict TS compiler options
function parse(x: Function, y: unknown) {
  return y instanceof x;
}

// this solves the abstract issue, and prevents passing incorrect subtypes of `Function`

/** this union is not necessary and will work with only the abstract variant. The union is to be more verbose */
type MaybeAbstractClass = (abstract new (...args: any[]) => any) | (new (...args: any[]) => any);

function parse(x: MaybeAbstractClass, y: unknown) {
  return y instanceof x;
}
```",,
1336354033,1331,"Creating a custom type for number, strings, etc","We use numbers all over our codebase to represent numbers, dollar value, percentages, etc. Ideally, we'd like to keep the zod type along with a typescript type that represents that type. 

Here's an example:

```ts
type DollarValue = number;

const dollarValueSchema = z.number();
```

Ideally, when using `z.infer<typeof dollarValueSchema>` we get `DollarValue` type, instead of `number`. 

Thoughts? ",,
1334954938,1326,Readme.md typo.,"In the Readme.md it says for the documentation of keyof property.
### `.keyof`

Use `.key` to create a `ZodEnum` schema from the keys of an object schema.

```ts
const keySchema = Dog.keyof();
keySchema; // ZodEnum<[""name"", ""age""]>
```

there a type in Use `.key` it's actually .keyof method not .key.

And A salam alaykoum.",,
1334860777,1325,"`.keyof()` relies on key order, resulting in unsound `.options` tuple type","Saw this [awesome trick](https://github.com/colinhacks/zod/pull/1216/files#diff-44137e14e4c38858d2925367bcf2455388e24146f88934724da11d2f9ecaa7d2) by @ecyrbe transforming object keys into string tuple ordered by source declaration, but beware [TS treats key order differently than JS engines](https://2ality.com/2015/10/property-traversal-order-es6.html#traversing-the-own-keys-of-an-object):

```ts
z.object({ a: z.string(), '1': z.string() }).keyof().options()
// TS says it's ['a', '1']
// JS runtime it's ['1', 'a']
```

I believe `.options` is public API for enums, therefore this typing is unsound.
A simple solution that comes to mind is having an `UnorderedZodEnum` like

```ts
type UnorderedZodEnum<T extends [string, ...string[]]> = Omit<z.ZodEnum<T>, 'options'> & { options: Set<T> }
```

Or just downgrade the keyof to return `ZodSet` instead of `ZodEnum`.

A * mostly * non breaking change could be something like:

```ts
type UnorderedZodEnum<T> = Omit<ZodEnum<T>, 'options'> & { options: Repeat<typeof T[number], T['length']> }

type Repeat<N extends number, T, Acc extends T[] = []> = N extends Acc['length']
  ? Acc
  : Repeat<N, T, [T, ...Acc]>
```

Will still be breaking change in use-cases relying on contravariance or assignability, but those are exactly the cases that would be unsound in current version, eg:

```ts
const Enum = z.object({ a: z.string(), b: z.string() }).keyof()

// user relying on ordering of current API
const first: 'a' = Enum.options[0]
// Type '""a"" | ""b""' is not assignable to type '""a""'.

// needs to be cast instead
const first = Enum.options[0] as 'a'
```

A more non-breaking solution would be to try mimicking JS engines, beware of typescript `keyof` though, it seems to sometimes result in desired order (i really didn't get the rule on that), but only with object literals, not when the object comes from a generic param. Seems the safer would be to force the engine ordering with something like:

```ts
type ObjectKeys<T> = [
  ...Sort<enumUtil.UnionToTupleString<IntString<keyof T>>>, 
  ...enumUtil.UnionToTupleString<Exclude<keyof T, IntString<keyof T>>>
]
```

But to implement a 'Sort' for that would need some more possibly unsound tricks",,
1333118374,1322,[Bug] Type inference does not work as expected when using catchall,"Using zod's type inference (schema first approach) I get typescript errors when using catchall.

Example:

```typescript
import z from 'zod';

const zschema = z
  .object({
    'main': z.string()
  })
  .catchall(z.number().optional());

const result = zschema.safeParse({
  'main': 'foo',
  'catch': 1
});

type Test = z.infer<typeof zschema>;
const foo: Test = {
  'main': 'foo',
  'a': 1
}
```

This example shows the expected behaviour for `safeParse` (which correctly validates the object), but it results in a typescript error when trying to instantiate an object using the infered type `Test`.

Expected behaviour:

`type Test` should resolve to something like:
```typescript
{
  main: string,
  [x: string]?: number
}
```

However it produces the following error given the example above:
```typescript
const foo: {
    [x: string]: number | undefined;
    main: string;
}
'foo' is declared but its value is never read.ts(6133)
Type '{ main: string; a: number; }' is not assignable to type '{ [x: string]: number | undefined; main: string; }'.
  Property ''main'' is incompatible with index signature.
    Type 'string' is not assignable to type 'number'.ts(2322)
```",,
1330054611,1316,support coercion for non primitives,"Would you be open to a PR, providing built-in implementation for processors, performing coercion to most common types? (numbers, string, booleans, arrays)? 

This is how type coercion looks like right now:
```ts
        const preprocessor = (value) => {
            switch (typeof value) {
                case 'bigint':
                case 'boolean':
                case 'number':
                    return value.toString();

                case 'object':
                    if (value == null) {
                        return value;
                    }
                    if (value instanceof Date) {
                        return value.toISOString();
                    }
                    return value; // could not coerce, return the original and face the consequences during validation

                case 'string':
                    return value.trim();

                case 'undefined':
                    return value;

                default:
                    return value; // could not coerce, return the original and face the consequences during validation
            }
        }

        const CREATE_USER_SCHEMA = z.object({
            age: z.preprocess(preprocessor, z.string().max(15))
        })

        const result = CREATE_USER_SCHEMA.parse({
            age: 44
        });

        expect(result).toEqual({
            age: '44'
        })
```

This is pretty verbose and requires plenty of boilerplate every time.

This is a proposed API:
```ts
        const CREATE_USER_SCHEMA = z.object({
            age: z.string().max(3).coerce()
        })

        const result = CREATE_USER_SCHEMA.parse({
            age: 44
        });

        expect(result).toEqual({
            age: '44'
        })
```

Resolution of a specific preprocessor would be based on ZodType `typeName`, and throw an error if no preprocessor is implemented for a given type.",,
1328332628,1309,[Feature Request] Catch errors thrown in transform,"README says that `transform` should not throw errors. This makes it less convenient to use for two reasons:
1. If the code can throw errors, we need to ensure that they are caught and transformed to `ctx.addIssue` calls with `fatal: true`
2. There is often no meaningful value to return in case the error happens, so for zod to infer the output type correctly, some hacks are needed

For example, I wrote this utility helper in my applicaiton to handle this problem:
```
export const zodCatch =
  <Input, Result>(fn: (input: Input) => Result) =>
  (input: Input, ctx: RefinementCtx) => {
    try {
      return fn(input);
    } catch (error) {
      if (error instanceof Error) {
        ctx.addIssue({
          fatal: true,
          code: ZodIssueCode.custom,
          message: error.message,
          params: {
            ...error,
            name: error.name,
          },
        });
      } else {
        ctx.addIssue({
          fatal: true,
          code: ZodIssueCode.custom,
          message: String(error),
        });
      }

      // Hack for zod to infer type correctly
      // this value won't be used because we added fatal issues to ctx
      return undefined as any as Result;
    }
  };
```

I use it like this:
```
const schema = z.string().transform( zodCatch((v) => JSON.parse(v)) );
const parsed = schema.parse(""invalid json"");
```

Although this helper solves the problem for me, it would be nice if something like this could be included in zod itself. If catching all errors is too much (it would likely be a breaking change), maybe it can only catch instances of a specific error class. That would still be beneficial because it would eliminate the need for a return type hack.
",,
1328312382,1308,Incorrect Input type when using `refine` with a type guard,"When using `refine` with a type guard, the Input type gets changed to `RefinedOutput` type. I do not expect this to be the desired behavior, because this breaks the Input type when used with transforms. See example:


```
import { z } from 'zod';

const schema = z.string().transform(v => 5 as number | undefined /* Imagine some lookup here */);

type input = z.input<typeof schema>;
//   ^ string

type output = z.output<typeof schema>;
//   ^ number | undefined

const refined = schema.refine((v): v is Exclude<typeof v, undefined> => v !== undefined);

type input2 = z.input<typeof refined>;
//   ^ number <-- wrong, should be string

type output2 = z.output<typeof refined>;
//   ^ number
```
[Link to CodeSandbox](https://codesandbox.io/s/zod-refine-type-issue-kg7mlh?file=/src/index.ts)

The potential cause is that the corresponding `refine` type definition returns `ZodEffect` with `RefinedOutput` instead of `Input`.
https://github.com/colinhacks/zod/blob/master/src/types.ts#L272

",,
1328000947,1307,How would I extract first property type from zod object?,"Here is what I got:

```ts
import {
  z,
  type ZodTypeAny,
} from 'zod';

const foo = z.object({
  name: z.string(),
});

const bar = <T extends ZodTypeAny>(shape: T) /* ??? */ => {
  return null as any;
};

const baz = bar(foo);

console.log(baz);
```

I need `baz` to be first/any property value of `foo`, i.e. in this case it should be `string`.

How would I extract first property type from zod object?",,
1326315581,1304,Allow default values for empty strings,"I'm trying to assign [a default value when string is empty](https://codesandbox.io/s/typescript-playground-export-forked-s0g6ip?file=/index.ts) without any luck. 

```ts
import { z } from ""zod"";

const stringWithDefault = z.string().optional().default(""tuna"")

const result = stringWithDefault.parse(""""); // => Should be ""tuna"" instead is """"
//      ^ ?

console.log(result);
```

How could I achieve this?

```ts
const result = stringWithDefault.parse(undefined) // => returns ""tuna""; 
const result = stringWithDefault.parse("""") // => returns """"; 
```

Basically I want  both cases to use the default value.",,
1325463823,1302,Zod claims that types are incompatible: required is missing,"For some reason even a simple schema doesn't work for me:

```ts

import { z } from 'zod'

type Foo = {
  a: number
}
export const schemaFoo: z.ZodType<Foo> = z.object({ // ***
  a: z.number(),
})

```

In the ***-line I get an error:
```
Type 'ZodObject<{ a: ZodNumber; }, ""strip"", ZodTypeAny, { a?: number; }, { a?: number; }>' is not assignable to type 'ZodType<Foo, ZodTypeDef, Foo>'.
  Types of property '_type' are incompatible.
    Type '{ a?: number; }' is not assignable to type 'Foo'.
      Property 'a' is optional in type '{ a?: number; }' but required in type 'Foo'.ts(2322)
```",,
1321703791,1297,how can I fix this type error,"![image](https://user-images.githubusercontent.com/23290513/181674944-f54a89e5-4bdf-41fa-9c68-2a858594b70d.png)

```
export function parseClientData<T>(
  schema: z.ZodType<T>,
  input: z.input<z.ZodType<T>>
) {
  return schema.safeParse(input);
}

const Schema = z.object({
  a: z.string().transform((val) => JSON.parse(val) as { b: string })
});

parseClientData(Schema, { a: JSON.stringify({ b: ""1"" }) });
```",,
1318573759,1292,Addition of `.keyof()` breaks assignability for `ZodObjects`,"Hi there,

#1216 appears to break assignability of `ZodObjects` in a subtle way.  For example, the following worked before Zod 3.17.9, but fails in the latest Zod (3.17.10).  I'm on TypeScript version 4.7.4.

```ts
declare const superset: { foo: string } & z.ZodObject<{
  prop1: z.ZodString;
  prop2: z.ZodNumber;
}>; // The `{ foo: string }` intersection is necessary for this to fail for some reason.

const subset: z.ZodObject<{ prop1: z.ZodString }> = superset;
//    ^^^^^^ Error here
```

This produces the following type error:

```
Type '{ foo: string; } & ZodObject<{ prop1: ZodString; prop2: ZodNumber; }, ""strip"", ZodTypeAny, { prop1: string; prop2: number; }, { prop1: string; prop2: number; }>' is not assignable to type 'ZodObject<{ prop1: ZodString; }, ""strip"", ZodTypeAny, { prop1: string; }, { prop1: string; }>'.
  The types returned by 'keyof()._parse(...)' are incompatible between these types.
    Type 'ParseReturnType<""prop1"" | ""prop2"">' is not assignable to type 'ParseReturnType<""prop1"">'.
      Type 'OK<""prop1"" | ""prop2"">' is not assignable to type 'ParseReturnType<""prop1"">'.
        Type 'OK<""prop1"" | ""prop2"">' is not assignable to type 'OK<""prop1"">'.
          Type '""prop1"" | ""prop2""' is not assignable to type '""prop1""'.
            Type '""prop2""' is not assignable to type '""prop1""'.ts(2322)
```

The problem arises because `z.ZodEnum<[""prop1"", ""prop2""]>` is not assignable to `z.ZodEnum<[""prop1""]>`.  This makes sense!  However, I would argue that `superset` _should_ be assignable to `subset`, because that aligns with TypeScript's structural typing.  In particular, in TypeScript,
```ts
interface Superset {
  prop1: string;
  prop2: number;
}
```
is assignable to
```ts
interface Subset {
  prop1: string
}
```

As I mentioned in the comment, for some reason this error doesn't surface unless you intersect the `z.ZodObject` with a non-empty object type (i.e., `{ foo: string }` in the example above).  As far as I can tell, this is a TypeScript quirk.  I _think_ with the addition of `.keyof()`, TypeScript _should_ be raising an error even without that intersection present.  Maybe I'm missing something?

Not sure what the solution is here other than removing `.keyof()` I guess.  It could be replaced with `z.keyOf(object: z.ZodObject)`  or something else that doesn't change the `ZodObject` type?  Or you could decide that this problem doesn't matter!  But a project I'm working on does lots of fun stuff with Zod and we rely on `ZodObject` assignability working this way 🥲.

Thanks for reading and for the fantastic library.

P.S. I feel like somehow the new [variance annotations](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#optional-variance-annotations-for-type-parameters) could be used to solve this but I'm not sure how.",,
1318559702,1291,`tuple` produces broken schema on bad input,"An easy typo to make with `tuple` is to pass the arguments without wrapping them in an array:

```
// correct:
const schema = z.tuple([z.number(), z.number()])

// incorrect:
const schema = z.tuple(z.number(), z.number())
```

Rather than throwing an error on construction, a schema is created which parses successfully to the empty array:

```
const schema = z.tuple(z.number(), z.number())
schema.parse([1,2]) // []
```

Admittedly, this is only a problem if type checking is not enabled. However, if supporting vanilla JS is design goal, `tuple` should probably perform some runtime validation of its inputs.",,
1315876402,1284,strictObjects and unions,"Hey,
I'm trying to create a schema for an object that has a `code` property, a `path` property, or both.
But not none, and that no other key exists by combining 2 strict objects, and then doing a ""and / or"" mechanism as following:

```
import z from ""zod"";

const withCode = z.strictObject({code: z.string()});
const withPath = z.strictObject({path: z.string()});

const withCodeOrPath = withCode.or(withPath);
const withCodeAndPath = withCode.and(withPath);
const withCodeAndOrPath = withCodeAndPath.or(withCodeOrPath);

withCodeAndOrPath.parse({
  code: ""bob"",
  path: ""bob""
});
```

But this doesn't work, parsing fails with:
`Unrecognized key(s) in object: 'path'`

The TS version of this does seem to work, here's a sandbox link - https://codesandbox.io/s/blissful-fog-xcdyh5?file=/src/pure-types.ts

PS: I fixed it by making both properties optional, and then using a custom refinement.
`.refine((obj) => obj.code || obj.path)`

Is this a bug? expected behavior? 

Thanks in advance!


",,
1315248674,1278,New Feature - Variadic tuples with noUncheckedIndexedAccess,"Variadic tuples were introduced in Typescript 4.0, and they allow some pretty nifty tricks.
If the [--noUncheckedIndexedAccess](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess) is enabled, it's possible to differentiate arrays that are guaranteed to have at least one element from simple arrays, like so:

```
type Array1<T> = [T, ...T[]];

const a: Array1<string> = []; // this will show an error
const b: string[] = []; // no error here
```
<img width=""363"" alt=""example"" src=""https://user-images.githubusercontent.com/4076804/180491063-07e12dee-bcba-4852-a219-a1596c7c7077.png"">

and it also correctly types if we want to access some index:

<img width=""391"" alt=""example2"" src=""https://user-images.githubusercontent.com/4076804/180491067-dc6f336b-2f70-4c44-9133-7fc33b093a0c.png"">

I used this approach in a previous project, but had to define manually all the necessary type guards to check if a standard array has at least one element.

https://github.com/nicu-chiciuc/dependent-ts/blob/59f92dc243bfdc53494fd6e3dfd13efbef026829/src/index.ts#L82

I was wondering if this is something that would be of interest to somebody.

",,
1312990100,1277,.strip and .partial not available methods on ZodDiscrimatedUnion schema,"I have a base generic equal to `z.ZodObject<{ [k: string]: any }>`.

Unfortunately the follwowing schema doesn't satisfy that requirement which seems like an error?

```typescript
export const schema = z
  .object({
    id: z.string().min(1),
  })
  .and(
    z.discriminatedUnion(""type"", [
      z.object({ type: z.literal(""A""), payload: z.object({a: z.string()}) }),
      z.object({ type: z.literal(""B""), payload: z.object({b: z.string()}) }),
    ])
  );
```

My base generic needs to be `z.ZodObject<{ [k: string]: any }>` which exposes `.strip` and `.partial` on the schema. A `z.discriminatedUnion` (nor `z.ZodIntersection`) schema does not which seems odd?

Shouldn't the following code be valid?

```typescript
// example 1 discriminated union
z.discriminatedUnion(""type"", [
      z.object({ type: z.literal(""A""), a: z.string() }),
      z.object({ type: z.literal(""B""), b: z.string() }),
  ]).partial()  // TS and runtime error

// example 2 intersection
z.object({
    a: z.string(),
  })
  .and(
    z.object({ b: z.string() })
  ).partial()  // TS and runtime error

// example 3 union
z.union([
    z.object({ a: z.string() }),
    z.object({ b: z.string() }),
  ]).partial()  // TS and runtime error
```",,
1311422574,1275,Please add TypeScript support for `.extend()` method in the z.Schema type,"I find it very useful to add my types for Zod schemas, so that if I change the type, TypeScript helps me in highlighting the errors in my broken schemas. But as soon as I assign any schema `z.Schema<MyType>`, I can no longer extend this schema.
Here's a detailed example:
1. Without `z.Schema<MyType>` specification:
```
const mySchema = z.object({ ... });
const anotherSchema = mySchema.extend({ ... });
```
Works just fine, but no highlights if I have my types mismatched with the schema.

2. With `z.Schema<MyType>` specification:
```
const mySchema: z.Schema<MyType> = z.object({ ... });
const anotherSchema = mySchema.extend({ ... });
```
Here, I have my type definitions connected to Zod schemas, but I can no longer safely extend from `mySchema` (by safely, I mean type-safety, if I put @ts-ignore, it works just as expected).

Please suggest a workaround if any exists or add a type support for `extend` method in Schema type definition. Thanks!",,
1308924744,1270,'Invalid binding pattern' error when remapping object properties in transformer,"Using a spread operator in a transformer raises an error.

### Versions

* node v18.3.0
* zod v3.17.9
* typescript 4.7.4

### Repro

```ts
//  SymbolInfo.ts
import { z } from 'zod'

const Parser = z.object({
    business_description: z.string().min(1),
    country: z.string().min(1),
    currency_code: z.string().min(1),
    exchange: z.string().min(1),
    industry: z.string().min(1),
    isin: z.string().min(1),
    local_code: z.string().min(1),
    nsin: z.string().min(1),
    pro_name: z.string().min(1),
    sector: z.string().min(1),
    sedol: z.string().min(1),
    session_holidays: z.string()
      .refine((x) => /^(?:\d{8},?)*$/.test(x))
      .transform((x) => x.split(',')),
    short_description: z.string().min(1),
    web_site_url: z.string().min(1),
  })
  .transform(({
    business_description: description,
    currency_code: currency,
    pro_name: identifier,
    local_code: localCode,
    session_holidays: holidays,
    short_description: name,
    web_site_url: url,
    ...entries,
  }) => ({
    identifier,
    name,
    localCode,
    description,
    url,
    currency,
    holidays,
    ...entries,
  }))

export type SymbolInfo = z.infer<typeof Parser>
export const createSymbolInfo = (params: unknown): SymbolInfo => Parser.parse(params)
```

```json5
// tsconfig.json
{
  ""compilerOptions"": {
    ""esModuleInterop"": true,
    ""module"": ""esnext"",
    ""moduleResolution"": ""node"",
    ""target"": ""esnext"",
    ""strict"": true,
  },
}
```

### Error

```text
Error: Transform failed with 1 error:
file:///project/SymbolInfo.ts:29:14: ERROR: Invalid binding pattern
    at failureErrorWithLog (/project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:1605:15)
    at /project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:1394:29
    at /project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:666:9
    at handleIncomingPacket (/project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:763:9)
    at Socket.readFromStdout (/project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:632:7)
    at Socket.emit (node:events:527:28)
    at addChunk (node:internal/streams/readable:324:12)
    at readableAddChunk (node:internal/streams/readable:297:9)
    at Readable.push (node:internal/streams/readable:234:10)
    at Pipe.onStreamRead (node:internal/stream_base_commons:190:23) {
  errors: [
    {
      detail: undefined,
      id: '',
      location: {
        column: 14,
        file: 'file:///project/SymbolInfo.ts',
        length: 1,
        line: 29,
        lineText: '    ...entries,',
        namespace: '',
        suggestion: ''
      },
      notes: [],
      pluginName: '',
      text: 'Invalid binding pattern'
    }
  ],
  warnings: []
}
```",,
1308906473,1269,how can i transform class-validator + class-transfomer to zod?,"```
import {Type} from 'class-transfomer';
import {IsNumber} from 'class-validator';

class TestDto {
  @IsNumber()
  @Type(() => Number)
  a: number;
}
```

I can input { a: '123' } , and then output { a: 123 } with class-validator，although the type of a does not match，so how can I use zod to describe this case?",,
1308011448,1268,how can i use circular zod schema,"typescript:

```
export interface IndustryDTO {
  name: string;
  tagGroups: Array<TagGroupDTO>;
  id: number;
  subs: Array<IndustryDTO>;
}
```

zod schema

```
export const IndustryDTOZodSchema = z.object({
  name: z.string(),
  tagGroups: TagGroupDTOZodSchema.array(),
  id: z.number().int(),
  subs: IndustryDTOZodSchema.array()
});
```


but this will case `ReferenceError: Cannot access 'IndustryDTOZodSchema' before initialization`",,
1305339221,1263,`discriminatedUnion` produces TS error when `.default` or `.preprocess` are applied,"[Playground link.](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFAxhAHYDO8AYhBAMrUAWApiAIZwAvCgB0EAEYArHtRgAKBBThwYATzA8AXGIA2wGDyj9d8-Jjb4AlKOI9M-AK66F5y1YA0yuPx3JRTFDAdADm8p4UaFaUNPRMcABC-FCcvALCYpIycore6pp+ovqGxqb41I5MuNZeKiA8MFwkhYHBYRFRMbSM8EnIqXyCIv7EwAzUQSDB-IbEAKp0wPRm+Tz4HnAA2qwc3IMbSSl7AgC60bGMELo8RRBhfQMComDJDDyKPjpuEPjoVudAA)

Given this snippet:

```ts
import { z } from 'zod';

const FooSchema = z.object({
  type: z.literal('foo').default('foo'),
  a: z.string(),
});

const BarSchema = z.object({
  type: z.literal('custom'),
  method: z.string(),
});

const BazSchema = z.discriminatedUnion('type', [FooSchema, BarSchema]);
console.log(BazSchema.parse({ a: 'foo' }));
```

TypeScript produces this error:

```
$ tsc tmp.ts
tmp.ts:13:49 - error TS2322: Type 'ZodObject<{ type: ZodDefault<ZodLiteral<""foo"">>; a: ZodString; }, ""strip"", ZodTypeAny, { type?: ""foo""; a?: string; }, { type?: ""foo""; a?: string; }>' is not assignable to type 'ZodDiscriminatedUnionOption<""type"", Primitive>'.
  Type '{ type: z.ZodDefault<z.ZodLiteral<""foo"">>; a: z.ZodString; }' is not assignable to type '{ type: ZodLiteral<Primitive>; } & ZodRawShape'.
    Type '{ type: z.ZodDefault<z.ZodLiteral<""foo"">>; a: z.ZodString; }' is not assignable to type '{ type: ZodLiteral<Primitive>; }'.
      Types of property 'type' are incompatible.
        Property 'value' is missing in type 'ZodDefault<ZodLiteral<""foo"">>' but required in type 'ZodLiteral<Primitive>'.

13 const BazSchema = z.discriminatedUnion('type', [FooSchema, BarSchema]);
                                                   ~~~~~~~~~

  node_modules/zod/lib/types.d.ts:531:9
    531     get value(): T;
                ~~~~~
    'value' is declared here.


Found 1 error in tmp.ts:13
```

This code works at runtime however and Zod correctly parses the object:

```
{ type: 'foo', a: 'foo' }
```",,
1303419332,1258,Extending z with custom types,"I'm using [Day.js](https://day.js.org) extensively in my application. The way to check for dayjs type is to check instanceof dayjs (the function):
```js
import dayjs from ""dayjs"";
const date = dayjs();
console.log(date instanceof dayjs) // true
```

The param type of `z.instanceof` only accepts classes with constructors, but it works in runtime for checking instanceof dayjs. This means that I have to typecast dayjs as any every time I need it in instanceof:
```ts
const dateType = z.instanceof(dayjs as any);
```

Is there an option to extend `z` so that I can do something like `z.dayjs()`?",,
1302145509,1257,Incorrect validation with `optional` and `default` properties,"## The problem 

I noticed that when setting the `optional` property before the `default` the validation does not have the same behavior.
Look at the example below:

```tsx

const mySchema1 = z.object({
  name: z.string(),
  surname: z.string().min(1).max(120).optional().default("""")
});

const mySchema2 = z.object({
  name: z.string(),
  surname: z.string().min(1).max(120).default("""").optional()
});

const data = {
  name: ""Leo""
};

const result1 = mySchema1.safeParse(data);
/**
 * Result:
 * {
 *  ""success"": false,
 *  ""error"": {
 *    ""issues"": [
 *      {
 *        ""code"": ""too_small"",
 *        ""minimum"": 1,
 *        ""type"": ""string"",
 *        ""inclusive"": true,
 *        ""message"": ""String must contain at least 1 character(s)"",
 *        ""path"": [""surname""]
 *      }
 *    ],
 *    ""name"": ""ZodError""
 *  }
 * }
 */

const result2 = mySchema2.safeParse(data);
/**
 * Result:
 * { ""success"": true, ""data"": { ""name"": ""Leo"" } }
 */
```
I expected `result1` to have the same behavior as `result2`.

### Possible fix
Change type `default(def: util.noUndefined<Input>): ZodDefault<this>;` to also accept `undefined`

```tsx

const mySchema1 = z.object({
  name: z.string(),
  surname: z.string().min(1).max(120).optional().default(undefined)
});

```

### **Packages and versions:**
""zod"": 3.17.3
""typescript"": ""4.5.5""




",,
1294561321,1247,Functions with transform in returns/args,"Hello and first of all, thank you for this great library.  
I'm trying to validate a function with a schema with a `returns` that contains a `transform`. The problem occurs when the function schema is implemented : the return type is `Returns['_input']` instead of `Returns['_output']`. Here is a simple example :

```ts
const a = z.function().args(z.string()).returns(z.number().transform((v) => `${v}`));
const b = a.implement((e) => +e); // b is (e:string) => number but should be (e:string) => string
```
By investigating, I guess the problem comes from https://github.com/colinhacks/zod/blob/master/src/types.ts (lines 2884-2894) where the return types of `implement` and `strictImplement` are not accurate :
```ts
implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
    const validatedFunc = this.parse(func);
    return validatedFunc as any;
}

strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns> {
    const validatedFunc = this.parse(func);
    return validatedFunc as any;
}
```
I guess they should match the `OuterTypeOfFunction` defined in the same file at line 2752.
",,
1294532679,1246,Getter maxLength in ZodString has incorrect type (null),"**Snippet:**

```typescript
const s = z.string().max(10);
type L = typeof s.maxLength;
```

**Expected:**

```typescript
type L = number | null        // or ideally just number
```

**Actual:**

```typescript
type L = null
```

**Setup:**
- zod v3.17.3
- typescript v4.7.4

**Context:**

This is the current implementation of `maxLength`.

```typescript
  get maxLength() {
    let max: number | null = null;
    this._def.checks.map((ch) => {
      if (ch.kind === ""max"") {
        if (max === null || ch.value < max) {
          max = ch.value;
        }
      }
    });
    return max;        // typescript considers max to be of type null here
  }
```

The issue here is that Typescript ignores callbacks when it comes to type narrowing (assumes that they won't have any side effects). See https://github.com/microsoft/TypeScript/issues/35593 and https://github.com/microsoft/TypeScript/issues/9998. Since the only other operation on the variable `max` is its assignment to `null`, Typescript will narrow down its type to just `null`.

**Potential Fixes:**

- Add an explicit return type annotation of `number | null`.
- Replace `.map` with a for-of loop.",,
1294220346,1245,Schemas generated by refine do not have the omit method (or that is what typescript says),"Hello, first of all, thanks for Zod, it's fantastic.
According to typescript, the objects that have been refined do not have the omit method.
To reproduce you can try something as simple as this

```ts
const schema = z.object({ name: z.string(), age: z.number() }).refine(() => true);
const newSchema = schema.omit({ name: true }) // <- omit does not exist 
```
",,
1293361208,1243,Custom error map not working,"Hello,
I'm trying to customize the error messages using an error map but it doesn't seem to have any effect, the function gets executed, but the returned message doesn't come from the map.

Example:
```js
const customErrorMap = (issue, ctx) => {
  return { message: ""custom"" };
};

const email = z.string({ required_error: ""required"" }).email(""invalid"");

const res = email.safeParse(""email"", { errorMap: customErrorMap });
``` 

I would expect `res` to contain the `custom` error message, but in fact it returns:
<img width=""298"" alt=""Screenshot 2022-07-04 at 13 59 40"" src=""https://user-images.githubusercontent.com/23037261/177150474-61cd571c-4a59-4ff7-a3d8-b0e01561d74b.png"">

If I remove `.email(""invalid"")` it works, so seems like the chained validation has a higher priority than the error map which should not be the case.

Repro:
https://codesandbox.io/s/festive-gould-m7y3nk?file=/src/index.ts:22-297",,
1289883408,1237,Feature request for reverse transform,"I love how the `.transform` function works and how it all makes working with external data so easy. In my example I'm loading and parsing an ini file and then transform it into usable JSON to work with in forms in my app. This is all great and smooth but the problem I encountered was when I wanted to save the modified data back into an ini file. What I had to do was basically double all my schemas, one for parsing data from the ini (`MatrixValueSchema`) and one for parsing my form values back to the shape of the ini file data (`RawMatrixValueSchema`).

Here is the [schema file](https://github.com/Haaxor1689/FightKnightEdit/blob/master/src/utils/types.ts#L13) for full context.

One solution that I think would work nicely, would be to add an optional reverse callback to the `.transform` helper and then a new `.reverseParse` function which would take a output value and return a input value.

I'm sure there are a bunch of more steps to think through for this to work, but I'd like to hear your opinion on usefulness of feature like this or some way to better solve this problem with current features.",,
1288520522,1234,Undefined description with default,"Example:
```typescript
import { z } from ""https://deno.land/x/zod/mod.ts"";

const schema1 = z.object({
    param: z.string({ description: 'description of the param' }),
});

const schema2 = z.object({
    param: z.string({ description: 'description of the param' }).default('value'),
});

console.log(schema1.shape.param.description);
console.log(schema2.shape.param.description);

// result:
description of the param
undefined
```
I expect description value in schema2.",,
1287111659,1232,ZodEffects not assignable to paremeter type ZodRawShape,"Trying to upgrade a codebase to use the latest version of Zod, but we have a lot of schemas that extend other schemes that have refinements on them. Now refinement outputs a ZodEffect, these all throw a type error. Is there a way around this?",,
1284885663,1230,How to make an optional property with a default value?,"Hello, first of all, thank for this awesome library, it is making wonders in my user-data interactions.
I want to define an schema for user input that has an optional field with a default value. However, it is being impossible for me to make the runtime behaviour match the type, maybe I'm getting something wrong.
What I want, is the field to be optional, and when not provided, or provided as undefined, use the default value. If I want to have this behaviour I can't have the field optional in the generated type, and if I manage to make it optional in the generated type, then it will not get a default value during runtime.

Let me explain it with code:

```ts
import { Timestamp } from 'firebase/firestore';
import { z } from 'zod';

export const someSchema = z.object({
  id: z.string(),
  timestamp: z.instanceof(Timestamp),
  type: z.enum(['fever', 'constipation']),
  notes: z.string().optional().default(''),
});

export const someInput = someSchema
  .omit({ id: true })
  .merge(
    z.object({
      timestamp: z
        .date()
        .optional()
        .default(() => new Date()),
    }),
  )
  .partial({
    notes: true,
  });

export const schemaArray = z.array(someSchema);

export type Schema = z.infer<typeof someSchema>;
export type SchemaInput = z.infer<typeof someInput>; // <- Here I expect timestamp to be optional, but it is required


function a({ type, timestamp, notes}: SchemaInput){
  someInput.parse({
  type, timestamp, notes
  })
}

a({type: 'fever'}) <- Error, timestamp is required

```",,
1284844633,1229,Export `RawCreateParams` and `processCreateParams` to allow custom type definitions?,"I'm attempting to build out a series of local `Zod` type definitions and following the pattern from [`types.ts`](https://github.com/colinhacks/zod/blob/master/src/types.ts)

However, I've hit a snag not being able to access some of the final elements, specifically `RawCreateParams` and `processCreateParams`.


### Example

```typescript
export enum ZodThirdPartyTypeKind {
  ZodSymbol = ""ZodSymbol""
}

type ZodSymbolCheck =
  | {
      kind: ""description""
      value: string
      message?: string
    }
  | {
      kind: ""prefix""
      value: string
      message?: string
    }

export interface ZodSymbolDef extends ZodTypeDef {
  checks: ZodSymbolCheck[]
  typeName: ""ZodSymbol""
}

export class ZodSymbol extends ZodType<symbol, ZodSymbolDef> {
  public _parse(input: ParseInput): ParseReturnType<any> {
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input)
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      })
      return INVALID
    }

    const status = new ParseStatus()
    let ctx: undefined | ParseContext = undefined
    for (const check of this._def.checks) {
      switch (check.kind) {
        case ""description"":
          if (input.data.description !== check.value) {
            ctx = this._getOrReturnCtx(input, ctx)
            addIssueToContext(ctx, {
              code: ZodIssueCode.custom,
              message: check.message
            })
            status.dirty()
          }
          break
        case ""prefix"":
          if (input.data.description?.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx)
            addIssueToContext(ctx, {
              code: ZodIssueCode.custom,
              message: check.message
            })
            status.dirty()
          }
          break
        default:
          util.assertNever(check as never)
      }
    }

    return { status: status.value, value: input.data }
  }

  public static create = (
    params?: RawCreateParams // MISSING!
  ): ZodSymbol =>  
    new ZodSymbol({
      checks: [],
      typeName: ZodThirdPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)  // MISSING!
    })
}


export const symbolType = ZodSymbol.create

```",,
1284825386,1228,z.record(z.object) bug?,"Hello,

I've minimized my schema so that the basic configuration is seen.

**Schema:**
```Typescript
import * as z from 'zod';

const Schema = z.object({
    parameters: z.record(
        z.object({
            choices: z.object({values: z.array(z.string())}).optional(),
            question: z.string().optional(),
        })).optional(),
});

export default Schema;
```

**Usage:**
```Typescript
const parsedSchemaResult = Schema.safeParse({
            parameters: {
                whatever: {
                    unrecognizedField: [],
                },
            }
        });
        if (!parsedSchemaResult.success) {
            throw new ConfigError();
        }
```

I get `parsedSchemaResult.success === true`.

Is this a bug or misconfiguration?

**Zod**: ^3.16.1",,
1284763477,1227,New ZodDefaultOnMismatch class for providing a default value when there is a type mistmatch,"## Summary
A new class ZodDefaultOnMismatch which will replace the data with the default value when the provided value is a mismatch in type with the expected value. When data is undefined, ZodDefaultOnMismatch acts like ZodDefault.

```javascript
const deleteAllFiles = z.boolean().defaultOnMismatch(false).parse(""monkeys"")  // deleteAllFiles = false
```

Below, I layout two real world use cases. Whether or not this gets accepted, we will need this functionality, and I am hoping that we don't have to work off a forked version of zod.

Below, I also layout three implementations. All are tested and ready to be merged. I just need @colinhacks to tell me which is a sounder implementation, so I know which branch to make a pull request. Also, if the naming should be changed, I am up for that as well.

The implementation I suggest is the first one: https://github.com/seancrowe/zod/commit/40579cacf411f37a0458dd1abf85b8aba679fb81

So, if you don't feel like reading through all these implementations, the first one is the simplest and logical choice at the expense of JavaScript users requiring discipline.

## Use Case

### Use Case 1
Application is pulling data from a JSON file where both the data's type is not guaranteed to be correct or even defined. Our application wants to use zod to verify the parsed JSON, but we don't want to fail if there is a type mismatch, but instead default to a safe value.

### Use Case 2
Our application uses an FP technique of passing data around as objects. This data is passed to a function, the function will copy the data, modify the data, and potentially add more data. Due to JavaScript being dynamic typed and TypeScript not having sound typing, the types defined by TypeScript are not guaranteed 100% at compile time. This scenario means that as we pass these data objects around, we cannot be guaranteed 100% that the data object is exactly as we expect.

To defend against this, a type check must be made everytime. If there is a type mismatch, we don't want to cause an error, but instead default to a safe value with the correct type. Since these objects can be complex or contain extra data our current function does not care about, we need make sure the input and output is untouched accept for the specific properties we are interested in.

## ZodDefaultOnMismatch
Unfortunately, Zod does not have built way to support the two above use cases. Maybe it can be done with preprocess, but for our use case, that defeats the purpose of zod if every object property needs a handwritten type check anyway. 

Instead, all zod needs is something like ZodDefault but that will use the default value not only when there is undefined but when there is a mismatch in types. Thus ZodDefaultOnMismatch.

A new class ZodDefaultOnMismatch which will replace the data with the default value when the provided value is a mismatch in type with the expected value. When data is undefined, ZodDefaultOnMismatch acts like ZodDefault.

### Name
At first, I named this ZonDefaultAlways, but that implied it would always default to a value no matter what. ZodDefaultOnMismatch, while lengthy, is descriptive in what it does. However, I am not set on ZodDefaultOnMismatch. Maybe there is a better name?

## Implementation
After tinkering, there were three options:

- 👍 Assume the value of the defaultValue is the same as the expected value and compare types
- Go down the innerType branch until we get to the end, and then compare the last innerType (excepted) to the current type
- Allow the running as normal, and if there is an abort, run again with the default type

The last two implementations require going down the inner branch twice. 

## First defaultValue type Implementaion
This is my suggestive implementation.

This implementation makes the assumption that the value from _def.defaultValue() will be the same type as the expected value. This is a safe assumption if the user is using TypeScript. If the user is using JavaScript, then they can pass whatever they want into the defaultValue. In my mind this an acceptable risk, as there are other areas already in zod, where JavaScripts lack of compiler type checking can break the result.

You can find this implementation here:
https://github.com/seancrowe/zod/commit/40579cacf411f37a0458dd1abf85b8aba679fb81

(By the way, already made an improvement: https://github.com/colinhacks/zod/commit/354867bbebc437032f76750ac8a05e572cca8d00)

## Second innerType Implementation
This implementation will use the _def to get the final last type to be parsed, grab the type of that and compare it to the parsed type.

You can find this implementation here:
https://github.com/seancrowe/zod/commit/ee70583f9b18a86e4f25a05ad2b91e7f7745d215

This implementation had to solve two problems:

The first problem is that all the Zod classes do not share an interface that has innerType. Each class implements innerType separately. Since no common interface that means that either innerType is not always available or we would need to use a more generic ""any"" and hope innerType exists.

Actually, innerType is not always available. ZodEffect has a schema instead, which means you much go innerType -> schema -> innerType. This is one example, but if other Zod classes exist that use another naming convention, or future ones were added, we would end-up in the same scenario

The second problem is that the types are stored as Zod{type}, so ""ZodString"" or ""ZodNumber"" but our data type is stored as ""string"" or ""number"". This means that I would have to rely on the discipline of naming conventions to be able to compare ""ZodString"" to ""string"" or ""ZodNumber"" to ""number"".


## Third abort Implementation
This implementation utilizes the fact that mismatch types are aborted, to then go down the parse function again but with the default value.

You can find this implementation here:
https://github.com/seancrowe/zod/commit/1dd93075946436672771a25411a084a102f5da8e

This implementation feels less breaky at the expenses of having to carry around our defaultValue function in the ParseContext common. Meaning that defaultValue must not be readonly as it is set only after parsing begins.

The upside is that this will not break due to the problems listed above changing. For example, a new Zod class implemented that does not use innerType or schema, but something else altogether. 

The downside of requiring parsing to happen twice at the fist ZodDefaultOnMismatch. It goes down the tree once, gets the abort and then goes down the tree again but with the value from ZodDefaultOnMismatch. I have to do this, because I don't know the type of the inner most value.
",,
1284555184,1226,infer is not a function,"
![image](https://user-images.githubusercontent.com/4569866/175771246-d2229e67-a3fa-4494-8e72-86543b1f5d91.png)

![image](https://user-images.githubusercontent.com/4569866/175771235-1807a5bf-754c-4e9e-982b-fb8e7b2c56d0.png)

![image](https://user-images.githubusercontent.com/4569866/175771216-de0adedc-f849-45e1-a92e-cf3d603ac58b.png)
",,
1283933966,1223,"Request: Introduce a convert method, to allow for transforms that may fail","When attempting a transform, it's possible that the transform may fail. In this case, it's necessary to return a typecast dummy value.

I think having a 'convert' method on ZodType, which could return a success or failure value, would make for nicer DX.

The convert method would essentially combine a refine and transform, where the refinement failure would be fatal but the transform is necessary to determine the refinement.

The following serves as an example:

```ts
const IdToUser = z
  .string()
  .uuid()
  .convert(async (id) => {
    try {
      const user = await getUserById(id);
      return z.success(user);
    } catch (e) {
      return z.failure([
        {
          code: ""custom"",
          message: ""Unable to fetch user"",
        },
      ]);
    }
  });
```

See https://github.com/colinhacks/zod/pull/1224 for a potential implementation",,
1283379828,1221,'keyof typeof' js-object to zod-schema,"Hi,

we are slowly transitioning from a JavaScript code base to TypeScript. Due to the quantity of code and our inexperience with TypeScript, we have to live with both worlds for the foreseeable future.

We used simple js Objects as pseudo enums in the past:

**within a js file:** 

```
const pseudoEnum = {
  ELECTRIC: {someProp: true, anotherProp: ""xxx""},
  PNEUMATIC: {someProp: false, anotherProp: ""yyy""},
  HYDRAULIC: {someProp: true, anotherProp: ""zzz""},
}
```
This allows us to type stuff like this:

**within a ts file:**
```
type Application: keyof typeof pseudoEnum
```
Which nicely restricts possible values for elements of type Application:
![image](https://user-images.githubusercontent.com/1145346/175484336-aefb28bc-1b3e-4944-9f1d-d9d3e2ffa8cb.png)


How can I mimic this behavior in a zod schema?
I spent quite a while playing with z.enum and z.nativeEnum, but I don't get it to resolve properly.

_I'd prefer not to rewrite our pseudoEnums since so much of our js code base relies on it..._

Thanks in advance
Nice regards
Christian


---
My apologies if you think that this does not belonging here. Feel free to close it. :)",,
1283166548,1220,Property 'infer' does not exist,"![image](https://user-images.githubusercontent.com/4569866/175447934-01797006-914e-4efc-b06f-2330c737a2a2.png)
",,
1278224615,1217,Enums `invalid_type` issues have unexpected `expected` value,"When adding translations to my global errorMap function, I ran into an issue with the `enum` type.

```ts
const s = z.enum(['Red', 'Green', 'Blue']);
console.log(s.safeParse(null));
```
This produces a `ZodError` with the following issue:
```json
{
    ""expected"": ""'Red' | 'Green' | 'Blue'"",
    ""received"": ""undefined"",
    ""code"": ""invalid_type"",
    ""path"": [
        ""color""
    ]
}
```
The problem here, is that the `expected` value ends up as a string representation of the array provided. I assume the point is to make it look like the Typescript representation, but that's not any of the expected values in the `ZodInvalidTypeIssue.expected` type. This makes it kind of impossible to add a general translation for enum errors in the generic global error map function.

It would be much better if `expected` was hardcoded `""enum""`, and then the valid enum values instead came as a separate property. This would make it possible to translate all enum errors properly, and also give the ability to format the valid options however you want:
```ts
function zodErrorMap(...[issue, ctx]: Parameters<ZodErrorMap>): string {
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      switch (issue.expected) {
        case 'number':
          return 'must be a valid number';

        case 'integer':
          return 'cannot have decimals';

        case 'enum': // Currently not possible
          return `must be one of ${issue.valid.join(', ')}`

        case 'boolean':
          switch (issue.received) {
            case 'null':
            case 'undefined':
              return 'må fylles ut';
            default:
              return 'må være en boolsk verdi';
          }
      }
      break;
```",,
1277166517,1215,non-partial `record`?,"Hey, I notice that the type created by `z.record` is `Partial<Record>`, and I can't see a way to avoid the `Partial`. I don't want to use `z.object` because I have one enum of keys that I want to use across many record types, with different value types.

Maybe z.record isn't the one for this. In other words how can I create a schema for keys in one place, and re-use it for many object schemas?

For example:

```ts
const Languages = z.enum([""en"", ""fr""])

const Translations = z.record(Languages, z.string())
const hello = Translations.parse({ en: ""hello"", fr: ""bonjour"" })
const v = hello.en // string | undefined

const Numbers = z.record(Languages, z.array(z.string()))
const numbers = Numbers.parse({ fr: [""un"", ""deux""] }) // should fail without 'en' key",,
1277058126,1214,ZodFormattedError Does not work for union type,"I have an interface with a template property that can be either a number or an object. The typewriter does not correctly display the type for the formatted error

```ts
zod.object({
    template: zod
        .number()
        .or(zod.object({
            label: string().nullish(),
        }))
```

I want to get a formatted error type
```ts
ZodFormattedError<ZodInterface, string>
// Expected
// {_errors: string[]} |  {_errors: string[], label: {_errors: string[]}}

// Actual
// {_errors: string[]}
```

[Reproduction in playground](https://www.typescriptlang.org/play?ts=4.5.5#code/C4TwDgpgBAWg9gEwGJwE4FsCGxgQQUVVTQB4AVAGigFUoBeKAZ2FQEsA7AcwD56oBvALAAoKGKgB9CETSMAXDQDaAXQDcIgL5QAZFAAUZKBAAeudgkZRFmdiCoA6RzZArlUAPwCR4qwGkoHFAA1hAgcABmUGTK7grwyGhYOHiExKjkir7K3OrCWgqGJmYWUM4qHl6i4opBCuwArugARtLKcYgoGNi4BDLpZIoNza05mlAFRqYQ5pZwTQBWEADGwBVCVWKZAezBoRFRMe0JXcm9aRlZo3njUPXsQexwAO7sAJS5IiIA9ABUUCIAL0Q9jmixWenWPlw6DAABtsBAFECEN4fOJ7EMWqg9K9UWioCDsciQQtlsAIXj8eJ4S1YQpmGwuDj7CxWOhmQ1YbDWIwABY4iiUnwaV64vJin5fESgSCwRAASXYuFQ4UwS2gDEh4mhcIRdUaWKgAB9KlSoDSILDYkxWVxjVBObD7XcEBBwhw8LlhbkNJ9hDLoKk+PFOkkeqlSPFFcrVeqqAyODw-Us4OxmEY+PwtJhLKk-RAWRAYfDcO57BarfYpH1LF8vlASABaGjsEyQFZ4Ix9IA)

",,
1270709834,1206,"How can I allow `null` as input value of a schema, but not as a valid output?","I'm trying to use `zod` and `react-hook-form` together, and find it a bit difficult to deal setting `defaultValues` in a way that makes both `react-hook-form`, `typescript` _and_ the actual schema validation happy.

Say you have this schema:
```ts
const zodSchema = z.number().int().nonnegative()
type ZodValues = z.input<typeof zodSchema>
// number <-- want null to be allowed here
type ZodValid = z.output<typeof zodSchema>
// number
```
Here both `ZodValues` and `ZodValid` does not allow `null` as a value.

If I add `nullable`, we get this:
```ts
const zodSchema = z.number().int().nonnegative().nullable()
type ZodValues = z.input<typeof zodSchema>
// number | null
type ZodValid = z.output<typeof zodSchema>
// number | null // <-- don't want null to be allowed here
```

Using `yup@0.32.11` (latest now), it seems I'm able to do it like this, which is what I want:
```ts
const yupSchema = number().nullable(true).required().integer().min(0)
type YupValues = TypeOf<typeof yupSchema>
// number | null | undefined
type YupValid = Asserts<typeof yupSchema>
// number
```

Is there any way I can write this schema with `zod`, so that the _input_ allows `null`, while the _output_ does not?

The issue is that `react-hook-form` preferably wants non-undefined default values for the input, and for e.g. `number` and `Date` inputs I'd really prefer to use `null` as I do not want to pick a random number or date to use as the default.",,
1270305538,1205,"Issue with types? Using refine() with an array results in typescript linting error saying type is missing the message property. However, works in runtime. ","Hello, I am using zod as a resolver with react hook form. I have a schema setup as follows:

```typescript

const mySchema = z.object({
  // some other properties
  myArray: z.array({
    // some properties
  })
  .min(1)
  .max(10)
  .refine(
    (item) => {
      // some validation
    },
    {
      message: ""My error message""
    }
  )
});
```

When trying to access the error message like below, I get a linting error saying property 'message' does not exist on type. However during runtime there is no error and I can access the message properly.

```typescript
formState.errors.myArray.message
```

Any idea on how to resolve this?",,
1264877793,1196,Discriminated unions became incompatible with `zod.input`,"The issue is reproducible with Typescript v. 4.6+ and is very likely caused by its new feature called [Control Flow Analysis for Destructured Discriminated Unions](https://devblogs.microsoft.com/typescript/announcing-typescript-4-6/#control-flow-analysis-for-destructured-discriminated-unions).
[Here](https://codesandbox.io/s/festive-marco-0tv0uk?file=/index.ts) is a sandbox that reproduces the error. Run `yarn build` in the terminal tab.
Essentially, here's the compiler error that I get when trying to reference the result of `zod.input` that was applied to a discriminated union type constructed using `zod.union` (classic way):

<img width=""1231"" alt=""image"" src=""https://user-images.githubusercontent.com/32125472/172644267-0ed33e49-c9ce-4abb-859b-f76f35238d92.png"">

And nothing changes if I use the brand new `zod.discriminatedUnion`:

<img width=""1244"" alt=""image"" src=""https://user-images.githubusercontent.com/32125472/172646717-7b557fb5-e166-449c-8f22-c4357624f1d3.png"">

The issue is not reproducible in Typescript v. 4.5 and older.
",,
1263415532,1193,Cannot read properties of undefined (reading '_parse'),"Hey, I've come across this issue in my project while composing schemas from imported zod objects/enums.Here is the code:

**CountryCode.ts**
```TS
import { z } from 'zod';

const countryCode = z.enum(['IE', 'GB']);

type CountryCode = z.infer<typeof countryCode>;

const countrySchema = z.object({
  alpha2: z.string(),
  alpha3: z.string(),
  code: countryCode,
  name: z.string(),
  region: z.string(),
  regionCode: z.number(),
  subRegion: z.string(),
  subRegionCode: z.number(),
});

type Country = z.infer<typeof countrySchema>;

export { countryCode, countrySchema };
export type { Country, CountryCode };
```
**CurrencyCode.ts**
```TS
import { z } from 'zod';

const currencyCode = z.enum(['EUR', 'GBP']);

type CurrencyCode = z.infer<typeof currencyCode>;

const currencySchema = z.object({
    code: currencyCode,
    name: z.string(),
    minorUnit: z.number(),
  });


  type Currency = z.infer<typeof currencySchema>;

export { currencyCode, currencySchema };    
export type { CurrencyCode, Currency };   
```

If i import the above like so:
**invitePerson.ts**
```TS
import { z } from 'zod';
import { countryCode, currencyCode } from '../../api';

const invitePersonSchema = z.object({
  startDate: z.date().optional(),
  firstName: z.string().min(1, 'First name is required'),
  lastName: z.string().min(1, 'Last name is required'),
  role: z.string().optional(),
  dateOfBirth: z.date().optional(),
  email: z.string().email('Email is required'),
  residentialAddress: z.object({
    addressLine1: z.string().optional(),
    addressLine2: z.string().optional(),
    addressLine3: z.string().optional(),
    city: z.string().optional(),
    countryCode: countryCode,
    postalCode: z.string().optional(),
  }),
  annualSalary: z
    .string()
    .min(1, 'Annual salary is required')
    .transform(value => parseInt(value, 10)),
  salaryCurrency: currencyCode,
  taxId: z.string().optional(),
});

type InvitePersonData = z.infer<typeof invitePersonSchema>;

export { invitePersonSchema };
export type { InvitePersonData };

```
I get the error in the title. However, if I define the enums directly in the `invitePersonSchema` and don't import, there is no error. I would have expected this to be allowed, so please forgive me if I am misusing the library in some way.

Note: this was already discussed here, but the last comment provides a reproducible example which I have copied below, just in case it helps: https://github.com/colinhacks/zod/issues/643 

> I ran into the same error message and found this issue. Now while my problem is likely a different another one, I thought sharing this might still help others ending up here.
> 
> Essentially what I was doing is exporting a schema from one file, using it in another one to compose another schema, and then importing that composed schema back into the first file. While there isn't a cyclic dependency per se, it causes the mentioned error at runtime.
> 
> See this CodeSandbox for an example: https://codesandbox.io/s/patient-butterfly-hsg3q?file=/src/index.ts The message isn't as descriptive as in my local (larger) project, but removing this exact kind of import solved it for me. (Maybe this is generally ""wrong"" in terms of my tsconfig or simply unsupported by zod and I don't know it, but I would intuitively expect it to work 🙈.)",,
1262617372,1192,Simple `ZodObject` inference from existing Interface?,"When needing to attempt to bind an existing Interface to `ZodObject`, there are a few issues with using the more simplistic `ZodSchema` to achieve this - namely losing all the object-specific options such as `schema.shape`.

As far as I know, there isn't really a way to neatly infer a `ZodObject` without needing to recapitulate the entire schema again within the definition, which is often not possible when the source type is external and the point of the binding is to notice if the shape of the schema differs from the source.

This is what I (very roughly) have worked out so far, so was wondering if 
a) there is any existing internals that might be better suited to this, and;
b) if there is any chance some more developed version of this inference type might be possible to include in the main package?

```typescript
/**
 * Simple example mapping to string version of each type, would need to be completed with all types
 */
export type GetRequiredType<T> = T extends string
  ? ""string""
  : T extends number
  ? ""number""
  : T extends boolean
  ? ""boolean""
  : never

/**
 * Append `Optional` to the key name for optional properties.
 */
export type GetType<T> = undefined extends T
  ? `${GetRequiredType<T>}Optional`
  : GetRequiredType<T>

/**
 * Simple example mapping / lookup of ""rough"" Zod types for each concrete type.
 */
export interface ZodTypes {
  string: ZodString | ZodEffects<ZodString, string, any>
  stringOptional: ZodOptional<ZodString | ZodEffects<ZodString, string, any>>
  number: ZodNumber | ZodEffects<ZodNumber, number, any>
  numberOptional: ZodOptional<ZodNumber | ZodEffects<ZodNumber, number, any>>
  boolean: ZodBoolean | ZodEffects<ZodBoolean, boolean, any>
  booleanOptional: ZodOptional<
    ZodBoolean | ZodEffects<ZodBoolean, boolean, any>
  >
}

/**
 * Cast the existing output interface as a ZodRawShape using the lookups defined above.
 */
export type ToZodRawObject<Output extends object> = {
  [Key in keyof Output]: ZodTypes[GetType<Output[Key]>]
}

/**
 * Case the existing output interface as a valid ZodObject.
 */
export type ToZodObject<Output extends object> = ZodObject<
  ToZodRawObject<Output>,
  ""strip"",
  ZodTypeAny,
  Output
>

```

## Passing Example

```typescript
export interface User {
  name?: string
  email: string
}

export const UserSchema: ToZodObject<User> = z.object({
  name: z.string().optional(), // Passes
  email: z.string().email() // Passes
})
```

## Failing Example

```typescript
export interface Product {
  name: string
  serial?: number
}

export const ProductSchema: ToZodObject<Product> = z.object({
  name: z.string().transform((value) => value.toUpperCase()), // Passes
  serial: z.number().refine((value) => value > 1000) // Fails! (must be optional)
})

```",,
1262205976,1191,.omit/.pick support for enums,"I have use-cases for `pick`/`omit` like https://github.com/colinhacks/zod#pickomit but for enums:

- https://github.com/colinhacks/zod#zod-enums
- https://github.com/colinhacks/zod#native-enums

Example currently:

```ts
export const DatasourceProvidersNormalizedSupportingMigration = z.nativeEnum(
  omit(Reflector.Schema.DatasourceProviderNormalized.enum, ['mongodb'])
)
```

Imagined example with better API:

```ts
export const DatasourceProvidersNormalizedSupportingMigration = Reflector.Schema.DatasourceProviderNormalized.omit('mongodb')
```",,
1261001456,1188,Type numeric native enum is not assignable to type 'string',"I'd like to produce the following type:
```ts
export type ButtonItem = {
  type: ItemType.BUTTON
}
```

where `ItemType` is a native numeric enum

So I try this:
```ts
z.object({
    type: z.nativeEnum([ItemType.BUTTON]),
  })
```

But it says: `Type 'ItemType' is not assignable to type 'string'`

I'm not sure how to proceed here?",,
1255844188,1182,[Feature Request|Question]How to add a plain field to the schema type?,"For example, I want to add a reference between children and parent, but the 'parent' field is not inside the data object(json):
```typescript
type Child = {
    parent: Group,
    name: string,
}

type Group = {
    name: string,
    children: Child[]
}
```
The data is:
```typescript
[
    {
        name: 'group1',
        children: [
            { name: 'child1' },
            { name: 'child2' },
        ]
    }
]
```

So I build the schema:
```typescript
const ChildSchema = z.object({ name: z.string() });
const NodeSchema = z.object({ name: z.string(), children: z.array(ChildSchema) });

type Node = z.infer<typeof NodeSchema>;
type Child = z.infer<typeof ChildSchema> & { parent: Node }; // How to add this field?
```
",,
1254317565,1181,Type error with discriminatedUnion when using dynamic amount of objects,"For a project I am working on we are using zod to type check user provided input at runtime, we have ""sections"" which are defined in a manifest. I need to have a discriminatedUnion by am getting a type error when doing the following:

```ts
const section = z.discriminatedUnion('type', [
  ...Object.values(manifest.sections).map((section) => section.zod),
])
```

The above code does work, and what is weirder is that when accessing the items individually it works:

```ts
const zodObjects = Object.values(manifest.sections).map((section) => section.zod)

const section = z.discriminatedUnion('type', [
  zodObjects[0],
  zodObjects[1],
  zodObjects[2],
  // ...
])
```

At a guess it's because it doesn't know that it's a array with multiple items but am unsure the best way of fixing this",,
1254070466,1180,[Proposal] Allow to add arbitrary values to `ZodIssue`,"I'm trying to add the value that caused an error to the `ZodIssue`s returned by the `parse`-functions and as far as I can see the only way to do it is
- either misuse `errorMap` and put it into the `message`
- or post-process the `issues` array and do whatever after parsing it:

https://codesandbox.io/s/suspicious-minsky-s8mjgn?file=/src/index.ts

Proposal:

Allow `errorMap` (or a new method) to add arbitrary values to `ZodIssue` return by the `parse` functions.",,
1253399776,1179,cannot able to extract type form schema z.infer<myzodschema>,"version: 3.17.3

i'm unable to extract type from schema
```
//here is my code
const body:ZodSchema =z.object({
	username:z.string(),
	password:z.string()
})
type login = z.infer<typeof body>

//here it shows data as type of any and  therefore shows no autosuggestions
const data:login = {}


```
it was working fine yesterday i haven't change any code  is this version issue? i'm not sure if its updated,",,
1252120019,1177,Doubts about type inference when using picks,"Hello everyone, when calling the pick method of a `zodObject` in a function by passing in a reference, how to set the type of `T` to ensure the correct type of return value？

```typescript
function zodPickDemo<T extends ZodObject<ZodRawShape>>(src: T) {
  return src.pick({ id: true });
}

const dto = z.object({ id: z.string(), name: z.string() });
const picked = zodPickDemo(dto);
// In this case the type of picked is not the expected type
```

In the above code, the type expected to be obtained is a `zodObject` object type containing only the id, but what is obtained is a type such that:

```typescript
z.ZodObject<Pick<z.ZodRawShape, never>, ""strip"", z.ZodTypeAny, {}, {}>
```

Playground: [link](https://stackblitz.com/edit/vitejs-vite-iauawv?file=src%2Fmain.ts&terminal=dev)",,
1251982190,1174,Don't let `invalid_type_error` replace the default `required_error`,"The default error when parsing `undefined` for a required value is ""Required"". When a value overrides its type error with `invalid_type_error`, that message also also overrides the default message for undefined values. I would expect that only `required_error` would override that message.

```
z.number().parse(undefined);
// Throws error with message ""Required""

z.number({ invalid_type_error: 'Wrong type!' }).parse(undefined);
// Throws error with message ""Wrong type!""
// Expected behavior: Throws error with message ""Required""
```",,
1250324288,1171,Discriminated union doesn't work with `transform`,"Possibly it is not bug. Any way to ""post""-define discriminator (define in `transform`)?

[Codesandbox example 1](https://codesandbox.io/s/typescript-playground-export-forked-y43ihh?file=/index.ts:0-410)
[Codesandbox example 2](https://codesandbox.io/s/typescript-playground-export-forked-gnlt25?file=/index.ts)

Example 1:

```ts
import z from ""zod"";

const schemaA = z
  .object({
    mo: z.number().optional(),
    aa: z.number()
  })
  .transform((content) => ({
    ...content,
    k: ""kindA"" as const
  }));

const schemaB = z
  .object({
    mi: z.number().optional(),
    aao: z.number()
  })
  .transform((content) => ({
    ...content,
    k: ""kindB"" as const
  }));

const schemaC = z.discriminatedUnion(""k"", [schemaA, schemaB]);
```

Example 2:

```ts
import z from ""zod"";

const schemaA = z.object({
  T: z.literal(""error""),
  c: z.number(),
  m: z.string()
});

const schemaB = z
  .object({
    T: z.literal(""ss""),
    mi: z.number().optional(),
    aao: z.number()
  })
  .transform((content) => ({
    ...content,
    someField: ""someValue"" as const
  }));

const schemaC = z.discriminatedUnion(""T"", [schemaA, schemaB]);
```

Error: The discriminator value could not be extracted from all the provided schemas
",,
1246405429,1164,Failing a `.refine` check does not report error,"First of all thank you for a great library! 🙏 

I ran into what I believe to be a bug while using this to build some programmatic input parsing and validation, where objects containing keys that do not match the schema need to be removed from an array. The details of how and why are probably uninteresting for this issue, though I can make a write-up if you would like.

The general structure of the schema is like this:

```typescript
const schema = z.object({
    foo: z.array(
        z.object({
            k1: z.string(),
            k2: z.number()
        })
    ).refine(
        (os) => os.filter((o) => o.k1 === ""bar"").length < 2,
        ""At most one k1 with value \""bar\"" allowed!""
    )
});
```

I want to parse an unknown input using this schema, and do two things:

1. Remove any entries of the array in `foo` that fail the schema
2. Merge any entries of the array in `foo` if the ""At most one k1 ..."" refinement failure occurs

If I have a value that fails just the refinement part of the schema, it shows the refinement error. However, once I have a value that fails both the inner `z.object` schema and the refinement, only the schema error for the `z.object` schema is reported. I would have expected it to report all errors in the first pass.

With this limitation, solving the problem becomes:

1. Run validation
2. Remove objects as required
3. Run validation with the new value (which I now know does not contain any of the issues reported in step 1)
4. Rinse and repeat (presumably just once)

The looping/recursion works, but it is not optimal.

To help debug this I have created a repo with a very small example of a schema and values that show the problem: https://github.com/mdiin/zod-parse-repro",,
1246003697,1163,Applications fail to build with tsc 4.3.5 and zod 3.17.2 due to invalid import in parseUtil.d.ts,"When I try to compile my typescript application with tsc to js, and depend on zod 3.17.2, I get a number of compile errors:

```
 tsc -p tsconfig.json
node_modules/zod/lib/helpers/parseUtil.d.ts:1:15 - error TS1005: ',' expected.
1 import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
                ~~~~~~~~~

node_modules/zod/lib/helpers/parseUtil.d.ts:1:31 - error TS1005: ',' expected.
1 import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
                                ~~~~~~~~~~~

node_modules/zod/lib/helpers/parseUtil.d.ts:1:49 - error TS1005: ',' expected.
1 import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
                                                  ~~~~~~~~

node_modules/zod/lib/helpers/parseUtil.d.ts:2:15 - error TS1005: ',' expected.
2 import { type ZodParsedType } from ""./util"";
                ~~~~~~~~~~~~~
```
This is with the following compiler options:
```
  ""compilerOptions"": {
    ""incremental"": true, 
    ""target"": ""ES2020"",
    ""module"": ""commonjs"",
    ""lib"": [""ES2020""],
    ""allowJs"": true,
    ""pretty"": true,
    ""declaration"": true,
    ""sourceMap"": true,
    ""removeComments"": true,
    ""strict"": true,
...
}

and 
```
tsc -V
Version 4.3.5
```.

Logging at the offending lines from `parseUtil.d.ts`:
```
import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
import { type ZodParsedType } from ""./util"";
```

I think those import statements should be:
```
import type { IssueData, ZodErrorMap, ZodIssue } from ""../ZodError"";
import type { ZodParsedType } from ""./util"";
```
Am I right? I would be happy to create a PR with the fix. ",,
1245187913,1161,Latest release's types not working?,"Excuse the horrible title, but I'm creating a PR over at trpc and some CI tool is telling me this:

```
$ next build
--
10:53:39.158 | info  - Loaded env from /vercel/path1/.env
10:53:39.404 | info  - Checking validity of types...
10:53:44.795 | Failed to compile.
10:53:44.795 |  
10:53:44.796 | ./node_modules/zod/lib/helpers/parseUtil.d.ts:1:15
10:53:44.796 | Type error: ',' expected.
10:53:44.796 |  
10:53:44.796 | > 1 \| import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
10:53:44.796 | \|               ^
10:53:44.797 | 2 \| import { type ZodParsedType } from ""./util"";
10:53:44.797 | 3 \| export declare const makeIssue: (params: {
10:53:44.797 | 4 \|     data: any;

```

I didn't have this error yesterday, so I'm assuming that this is relate to the latest release.
In fact, it looks like [this github actions job](https://github.com/colinhacks/zod/commit/44916fe7dee9413216ee0b24001cfbf835cda584#diff-cf85b3e0a8cdc5f1bfea0bff847e1d89dfbb182c744fd0bc95eae659117b70fd) is telling that there needs to be some fixes.",,
1242860311,1155,How to use Enum to map between numbers and member names,"Hi I'm a beginner at TS, I'm trying to easily map between the number and status.

Here is a python example of what am I trying to achieve:

```python
from enum import Enum

class Status(Enum):
    GOOD = 1
    BAD = 2

response = {""status"": ""GOOD""}

print(Status.GOOD)  # Status.GOOD
print(Status.GOOD.value)  # 1
print(Status.GOOD.name)  # GOOD

good_status = Status[response['status']]

print(good_status == Status.GOOD)  # True

print(good_status.value)  # 1
```

When I try something similar with `zod` I get TS error: `Element implicitly has an 'any' type because index expression is not of type 'number'`


Please see attached CodeSandbox: https://codesandbox.io/s/typescript-playground-export-forked-sf66kp?file=/index.ts:1040-1428

```typescript
import { z } from ""zod"";

enum StatusEnum {
  GOOD,
  BAD
}

export const ASchema = () =>
  z.union([
    z.literal(StatusEnum[StatusEnum.GOOD]),
    z.literal(StatusEnum[StatusEnum.BAD])
  ]);

type A = z.infer<ReturnType<typeof ASchema>>;

export const BSchema = () =>
  z.enum([
    StatusEnum[StatusEnum.GOOD] as string,
    StatusEnum[StatusEnum.BAD] as string
  ]);

type B = z.infer<ReturnType<typeof BSchema>>;

export const AResponseSchema = () =>
  z.object({
    body: z.string().optional(),
    status: ASchema()
  });

type AResponse = z.infer<ReturnType<typeof AResponseSchema>>;

export const BResponseSchema = () =>
  z.object({
    body: z.string().optional(),
    status: ASchema()
  });

type BResponse = z.infer<ReturnType<typeof BResponseSchema>>;

const received = { status: ""GOOD"" } as const;

const x = AResponseSchema().parse(received);

const iWantThisToEvaluate = x.status === StatusEnum.BAD; // this is a problem

if (iWantThisToEvaluate) {
  console.log(""finally!"");
} else {
  console.log(""does not work"");
}

const works_number = StatusEnum[received.status];
const works_name = StatusEnum[StatusEnum[received.status]];
const notWorks_number = StatusEnum[x.status]; //Element implicitly has an 'any' type because index expression is not of type 'number'
const notWorks_name = StatusEnum[StatusEnum[x.status]]; // Element implicitly has an 'any' type because index expression is not of type 'number'

```

Thank you",,
1242438766,1154,Ability to add label to be shown in error instead of generic like: String must contain at least 3 character(s),"For example if I have this validation
```typescript
const schema = z.object({
   firstName: z.string().min(3).max(12),
   isActive: z.boolean(),
   role: z.enum(['Admin', 'User']),
});

const result = schema.safeParse({
   ""firstName"": '',
   ""isActive"": null,
   ""role"": ""min"",
});

console.log(JSON.stringify(result, null, 2));
```

```
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""too_small"",
        ""minimum"": 3,
        ""type"": ""string"",
        ""inclusive"": true,
        ""message"": ""String must contain at least 3 character(s)"",
        ""path"": [
          ""firstName""
        ]
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""boolean"",
        ""received"": ""null"",
        ""path"": [
          ""isActive""
        ],
        ""message"": ""Expected boolean, received null""
      },
      {
        ""received"": ""min"",
        ""code"": ""invalid_enum_value"",
        ""options"": [
          ""Admin"",
          ""User""
        ],
        ""path"": [
          ""role""
        ],
        ""message"": ""Invalid enum value. Expected 'Admin' | 'User', received 'min'""
      }
    ],
    ""name"": ""ZodError""
  }
}
```

Error message will be 

`firstName must contain at least 3 character(s)` instead of `String must contain at least 3 character(s)`

",,
1238706809,1145,Union of Enum values or object values,"Is there any way to create a union validation of enum values or object values?

I tried the code below but it doesn't work:
```ts
import {z} from 'zod';

const Fruits = {
  Apple: ""apple"",
  Banana: ""banana"",
} as const;

const FruitEnum = z.nativeEnum(Fruits);

type Fruit = z.infer<typeof FruitEnum>; // ""apple"" | ""banana""

const fruitValuesLiterals = Object.values(Fruits).map(value => z.literal(value)); // z.ZodLiteral<""apple"" | ""banana"">[]

const fruitUnion = z.union(fruitValuesLiterals); // ERROR: Argument of type 'ZodLiteral<""apple"" | ""banana"">[]' is not assignable to parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
```

[TS playground code](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHA5EiAE1wG4AoMgYwgDsBneAMSgFdgY64BeRMuOAIJgwAGwCmALjgAiAIbDx0gDR84AIVk1NsqdIBG2rcrJpZnavRjkqtBnGZsYAURoscPJADotMYADcxFzcACgd2OgBKaxgATzAxe1Z2bjgvYBp0MSgAHlj4iHRExyCQAD4SOAB6Spl5UTFpOAAfGQMtIwoLO0xHADVZERYxOgAZdiyBzh4AeT0AKzFKGE8-AaG6UKSOCM8QeWDVwYSuUtTPEXGoAYO1sQioqpqvAC0iMZgJkWy5BQbm1sMsmkpQA2gBdTq2eA9dgAVRowFoKS8LARtGCMJg-SOo0ukwe1TgTgASsTpsSpAIoABzNxiGjwApwPIJXCvQjvT7fOqKf76QHA8G4ODATg0CDwMx0YDUrR6cTMiBwMCyK4gMQfKBwJksvBQMSyQi0EQxOAg9kAFTiYgENBiSjgluttvtcE87qd8Rd4LBuE8QA)",,
1238672147,1144,Union form Enum values,,,
1237506510,1140,Using z.instanceof in z.union swallows invalid_union error,"Given a schema like `z.union([z.string(), z.instanceof(Date)])`, you would expect `parse(null)` to return an `invalid_union` error. Instead of that, `custom` is returned from the `z.instanceof`. The following test case demonstrates:

```typescript
import { z } from ""zod"";

describe(""zod"", () => {
  it.each([
    z.union([z.string(), z.number()]),
    z.union([z.string(), z.instanceof(Date)]),
  ])(""%#"", (schema) => {
    const result = schema.safeParse(null);
    const error = (result as z.SafeParseError<any>).error;
    expect(error).toMatchObject({
      issues: [{ code: z.ZodIssueCode.invalid_union }],
    });
  });
});
```

The input can be any invalid value. The argument to `instanceof` can be any constructor. Using zod `3.16.0`.",,
1236757969,1139,zod types with circular references can't be merged into other zod objects.,"Thanks for this repository ~
But I get confused when trying to merge a type with circular reference into other objects.
- zod: 3.16.0
- typescript: 4.6.4

I defined two types that depend on each other by the instruction in zod document like this:
```TypeScript
import { z } from ""zod"";

export interface IObj {
  name: string;
  items: IItem[];
}

export interface IItem {
  name: string;
  obj: IObj;
}

export const obj: () => z.ZodSchema<IObj> = () =>
  z.object({
    name: z.string(),
    items: z.array(item),
  });

export const item: z.ZodType<IItem> = z.object({
  name: z.string(),
  obj: obj(),
});
```
but when I try to merge the type 'item' into other zod objects, it shows the error: Argument of type 'ZodType<IItem, ZodTypeDef, IItem>' is not assignable to parameter of type 'AnyZodObject'.
```TypeScript
export const extItem = z
  .object({
    ext: z.string(),
  })
  .merge(item); // error

export type IExtItem = z.infer<typeof extItem>;
```
<img width=""584"" alt=""image"" src=""https://user-images.githubusercontent.com/47050572/168543769-bd7cd276-7ac8-4da2-b450-c9529fa588ad.png"">
how can I merge the type with circular reference into other zod objects?",,
1236296087,1138,Union of z.literal() numbers,"How would you go about doing this? 

```
const union = z.union(
    [1, 2, 3, 4, 5].map((val) => z.literal(val)),
)
-----------------------------------------------------
const arr = [1, 2, 3, 4, 5] as const
const union = z.union(
    arr.map((val) => z.literal(val)),
)
```

Neither works with the type system. 

```
Argument of type 'ZodLiteral<number>[]' is not assignable to 
parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
Source provides no match for required element at position 0 in target.
------------------------------------------------------------------------------------
Argument of type 'ZodLiteral<0.166667 | 0.2 | 0.25>[]' is not assignable to 
parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
Source provides no match for required element at position 0 in target.
```

I've tried using refine which works but gives me inferred type 'number' instead of 1 | 2 | 3 | 4 | 5.",,
1236145837,1136,Relationship between schema object fields,"Hello there!
I was exploring Zod with the intent of migrating from Joi. This looks awesome and makes me feel the schemas are more solid. I think it might be an excellent ally for my open-source library!

I observed how Joi owns a way to specify a relationship between schema object fields through the properties `when` ([doc](https://joi.dev/api/?v=17.6.0#anywhencondition-options)) and `with` ([doc](https://joi.dev/api/?v=17.6.0#objectwithkey-peers-options)).

So, I could write:

```js
Joi.object().keys({
	 ...,        
	 value: Joi
		.alternatives(z.string().allow(""""), z.number(), z.date().iso())
		.required(),
	numberStyle: Joi
		.string()
		.regex(
			/(aaaaa|bbbbbb|ccccccc|ddddddd)/,
		)
		.when(""value"", {
			is: Joi.number(),
			otherwise: Joi.string().forbidden(),
		}),
});
```

Which tells Joi to forbid `numberStyle` if `value` is a not a `number`, or

```js
Joi.object().keys({ ... }).with(""webServiceURL"", ""authenticationToken"");
```

Which enforces that two properties must appear at the same time for the schema to be valid.

So, is there a way to define a relationship between keys, if necessary with a condition?
I guess something could be done with `z.never()` but I can't figure it out right now.

A solution that comes to my mind might be to create a discriminated union of objects based on `value` for what concerns `when`.

I would do something like this:

```typescript
z.object<Field>({
	/** The rest of props... */
}).merge(
	z.discriminatedUnion(""value"", [
		z.object<Field>({
			value: z.string().or(isoDateString),
			numberStyle: z.never(),
		}),
		z.object({
			value: z.literal(z.number()),
			numberStyle: z
				.string()
				.regex(
					/(aaaaa|bbbbbb|ccccccc|dddddddd)/,
				)
				.optional(),
		}),
	]),
);
```

But, it seems that value must be literal, but in my case, it is a generic string or a generic number. So how can I achieve this? Would union still be okay?

For what concerns `what`, instead, I don't yet know how to create the relationship.

I guess the big issue here is that I'm attempting to migrate my Joi schemas 1-to-1 to Zod, but it probably requires a whole mindset change. 😄

Thank you very much!",,
1232340352,1128,.pick doesn't typecheck keys and throws `Cannot read property '_parse' of undefined`,"I've run into this issue when using `.pick` that the keys are not typechecked that they're actual keys on the source object.

Here's a small example to reproduce this using 3.15.1:

```typescript
import { z } from 'zod';

const schema = z.object({
  a: z.string(),
  b: z.number(),
});

const pickedSchema = schema.pick({
  a: true,
  doesntExist: true,
});

pickedSchema.parse({
  a: 'value',
});
```

Results in:

```
/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:1060
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                                    ^
TypeError: Cannot read property '_parse' of undefined
    at ZodObject._parse (/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:1060:37)
    at ZodObject._parseSync (/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:109:29)
    at ZodObject.safeParse (/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:139:29)
    at ZodObject.parse (/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:120:29)
    at Object.<anonymous> (/zodTest.ts:13:14)
    at Module._compile (internal/modules/cjs/loader.js:1085:14)
    at Module.m._compile (/node_modules/.pnpm/ts-node@10.7.0_3yjwidxeabsavpmncg7zl6hyk4/node_modules/ts-node/src/index.ts:1455:23)
    at Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    at Object.require.extensions.<computed> [as .ts] (/node_modules/.pnpm/ts-node@10.7.0_3yjwidxeabsavpmncg7zl6hyk4/node_modules/ts-node/src/index.ts:1458:12)
    at Module.load (internal/modules/cjs/loader.js:950:32)
```",,
1228779363,1121,Zod resolved type change for Opaque type between v3.14.4 -> v3.15.1,"I have the following code:

```typescript
type Opaque<Type, Token = unknown> = Type & { tag: Token }; 

enum FACE {
    QUEEN = 'QUEEN',
    KING = 'KING'
}

enum SUIT {
    HEARTS = 'HEARTS',
    DIAMONDS = 'DIAMONDS'
}

type FaceCard<Face extends FACE> = Opaque<`${ Face }_${ SUIT }`, 'FaceCard'>;

type Hand = z.output<
    z.ZodObject<{
        card : z.ZodType<FaceCard<FACE.QUEEN>, z.ZodTypeDef, string>,
    }>
>;
```

In `zod@3.14.4`, `Hand` resolved to:

```typescript
type Hand = {
    card: FaceCard<FACE.QUEEN>;
}
```

But now in `zoid@3.15.1`, `Hand` is resolving to:

```typescript
type Hand = {
    card: (FaceCard<FACE.QUEEN> | undefined) & FaceCard<FACE.QUEEN>;
}
```

Why did the second type get more complex here, when the first one is correct?

(By the way -- **incredible** library. Thank you for making this, seriously.)",,
1228714211,1120,Deno missing z.infer ?,"As a deno user I can't find z.infer.
Idk if I'm doing something wrong but if there is no z.infer implementation I would strongly suggest to add a Note in the docs.",,
1227054851,1118,enum of numbers,"This code fails:

```ts
import { z } from ""zod"";

const Multipliers = [1, 2, 3, 4] as const;

const schema = z.enum(Multipliers);
```

With error

```
No overload matches this call.
  Overload 1 of 2, '(values: readonly [string, ...string[]]): ZodEnum<[string, ...string[]]>', gave the following error.
    Argument of type '[1, 2, 3, 4, 5, 6]' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Type at position 0 in source is not compatible with type at position 0 in target.
        Type 'number' is not assignable to type 'string'.
  Overload 2 of 2, '(values: [string, ...string[]]): ZodEnum<[string, ...string[]]>', gave the following error.
    Argument of type '[1, 2, 3, 4, 5, 6]' is not assignable to parameter of type '[string, ...string[]]'.
      Type at position 0 in source is not compatible with type at position 0 in target.
        Type 'number' is not assignable to type 'string'.ts(2769)
```

Is there any reason why `z.enum` only expects `string`s?

https://codesandbox.io/s/zod-number-union-4pqezv",,
1225193295,1115,"Support for Go To Definition, Rename Symbol and other IDE features","Thanks for your amazing work on this library! I'm a big fan of the approach you have taken with Zod of defining a type's schema only once rather than duplicatively for each type and its parser. 

The one major downside I have found with using Zod for declaring types is that Visual Studio Code (and I assume the TypeScript language server more generally) does not seem to be able to connect usages of object properties back to their declaration in `z.object`. 

For example, consider the following code:

```TypeScript
const Example = z.object({ property: z.string() });

type Example = z.infer<typeof Example>;

const instance: Example = { property: ""value"" };
```

Using any language server action like Go To Definition, Find Usages or Rename Symbol on `Example[""property""]` does not work. This is a particular pain point for Rename Symbol, which is incredibly useful when working on a large code base.

I assume this is a limitation of the Typescript language server given the specific type-level programming that Zod is using. However, these features do appear to work with [io-ts](https://github.com/gcanti/io-ts) (a library that takes a similar approach), which makes me think it may be possible to implement Zod's type mappings in a way that preserves these IDE features, at least for some scenarios.

Is this a valuable goal to pursue, or have I misunderstood how most people are using Zod? 

Digging a little deeper, TypeScript does not appear to be able to connect the properties in an object to those same properties in its associated mapped type if the keys are changed.  This appears to be what is causing the IDE features to not work. For example, consider a simplified version of the return type of `objectType` in Zod:

```TypeScript
type optionalKeys<T extends object> = {
    [k in keyof T]: k;
}[keyof T];

type requiredKeys<T extends object> = {
    [k in keyof T]: undefined extends T[k] ? never : k;
}[keyof T];

export type addQuestionMarks<T extends object> = {
    [k in optionalKeys<T>]?: T[k];
} & {
    [k in requiredKeys<T>]: T[k];
};

export type mergeIntersections<T extends object> = { [K in keyof T]: T[K] };

type Example2 = { property: string; optionalProperty: string | undefined };

const instance2: mergeIntersections<addQuestionMarks<Example2>> = { property: """" };

// type Instance2 = {
//    property: string;
//    optionalProperty?: string | undefined;
// }
type Instance2 = typeof instance2;
```

This code is responsible for making schemas marked with `.optional()` optional (rather than just `undefined`) in the final object type. The `addQuestionMarks` type is transforming the keys in `T` using `optionalKeys` and `requiredKeys`. Due to these transformations of the keys of `T`, TypeScript can no longer connect the original type's keys to the mapped type's keys. As a result, using Go To Definition on `property` on the line starting with `const instance2` does not work. 

However, I believe we can get the same outcome in a way that preserves the IDE features:

```TypeScript
export type addQuestionMarksPreserve<T extends object> = {
    [k in keyof T]?: T[k];
} & {
    [k in requiredKeys<T>]: T[k];
};

type Example3 = { property: string; optionalProperty: string | undefined };

const instance3: mergeIntersections<addQuestionMarksPreserve<Example3>> = { property: """" };

// type Instance3 = {
//    property: string;
//    optionalProperty?: string | undefined;
// }
type Instance3 = typeof instance3;
```

All I have done is changed `[k in optionalKeys<T>]?: T[k];` to `[k in keyof T]?: T[k];`. Using Go To Definition and Rename Symbol on `property` on the line starting with `const instance3` now works as you would expect.
I believe this works because `{ [k in keyof T]?: T[k]; }` directly passes on the keys of `T` without transforming them. This allows TypeScript to connect the original type with the mapped type. We then rely on the fact that `{ a?: A | undefined } & { a: A }` merges to `{ a: A }`, giving us the original type mapping behaviour. 

What do you think? Is it worth seeing whether these sorts of changes can improve the IDE experience when using Zod?",,
1224581813,1114,Lost values on JSON.stringified formatted errors if schema contains array of objects,"Title is quite a mouthful, so an example will probably be helpful. :)

Given
```javascript
const schema = z.array(
  z.object({
    name: z.string()
  })
);
const result = schema.safeParse([{name: ""name""}, {}]);
```

results in
```javascript
result.error.format()
// {
//   '1': [ _errors: [], name: { _errors: [ 'Required' ] } ],
//   _errors: []
// }
```

but once piped through JSON.parse + JSON.stringify (which should pretty likely if used in common web environments)
```javascript
JSON.parse(JSON.stringify(result.error.format()))
// { '1': [], _errors: [] }
```

Basically all nested errors are lost on serialization.

The culprit are these lines: https://github.com/colinhacks/zod/blob/7296aae7d5062f60ca73d39adf71a2e62cc3d1d2/src/ZodError.ts#L213...L219
Removing the seperate type handling and unconditionally use `curr[el] = curr[el] || { _errors: [] };` should/would potentially fix the problem but slightly change the output format.

```javascript
result.error.format()
// {
//   '1': { _errors: [], name: { _errors: [ 'Required' ] } },
//   _errors: []
// }

JSON.parse(JSON.stringify(result.error.format()))
// {
//   '1': { _errors: [], name: { _errors: [ 'Required' ] } },
//   _errors: []
// }
```

Is the current behaviour intended or a bug? If you want I could open a pull request with the change and some tests.",,
1221809151,1110,Provide a way to extract implementation from function schema,"Given a function schema with an implementation, it would be nice to have a way to extract the implementation out, so that it can be directly invoked when the overhead of validation is not desirable and 

```ts
const doSomething = z
    .function()
    .args(z.string())
    .returns(z.promise(Something))
    .implement((id) => {
        // ...
    })

const doSomethingUnsafe = doSomething.implementation; // Same signature as doSomething
```

I understand that I can separately define and expose the function I am passing to `.implement` but then I need to annotate the types explicitly rather than having them inferred for me as is the case above. This also results in more boilerplate when the args/returns take in complex types that are defined inline. 
",,
1221274076,1108,[Request] bigints for z.literal,"I'm trying to create an enum validator who's values are bigints, and to validate if the data provided is one of those bigints, I use zod.

The README said to create an issue for support for bigints in z.literal",,
1219030598,1105,Support TS 4.7 instantiation expressions,"TS 4.7.0 (currently in beta) will bring in ""Instantiation Expressions"" (see https://github.com/microsoft/TypeScript/pull/47607).

Essentially this means that you can write things like:
```ts
function foo<T>(val: T) {}
type Foo<T> = typeof foo<T>
// type Foo<T> = (val: T) => void
```

The application for Zod schemas is as detailed here (https://github.com/microsoft/TypeScript/issues/40542), in particular that we can now write such things as:
```ts
// the dateSchema param could be a schema for an ISO 8601 string or a Date object, or even some custom date-like type
const fooSchema = <T>(dateSchema: z.ZodSchema<T>) => z.object({
  name: z.string(),
  date: dateSchema
})
type Foo<T> = z.infer<ReturnType<(typeof fooSchema)<T>>>
// expected result: type Foo<T> = { name: string, date: T }
```

Unfortunately this does not ""Just Work"" by upgrading to TS 4.7.0-beta:

```ts
import { z } from ""zod"";

function genericFooSchema<T>(inner: z.Schema<T>) {
  return z.object({
    type: z.literal(""foo""),
    inner,
  });
}

type Foo<T> = z.infer<ReturnType<typeof genericFooSchema<T>>>;

function useAFoo<T>(foo: Foo<T>): string {
  switch (foo.type) {
    // Hovering over foo.type gives:
    // ```
    // (property) type: z.objectUtil.addQuestionMarks<{
    //     type: ""foo"";
    //     inner: T;
    // }>[""type""]
    // ```

    case ""foo"":
      return ""TS should infer that this switch is exhaustive"";
  }
}
```",,
1217473052,1103,enum of integers,"Would it be feasible to create an enum of integers?

TypeScript seems to accept unions of integers, being able to have also a schema would be great.

Very nice and useful library.",,
1217009145,1102,z.infer does not return correct types with Typescript conditionals,"Hi team, thank you for the library. 

I'm new to zod and I was looking for ways I could create conditional schemas (something similar to generics in typescript), but couldn't find anything out of the box, so I opted to create multiple objects that could be called conditionally. However, after creating a generic function that conditionally returns `z.infer<typeof DogSchema>`, I do not get the raw typed object.

```
const DogSchema = z.object({
  sound: z.string(),
});

```
`type DogSchemaTypes<T> = T extends AnimalEnum ? z.infer<typeof DogSchema> : string;`

```
const getAnimal = <T>(data: any): DogSchemaTypes<T> => {
    const parsedData = DogSchema.parse(data)
    return  parsedData
}

```
The implementation above throws the error on `parsedData`: 

`Type '{ sound: string; }' is not assignable to type 'DogSchemaTypes<T>'`

and if you inspect the return type of `parsedData`, I get this:

```
z.ZodObject<{
    sound: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
    sound: z.ZodString;
}, {
    sound: z.ZodString;
}>
```

However, if: `type DogSchemaTypes<T> = z.infer<typeof DogSchema>`, It returns the proper object type. Is there a way to return the right type using typescript conditionals?

I have `""zod"": ""^3.14.4""`",,
1215066538,1100,Use of `RawCreateParams` for `preprocess` context,"Hey there 👋🏻 I'm coming in from `io-ts` and very happy to have found this project.

**TL;DR:** assuming I've set up some of my own-built schemas correctly, I can't seem to get custom errors out of a `preprocess`-based schema.

---

What I have is an own-rolled schema like the following, based on the `Dates` example from your docs:
```ts
export const dateString = (
  params?: RawCreateParams // <-- added params
) =>
  z.preprocess(
    (input: unknown) => {
      if (!(typeof input == 'string')) {
        return;
      }

      const date = new Date(input);

      if (isNaN(date.getTime())) {
        return;
      }
      return date;
    },
    z.date(),
    params
  );
```

Pretty basic stuff. The idea is to use it like so:

```ts
const someSchema = z.object({
  updated_at: dateString({
    invalid_type_error: ""Field `updated_at` had wrong type""
  })
})
```

Problem is whenever I do this, the custom error message doesn't seem to survive. I've tried all the fields under `RawCreateParams`, but still just get the default error object when parsing fails.

By contrast, doing this with a built-in schema works just fine:

```ts
const someSchema = z.object({
  someString: z.string({
    invalid_type_error: 'Custom error message here!',
  }),
});
```

So, what am I doing wrong? Or is this a bug with `preprocess`?",,
1211280339,1094,Add Custom Message To Enum,"First off, love this library seems to solve all my teams pain points! The one thing we can't figure out is adding a custom message to an enum type, something like the following:

```
z.enum(['apple', 'orange', 'banana'], {
  message: 'You must select an acceptable fruit',
});
```",,
1209993784,1092,Suggested feature: z.enumMap() ,"Given the updated change in 3.13.3, (#992), where the z.record function now correctly types as a `Partial<Record>` I wonder if it's possible to introduce some validation for exhaustively checking object keys against an enum (or even a union but haven't gone in depth there).

I have created a helper function to create such a schema but I feel it might be something to consider for the core library with a correct type?

The code:

```typescript
export const enumMap = <
  T extends [string, ...string[]],
  U extends z.ZodTypeAny,
>(
  enumeration: z.ZodEnum<T>,
  obj: U,
) => {
  const validateKeysInEnum = <I extends any>(
    record: Record<string, I>,
  ): record is Record<
    typeof enumeration.enum[keyof typeof enumeration.enum], // Yes this is ugly
    I
  > => Object.keys(record).every((key) => enumeration.safeParse(key).success)
  return z.record(obj).refine(validateKeysInEnum)
}

// produces a gnarly z.ZodEffects<> due to refinement?
const myEnumMap = enumMap(
  z.enum(['aaa', 'bbb', 'ccc', 'dddd']),
  z.object({ hhh: z.literal('a') }),
) 

// Zod does infer the type correctly:
// {
//   aaa: {
//     hhh: 'a'
//   }
//   bbb: {
//     hhh: 'a'
//   }
//   ccc: {
//     hhh: 'a'
//   }
//   ddd: {
//     hhh: 'a'
//   }
// }
export type MyEnumMap = z.infer<typeof x>
```

I am fairly new to using Zod and so there may be several reasons not to do this and I may be passing by good reasons to do this but I thought I should share. I don't believe the refinement will lead to easier composition with other schemas. Ideally I would be looking for a solution that can reconcile the current `z.record` behaviour which removes the `Partial` aspect ",,
1205258216,1086,Generating on-the-fly zod validation objects for 3rd party libs,"I used yup for years in a totally half-assed way because it didn't have typescript support. I have since fallen absolutely in love with zod and I'm now validating nearly everything. And most of my type definitions are coming from `z.infer<typeof MyZodSchema>`.

However the only deficiency I have found is the ability to support validation for 3rd party types.

My best example of this is the Stripe library. Nowadays, Stripe actually provides a very robust set of types for their very many entities (customers, subscriptions, charges, payment methods, etc, it goes on and on).

You can use these types easily like this:
```
import {Stripe} from 'stripe';
const customer: Stripe.Customer = {
  // ... a bunch of properties here ...
};
```

But I would like to be able to validate these types as well. This is particularly useful when I have cached stripe objects in browser storage (or async storage for mobile) and I need to validate that they are not corrupted before consuming them.

I have seen some people create some codegen tools to go from typescript interface -> zod schema, but is there any way to do this in code on the fly? I'm working on stripe lib right now, but I can imagine doing this for many other libraries as well.

Thanks again for the great lib!!",,
1205226492,1085,Support for schemas that is an enum of the keys of an object?,"Essentially what I'm looking for would be something akin to this:

```typescript
const Inputs = Z.object({
  email: Z.string().email(),
  password: Z.string().min(8),
  username: Z.string().min(3),
  id: Z.string().uuid(),
  base: Z.unknown().optional(),
})
const InputFields: Z.ZodEnum<['email', 'password', 'username', 'id', 'base']> = Z.keyof(Inputs)
```

Is any form of the above currently possible, and if not, would anything bar its creation?",,
1202127283,1082,The inferred type of '...' cannot be named without a reference to '..node_modules/zod/lib'. This is likely not portable. A type annotation is necessary.,"I realize that this is most likely not a bug at zod but maybe it is!?

I have a package that exposes an API to firestore with zod validation. I'm using generics to determine the type of data returned based on the validation schema given.

But when I install the package and create my client I get a lot of errors like this

```
The inferred type of 'databaseClient' cannot be named without a reference to '../../firestore-zod/node_modules/zod/lib'. This is likely not portable. A type annotation is necessary.ts(2742)
```

I don't really understand the issue but I'm guessing it's related to using `z.infer<typeof validationSchema>`? Anyone able to help to get around it?",,
1198435893,1078,"When defining a function with a return type of `z.void()`, is it necessary to verify the return type of the function?","Please consider following example:

https://stackblitz.com/edit/typescript-m6zgjb

```ts
import * as z from 'zod';
import { expectType, TypeEqual } from 'ts-expect';
import { expect } from 'chai';

const src = [1, 2, 3];
const dst = [0];

const push = dst.push.bind(dst) as typeof dst.push;

const pushWithoutReturnValue = z
  .function(
    z.tuple([]).rest(z.number()),
    z.void() // should not throw Error
  )
  .implement(push);

// should be true
expectType<TypeEqual<typeof pushWithoutReturnValue, (...items: number[]) => void>>(true);
// @ts-expect-error: should not use the return value
const _: number = pushWithoutReturnValue(...src);
expect(dst).deep.eq([0, 1, 2, 3]);
```

1. When defining a function with a return type of `z.void()`, is it necessary to verify the return type of the function?
2. It seems that `pushWithValidation` will be inferred to `typeof push` instead of the type defined in `z.function`.

Are there any considerations about this?

Thanks.

---

References:
> ... Another way to say this is a contextual function type with a void return type (type vf = () => void), when implemented, can return _any other_ value, but it will be ignored. - https://www.typescriptlang.org/docs/handbook/2/functions.html#return-type-void
",,
1196478045,1075,Allow more types in discriminated unions,"It seems like `z.discriminatedUnion` currently has quite narrow requirements for what you can use it with. Here are some example use cases that seem sound to me (in the sense that the discriminator should still be able to uniquely determine the union member) but currently aren't allowed:

```typescript
const A = z.object({ type: z.literal('a') });
const B = z.object({ type: z.literal('b') });
const C = z.object({ type: z.literal('c') });
const D = z.object({ type: z.literal('d').optional() });
const E = z.object({ type: z.enum(['e', 'ee', 'eee']) });

const AorB = z.discriminatedUnion('type', [A, B]);

// using another discriminated union with the same discriminator as a union member
const AorBorC = z.discriminatedUnion('type', [AorB, C]);

// the discriminator is optional in one union member
const CorD = z.discriminatedUnion('type', [C, D]);

// the discriminator is an enum
const CorE = z.discriminatedUnion('type', [C, E]);
```

Any chance these cases can be supported? It would great if the requirement for discriminated union members could be widened to something like ""any type that has the discriminator as a field and the type of the discriminator is a subtype of `string | null | undefined` and is mutually exclusive between the discriminated union members"", but supporting at least the cases I mentioned above would still be much appreciated.",,
1194478371,1069,Type inference on schema with passthrough(),"Hi,
Vscode infers this code:
```
const test=z.object({id:z.string()}).passthrough()
type Typetest=z.infer<typeof test>
```
to be
```
type Typetest ={
id:string
}
```
Is this correct? I was thinking about using this pattern to have a converter for ""id"", so I can transform the id objects before I ship my data (which is a document including id) off to the db driver. I was thinking that Typetest should display ""id"" and then some..
",,
1193525473,1068,`schema.safeParse(...).error.flatten()` return type and `z.inferFlattenedErrors<...>` don't match,"I'm trying to create a function that takes an object and a generic ZodObject schema and validates the object against the schema. But TypeScript complains that the error object from `schema.safeParse(...).error.flatten()` has a different type than `z.inferFlattenedErrors<...>`.

I've reduced my code to where the error is below:

```ts
import { z } from ""zod"";

type BaseSchema = z.ZodObject<Record<string, z.ZodTypeAny>>;

type Arg<Schema extends BaseSchema> = {
  fields: Record<string, string | null>;
  schema: Schema;
  onSuccess: (data: z.infer<Schema>) => Promise<Response>;
  onFailure: (data: z.inferFlattenedErrors<Schema>) => Promise<Response>;
};

export async function v<Schema extends BaseSchema>({
  fields,
  schema,
  onSuccess,
  onFailure
}: Arg<Schema>): Promise<Response> {
  const validation = schema.safeParse(fields);

  if (validation.success) {
    return await onSuccess(validation.data);
  } else {
    const error = validation.error.flatten();

    // This fails
    const response = await onFailure(error);

    // So I have to do this instead
    // const response = await onFailure(error as z.inferFlattenedErrors<Schema>);

    return response;
  }
}
```

[Demo](https://codesandbox.io/s/relaxed-turing-x55ycj?file=/src/index.ts).

The complaint is that the `.flatten()` error has this shape:

```
{
  formErrors: string[];
  fieldErrors: {
      [k: string]: string[];  // issue here
  };
}
```

while the `z.inferFlattenedErrors<...>` has this shape:

```
{
  formErrors: string[];
  fieldErrors: {
    [P in allKeys<TypeOf<Schema>>]?: string[] | undefined;  // issue here
  };
}
```

I found this in zod's source that looks related to my problem: the `fieldErrors` keys from the `.flatten()` error are typed as strings.

https://github.com/colinhacks/zod/blob/753f627504a6801d3637a33efab6ad87b216d4a6/src/ZodError.ts#L234-L247

Is this intentional or am I doing something wrong please? Thank you.",,
1192215328,1066,enum type inference loses refinement,"Using a zod enum in an object degenerates to generic string.
```ts
const MyEnumType = z.enum(['a', 'b']);
type MyEnum = z.infer<typeof MyEnumType>;
type MyObject = {foo: MyEnum};

function testFunc() {
  let x: MyObject = {foo: 'a'};
  const parsed = MyEnumType.safeParse('a');
  if (parsed.success) {
    let y = {foo: parsed.data};
    x = y; // Type '{ foo: string; }' is not assignable to type 'MyObject'.
  }
}
```

As a workaround, I can use `z.union([z.literal('a'), z.literal('b')])`, but the verbosity is inconvenient.",,
1190471548,1065,Cannot assign a 'private' constructor type to a 'public' constructor type,"I'd like to ensure that the `to` and `from` property are of the TransactionAmount class. The TransactionAmount class has it's own validation and I figure it can do the validation and creation before being passed in as props here. Is this the right way to do that?

```
export const transactionProps = z.object({
  id: z.string(),
  to: z.instanceof(TransactionAmount), // Argument of type 'typeof TransactionAmount' is not assignable to parameter of type 'new (...args: any[]) => any'. Cannot assign a 'private' constructor type to a 'public' constructor type.
  from: z.instanceof(TransactionAmount), // same.
});
```

```
export const transactionAmountProps = z.object({
  amount: z.string(),
  currency: z.string(),
});

export type TransactionAmountProps = z.infer<typeof transactionAmountProps>;

export class TransactionAmount {
  private constructor(private readonly props: TransactionAmountProps) {}

  get amount(): string {
    return this.props.amount;
  }

  get currency(): string {
    return this.props.currency;
  }

  public static create(props: TransactionAmountProps): Result<TransactionAmount, TransactionValidationError> {
    const validation = transactionAmountProps.safeParse(props);

    if (!validation.success) {
      return Err(new TransactionValidationError(JSON.stringify(validation.error.format())));
    }

    return Ok(new TransactionAmount(validation.data));
  }
}
```",,
1188456832,1064,"z.shape, infer and TypeScript","I have the following function, which generically validates a value of a poperty on an object, with zod:
```ts
import type { z } from 'zod';

const validateValue = <M extends z.ZodObject<z.ZodRawShape>, T extends keyof M[""shape""]>(
    model: M,
	field: T,
	value: z.infer<M[""shape""][T]>,
): z.infer<M[""shape""][T]> => model.shape[field].parse(value) as z.infer<M[""shape""][T]>;
```

This leads to multiple problems:

- TypeScript claims that the `model.shape[field]` object could possibly be undefined (I have all strict flags on), but this can't be true because the type of `field` is a generic key of `model[""shape""]`
- My ESLint configuration (`@typescript-eslint/no-unsafe-return`) complains that the return type of `.parse(value)` is `any`, but since it is explicitly assessed to be `z.infer<M[""shape""][T]>`, this must mean said type is `any`, which makes the function unusable for type safety.

Does anyone know what I can do to make this work fully type-safe, i.e. preventing calls with bad field/value parameters?",,
1187424744,1062,"Derivative schema usage, undocumented methods, and generic functions","Hey! in the last few days I became obsessed with zod after years of being driven crazy with working with ""soft"" interfaces from trash api. nevermind that, I have a proposal(?) and a question.

There are a few situations that I encountered with zod which I hit a dead end. 
The first is a generic wrapper. Lets say the data I'm working on has this repeated pattern:
```json
{
  ""data"": {
    ""id"":  ""1"",
    ""attributes"": {
      ""name"": ""zod"",
      ""author"": {
        ""id"": ""2"",
        ""attributes"" : {
          ""name"": ""colinhacks""
        }
      }
    }
  }
}
```
or, in other words
```ts
interface Payload<T> {
  data: {
    id: string
    attributes: T
  }
}
```
I'd wish to make generic helper or generic schema for these situation. With an important distinction. **I want the schema to transform (read strip) these boilerplate fields**. But TS breaks and won't let me 🤷🏻‍♂️ 
```ts
// this doesn't work
export const gqlPayload = <T extends object>(shape: T) =>
  z.object({
    data: z.object({
      id: z.string(),
      attributes: z.object(shape),
    }),
  }).transform(({data}) => ({id: data.id, ...data.attributes}))

// nor does this
export const gqlPayload = <T extends z.ZodTypeAny>(schema: T) =>
  z.object({
    data: z.object({
      id: z.string(),
      attributes: schema,
    }),
  }).transform(({data}) => ({id: data.id, ...data.attributes}))
```
very sad, next issue

---------------------

I also hit a wall when I wanted to continue working from an already-parsed object.
for example lets say I have a `Dragon` schema, and the schema makes a few transformations, and now I have a `startQuery` function, that should recieve that transformed `Dragon`, and extend/transform it again. but I could only set the input as the _untransformed_ `Dragon`. Which sucks eggs.

example:
```ts
const Wings = z.object({
  leftHp: z.number(),
  rightHp: z.number()
}).transform(({leftHp, rightHp}) => [leftHp, rightHp])

const Dragon = z.object({
  wings: Wings,
  legs: z.number(),
  eyes: z.enum(['red', 'blue'])
})


// requires a Dragon with array wings instead of object wings
const SlainDragon = Dragon.outputSchema.refine(/** check for less than 5 legs or something */).transform(value => ({...value, wings: [0,0]}))
type DragonToSlay = z.input<typeof SlainDragon>
// {
//   wings: [number, number];
//   legs: number;
//   eyes: ""red"" | ""blue"";
// }

function slayDragon(dragon:  Dragon) {
  try {
    const slainDragon = SlainDragon.parse(dragon)
    return slainDragon
  } catch (e) {
    throw new Error('you cannot hope to slay a beast with that many legs!')
  }
}
```
I know the example is a bit out there. The real-world example is just a bit more complicated. But basically it's getting an `Item` from somewhere, transforming it to be usable in my app, and in some other interaction take that transformed item and transform it more before sending it back. I could use 2 schemas, but then I'll have to make sure they are synced all the time. I just want the output of one schema to be the input of a different schema.. 😢 

-----------------------

last but not least, whats up with all the undocumented stuff? `shape`, `innerShape()`, `describe`, tell me what they doooooooo why do I have to figure it out myselfffffff (no need for all the `_` prefixed ones, you can have your secrets 😉 )

I love zod, and sorry for the long issue. I'd open a PR instead, but I know nothing about the inner workings of zod, so I thought it'd approach you first",,
1186951698,1061,z.record returns partial type when using enum with a 2nd schema,"Love this library, and while I was updating a site to the latest version, I realized something had changed on `z.record`. I had been using `record`  with two schemas as described in the changelog, since I realized it was allowed and the readme documentation seemed behind on fancy functionality:

```
const schema = z.record(z.enum([""Tuna"", ""Trout""]), z.boolean());
type schema = z.infer<typeof schema>; // Record<""Tuna"" | ""Trout"", boolean>
```

This was working fine until around v3.13.2. Now the result seems to be `Partial<Record<""Tuna"" | ""Trout"", boolean>>` ",,
1186890345,1060,Type error in monorepo with different Zod versions across packages,"TypeScript fails to resolve the correct types in a monorepo if different Zod versions are installed.

I created a minimum reproducible repo with our setup with Zod, React Hook Form, and its resolver; see https://github.com/bkiac/typescript-error-with-monorepo-zod-react-hook-form.

Upgrading all packages to the same `zod` version resolves the issue.",,
1181304034,1049,ZodType<Output> does not get the correct output of a union with transformations.,"Given this code

```typescript
import { z } from 'zod';

const stringToNumber = z.string().transform((val) => val.length);

const Data = z.object({
  prop: z.union([z.number(), stringToNumber])
});

function Parse<Output>(type: z.ZodType<Output>, data: unknown): Output {
  return type.parse(data);
}

const directlyParsed = Data.parse({}); // { prop: number; }
const indirectlyParsed = Parse(Data, {}); // { prop: string | number; }
```

Extracting the output on `indirectlyParsed` returns `string | number` instead of the correct one which should be just `number`. Am I doing something wrong or is there a problem with ZodType here?",,
1179777907,1046,`.required()` doesn't remove optional flag from the result of `.nullish()`,"The (undocumented) function `.required` is not working properly for properties defined with `.nullish()`:

```js
const base = z.object({
  required: z.string(),
  nullable: z.string().nullable(),
  optional: z.string().optional(),
  nullableOptional: z.string().nullable().optional(),
  nullish: z.string().nullish(),
})

const req = base.required()
```

The resulting inferred type of `req` is:
```ts
{
    required: string;
    nullable: string | null;
    optional: string;
    nullableOptional: string | null;
    nullish?: string | null | undefined;
}
```

As you can see, all fields that were defined as `.optional()` have properly been made non-optional except for the one created using `.nullish()`

This seems to arise from the fact that `.nullish()` is defined to return a `ZodNullable<ZodOptional<T>>` and `.required` simply returns the outermost `ZodOptional` without doing any type recursion, and as such it cannot see the optional in that type.",,
1179460222,1044,Callback on function arguments throws error,"I've started using this package to automatically infer types for Typescript declarations and to ensure object schemas, however I've came across some issues when it comes to having callbacks on functions.

When declarating a function like this:
```js
function processAndCallback(num, string, callback) {
    // Process data...
    callback(err, ""some string"", 0)
}
```
And using a Zod Schema like:
```js
const schema = z.function()
  .args(
    z.number(),
    z.string(),	
    z.function()
        .args(
            z.instanceof(Error),
            z.string({
                invalid_type_error: ""Paramether must be a string value"",
            }),
            z.number({
                invalid_type_error: ""Paramether must be a numeric value"",
            })
        )
        .returns(z.void())
        .implement((err: Error, address: string, family: number) => {
            err;
            address;
            family;

            return;
        })
    )
    .returns(z.void())
    .implement((err, options, callback) => {
        err;
        options;
        callback;

        return;
    })
```

The following error is thrown:
```
Argument of type '[ZodNumber, ZodString, (err: Error, address: string, family: number) => void]' is not assignable to parameter of type '[] | [ZodTypeAny, ...ZodTypeAny[]]'.
  Type '[ZodNumber, ZodString, (err: Error, address: string, family: number) => void]' is not assignable to type '[ZodTypeAny, ...ZodTypeAny[]]'.
    Type at positions 1 through 2 in source is not compatible with type at position 1 in target.
      Type 'ZodString | ((err: Error, address: string, family: number) => void)' is not assignable to type 'ZodTypeAny'.
        Type '(err: Error, address: string, family: number) => void' is missing the following properties from type 'ZodType<any, any, any>': _type, _output, _input, _def, and 30 more.
```

What I pretend is generating names for the arguments of the callback on the callback function for Typescript Declarations.
The only way I found that could do it was using `z.function().implement()`. Is there another way?",,
1179359504,1043,"""errorMap"" are not working for me, ""defaultErrorMap"" takes precedence","## What?

Hi I'm trying to override [errorMap order as explained in ERROR_HANDLING.md](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#customizing-errors-with-zoderrormap)

I'm trying this:

``` javascript
import { customErrorMap } from ""./customError"";

  z.setErrorMap(customErrorMap);
async function parse () {
  const result = await schema.safeParseAsync(
    {
      field_one: ""Hello there"",
      field_two: file
    },
    { errorMap: customErrorMap }
  );
}

parse()
```

But I see this error which is [hitting here](https://github.com/colinhacks/zod/blob/master/deno/lib/ZodError.ts#L361)

## DEMO
I made a [CODESANBOX CODE](https://codesandbox.io/s/pensive-frost-txd20s?file=/src/index.ts:21-85) with reproducing the error and using `zod@3.14.2` (Latest version at March 24th)

I see you have [errors in place](https://github.com/colinhacks/zod/blob/master/src/__tests__/error.test.ts#L318-L350) and if you check my code sandbox I think I'm doing the same.

Any ideas of what could be happening?",,
1178131339,1041,Validation errors not cleared from fields after passing checks,"`zod 3.14.2`

When using `refine()` to, for example` compare passwords:
```js
const register_schema = z
  .object({
    email: z.string().min(3).email(),
    password: z.string().min(6).max(64),
    password_confirm: z.string(),
  })
  .refine((data) => data.password === data.password_confirm, {
    message: ""Passwords don't match"",
    path: ['password_confirm'],
  })
```
Errors from the associated field - `password` in this case - are not being cleared even if said field passes it's validation. Here's a simple validation function
```js
export const createValidator = () => {
  let errors = {}

  const validate = async <T>(values: FormInitialValues<T>) => {
    try {
      await register_schema.parseAsync(values)
      errors = {}
    } catch (err) {
      if (err instanceof ZodError) {
        const err_array = err.flatten().fieldErrors
        errors = { ...errors, ...err_array }
      }
    }
    return errors
  }

  return validate
}
```
It records validation results in the `errors` object. Elsewhere, I'm using the returned `errors` object to enable / disable submit button or display the error messages to to user.

This doesn't work as expected as errors from the `password` field (`min()`, for example) won't be removed from from the `errors` object until the `refine()` checks pass. Nor will errors from the `email` field until all validation check pass.

[Here's a working example on Codesandbox](https://codesandbox.io/s/flamboyant-ellis-227d69?file=/createForm.js) .",,
1177592571,1040,Any better workarounds for TS7056?,"I'm responsible for a project with pretty complex schemas. We're running into a lot of TS compile errors like this:

> error TS7056: The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.

The best workaround I've found is to annotate schema declarations with zod types ahead of time (rather than using `z.infer`):

```ts
export type ZBlockEntity = z.ZodUnion<
  [
    typeof paragraphPropsOrElement,
    typeof layoutPropsOrElement,
    ...
    typeof escapeElement
  ]
>
export const blockEntity: ZBlockEntity = z.union([
  paragraphPropsOrElement,
  layoutPropsOrElement,
  ...
  escapeElement,
])
```

TypeScript will declare the array of `typeof name` referentially with this explicit annotation, otherwise it repeats a literal of each schema in the union.

The example I gave was simple, but some schemas that are hitting TS7056 are very tricky to mint and maintain explicit type annotations for, and even if it's achievable it will greatly increase technical inertia for the features that hit that wall.

I'd like to find a way to compile schemas in a way that TypeScript can declare and reuse named types instead of it repeating the same literals so many times it breaks.

Is there a workable solution here, or have we hit a wall?",,
1171584870,1019,Feature Proposal: Preprocessed string types,"I use Zod heavily for parsing environment variables and in each project need to reimplement transformer definitions to convert the raw env object (either from `process.env` or `dotenv`) to their intended types.

What would alleviate a bunch of pain in this use case is having built in `<number|boolean|bigint|null>String()`, for example:

```typescript
const isString = (value: unknown) : value is string => typeof value === ""string""

const booleanString = z.preprocess(
  (value) => (isString(value) ? value === ""true"" : value),
  z.boolean()
)

const numberString = z.preprocess(
  (value) => (isString(value) ? parseInt(value) : value),
  z.number()
)

const bigintString = z.preprocess(
  (value) => (isString(value) ? BigInt(value) : value),
  z.bigint()
)

const nullString = z.preprocess(
  (value) => (isString(value) && value === ""null"" ? null : value),
  z.null()
)
```

The ideal implementation would be for the `z` import to provide these like:

```typescript
import { z } from ""zod""

const EnvSchema = z.object({
  FOO_NUMBER: z.numberString().default(100),
  BAR_BOOL: z.booleanString().default(false)
  // etc...
})

```

Happy to do an MR if this is something that might be accepted? ",,
1169596014,1018,Documentation: More specific on use of validator.js,"I have an application using zod but I'd like to use some methods from a different library (validator.js) zod documentation says:

> Check out validator.js for a bunch of other useful string validation functions.

Not sure if that means this functions are implemented on zod, or I have to also install validator.js, in that other case how I can use both libraries together? cant find any example.

I got this answer from stackoverflow, is this the way you refer in your docs?

```
import { z } from ""zod"";
import isCreditCard  from ""validator/lib/isCreditCard"";

const userSchema = z.object({
  name: z.string(),
  creditCard: z.string().refine(isCreditCard, {
    message: 'Must be a valid credit card number'
  }),
})
```

Thanks!",,
1167637230,1016,A schema where property value is limited to another zod schema of any type,"Hi, first of all. Thanks for an awesome and intuitive library! I've been using it for multiple projects and bragging about it to other developers :D

I'm wondering if there is a way to declare a schema where a single property value is itself a `zod` schema. I'm trying to define some rules for a specific object type, but leave the ""value"" validation up to the object itself. Something like this:

```typescript
const FieldDefinition = z.object({
  title: z.string(),
  value: // type of any valid zod schema
})
type FieldDefinitionType = z.infer<typeof FieldDefinition>
```

Then in some other part of my program I want to be able to do something like this:

```typescript
const TextField: FieldDefinitionType = {
  title: ""Text field"",
  value: z.string().length(128)
}
```

Basically limiting the `value` property to only be another `zod` schema. How would I type that up in the `FieldDefinition` schema?

Edit: To be clear. The value should not be limited to `z.string()` or `z.number()`, any valid zod schema should be allowed.",,
1167440909,1015,Support multiple discriminated unions on same object,"First of all, thank you for Zod! I'm just starting to use it on a new project. I have a case come up quite frequently that I don't know how to resolve using current Zod functionality. I've asked a similar question [here](https://github.com/colinhacks/zod/discussions/1006) and haven't received a response, so I'm logging an issue considering functionality may need to be added to Zod.

I believe I want multiple discriminated unions on the same object. Here's some code that illustrates what I'm trying to accomplish:

```js
const schema = z.object({
    sku: z.string()
  }).merge(z.discriminatedUnion(""product"", [
    z.object({
      product: z.literal(""shoes""),
      price: z.number(),
      material: z.union([z.literal(""leather""), z.literal(""suede"")])
    }),
    z.object({
      product: z.literal(""shirt""),
      price: z.string()
    })
 ]).merge(z.discriminatedUnion(""color"", [
    z.object({
       color: z.literal(""red""),
       size: z.enum([""s"", ""m""])
    }),
    z.object({
      color: z.literal(""blue""),
      size: z.enum([""m"", ""l""])
    })
  ]);
```

In other words, the object will (1) always have a sku, (2) always have `product` and `price` (and sometime `material`), and (3) always have `color` and `size`.  The combinations would be restricted by the discriminated unions.

This doesn't work, though, because ZodDiscriminatedUnion doesn't have a merge property and ZodDiscriminatedUnion can't be merged into ZodObject.

I'm not particular about the implementation, so long as it's simple (it's a common use case) and preferably does not require `refine` or `superRefine` (though I'd still like to understand how solve it with `refine` or `superRefine` in the meantime). Thanks!",,
1167123541,1014,Feature Request: async preprocess,"I’m trying to parse some minecraft NBT data with zod. However, in order to do this, one key of the object (`item_bytes`) first needs to be converted from the binary NBT format to a JSON-like structure.

The best way to implement this in my opinion would be to use zod’s `z.preprocess()`. Unfortunately, the library I’m using [`prismarine-nbt`](https://www.npmjs.com/package/prismarine-nbt) only exposes `parse` as an `async` function.

As far as I can tell, async preprocessing is not supported right now. I think it would be great if it’s allowed as it would really simplify parsing with `async` libraries.

I’d suggest either `z.preprocess(async () => { /* ... */ }, z.any())` or `z.preprocessAsync(async () => { /* ... */ }, z.any())` as I think either would be reasonable from an API standpoint.",,
1164340316,1004,Validate Keys,"It would be nice to validate keys just like it is possible to validate values. Currently I am using this code
```js
export const counter = z
  .object({})
  .catchall(
    z.object({
      true: z.number().positive().max(process.env.MAX_NUM_IN_COUNTER),
      false: z.number().positive().max(process.env.MAX_NUM_IN_COUNTER),
    })
  )
  .strict();
```

In this code the key could be anything. I will store the resulting parsed object in a database as is. In order to stop users from exploiting this, I would like to make sure that the key is at most x characters long. I think this is currently not possible, but would be a nice feature. Awesome library though, I'm absolutely loving it.",,
1161734179,1001,New `refine` behaviour issues with `z.custom` (and `z.instanceof`),"Because `z.custom` returns a `ZodType<T>`. successive refinements believe to operate on a `T` when they're actually receiving the untouched input instead.

### Example
```ts
import { z } from 'zod';

class Foo {
  isValid(): boolean {
    return true;
  }
}

const FooSchema = z.instanceof(Foo)
  .refine((val) => {
    // `val` is typed as `Foo` because `z.instanceof(Foo)` is a `ZodType<Foo>`
    // but we will be operating on the raw input instead causing a runtime error.
    return val.isValid();  
  });

FooSchema.parse(undefined); // TypeError: cannot read properties of undefined (reading 'isValid')
```

### Possible Solution
I think a viable non-breaking solution would be to have `z.custom` rely on `superRefine` instead of `refine` and create an issue with `fatal: true` when the validation fails.",,
1158246425,995,Property does not exist on type '{ [k in keyof addQuestionMarks]...',"Hi, I'm not sure if this is a bug or if TypeScript just needs some more guidance but I'm having an issue with a generic function for generating schemas. Specifically the return type of the .parse() method

```typescript
import { z } from ""zod"";

export const createSchema = <T extends z.ZodTypeAny>(schema: T) => {
  return z.object({
    foo: schema,
    bar: z.string()
  });
};

export const createHandler = <T extends z.ZodTypeAny>(
  schema: T,
  data: unknown
): void => {
  const eventSchema = createSchema(schema)
  const result = eventSchema.parse({foo: data, bar: 'baz'})
  console.log(result.foo) // Error!
  console.log(result.bar) // No error
};

createHandler(z.string(), 'hello');
createHandler(z.number(), 123);
```

The error that I'm getting on the `console.log(result.foo)` says:

>Property 'foo' does not exist on type '{ [k_1 in keyof addQuestionMarks<{ foo: T[""_output""]; bar: string; }>]: addQuestionMarks<{ foo: T[""_output""]; bar: string; }>[k_1]; }'.ts(2339)

Here is a CodeSandbox with the same code as above.

https://codesandbox.io/s/nervous-banach-vkf8d5?file=/src/index.ts",,
1157260924,993,Type Inference : Named Types with nested schemas in objects,"Hey everyone!
I've recently discovered Zod and this is quite a marvel! Congrats @colinhacks and every contributor for the awesome work !

I've got an ""issue"" that can be quite annoying when dealing with complex objects, let me explain with this short example : 

```typescript
const foo = z.object({
    name: z.string(),
    birthdate: z.date()
})
type Foo = z.infer<typeof foo>

const bar = z.object({
    property: z.string(),
    foo
})
type Bar = z.infer<typeof bar>
```

Here i defined two schemas, a practical example would be : Foo is a Person, and Bar is an Order or something, it doesn't matter.
When I infer the type of Bar, I would like the final output to look like this : 

```typescript
type Bar = {
    property: string;
    foo: Foo;
}
```

Of course right now, this is impossible, I've searched the docs and tried a few things, but unfortunately nothing worked.

**What the inferred type looks like (no surprise here)**
```typescript
type Bar = {
    property: string;
    foo: {
        name: string;
        birthdate: Date;
    };
}
```

**What i've tried so far, without any luck**
```typescript
const bar = z.object({
    property: z.string(),
    foo: foo as z.ZodSchema<Foo>
})
```

```typescript
const bar = z.object({
    property: z.string(),
    foo: foo.transform((arg): Foo => { return arg })
})
```

**My terrible workaround**
```typescript
type Bar = { property: string, foo: Foo }
```

**Why I consider it important**
With large DB infrastructures, having understandable and clear typings is essential, while Zod allows me to really enforce typing, I would really like to have a clear type hinting from VSCode when using z.infer<T>. The workaround is fine but it's static.

Have anyone figured out how to achieve such behavior ?

Cheers!
Julien",,
1154440650,981,Complex ZodObject type causes infer error,"I was able to isolate the bug with `infer` and `ZodObject` described in this issue: microsoft/TypeScript#48059

That requiredKeys (https://github.com/colinhacks/zod/blob/v3.12.0/src/types.ts#L1306) adds complexity to the type causes `infer` error:

> Type 'U' does not satisfy the constraint 'ZodRawShape'.(2344)

Reproduction ([playground](https://www.typescriptlang.org/play?ts=3.9.7#code/C4TwDgpgBAyglgWzAGzgMxAHgCoD4oC8UA3gNoDSEI240cAdlANZUD2aU2AugFycVUakLgF8A3AFgAUNNCQorMMDit6AQ2SUQAZxxQIAD2AR6AE20KARgCsIAY2D4ixaVDdRSTKA2ZsO3PgBXMwg0BghTfSMTc34mLigAfmYoPnoIADcIACdJKRFPP04uPOkAegAqWVoobIgAR0C4OtMtXWwo4zMLVht7R0ISVw8vHxYQdmKgkLD0yMMu2OxPBOT0rOzU5jyC8cnuPIqy6Wr5OsbmiLa9BZievocnKABRAztkQNMITD3-ABoFEoVOpNFR2rhcKUpIYwKxssAoHJoGpTKYAIqBCDaZSqACyamyTHanTuVlsj0GLik7hG3kYihxIOueC4iT4y3iOygADIhtT3J46bUGk0WszcLw4iVpOITlIkVAAFqsUwAJTUAHcYAALNTyZzDNyePjY7IMADmkuVpiE3zU9BAkJlUIYxmyaDUdmg1ttmAA8oFgGBA-gqW4APpIvgBoOBnZy6SunIer1KlV+h7ATDDDq3bpptWanV6iB-YYx4MIojwJCoDDZ-luMM02k+BnAjTi1nslZ5GkiHl8lutxjnUVXME4CU9zmGqAiYa4aT4POxH20f2Byuh4Z1FGqZAgKDh7S6yDs+MyeU1XEgDPkrN4Qa56L5633-qYBhoHJQACqS78skf4km+KrqlqZ4QHOwFzmkmQ5MM8EbHkQA)):

```ts
type Simplify<T> = {[KeyType in keyof T]: T[KeyType]};

type optionalKeys<T extends object> = {
    [k in keyof T]: undefined extends T[k] ? k : never;
}[keyof T];

type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;

export type addQuestionMarks<T extends object> = {
    [k in optionalKeys<T>]?: T[k];
} & {
    [k in requiredKeys<T>]: T[k];
};

type ZodRawShape = {
    [k: string]: ZodType<any>;
};

interface ZodType<Output> {
  _type: Output;
}

interface ZodObject<
  T extends ZodRawShape,
  Output = Simplify<
    {
      [k in optionalKeys<T>]?: T[k];
    } & {
      [k in requiredKeys<T>]: T[k];
    }
  >
> extends ZodType<Output> {
  readonly _shape: T;
}

type MyObject<T> = T extends ZodObject<infer U>
  ? U extends ZodRawShape
    ? U
    : never
  : never;
```

After changing requiredKeys to more simplified implementation similar to optionalKeys, the error disappears:

```ts
type requiredKeys<T extends object> = {
  [k in keyof T]: undefined extends T[k] ? never : k;
}[keyof T];
```

Versions to reproduce:

TypeScript v3.9.x (3.9.7) or higher
zod v3.1.2",,
1154393791,980,"Value or undefined is not the same as an optional, and should not be a required property either","### Discussed in https://github.com/colinhacks/zod/discussions/971

<div type='discussions-op-text'>

<sup>Originally posted by **emanuel-lundman** February  7, 2022</sup>
```typescript
type A = {
    b: string | undefined
}
```

is not the same as:

```typescript
type A = {
    b?: string | undefined
}
```

The first requires undefined to be set, and can't just be left out.

Zod though both seem to infer:
```typescript
type A = {
    b: string | undefined
}
```

 to an optional when writing the schema first and then inferring a type. And when doing the other way around, writing a schema for the type, thinks it's required and only accepts the following:

```typescript
type A = {
    b: string | undefined
}

const a = z.ZodScheme<A> = z.object({
    b: z.string()
})
```

even though it should be `z.string().or(z.undefined())`
But writing is it should be results in error:
`Property 'b' is optional in type '{ b?: string | undefined; }' but required in type 'A'`

Am I missing something?</div>",,
1149989659,970,Enums should support an omit method,"Example of what has to be done right now:

<!-- <img width=""624"" alt=""CleanShot 2022-02-24 at 22 05 16@2x"" src=""https://user-images.githubusercontent.com/284476/155646051-b8250501-6855-4da1-8c7c-d8fafaa3159f.png""> -->
```ts
const a = z.nativeEnum( { a: 1, b: 2 } as const )
const b = z.nativeEnum( Remeda.omit( a._def.values, [ 'a' ] ) )

b._def.values.b // works
b._def.values.a
//            ^
// Property 'a' does not exist on type 'Omit<{ readonly a: 1; readonly b: 2; }, ""a"">'.
```


I'm not sure how to do it with zod enums actually.

This issue would be asking for native and zod enums though to support an omit method.",,
1149368710,965,skypack error on v3.12.0,"I tried importing the most recent version of skypack and received an error:
```
[Package Error] ""zod@v3.12.0"" could not be built. 
[1/5] Verifying package is valid…
[2/5] Installing dependencies from npm…
No matching version found for zod@3.12.0.
```

Reproduce:
Go to https://www.skypack.dev/view/zod and click ""Open in Codepen"" and view the console logs

version 3.11.6 works as expected with Skypack via `import * as zod from 'https://cdn.skypack.dev/zod@3.11.6'`, so not sure if something changed in 3.12.0",,
1149248759,964,`union` and `discriminatedUnion` do not work well together with `inferFlattenedErrors` ,"Given the code
```ts
const SomeData = z.discriminatedUnion(""kind"", [
    z.object({
        kind: z.literal(""with-number""),
        num: z.number()
    }),
    z.object({
        kind: z.literal(""with-string""),
        str: z.string()
    })
]);

type ErrorType = z.inferFlattenedErrors<typeof SomeData>;

const err: ErrorType = {
    formErrors: [],
    fieldErrors: {
        num: [""Could not parse number""]
    }
}
```
Typescript complains because the only field in `ErrorType.fieldErrors` is `kind`. Similar happens when `union` is used instead of `discriminatedUnion`. I would have expected the ErrorType to contain the union of the potential errors (as optional properties), not the intersection, as that is what the errors returned will contain.

Tested with Zod version 3.12.0 with typescript 4.5.5.",,
1142431463,946,Cannot read property '_parse' of undefined,"Hi, I have a Zod object like this

```ts
const zodObj = z.object( { id: string } )
```
then I extend it by
```ts
const extendObj = zodObj.pick( { wrongKey: true, id: true } )
```
when I run 
```ts
extendObj.parse( { id: ""xxx"" } )
```
I will get error

```
TypeError: Cannot read property '_parse' of undefined
    at s._parse (file:///E:/Job/test/node_modules/zod/lib/index.mjs:1:32502)
    at s.e._parseSync (file:///E:/Job/test/node_modules/zod/lib/index.mjs:1:13917)
    at s.e.safeParse (file:///E:/Job/test/node_modules/zod/lib/index.mjs:1:14474)
    at s.e.parse (file:///E:/Job/test/node_modules/zod/lib/index.mjs:1:14128)
    at Array.eval (webpack-internal:///(api)/./src/pages/api/test.ts:14:104)    
    at loop (file:///E:/Job/test/node_modules/next-connect/dist/index.js:79:47)
    at next (file:///E:/Job/test/node_modules/next-connect/dist/index.js:81:25)
    at AsyncFunction.handle (file:///E:/Job/test/node_modules/next-connect/dist/index.js:83:5)
    at nc (file:///E:/Job/test/node_modules/next-connect/dist/index.js:21:8)
    at Object.apiResolver (E:\Job\test\node_modules\next\dist\server\api-utils\node.js:182:15)
```
This can be fixed by remote `wrongKey` but I think you can fix this to avoid error ",,
1136706391,935,[Proposal] Pass `description` to `ZodError` constructor.,"After minification / bundling it's not always feasible to access a source map for tracing errors, making it hard to diagnose specific ZodError causes in an app with many Zod schemas. 

It would be handy for the `ZodError` context to include the `description` property (or possibly a new `name` property) of the schema that triggered it by passing this info to the constructor.

## Example

### ZodError

https://github.com/colinhacks/zod/blob/12dcdf5169c809e1d3804ed3c2f2fcbf72ee6e54/src/ZodError.ts#L140

```typescript

export class ZodError<T = any> extends Error {
  // ...
  constructor(description: string, issues: ZodIssue[]) {  // Add description to constructor here...
    super();
    // ...
    this.name = ""ZodError"";
    this.description = description;
    this.issues = issues;
  }
}

```
### handleResult()
https://github.com/colinhacks/zod/blob/12dcdf5169c809e1d3804ed3c2f2fcbf72ee6e54/src/types.ts#L89

```typescript
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.issues.length) {
      throw new Error(`Validation failed on ${ ctx.description } but no issues detected.`); // Add description to generic error here...
    }
    const error = new ZodError(ctx.description, ctx.issues); // Add description to constructor here...
    return { success: false, error };
  }
```



If the schema provided it's `description` to the `ZodError` constructor, it would make it a lot easier to trace issues in these cases where a source map is not available, or even more gracefully in logging with something like:


```typescript
import { EOL } from ""node:os""
const logZodError = ({ name, description, issues }: ZodError) => {
  const message: string = [
    `Encountered a ${ name } error while parsing ${ description }`,
     issues.map(
          ({ message, path }: ZodIssue): string =>
            `[${ path.join(` › `) }]:  ${ message }`
        ).join(EOL)
  ].join(EOL)
  console.error(message)

}

```",,
1128888424,925,z.object().passthrough() not working with objects like Buffer,"Thanks for Zod!

Perhaps I am using this incorrectly, or missed something in the docs. I wanted to use a zod schema to parse an object containing a field that points to a `Buffer` , more generally an object that implements `Reader` (`Buffer` does), but that detail isn't important for this. I didn't expect native support for `Buffer`, so I figured I could use `z.object({ ... }).passthrough()`, checking for the methods on `Buffer` I cared about, but then passing through the whole object to keep the internals working.

What seems to happen is that I get back an object that has the `bytes()` function, but the rest of the fields _do not_ passthrough. So fundamentally, it seems that `passthrough()` isn't working for this case, unless i'm using it incorrectly.

Here is a reproduction using Deno:

```js
import * as z from ""https://cdn.skypack.dev/zod@^3"";
import { Buffer } from ""https://deno.land/std@0.125.0/io/buffer.ts"";

const FooSchema = z.object({
  bar: z.string(),
  // stream is a Buffer, but passthrough all fields
  stream: z.object({
    bytes: z.function(),
  }).passthrough(),
});

const throws = FooSchema.parse({
  bar: ""fizz"",
  stream: new Buffer(new Uint8Array(4).buffer),
});

console.log(""typeof Buffer: "", typeof new Buffer(new Uint8Array(4).buffer));

// this throws because another method has been stripped that bytes() uses internally
console.log(""throws.stream.bytes(): "", throws.stream.bytes());
```",,
1128051725,923,Type Error when recursive types with default,"```
type NodeType = {
    id: string;
    parent?: NodeType;
};

export const NodeTypeSchema: z.ZodSchema<NodeType> = z.lazy(() =>
    z.object({
        id: z.string().default(''),
        parent: NodeTypeSchema.optional()
    })
);
```

typescript 4.5.5 error:

Type 'ZodLazy<ZodObject<{ id: ZodDefault<ZodString>; parent: ZodOptional<ZodType<NodeType, ZodTypeDef, NodeType>>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<NodeType, ZodTypeDef, NodeType>'.
  The types of '_input.id' are incompatible between these types.
    Type 'string | undefined' is not assignable to type 'string'.
      Type 'undefined' is not assignable to type 'string'",,
1126662785,920,"Value or undefined is not the same as an optional, and should not be a required property either","```typescript
type A = {
    b: string | undefined
}
```

is not the same as:

```typescript
type A = {
    b?: string | undefined
}
```

The first requires undefined to be set, and can't just be left out.

Zod though both seem to infer:
```typescript
type A = {
    b: string | undefined
}
```

 to an optional when writing the schema first and then inferring a type. And when doing the other way around, writing a schema for the type, thinks it's required and only accepts the following:

```typescript
type A = {
    b: string | undefined
}

const a = z.ZodScheme<A> = z.object({
    b: z.string()
})
```

even though it should be `z.string().or(z.undefined())`
But writing is it should be results in error:
`Property 'b' is optional in type '{ b?: string | undefined; }' but required in type 'A'`

Am I missing something?",,
1126351678,917,Branded helper,"Instead of:

```ts
type Age = Branded<number, ""Age"">;

const Age = z
  .number()
  .min(0)
  .max(100)
  .refine((a: number): a is Age => true);
```

Zod can provide a simple helper:

```ts
const Age = z
  .number()
  .min(0)
  .max(100)
  .brand('Age');
```

What do you think? 

---

This line:

```ts
.refine((a: number): a is Branded<number, ""Age""> => true)
```

to this line:

```ts
.brand(""Age"").
```

I suppose it's a tiny change but would improve DX a lot.

---

Or something like that?

```ts
const brand =
  <B extends string>(brand: B) =>
  <T extends string | number>(a: T): a is Branded<T, typeof brand> =>
    true;

.refine(brand(""Age""))
```

---

OK, this is what I reiterated. Still, I suppose it should be part of the official Zod API. 

```ts
export type Branded<T extends string | number, B extends string> = T & {
  readonly __brand: B;
};

export const branded =
  <B extends string, T extends string | number>(
    brand: B,
    predicate?: Predicate<T>
  ) =>
  (a: T): a is Branded<T, typeof brand> =>
    predicate ? predicate(a) : true;
```",,
1125229044,916,Cannot raise issue with custom code and global error map,"Using `z.setErrorMap` a custom error map can be registered, but the default error map is called before this one and throws an error if the code is not one of the default error codes.

[ZodError.ts](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts)
```js
switch (issue.code) {
    // ...
    default:
      message = _ctx.defaultError;
      util.assertNever(issue); // <--
```

```stacktrace
Error
    at Object.assertNever (node_modules\zod\lib\helpers\util.js:18:15)
    at defaultErrorMap (node_modules\zod\lib\ZodError.js:291:25)
    at makeIssue (node_modules\zod\lib\helpers\parseUtil.js:174:28)
    at addIssueToContext (node_modules\zod\lib\helpers\parseUtil.js:189:39)
    at Object.addIssue (node_modules\zod\lib\types.js:2310:55)
    at Object.notWhiteSpace [as refinement] (out\server.js:5871:13) | <= Custom super refinement here
    at executeRefinement_1 (node_modules\zod\lib\types.js:2326:37)
    at ZodEffects._parse (node_modules\zod\lib\types.js:2346:17)
    at ZodObject._parse (node_modules\zod\lib\types.js:1158:41)
    at ZodObject._parse (node_modules\zod\lib\types.js:1158:41)
```",,
1122573789,905,`z.infer` creates object types with optional keys,"When creating an object like,

```ts
  const Schema = z.object({
    email: z.string()
  })

  type Schema = z.infer<typeof Schema>
```

The created type is,

```ts
  type Schema = {
    email?: string
  }
```

But according to the documentation the keys should be required.",,
1121457323,904,"Namespace '""./zod/lib/index""' has no exported member 'inferFlattenedErrors'","First of all, awesome work on this library!

According to [the docs](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#type-safety-with-safeparse), I can use `inferFlattenedErrors` to improve the type safety of errors. However, it seems like it's not being exported from the package, because I get this error:

```
Namespace '""./zod/lib/index""' has no exported member 'inferFlattenedErrors'.
````

To be sure, I copy/pasted code from the [test files](https://github.com/colinhacks/zod/blob/cc8ad1981ba580d1250520fde8878073d4b7d40a/src/__tests__/all-errors.test.ts),  but I get the same error. Is the code somehow not included in the build, or am I doing something wrong?

",,
1118351795,897,optional().default() getter doesn't allow returning undefined,"Given the following snippet:

```ts
import { z } from ""zod"";

const checkIfOnPath = (executableName: string) => false;

const parsed = z.string()
  .nonempty()
  .optional()
  .default(() => [""a"", ""b"", ""c""].find(checkIfOnPath))
  .parse(undefined);
```

I get this error:

```
No overload matches this call.
  Overload 1 of 2, '(def: string): ZodDefault<ZodOptional<ZodString>>', gave the following error.
    Argument of type '() => string | undefined' is not assignable to parameter of type 'string'.
  Overload 2 of 2, '(def: () => string): ZodDefault<ZodOptional<ZodString>>', gave the following error.
    Type 'string | undefined' is not assignable to type 'string'.
      Type 'undefined' is not assignable to type 'string'.(2769)
```

[(TS Playground link.)](https://tsplay.dev/WP7Rkm)

My expectation is that `.default()` with a function on `ZodOptional<ZodString>` should be able to return `string | undefined`, but it only accepts a function that returns `string`.

Further, at runtime this works just fine -- if the default getter returns `undefined`, `.parse()` doesn't throw, and its return value is `undefined` as I expect.",,
1118280770,896,How to model nominal types,"I've got a simple nominal type:
```typescript
export type Id = string & { readonly """": unique symbol };
export interface Hero {
  id: Id;
  name: string;
}
```
How can I create a schema for `Hero`? I tried `ts-to-zod`, but it doesn't seem to be able to handle the case. Is there any way to model this on zod?  (Note: I don't need to use ts-to-zod, I can write the schema manually as long as I know how to do it.)
Thanks.",,
1118193719,895,`.pick()` mask allowing non-present props when present props are defined,"### Example
```typescript

// Original schema
const FooSchema = z.object({
  foo: z.string(),
  bar: z.string()
})


const CorrectlyFailingSchema = FooSchema.pick({
  notARealProperty: true // This causes TypeScript error as expected.
})


const IncorrectlyPassingSchema = FooSchema.pick({
  foo: true,
  notARealProperty: true // Once an existing property is added to the mask, any non-defined props can pass as well.
})

```

This became an issue today where after passing through a bundler (esbuild), a non-descriptive error started throwing on `e.t._parse`: 
```
TypeError: Cannot read properties of undefined
```

The issue occurred because I had removed a property `""title""` from the original schema, but not from the `pick()` mask, so `title._parse()` was throwing as `title` was now undefined.",,
1117644345,894,Add `discriminatedUnion` schema type,"Our current implementation naively goes through and tests each member in a union and reports back all errors. This is both noisy and slower for cases where the union is a discriminated union.

Adding this issue to discuss how best to tackle adding a new schema type for discriminated unions.

## Some technical challenges

### Async?

How do we support an `async` version of the schema?

### Requiring schemas to be objects with the discriminate as a key

I _think_ there should be a way to do this, but I think it needs to be absolutely type-level constrained that you can't add a schema to the union that wouldn't contain the discriminant, so it needs to exclude non-objects and objects who's `shape` does not include the discriminant.",,
1116824340,891,Zod is calling addIssueToContext when no error is happening,"I noticed since 3.10 (new parsing engine) that we call `addIssueToContext` whenever we use an enum with union. See:

3.11:
![image](https://user-images.githubusercontent.com/3749095/151457293-6a382aff-9cfc-46e6-8050-681c067ed1b2.png)

3.9:
![image](https://user-images.githubusercontent.com/3749095/151457362-254fb234-084d-4644-8ad2-8a67208dd0a6.png)

After digging further, I noticed it's coming from here: https://github.com/colinhacks/zod/blob/cc8ad1981ba580d1250520fde8878073d4b7d40a/src/types.ts#L2820-L2826

Seems like the union is mapping through all the items and still calling error in the new parsing engine, whereas that wasn't the case before. 

Fix is to downgrade to 3.9 unfortunately. ",,
1116371805,890,Fields depending on other fields,"Bit of a complex one and might be a job for a layer on top of Zod but I couldn't find a similar issue so figured I'd open one.

I have a data structure that has a couple of fields that are required only if another field is set to some value.

```ts
z.object({
  entity: z.enum([""individual"", ""business""]),

  firstName: z.string(),
  lastName: z.string(),

  companyName: z.string(),
  companyNumber: z.string(),
});
```

If `entity` is `individual` then the company name and number are not required at all, but if `entity` is `business` then they are required.

What's the best way to go about this? I was thinking refine but there's no access to the object within this function, another method I could think of was something akin to a tagged type union:

```ts
type GeneralFields = { firstName: string; lastName: string }

type IndividualFields = { entity: ""individual"" } & GeneralFields 

type BusinessFields = { entity: ""business"" } & {
  companyName: string;
  companyNumber: string;
}

type Fields = IndividualFields | BusinessFields;
```

Is this possible to express with Zod?

Thanks for such a great library!",,
1116169805,889,inferrence for transformed sub schema fails when going through generics,"Let me preface this with that this might just be me having made some bad generics. But it seemed to work before I changed all my string based ISO-8601 dates to be `transform`-ed to `Date`.

Full repro repo here: https://github.com/karl-run/zod-repro

## Details

When you have a zod type that transforms a string to a date, for example like this:

```ts
export const LocalDateSchema = z
  .string()
  .refine((date) => isValid(parseISO(date)), { message: ""Invalid date string"" })
  .transform((date) => parseISO(date));
```

The resulting type here would be `Date` because that is what the transform-function returns, which is correct.

Given this example type, with it's corresponding (generated from GraphQL schema type):

```ts
  const SchemaWithDate = z.object({
    a: z.string(),
    date: LocalDateSchema,
    c: z.string(),
  });
  
  interface CompatibleGraphQLSchemaWithDate {
    a: string;
    date: Date;
    c: string;
  }
```

Parsing like this give you the expected result:

```ts
  const workingResult = SchemaWithDate.safeParse({});
  if (workingResult.success) {
      const reAssign: CompatibleGraphQLSchemaWithDate = workingResult.data
  }
```

So far so good. But I had this function that infers the type from the schema, so I could have one fetch function that passes inn path and schema, and parses and infers correctly (simplified for repro):

```ts
async function genericFetcher<SchemaType>({
  path,
  schema,
}: {
  path: string;
  schema: ZodType<SchemaType>;
}): Promise<SchemaType> {
  const response = await fakeFetch(path);
  const responseJson = await response.json();
  const result = schema.safeParse(responseJson);
  if (result.success) {
    return result.data;
  }

  throw new Error(`Unable to parse response`);
}
```

Now if we parse using this function, we get some strange behaviour:
```ts
  const doesNotWork: CompatibleGraphQLSchemaWithDate = await genericFetcher({
    path: ""/foo"",
    schema: SchemaWithDate,
  });
```

Gives us the following error on `schema`:

```
error TS2322: Type 'ZodObject<{ a: ZodString; date: ZodEffects<ZodEffects<ZodString, string, string>, Date, string>; c: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<{ a: string; date: Date; c: string; }, ZodTypeDef, { a: string; date: Date; c: string; }>'.
  The types of '_input.date' are incompatible between these types.
    Type 'string' is not assignable to type 'Date'.

45     schema: SchemaWithDate,
       ~~~~~~

  index.ts:54:3
    54   schema: ZodType<SchemaType>;
         ~~~~~~
    The expected type comes from property 'schema' which is declared here on type '{ path: string; schema: ZodType<{ a: string; date: Date; c: string; }, ZodTypeDef, { a: string; date: Date; c: string; }>; }'
```

Implying that the transformed `date` value is still viewed as `string`. :thinking: 

Again, full repro here if anyone would like to play around with it: https://github.com/karl-run/zod-repro",,
1115020153,886,Adding a default to a value converts its cast type to optional,"This works all right:

```ts
type Potato = {
  kiwi: string,
}

const potatoSchema : ZodSchema<Potato> = z.object({
  kiwi: z.string(),
});
```

But now I would like to add an additional value as a ""fallback"" in case a value for`kiwi` is missing. 

```ts 
// [typescript]
// Type 'ZodObject<{ kiwi: ZodDefault<ZodString>; }, ""strip"", ZodTypeAny, { kiwi: string; }, { kiwi?: string | undefined; }>' is not // assignable to type 'ZodType<Potato, ZodTypeDef, Potato>'.
//   The types of '_input.kiwi' are incompatible between these types.
//    Type 'string | undefined' is not assignable to type 'string'.
//      Type 'undefined' is not assignable to type 'string'
const potatoSchemaBroken : ZodSchema<Potato> = z.object({
  kiwi: z.string().default(""kiwi""),
});
```
`Z.infer` does deduce the correct type

```ts
type InferedPotato = z.infer<typeof potatoSchemaBroken>;
// Infers type correct,
// type InferedPotato = {
//     kiwi: string;
// }
```
From reading the docs, I expect that the type you get from ` : ZodSchema<Potato>` to match the type from  `z.infer<typeof potatoSchemaBroken>`. Am i missing something?


Thank you for your time! 😄 
",,
1114046647,885,No way to validate NaN,"- `z.number()` does not accept NaN (arguably correct behaviour)
- `z.union([z.number(), z.literal(NaN)])` does not accept NaN (presumably because under the hood `.literal` uses `===`)

I saw somebody in #512 mention `z.nan()` but this does not seem to exist (yet?)

My current workaround:
```ts
export const numberWithNaN = z.custom<number>(
    (val) => typeof val === 'number',
    (val) => ({ message: `Expected number (including NaN), received ${inspect(val)}` }),
);
```

Proposal: add `z.nan()`, or make `z.literal` use `Object.is` for equality under the hood.",,
1114033455,884,Type Error when used any() and ZodSchema,"## What

I wrote some code like below

```typescript
type A = {
  foo: any;
};

function AParser(): z.ZodSchema<A> {
  return z.object({
    foo: z.any()
  });
}
```

## Actual

```
Type 'ZodObject<{ foo: ZodAny; }, ""strip"", ZodTypeAny, { foo?: any; }, { foo?: any; }>' is not assignable to type 'ZodType<A, ZodTypeDef, A>'.
  Types of property '_type' are incompatible.
    Type '{ foo?: any; }' is not assignable to type 'A'.
      Property 'foo' is optional in type '{ foo?: any; }' but required in type 'A'.
```

## Expected

compilable (no type error)

I understand this is not compilable if I wrote like below

```typescript
type A = {
  foo: any;
};

function AParser(): z.ZodSchema<A> {
  return z.object({
    foo: z.any().optional()
  });
}
```

## Reproduce

https://codesandbox.io/s/zod-example-forked-8qnnq?file=/src/index.ts",,
1113451012,882,Discriminated unions execute parsing in all union sub-objects,"I'm not sure if this works as designed or not - I would expect a different behaviour though.
Consider the following [snippet](https://codesandbox.io/s/holy-violet-funks?file=/src/index.ts):
```ts
import * as zod from ""zod"";

const schema = zod.union([
  zod.object({
    flag: zod.literal(true),
    value: zod.string().min(1),
  }),
  zod.object({
    flag: zod.literal(false),
  }),
]);

console.log(
  schema.safeParse({
    flag: false,
    get value(): string {
      throw Error(`Should it get here?`);
    }
  })
);
```

This code throws an exception when executed. The model is valid if I remove the exception. However, the first part of the union shouldn't be run when the discriminator is `false`, should it?",,
1112182514,878,Schema with either `strip()` or `passthrough()` throwing on unrecognized keys.,"Interestingly I have just started getting a weird scenario where `z.object({}).strip()` and `z.object({}).passthrough()` are both throwing errors on any unexpected keys.

This is causing a massive error stack when I try to parse `process.env` with the message:

```
""Expected never, received string""
```

```typescript

// A handful of similar passthrough schemas...
const RedisEnvSchema = z
  .object({
    REDIS_HOST: z.string().default(""queue.undetect.io""),
    REDIS_PORT: t.numberString().default(6379),
    REDIS_PASSWORD: z.string().optional()
  })
  .passthrough()

// Final strip schema...
export const EnvSchema = z.object({
  NODE_ENV: z.enum([""development"", ""test"", ""production""])
})
.merge(RedisEnvSchema)
.strip()


// Parse function...
export const parse = <Output, Input = Output>(
  packageName: string,
  schema: ZodSchema<Output, ZodObjectDef, Input>,
  defaultValues: Partial<Output> = {}
): Output => {
  try {
    return schema.parse({ ...defaultValues, ...process.env })
  } catch (error) {
    throw new EnvSchemaParseError(packageName, error)
  }
}


```",,
1108374917,871,"'constructor' key is ignored with strict(), passthrough()","This code doesn't throw:
```typescript
const person = z
  .object({
    name: z.string(),
  })
  .strict();

person.parse({
  name: ""bob dylan"",
  constructor: 61,
});
```

With other names, it throws. It is expected to throw with any property name.

It is also not being passed through (`.passthrough()`), so it's hard to prove that the library code actually receives such a property. But I think it does, since this is working:

```typescript
console.log(
  JSON.stringify({
    name: ""bob dylan"",
    constructor: 61,
  })
);

// outputs {""name"":""bob dylan"",""constructor"":61}
```",,
1108313995,869,Support composable schema with refinements,"Hi, 

Thanks for the work on this library, it's great and I'm looking to bring it into our development tool chain. I had a quick question about using `refine`. I'd like to compose validation together, preferably through spreading (in or order help TS). For example:

```ts
const dateRange =  z.object({
        min: z.date(),
        max: z.date()
    })
    // Useful validation that I'd like to keep alongside the schema definition
    // so whenever I use ""dateRange"" this validation will always be included
    .refine(({ min, max }) => min < max);

// Compose up one schema
const params = def.object({
    id: z.string(),
    ...dateRange // or ...dateRange.shape etc.
});

// Compose up another schema
const params2 = def.object({
    name: z.string(),
    ...dateRange.shape
});
```

I understand that refine returns `ZodEffect` which[ doesn't have the shape property](https://github.com/colinhacks/zod/issues/830#issuecomment-998850309), although I don't quite understand how refine potentially alters input / output, I thought it was additional validation only?

Perhaps `.merge` offers an alternative route. However using TypeScript I was unable to use `.merge` to enforce the required keys (see [this approach](https://github.com/colinhacks/zod/issues/858#issuecomment-1016632896) to how I'm enforcing types). 

I just wondered if there were any other suggestions I could try?

Thanks in advance",,
1106494513,861,ZodSchema not strictly parsing union types,"I was trying to infer a ZodType from a well-defined typescript type:  e.g.

```ts
type Temp = {
 a?: string | null;
}
```

The following ZodType definition is considered as a valid ZodSchema type.

```ts
const guard: ZodSchema<Temp> = z.object({
 a: z.string();
})
```

What I am expected is it should throw an error like `ZodString` type is not assignable to `ZodOptional<ZodNullable<ZodString>>`

only 

```ts
const guard: ZodSchema<Temp> = z.object({
 a: z.string().nullable().optional();
})
```
Is strictly allowed.

Wondering whether this is by design or not?

Thanks~
",,
1104986186,858,ZodObject not inferred when using ZodSchema,"I'm trying to extend a `ZodObject` schema which is bound to an existing interface with `ZodSchema`, however the schema is detected as `ZodType` which does not have the `extend()` method.

Is there some way to specify that the `ZodSchema` is specifically a `ZodObject`?

```typescript

const ActiveServiceModel: ZodSchema<ActiveService> = z.object({
  service_id: z.string(),
  team_id: z.string().uuid()
})

// This fails:
const ExtendedActiveServiceModel = ActiveServiceModel.extend({
  bar: z.string()
})

```

### Error Detail

```
TS2339: Property 'extend' does not exist on type 'ZodType '.
(ActiveServiceModel: z.ZodType<ActiveService, z.ZodTypeDef, ActiveService>)
```",,
1104904759,857,Object returning all properties as optional,"### Example Code

```typescript
export interface ActiveService {
  service_id: string
  team_id: string
}

export const ActiveServiceModel: ZodSchema<ActiveService> = z.object({
  service_id: z.string(),
  team_id: z.string().uuid()
})
```

### Error details

```
TS2322: Type 'ZodObject<{ service_id: ZodString; team_id: ZodString; }, ""strip"", ZodTypeAny, { service_id?: string; team_id?: string; }, { service_id?: string; team_id?: string; }>' is not assignable to type 'ZodType<ActiveService, ZodTypeDef, ActiveService>'.   

Types of property '_type' are incompatible.     

Type '{ service_id?: string; team_id?: string; }' is not assignable to type 'ActiveService'.       

Property ''team_id'' is optional in type '{ service_id?: string; team_id?: string; }' but required in type 'ActiveService'.

```

The same issue occurs when using `z.lazy(() => `.

It seems as though the for some reason the type inferred from `z.object()` assumes all optional properties. Is the the expected behaviour or is there change to the definition I need to make?



Additionally, it doesn't appear that `.shape` is available when binding a Zod Schema to an existing interface?
The following code works fine when not setting the type on the schema but begins to error when explicitly setting `ZodSchema<Foo>` 
```typescript
export const activeServiceColumns = Object.keys(
  ActiveServiceModel.shape
)

```

```
TS2339: Property 'shape' does not exist on type 'ZodType '.
```",,
1104693687,855,Helper type to infer errors from flattened `safeParse` error result.,"When using `flatten()` on error the result from `safeParse()`, it doesn't currently return type-safe `fieldErrors`, as it is typed with index signatures.

The idea is to provide an additional helper type similar to `z.infer`, but which provides a type-safe flattened error result type.

My current solution looks like this:

```ts
type inferSafeParseErrors<T extends z.ZodType<any, any, any>, U = string> = {
  formErrors: U[];
  fieldErrors: {
    [P in keyof z.infer<T>]?: U[];
  };
};
```

The name of the type is subject to change.

A use case for this is when doing form validation, where you want to have type safety and autocompletion around error types from validated fields. [See an example of this with form validation in Remix](https://gist.github.com/fnky/7fe414b402baf5c9ba8f7ddecfdd263e).",,
1100955590,852,Possible to extend or merge across a union? ,"Is it possible to extend or merge across a zod union? 

The use case I have here is that I have a polymorphic type which I store in a JSON field in my DB where I want to:
(a) represent the input I get which does not have an id on it
(b) represent what I get from the database, which now has an id on it

I've provided an example below - I tried a few other attempts without any luck. Please let me know if there's a way to do this - thank you!

```
// example:

const TestThing1 = z.object({
  type: z.literal('thing1'),
  // ... other properties not shared 
});
const TestThing2 = z.object({
  type: z.literal('thing2'),
  // ... other properties not shared 
});
const TestThing3 = z.object({
  type: z.literal('thing3'),
  // ... other properties not shared 
});

const ThingInput = z.union([TestThing1, TestThing2, TestThing3]);

const BaseThing = z.object({
  id: z.string().uuid(),
});
// I want to do something like this, but I get an error (see below)
const Thing = z.union([TestThing1, TestThing2, TestThing3].map(BaseThing.merge));

// Error 
Argument of type 'ZodObject<extendShape<{ id: ZodString; }, { type: ZodLiteral<""thing1"">; } | { type: ZodLiteral<""thing2"">; } | { type: ZodLiteral<""thing3"">; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>[]' is not assignable to parameter of type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
  Source provides no match for required element at position 0 in target.ts(2345)
```
",,
1097172493,849,Parse in Date Object but  zod _.date() gives error,"I created a schema to validate a Date object
```
import {date, object} from ""zod""

const createFigureSchema = object({
  bornDate: date({
    required_error: `bornDate is required`,
  }).nullable(),
)};
```
However, when I make a POST request with request body below:
```
const createFigurePayload = {
  bornDate: new Date(""1925-07-11""),
}
```
It gives an error: `Expected Date, given string`

I tried to confirm the type of `bornDate` with `console.log(createFigurePayload.bornDate instanceof Date);`. It returns `true`. 

Need someone's help to explain why `_.date()` gives error despite parsing Date object!",,
1097107307,848,Ordered chaining for `.default()` values,"Hi, is it possible to have an ordered default value chain on a field with zod?

For now, I have only tried doing it this way, but it doesn't seem to work:
```ts
import env from ""env-var""

const schema = z.object({
    port: z.number()
        .default(env.get(""PORT"").asPortNumber()!)
        .default(env.get(""CONFIG.PORT"").asPortNumber()!)
        .default(4444)
})
```

Basically what I want to do here, is to assign 3 default values in an ordered way. So for example, if the `PORT` variable is `undefined | null` zod will try to default to `CONFIG.PORT`, if that's `undefined | null` too, the value default to `4444`.
```
[original field = undefined] --Try defaults--> undefined -> undefined -> 4444 (default)
```

If there's no default value at the end of the chain and the value from the previous matcher is `undefined | null` zod would throw an error.
```
[original field = undefined] --Try defaults--> undefined -> undefined -> ERROR (no default values)
```

Can this be achieved with zod?

Thanks!",,
1095465528,846,Help Needed: Hard time understanding Discriminated Union,"I'm having a hard time understanding how discriminated union work.

I have this schema bellow and I have a couple of conditions:
One is for the `workStatus` this is required. The user has 3 options, ""Full Time"", ""Contract"" and ""Both""
Now based on what the user selects we must display the appropriate fields
=> User selects ""Full Time"" then we need to request for `fullTimeCompensation` and `contractCompensation` should be undefined
=> User selects 'Contract"" then we need to request for 'contractCompensation` and `fullTimeCompensation` should be undefined
=> User selects 'Both"" then we need to request for `fullTimeCompensation` and 'contractCompensation`

The other condition is `workLocationType`, this is a required field and the user has two options, either ""Remote"" or ""Flexible""
If the user selects ""Flexible"" we need to as for field `acceptableTravelTime`, if user selects ""Remote"" then `acceptableTravelTime` should be undefined.

This is how I've defined my schemas

```ts  
  const workStatusEnumSchema = z.nativeEnum(Work_Status_Types_Enum, {
    errorMap: () => ({ message: formValidationMessages.format('fieldRequired') }),
  })
  const workLocationEnumSchema = z.nativeEnum(Work_Location_Types_Enum, {
    errorMap: (issue, _ctx) => {
      console.warn('issue', issue)
      console.warn('context', _ctx)
      return { message: formValidationMessages.format('fieldRequired') }
    },
  })
  const workVacationEnumSchema = z.nativeEnum(Work_Vacation_Durations_Enum, {
    errorMap: () => ({ message: formValidationMessages.format('fieldRequired') }),
  })
  const baseSchema = z.object({
    workStatus: workStatusEnumSchema,
    workLocationType: workLocationEnumSchema,
    vacationDuration: workVacationEnumSchema,
    address: z.string(),
    latitude: z.number(),
    longitude: z.number(),
    drivingToWork: z.boolean(),
    occasionallyTravelOffice: z.boolean(),
    relocateForWork: z.boolean(),
    visaSponsorShip: z.array(visaSponsorshipSchema),
    spokenLanguages: z.array(optionSchema),
  })

  const fullTimeSchema = baseSchema.extend({
    workStatus: z.literal(Work_Status_Types_Enum.FullTime),
    fullTimeCompensation: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
    contractCompensation: z.undefined(),
  })

  const contractSchema = baseSchema.extend({
    workStatus: z.literal(Work_Status_Types_Enum.Contract),
    contractCompensation: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
    fullTimeCompensation: z.undefined(),
  })

  const fullTimeContractSchema = baseSchema.extend({
    workStatus: z.literal(Work_Status_Types_Enum.FullTimeOrContract),
    contractCompensation: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
    fullTimeCompensation: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
  })

  const workStatusSchema = z.union([fullTimeSchema, contractSchema, fullTimeContractSchema])

  const flexibleSchema = baseSchema.extend({
    workLocationType: z.literal(Work_Location_Types_Enum.Flexible),
    acceptableTravelTime: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
  })

  const remoteSchema = baseSchema.extend({
    workLocationType: z.literal(Work_Location_Types_Enum.Remote),
    acceptableTravelTime: z.undefined(),
  })

  const workLocationSchema = z.union([flexibleSchema, remoteSchema])

  const schema = z.union([baseSchema, workLocationSchema, workStatusSchema])

  type FormData = z.infer<typeof schema>
```

```ts
const methods = useForm<FormData>({
    mode: 'onBlur',
    reValidateMode: 'onBlur',
    defaultValues: {
      vacationDuration: '' as Work_Vacation_Durations_Enum,
      workLocationType: '' as Work_Location_Types_Enum,
      workStatus: '' as Work_Status_Types_Enum,
      address: '',
      drivingToWork: false,
      occasionallyTravelOffice: false,
      relocateForWork: false,
      visaSponsorShip: [],
      spokenLanguages: [
        buildSpokenLanguageOption(router.locale as string, spokenLanguagesMessages),
      ],
    },
    resolver: zodResolver(schema),
  })
```

At this point I have no errors in the schema nor in the default values.
However, in my `onSubmit` function which is defined as follow:
```ts
const onSubmit = async ({
    vacationDuration,
    workLocationType,
    workStatus,
    fullTimeCompensation,
    contractCompensation,
    acceptableTravelTime,
    address,
    latitude,
    longitude,
    drivingToWork,
    relocateForWork,
    visaSponsorShip,
    occasionallyTravelOffice,
    spokenLanguages,
  }: FormData): Promise<void> => {
    ...
}
```
But this clearly doesn't work. If a user selects 'Full Time"" then I get an error ""Expeted 'CONTRACT', received 'FULL_TIME'"", and in `fullTimeCompensation` if the user enters a value he get's an error ""Expected undefined, received 'string'"". Same thing if the user selects 'CONTRACT' and same behaviour for `workLocationType` if user selects something else other than ""REMOTE"" he will get the same error.

I'm not sure how  to create the schema for my use case :(

Any help would be greatly appreciated.",,
1093764878,844,CommonJS vs ESModules deployment issues : uglification,"# Remove uglification for `index.mjs`

## Problem

If we look into the `zod` dist in `node_modules` after installation, the files `node_modules/zod/index.js` and `node_modules/zod/index.mjs` should be very similar.

The esm module, however, has been minified and uglified. This caused an issue with my plugin (which I was able to make a workaround). But more importantly, it seems that we should reserve uglification and tree-shaking to the final build of the app, not as a npm module. 

## Solution

Just do the same as the regular `index.js` and don't minify and uglify.

I think it is as easy as removing this line:
https://github.com/colinhacks/zod/blob/73a9a628e8e3f512908b5f2b4116a87197f43407/rollup.config.js#L20


",,
1091952173,843,How to represent a React Componenet in Zod?,"Essentially I'm defining some types and I have no clue how to tell Zod that I want something to be a ReactNode, Element, ReactChild, etc. Any idea on how to do this?

ex.

```
const higherOrderComponent = z.object({
      childComponent: ????,
})
type HigherOrderComponent = z.infer<typeof higherOrderComponent>
```",,
1091666368,842,Missing documentation for `.required()`,"It seems like `.required()` is not documented but implemented, see https://github.com/colinhacks/zod/blob/db8adf289925321068e9d05210951569a18c3fe1/deno/lib/__tests__/partials.test.ts#L144",,
1083837294,831,Mapping readonly array to Zod union  ,"Hi and thanks for Zod. It's been a joy to use. 

Being able to use the following would be even nicer, but it fails for a variety of hard-to-fix reasons...

```typescript
const items = [""a"",""b"",""c""] as const;
const unionSchema = z.union((items.map((item) => z.literal(item)));
```

I often use an `as const` array or object to simultaneously define types (guiding the compiler) AND sequences (used at runtime). 

For example in the toy case below, the `PRIORITIES` list defines the type of a `Priority` string, and can also be iterated to construct a dropdown menu for example. This is a common emerging pattern in typescript codebases. It can ensure that variants are defined once, and that none are missed in mapped types either at compile-time or runtime.

Defining a zod schema from an `as const` array hits a dead end for me. Perhaps it's impossible. Perhaps I am missing how to do this properly. If it's this hard, some kind of utility type could be needed.

# Problems

There are an interlocking set of problems...
* Zod not accepting `Readonly` definitions meaning the use of `as const` causes arguments to be rejected.
* the required arity of a union (at least two) meaning arrays of unknown length are not accepted - normally resolved by using readonly arrays with a known length
* a [weakness of typescript](https://github.com/microsoft/TypeScript/issues/44309), which can't keep the tuple nature when using e.g. map() 

# Solution: Utility Function

If a utility function was provided, I imagine overloaded signatures as follows...

```typescript
type ZodLiteralTuple<T extends readonly Primitive[]> = {
  readonly [K in keyof T]: ZodLiteral<T[K]>;
};

function createUnionSchema<T extends readonly []>(values: T): ZodNever;
function createUnionSchema<T extends readonly [Primitive]>(
  values: T
): ZodLiteral<T[0]>;
function createUnionSchema<
  T extends readonly [Primitive, Primitive, ...Primitive[]]
>(values: T): z.ZodUnion<ZodLiteralTuple<T>>;
```

Here, ZodLiteralTuple is a type to use as a type assertion after `Array.map`. It preserves tuple arity and projects each concrete literal found in T into a corresponding ZodUnionOptions datastructure. 

![image](https://user-images.githubusercontent.com/159819/146686024-e853dbc6-be11-4426-8f1b-6577b4ec9fcf.png)

## CASES 

* `createUnionSchema([])` should resolve to `z.never()`
* `createUnionSchema([""single""])` should return `z.literal(""single"")`
* `createUnionSchema([""first"",""second""])` should return `z.union([z.literal(""first""), z.literal(""second"")])`
* `createUnionSchema([""first"",""second"",""third""])` should return `z.union([z.literal(""first""), z.literal(""second""), , z.literal(""third"")])`

# Solution: Adding Readonly

Allowing the Readonly signature for arrays passed into all Zod functions would address one element of the issue. I can raise this as a PR.

# Reference Example

The toy example below is based on an experimental todo example. Here, keys for an index are a tuple,: task priority first, task due date second. Endpoint arguments will eventually need to validate the keys passed when paging the index, so we would like to have a schema for priority (a union of priorities), and compose it with a schema for date.

Each attempt hits some limitation, shown as a compiler error.

# FIRST ATTEMPT - DERIVE FROM as const TUPLE OF STRINGS

Here, because of a weakness preserving tuple nature, PRIORITY_SCHEMAS has an unknown length, so fails the union arity check.

```typescript
import { z } from ""zod"";

type Priority = typeof PRIORITIES[number];

const PRIORITIES = [""urgent"", ""soon"", ""normal"", ""backlog"", ""wishlist""] as const;

const DATE_SCHEMA = z.number();

/** Compiler error due to arity:
Argument of type 'ZodLiteral<""urgent"" | ""soon"" | ""normal"" | ""backlog"" | ""wishlist"">[]' is not assignable to parameter of type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
*/
const PRIORITY_SCHEMAS = z.union(PRIORITIES.map((priority) => z.literal(priority)))

const KEY_SCHEMA = z.tuple([PRIORITY_SCHEMAS, DATE_SCHEMA])
```

# SECOND ATTEMPT - DERIVE FROM  TUPLE OF SCHEMAS

Here, because of `z.union()` only accepting writeable arrays, it rejects a tuple defined with as const (`as const` ensures its length is known).

```typescript
import { z } from ""zod"";

type Priority = typeof PRIORITIES[number];

const PRIORITY_SCHEMAS = [
  z.literal(""urgent""),
  z.literal(""soon""),
  z.literal(""normal""),
  z.literal(""backlog""),
  z.literal(""wishlist""),
] as const;

const PRIORITIES = PRIORITY_SCHEMAS.map((schema) => schema.value);

const DATE_SCHEMA = z.number();

/** Compiler error:  The type 'readonly [ZodLiteral<""urgent"">, ZodLiteral<""soon"">, ZodLiteral<""normal"">, ZodLiteral<""backlog"">, ZodLiteral<""wishlist"">]' is 'readonly' and cannot be assigned to the mutable type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]' */
const PRIORITY_SCHEMA = z.union(PRIORITY_SCHEMAS);

const KEY_SCHEMA = z.tuple([PRIORITY_SCHEMA, DATE_SCHEMA]);
```

",,
1081997732,829,Missing `.exclude()` with functionality of `Exclude<>` in TS,"Hey, first of all thanks so much for the package!

As the title suggests I'm searching for a way to replicate the `Exclude<Type, ExcludedUnion>` functionality provided by TS ([docs](https://www.typescriptlang.org/docs/handbook/utility-types.html#excludetype-excludedunion)) using `zod`. I searched for ""exclude"" in issues and prs, but didn't find a single mention of this utility type (outside of internals), therefore I'm opening this issue.

My use case involves unions of many smaller action types, e.g.:
`type Actions = { type: ""added"", ... } | { type: ""removed"", ... } | { type: ""changed"", ... } | ... ;`
(or rather an equivalent `const Actions = z.union([ ... ]);` on which I'm using `z.infer`)

I need to retroactively exclude only a few specific actions from the main `Actions` type.

Using only TS, I can add a discriminator key such as `notA: true` to those few actions and then define:
`type ActionsOnlyA = Exclude<Actions, Actions & { notA: true }>;`

Using zod, I have to add a discriminator such as `isA: true` to a lot more actions to then use:
`const ActionsOnlyA = Actions.and(z.object({ isA: z.literal(true) }));`
(I still favor this over passing additional schemas for `ActionsOnlyA` from the definitions up to the root of the project due to the amount of code.)

Maybe I'm also missing an obvious way on how to get this behavior using the existing functionality... Any advice or comment is highly appreciated :)
",,
1081977076,828,Failed to parse source map,"Using zod: 3.11.6

We are having warning in `index.mjs`
```
WARNING in ./node_modules/zod/lib/index.mjs
Module Warning (from ./node_modules/source-map-loader/dist/cjs.js):
Failed to parse source map from 'C:\repos\Git\WorkZone\WZ-Teams\Source\tabs\node_modules\zod\src\types.ts' file: Error: ENOENT: no such file or directory, open 'C:\repos\Git\WorkZone\WZ-Teams\Source\tabs\node_modules\zod\src\types.ts'
```

apparently the referenced `src\types.ts` is not shipped with package, leading to such error.",,
1073793219,817,Using union on array containing spreaded arrays,"Hello,
I'm trying to use z.union together with multiple arrays that would let's say come from different files.

Below is the example of my code, variable names are just for the purpose of the example.

```ts
import { z } from 'zod';

const array1 = [
  z.object({
    type: z.literal('TEST_1'),
  }),
];

const array2 = [
  z.object({
    type: z.literal('SOME_OTHER_ACTION'),
    payload: z.object({
      myNumber: z.number(),
    })
  }),
  z.object({
    type: z.literal('NOTHING'),
    payload: z.object({
      otherNumber: z.number(),
    })
  }),
  z.object({
    type: z.literal('HELLO'),
    payload: z.object({
      firstNumber: z.number(),
      secondNumber: z.number(),
    })
  }),
];

/*
  The below results in error (replaced ZodObject with ...):
  Argument of type '...' is not assignable to parameter of type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
  Property '0' is optional in type '...' but required in type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.ts(2345)
*/
const wsMessagesParser = z.union([
  ...array1,
  ...array2,
]);
```

I guess this is to force users to provide at least 2 ZodTypeAny.
So for example doing something like this fixes the error mentioned above (or just anything that matches ZodTypeAny):
```ts
const wsMessagesParser = z.union([
  z.object({
    type: z.literal('DUMMY_1'),
  }),
  z.object({
    type: z.literal('DUMMY_2'),
  }),
  ...basicActionsPartial,
  ...inGameActionsPartial,
]);
```

Does anyone maybe have some proper way around this without the need of requiring those 2 dummies?",,
1070264330,810,mergeArray in parseUtils can crash if array has empty elements,"Repro with Zod 3.11.6:-
```
import { z } from ""zod"";

console.log(""Checking schema"");
const ZSchema = z.object({
  nos: z.number().nullable().array().optional().nullable()
});

const nos = [];
nos[1] = 10;
const res = ZSchema.safeParse({
  nos
});
```

Error:-
```
TypeError: Cannot read properties of undefined (reading 'status')
    at Function.ParseStatus.mergeArray (https://yb77t.csb.app/node_modules/zod/lib/helpers/parseUtil.js:221:23)

    at ZodArray._parse (https://yb77t.csb.app/node_modules/zod/lib/types.js:1046:40)

    at ZodOptional._parse (https://yb77t.csb.app/node_modules/zod/lib/types.js:2418:36)

    at ZodNullable._parse (https://yb77t.csb.app/node_modules/zod/lib/types.js:2443:36)

    at ZodObject._parse (https://yb77t.csb.app/node_modules/zod/lib/types.js:1158:41)

    at ZodObject.ZodType._parseSync (https://yb77t.csb.app/node_modules/zod/lib/types.js:161:27)

    at ZodObject.ZodType.safeParse (https://yb77t.csb.app/node_modules/zod/lib/types.js:190:27)

    at $csb$eval (https://yb77t.csb.app/src/index.ts:15:19)

    at H (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:99995)

    at K.evaluate (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:112619)

    at ge.evaluateTranspiledModule (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:122966)

    at c (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:112234)

    at loadResources (https://yb77t.csb.app/index.html:3:2)

    at $csb$eval (https://yb77t.csb.app/index.html:9:3)

    at H (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:99995)

    at K.evaluate (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:112619)

    at ge.evaluateTranspiledModule (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:122966)

    at ge.evaluateModule (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:122465)

    at https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:314166

    at c (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:3629)

    at Generator._invoke (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:3382)

    at Generator.forEach.t.<computed> [as next] (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:3986)

    at r (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:206)

    at u (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:417)
```


mergeArray in parseUtils:-
![image](https://user-images.githubusercontent.com/54072321/144555986-f9dede2c-d6ed-4e99-88c3-5073d5d9081a.png)

Code sandbox screenshot:-
![image](https://user-images.githubusercontent.com/54072321/144559110-a9b3c82a-7f34-47ca-8562-a05bc44af5d3.png)
",,
1070000025,808,Point-free `.parse` not possible since v3.9.0 – a feature or a bug?,"Hi! 

Zod is an awesome project. And for a while I had code looking like this when parsing data from API endpoints:

```ts
import { z } from ""zod"";

type User = z.infer<typeof User>;
const User = z.object({
  name: z.string()
});

function getUser(): Promise<User> {
  return getUserFromApi().then(User.parse);
}

getUser()
  .then(
    // Use User
  )
  .catch(
    // Handle parsing error
  );
```

This is just a simplified example, but the idea is that `User.parse` is called by `.then` to parse whatever data is coming from the Promise. If `User.parse` throws an error, the whole thing results in a rejected Promise. Nice and simple and without the need to write `.then(user => User.parse(user))`.

However, since the release of v3.9.0, `.parse` cannot be used in a point-free way. An error is thrown inside Zod:

```
TypeError: Cannot read properties of undefined (reading 'safeParse')
```

Now, I want to ask if this behaviour is intentional or if it's a bug?

Disclaimers:
- I know that many people discourage point-free programming in JavaScript. It can be problematic, as the error above demonstrates, but I still happen to use the technique when I find that it simplifies my code.
- It's absolutely fine with me if this is not considered a bug. It's a small thing, and I'll keep using Zod even if I can't use `.parse` in a point-free way. I just wanted to make sure that I reported my findings.

I created a CodeSandbox that shows running code in v3.8.2, but if you change the version to v3.9.0 under ""Dependencies"", the example breaks: https://codesandbox.io/s/point-free-zod-parse-473q1?file=/src/index.ts

<img width=""303"" alt=""Screen Shot 2021-12-02 at 22 23 08"" src=""https://user-images.githubusercontent.com/4602382/144505233-0c0597bb-adaf-4e3b-af32-7cbb07df2c26.png"">

Finally, thank you for Zod. It's truly awesome 🙏 ",,
1069740622,807,Optional field specific validations,"Im generating schema from api data in runtime for validating in Formik.
Is there any possibility to add for egzample **max** to z.number only if it is not null on my config object?
I have no idea how to achive this.

My config object interface

```ts
interface ISurveyQuestion {
    questionId: number;
    title: string;
    subtitle: string | null;
    placeholder: string | null;
    description: string | null;
    imgUrl: string | null;
    hint: string | null;
    unit: string | null;
    inputType: ""number"" | ""checkbox"" | ""radio"" | ""select"" | ""date"";
    min: number | null;
    max: number | null;
    options: [ISurveyOption] | null;
}
```",,
1068488507,805,Missing `types` field to `exports` in package.json,"`exports` field in package.json should look like this:
```JSON
""exports"": {
    ""."": {
      ""require"": ""./lib/index.js"",
      ""import"": ""./lib/index.mjs"",
      ""types"": ""./lib/index.d.ts""
    },
    ""./package.json"": ""./package.json""
  }
```
Otherwise TypeScript (v4.6.0-dev.20211201) errors: `Could not find a declaration file for module 'zod'. 'REDACTED/node_modules/zod/lib/index.mjs' implicitly has an 'any' type.`. Apparently, TS ignores the root `types` field.

Could this be fixed?",,
1068412850,804,Consider adding `lenient()` option for string inputs,"I was in the process of migrating my existing [`yup`](https://github.com/jquense/yup) schemas to `zod` and found that the main sticking point is handling the parsing/validation of request path and query string parameters. Since they are typically considered raw strings and the parsing is left to the application level, `zod` doesn't really provide a great DX in these scenarios. Specially when compared to how `yup` does it out-of-the-box.

```js
// My existing `yup` schema
const schema = yup.object({ params: yup.object({ id: yup.number().required() }) })

// GET /user/42
// req -> { params: { id: '42' } }
schema.validateSync(req) // { params: { id: 42 } } -> Passes 
```

```js
// `zod` equivalent
const schema = z.object({ params: z.object({ id: z.number() }) })

// GET /user/42
// req -> { params: { id: '42' } }

schema.parse(req) // -> Fails

/*
Uncaught:
[
  {
    ""code"": ""invalid_type"",
    ""expected"": ""number"",
    ""received"": ""string"",
    ""path"": [
      ""params"",
      ""id""
    ],
    ""message"": ""Expected number, received string""
  }
]
*/
```

Which leads me to write custom `preprocess()` validators, along with custom error messages, for each expected type, every time. Here's an example for validating numerical strings.

```js
const DEFAULT_ZOD_NUMERICAL_PARAMS = Object.freeze({
  errorMap: (issue, _ctx) => {
    const message =
      issue.code === z.ZodIssueCode.invalid_type
        ? `Expected ${issue.expected}, received ${issue.received === 'string' ? `'${_ctx.data}'` : issue.received}`
        : _ctx.defaultError

    return { message }
  },
})

function numerical(params) {
  return z.preprocess(value => {
    const num = isNilOrEmpty(value) ? NaN : Number(value)
    return Number.isNaN(num) ? value : num
  }, z.number(params ?? DEFAULT_ZOD_NUMERICAL_PARAMS))
}

export default numerical
```

I know this has been [discussed before](https://github.com/colinhacks/zod/discussions/330#discussioncomment-656126), but having something close to a `.lenient()` parsing option, allowing for values to be internally coerced would be great.

```js
z.lenient(z.number()).parse('42') 
// 42
```

IMHO, this is such a common scenario when dealing with serialized data, that it only makes sense for a library such as this to support it without extra hassle. In addition, while the `.preprocess()` method above works, it **transfers the responsibility of the parsing to the user**,  which is arguably the main use case of `zod`. ",,
1066309337,798,partial() doesn't work,"I use `userUpdateSchema` to make all fields optional and pass undefined `password` field but keep getting `Should be at least 3 characters` for `password` field. The schemas are bellow:


```typescript
export const userLoginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(3).max(20), // I send undefined for this field
});

export const userRegisterSchema = userLoginSchema.extend({
  name: z.string().min(3).max(15),
  username: z.string().min(3).max(15),
});

export const userUpdateSchema = userRegisterSchema
  .extend({
    avatar: isBrowser() ? z.instanceof(FileList) : z.any(),
  })
  .omit({ email: true })
  .partial(); // make all fields optional

...

const Settings: React.FC<Props> = ({ user }) => {

  const { register, handleSubmit, formState, watch, getValues } = useForm({
    resolver: zodResolver(userUpdateSchema), // use this schema
    defaultValues: {
      username: user.username,
      name: user.name,
      avatar: user.image,
      password: undefined, // like this, just submit initial values
    },
  });
```",,
1066138046,797,Object properties are all optional by default,"`import * as Zod from ""zod"";`

`const Dog = Zod.object({`
`name: Zod.string(),`
`age: Zod.number(),`
`});`
`type Dog = Zod.infer<typeof Dog>;`


Copied this code straight from the docs. The type of ""Dog"" is { name?: string, age?: number }. In the docs it says it should be { name: string, age: number }",,
1064747523,792,What is a good strategy to get a nice (nicer) error for invalid discriminated unions,"First of all: thanks for creating `zod` it is an awesome library.

Consider the following schema (contrived examples of course), and test. When you run this the error message is really long and hard for humans to grok. Note the schema has a discriminated union (the field `type` on each object is the discriminating field):

```typescript
import { z } from ""zod"";

const typeA = z.object({
    type: z.literal(""A""),
    prop1: z.string() 
})

const typeB = z.object({
    type: z.literal(""B""),
    prop2: z.string() 
})

const typeC = z.object({
    type: z.literal(""C""),
    prop3: z.string() 
})

const typeD = z.object({
    type: z.literal(""D""),
    prop4: z.string() 
})

const schema = z.object({ mytypes: z.union([typeA, typeB, typeC, typeD]).array() });

schema.parse({
    mytypes: [ 
        { type: ""A"", prop1: ""foo"" },
        { type: ""D"", bar: ""BAR"" } // misses prop4
    ]
});

```

<details>
  <summary>The long and hard to read error message</summary>
  
```
ZodError: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""A"",
            ""received"": ""D"",
            ""path"": [
              ""mytypes"",
              1,
              ""type""
            ],
            ""message"": ""Expected A, received D""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop1""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""B"",
            ""received"": ""D"",
            ""path"": [
              ""mytypes"",
              1,
              ""type""
            ],
            ""message"": ""Expected B, received D""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop2""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""C"",
            ""received"": ""D"",
            ""path"": [
              ""mytypes"",
              1,
              ""type""
            ],
            ""message"": ""Expected C, received D""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop3""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop4""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [
      ""mytypes"",
      1
    ],
    ""message"": ""Invalid input""
  }
]
    at new ZodError (/private/tmp/zodtest/node_modules/zod/src/ZodError.ts:140:5)
    at handleResult (/private/tmp/zodtest/node_modules/zod/src/types.ts:72:19)
    at ZodObject.ZodType.safeParse (/private/tmp/zodtest/node_modules/zod/src/types.ts:184:12)
    at ZodObject.ZodType.parse (/private/tmp/zodtest/node_modules/zod/src/types.ts:162:25)
    at Object.<anonymous> (/private/tmp/zodtest/index.ts:25:8)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Module.m._compile (/private/tmp/zodtest/node_modules/ts-node/src/index.ts:1371:23)
    at Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Object.require.extensions.<computed> [as .ts] (/private/tmp/zodtest/node_modules/ts-node/src/index.ts:1374:12)
    at Module.load (node:internal/modules/cjs/loader:981:32) {
  issues: [
    {
      code: 'invalid_union',
      unionErrors: [Array],
      path: [Array],
      message: 'Invalid input'
    }
  ],
  format: [Function (anonymous)],
  addIssue: [Function (anonymous)],
  addIssues: [Function (anonymous)],
  flatten: [Function (anonymous)]
}
```
</details>

I've read [ERROR_HANDLING.md](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md) but I still struggle how to actually make a more proper error message (whithout a whole lot of ugly coding).

The error that I want to see is in the error message but hidden in the forest of other messages:

```
...
{
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop4""
            ],
            ""message"": ""Required""
 }
...
```

What is the best strategy to handle this? Any tips/pointer appreciated.

I'm on Zod 3.11.6. My actual use case, a CLI app that parses a DSL yaml, has even more possible types in the union, so the error message is really long and hard to read.",,
1064180886,790,inconsistent behavior with default and optional,"when default is used together with optional some things are allowed others not e.g:

```ts
declare function findConfig(): string | undefined;

string().optional().default(() => findConfig()) // is not allowed only ""string"" but..

declare function findConfigAsync(): Promise<string | undefined>;
string().promise().optional().default(() => findConfigAsync()) // is allowed because is wrapped into a ""Promise""
```

currently i have 3 scenarios
user provide the config
user doesn't provide the config, so i search and found one
user doesn't provide the config, so i search but i didn't find any

so even when i provide a default value this value could be undefined too (currently my workaround is using null)
```ts
declare function findConfig(): string | undefined;

string().nullable().default(() => findConfig() ?? null) // i can't change findConfig signature
```

i think default signature should allow undefined if the type allow it too",,
1063702300,788,Schema only validating `.refine` when `object` passes.,"I'm using zod together with [react-hook-form](https://github.com/react-hook-form/react-hook-form) to create a user signup form. The schema is as follows: 
I am unsure as to whether this issue goes in [react-hook-form/resolvers](https://github.com/react-hook-form/resolvers) or here, so I am asking for support in both repos.


```
const schema = z
.object({
  name: z.string().nonempty('message'),
  email: z.string().nonempty('message').email('message'),
  password: edukPassword({ nonEmpty: 'message' }),
  confirmPassword: z.string(),
  cellphone: brazilianCellphoneNumber().nonempty('message'),
  privacyTermsAccepted: z.literal(true, {invalid_type_error: 'message',}),
})
.refine(({ password, confirmPassword }) => password === confirmPassword, {
  message: 'Passwords must match',
  path: ['confirmPassword'],
})

export const registerFormResolver = zodResolver(registerFormSchema)
```

The problem is, I am only getting an error on `.refine` when `.object` has passed. This results in the user not knowing they have entered an incorrect password confirmation until **after** they filled out the whole form.

Have I incorrectly built the schema for this useCase, or is the resolver incorrectly returning me formErrors?",,
1063365974,787,ZodObject with explicit type has an optional value can not be infered correctly after `omit` haven been called in Typescript.,"## Situation
When I define a custom ZodObjectType with explicit type, I found that this object can't not be infered correctly after `omit` haven been called in Typescript.

## Sample
```ts
import { z, ZodObject, ZodType } from ""zod"";

export type Guard<T extends Record<string, unknown>> = ZodObject<
  {
    [key in keyof T]: ZodType<T[key]>;
  }
>;

type User = {
    id: string,
    username: string,
    detail: string,
}

function testUser() {
    const userGuard: Guard<User> = z.object({
        id: z.string(),
        username: z.string(),
        detail: z.string(),
    });

    const omitUserGuard = userGuard.omit({ id: true, detail: true });

    console.log(""Omit UserGuard Shape:"")
    console.log(omitUserGuard.shape);
    console.log(""----------------"")
    console.log()
    console.log()

    console.log(""Username from Omit UserGuard:"")
    const { username } = omitUserGuard.parse({ username: 'Alex' });
    console.log(username)
    console.log(""-----------------------"")
}

type UserWithOptionalDetail = {
    id: string,
    username: string,
    detail?: string,
}

function testUserWithOptionalDetailGuard() {
    const userWithOptionalDetailGuard: Guard<UserWithOptionalDetail> = z.object({
        id: z.string(),
        username: z.string(),
        detail: z.string().optional()
    });

    const omitUserGuardWithOptionalDetail = userWithOptionalDetailGuard.omit({ id: true, detail: true })

    console.log(""Omit UserWithOptionalDetailGuard Shape:"")
    console.log(omitUserGuardWithOptionalDetail.shape)
    console.log(""---------------------------------------"");
    
    console.log()
    console.log()

    // this line of code will cause a problem: Property 'username' does not exist on type '{}'.
    const { username } = omitUserGuardWithOptionalDetail.parse({ username: 'Alex' })

    console.log(""Username from Omit UserWithOptionalDetailGuard:"")
    console.log(username)
    console.log(""-----------------------------------------"")
}

testUser()

console.log()
console.log()

testUserWithOptionalDetailGuard()
```
Both guards of the `User` and `UserWithOptionalDetail` type are correctly in console. but we can not build the typescript successfully.
![image](https://user-images.githubusercontent.com/10806653/143418511-0afe50fa-423c-4d09-aec8-490269fffe31.png)

Error message:
![image](https://user-images.githubusercontent.com/10806653/143417940-01228259-b9dd-4357-aa91-71e69ab3748e.png)

## Sample Code
you can reproduce the error by the source code below:
[typescript-playground.zip](https://github.com/colinhacks/zod/files/7601890/typescript-playground.zip)
```bash
npm i
sh ./run.sh
```

",,
1063295672,786,How to programmatically define the schema?,"Defining schema in a functional way is a very nice approach when the form model is known `z.string().max(...)`
However, I have a dynamic model, meaning my form can be of any type, and I need to validate it appropriately.
This means that I need to define the type and all the modifiers dynamically.

This doesn't look practical to me.
```ts
z[type][modifier1][modifier2]....
```

What other ways are there to achieve this requirement?",,
1062953827,785,Guarantee on self-compatibility within minor versions?,"This issue is a bit nebulous; my apologies that I don't have anything specifically actionable to list here. Feel free to close if this sort of commentary is not welcome.

When a library exports zod schemas, sometimes the consumers of those libraries will extend those schemas in various ways. For example, consider the following:

```
import { z } as ""zod"";
import { DocumentSchema } from ""library"";

const CreateDocument = z.object({ data: DocumentSchema, publishNow: z.boolean() });
```

In this scenario, what version of zod is safe for the consumer to import? Naively, we would think that something that matches the same minor version would be sufficient--that is, if the library has zod `^3.11.2` then the consumer can as well. However, this is not the case. Consider that when library was published, `3.11.2` was the latest published version of zod. But today, `^3.11.2` resolves to `3.11.6`, and this code fails to compile (because `DocumentSchema` is missing properties `describe` and `description`).

There are a few solutions here.

1. Zod guarantees that the `.d.ts` files never change without a corresponding change in minor version. I think this is best, because it most closely matches semver. There may be additional considerations beyond the `.d.ts` files as well, I'm not totally sure.
2. Any package exporting a zod schema must provide a corresponding `peerDependencies` for zod. This is suboptimal, because consumers of the library who only want to use the schema (not extend it) are now required to manually list zod as a dependency.
3. Any package exporting a zod schema needs to pin a precise zod version and document that consumers extending the zod schema must use the identical zod version. This is suboptimal because it requires these consumers to read the documentation ahead of time, lest they encounter strange errors when they do the natural `yarn add zod` and attempt to use it.
4. ~~export zod from the library.~~ This is a non-solution because it requires that the library is the ""one true zod"", which means it doesn't play nicely with other libraries.

Apologies again for not having anything more substantial. Hopefully this issue sparks some useful discussion that can lead to a working solution.",,
1061950950,782,schema.safeParse doesn't seem to have the appropriate signature.,"`zod`: `v3.11.6`
`TypeScript`: `v4.4.4`

I'm using `zod` to validate the body of my request. I expect to receive an email in the body.

Looking at the docs, I've created this:
```ts
const emailSchema = z.object({
      email: z.string().email(),
    })

    const result = emailSchema.safeParse({ email })
    if (!result.success) {
      res.status(400).json({ error: result.error.issues[0].message })
      return
    }
```

And according with the signature of `safeParse`, 
```ts
export declare type SafeParseSuccess<Output> = {
    success: true;
    data: Output;
};
export declare type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
};
export declare type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;
```
So it either returns a `SafeParseSuccess<Output>` if it validates successfully or `SafeParseError<Input>` if it fails.

However, when I try to return the message in the response, TypeScript get's mad, even though it returns the message
![image](https://user-images.githubusercontent.com/8176422/143164701-99aaffab-0476-4a2c-bb51-7941d5c5ec27.png)

I'm not sure what `safeParse` is supposed to to return. 

Any clarifications would be appreciated.",,
1060117897,775,ZodObject.merge: pick & omit Mask only infers added properties,"Zod: 3.11.6 (issue same also in 3.9.8 from which I'v updated)

```ts
const A = z.object({
  b: z.boolean(),
  x: z.number()
})
const B = A.merge(
  z.object({
    y: z.number()
  })
)

// resulting type correctly inferred: {b: boolean; x: number; y: number}
type C = z.TypeOf<typeof C>
const C = B.omit({}) // Mask only infers ""y""

// resulting type correctly inferred: {b: boolean; x: number; y: number}
type D = z.TypeOf<typeof D>
const D = B.pick({}) // Mask only infers ""y""

type E = z.TypeOf<typeof E>
// resulting type correctly inferred: {b: boolean}
const E = B.pick({b: true}) // Mask only infers ""y""

type F = z.TypeOf<typeof F>
// resulting type correctly inferred: {x: number; y: number}
const F = B.omit({b: true}) // Mask only infers ""y""
```

There is no type error passing the `right` properties from `ZodObject` that was the merge source.

Might be an issue with the order of instantiation of generics. The result is correctly mapped over the props and fails when wrong properties are passed to mask.

I'd rate this minor issue though, since it kind of works, just worser completion in IDE.",,
1059176904,774,Optional key,"I'm working on a Zod schema for [Node package exports](https://nodejs.org/api/packages.html). Part of it looks like this:

```ts
export const ExportsCoreConditional = z.object({
  import: z.string().optional(),
  require: z.string().optional(),
  node: z.string().optional(),
  default: z.string().optional(),
})
```

The problem here is that the resulting type is e.g. `import?: string|undefined`. The actually correct type is `import?: string`. This is because a user will never be able to write `import: undefined` in their package.json file, since that is not valid JSON.",,
1054346134,765,[Express.Request] Trying to type a req.locals field,"Hi! How are you?

I am trying to type an express `request.locals` field without success by the moment. I can see the types when I hover on the element but Typescript is complaining me.
Here in the images you can see the typing is correct (or I think so), but the VS Code is complaining.

`// request.locals.project seems to be ok`

![image](https://user-images.githubusercontent.com/45211582/141880853-06e93658-1371-4c3c-9f55-4b9219dc4c44.png)

But TS is complaining:

![image](https://user-images.githubusercontent.com/45211582/141880893-e9ac7d20-07e7-4491-b8f3-f0acdd726645.png)

Here is an exact copy of my code at this moment
```javascript
import express, { Request, Response } from 'express';
import { ParamsDictionary } from 'express-serve-static-core';
import { z, ZodType, ZodTypeDef } from 'zod';

const router = express.Router();

export type TypedRequestLocals<TLocals extends ZodType<any, ZodTypeDef, any>> = Request<
	ParamsDictionary,
	any,
	any,
	any,
	z.infer<TLocals>
>;

const projectData = z.object({
	id: z.string(),
	name: z.string(),
	days: z.number().min(1),
});
const base = z.object({
	locals: z.object({ project: projectData }),
});

router.route('/base').get(async (request: TypedRequestLocals<typeof base>, response: Response) => {
	const { project } = request.locals;

	return response.json({ project });
});
```

What my main goal is? To be able to type a `request.locals` object where I will store data related to the request.

Any clue? Thank you!",,
1054335791,764,`description` not presented in the `ProcessedCreateParams`,"According to the type sig, I'm expecting to retrieve my description set in the `RawCreateParams` previously.

```typescript
import { z } from 'zod'

const foo = z.string({ description: 'Foo' })
console.log(foo.description) // undefined in console
```

Then I check the code and find out that the processing function seems to [have no way passing the description data out](
https://github.com/colinhacks/zod/blob/72fa277a34970e542565c6d5630e7f451ff1e343/src/types.ts?_pjax=%23js-repo-pjax-container%3Afirst-of-type%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%3Afirst-of-type%2C%20%5Bdata-pjax-container%5D%3Afirst-of-type#L86-L103).

Is this a bug or I just miss something? Since I'm not really familiar with the codebase, just want to be sure before a PR.
",,
1052782972,762,zod object schemas being treated as partial,"The following example is using zod@3.11.6

```js
import { z } from 'zod'

const schema = z.object({
  type: z.string()
})

const foo = schema.parse(12)
```

This might be a bug with vscode (Version: 1.62.2), but when I hover over `foo`, it shows me that `foo.type` is optional:
<img width=""622"" alt=""Screen Shot 2021-11-13 at 14 42 31"" src=""https://user-images.githubusercontent.com/1906967/141659975-12d6ff98-e0f6-4524-9099-4b5a533c3838.png"">

The typescript cli (running `tsc`) doesn't complain about anything. So it's probably just something with vscode itself, but I wondered if maybe you might have some insight as to why that might happen so I can open the appropriate issue on their repo.
 ",,
1051530975,759,"Conflict between .optional, .default and TypeScript types","My use case is where I'd like to input an empty object and have it filled with default values via `.default` - but when I have the code below:

```ts
import { z } from 'zod'

const schema = z.object({
  name: z.array(z.string()).default([])
})

type SchemaType = z.infer<typeof schema>

const input: SchemaType = {}  // TypeScript error here
const output = schema.parse(input)
console.log(output)
```
there is a typescript error:
```
Property 'name' is missing in type '{}' but required in type '{ name: string[]; }'.ts(2741)
```

So I added `.optional()` like so:

```ts
const schema = z.object({
  name: z.array(z.string()).default([]).optional()
})
```
but the output is the empty object and it seemingly ignores `.default`:
```
{}
```

How would I be able to accomplish my goal of assigning types of the input, while having the `.default` work as I intend it to? It works if I remove `:SchemaType` but I'd really prefer to have types assigned",,
1047591749,755,How to validate an enum inside a schema,"I'm using zod alongside react-hook-form and I need to validate when the user submits the form that the data matches my schema.

I have a plugin to generate GraphQL types, queries and mutation and it generates this enum
```
export enum Audience_Range_Enum {
  ElevenTwenty = 'ELEVEN_TWENTY',
  FiftyOneOneHundred = 'FIFTY_ONE_ONE_HUNDRED',
  None = 'NONE',
  OneHundredOnePlus = 'ONE_HUNDRED_ONE_PLUS',
  OneTen = 'ONE_TEN',
  TwentyOneFifty = 'TWENTY_ONE_FIFTY'
}
```
And when the user selects an option this is what he'll be passing. 

So I have this schema
```
const schema = z
  .object({
    teamLeadOf: z.string().optional(),
    coachOf: z.string().optional(),
  })
```

And instead of using `z.string()` I'd need to check if it's a value of `Audience_Range_Enum`. How can I check this in the schema? Is it possible?

I've checked the doc and the only examples with `z.enum()` or `z.nativeEnum()` are used outside of the schema.

Thank you",,
1046317045,751,Record types should be partial,"I love that in v3.9 we can now specify the type of the record key using enums or literals.

But the inferred `Record` type now needs to be wrapped in `Partial`, otherwise typescript forces us to specify every key, which is inconsistent with how the Zod parser interprets the same schema.

For example, suppose we create a schema that allows us to map states to temperatures:

```ts
const Weather = z.object({
    temperatures: z.record(z.enum(['VT', 'NH', 'CA', 'AZ']), z.enum(['warm', 'cold']))
});
```

If we map a couple of states, it parses fine. This parses without throwing:

```ts
Weather.parse({ temperatures: {VT: 'cold', CA: 'warm'} });
```

But if we try to use the inferred type with the same object, typescript is not happy:

```ts
type Weather = z.infer<typeof Weather>;
const weather: Weather = { temperatures: {VT: 'cold', CA: 'warm'} };
```

This gives us this error:

```ts
Type '{ VT: ""cold""; CA: ""warm""; }' is missing the following properties from type
'Record<""VT"" | ""NH"" | ""CA"" | ""AZ"", ""warm"" | ""cold"">': NH, AZ
types.d.ts(639, 124)
```

It wants us to specify all the states in the enum, which is not intuitive or useful, and is inconsistent with the Zod parser.",,
1041085597,741,bug: wrong inferred types when combining transform and refine,"# Description

The inferred types in `.refine()` callback match the inferred return type of previous `transform` (`Date`) but during runtime the raw untransformed value is passed to the `refine` callback

## Example 1:

```ts
const zoddate = () => z
        .string()
        .transform((s) => parseISO(s));
        .refine((d) => d.toString() !== 'Invalid Date', { // `d` has the inferred type `Date`, but is actually the raw string during runtime
            message: 'invalid date',
        })
```
## Workaround 1:

```ts
const zoddate = () => z
        .string()
        .refine((d) => parseISO(d).toString() !== 'Invalid Date', {
            message: 'Invalid date',
        })
        .transform((s) => parseISO(s));
```

## Example 2
```ts
export const QuerySchema = z
    .object({
        date_start: zoddate(),
        date_end: zoddate(),
    })
    .refine(({ date_start, date_end }) => {
        const start = startOfDay(date_start); // runtime error: `startOfDay` only accepts `Date` but during runtime the type is `string`
        const end = startOfDay(date_end); // runtime error: `startOfDay` only accepts `Date` but during runtime the type is `string`
        return isAfter(end, start);
    }, 'date_end must be after date_start')
```

## Workaround 2
```ts
export const QuerySchema = z
    .object({
        date_start: zoddate(),
        date_end: zoddate(),
    })
    .refine(({ date_start, date_end }) => {
        // workaround by typecasting as any
        const start = startOfDay(parseISO(date_start as any));
        const end = startOfDay(parseISO(date_end as any));
        return isAfter(end, start);
    }, 'date_end must be after date_start')
```

# Versions
zod ^3.10.0
typescript ^4.4.3
",,
1038415176,738,No exported member 'ParseParamsNoData',"Hi,

Currently I use Zod with React Hook Form as validation schema. However when building code for production usage, I got this error:

**tsc && vite build

node_modules/@hookform/resolvers/zod/dist/types.d.ts:3:100 - error TS2694: Namespace '""/home/node_modules/zod/lib/external""' has no exported member 'ParseParamsNoData'.

export declare type Resolver = <T extends z.Schema<any, any>>(schema: T, schemaOptions?: Partial<z.ParseParamsNoData>, factoryOptions?: {

Found 1 error.**


Zod version is 3.11.6
React-hook-form 7.17.2
@hookform/resolvers 2.8.2",,
1037109200,734,Successive `refine` behave differently since 3.10.3,"Hello,

Since 3.10.3, all successive `refine` are being called, even when they return false.
For instance:
```javascript
import { z } from ""zod"";

const schema = z
  .string()
  .refine((value) => {
    console.log(""refine1 value"", value);
    return false;
  })
  .refine((value) => {
    console.log(""refine2 value"", value);
    return true;
  })
  .refine((value) => {
    console.log(""refine3 value"", value);
    return true;
  });

console.log(schema.safeParse(""a"").success);
```

was displaying in 3.9.8:
```
refine1 value a
false
```

but since 3.10.3 is displaying:
```
refine1 value a
refine2 value a
refine3 value a
false
```",,
1035868785,731,safeParseAsync error type is not generic,"Apologies if this has been discussed before, I wasn't able to find any existing issues.

In the definition for `safeParse`, the error type is `ZodError<Input>`, whereas for `safeParseAsync`, the type is `ZodError`. Is there any reason that prevents it from returning the same type that `safeParse` does?

```typescript
safeParse: (data: unknown, params?: Partial<ParseParamsNoData>) => {
    success: true;
    data: Output;
} | {
    success: false;
    error: ZodError<Input>;
};
safeParseAsync: (x: unknown, params?: Partial<ParseParamsNoData>) => Promise<{
    success: true;
    data: Output;
} | {
    success: false;
    error: ZodError;
}>;
```",,
1035449960,729,"An optional field that becomes required if a ""type"" field matches it's value","Thank you so much for building a fantastic library, @colinhacks. I'm a huge fan!

I have a schema that looks like this:

```js
ActivitySchema = z.object({
  amount: z.number(),
  type: z.enum[""deposit"", ""withdrawal""],
  deposit: z.object({ ... }).optional(),
  withdrawal: z.object({ ... }).optional(),
})
```

I'd like the `deposit` key to become required if `type == deposit` , and for the `withdrawal` key to become required if `type == withdrawal`. 

I hoped `.refine` might do the trick, but it doesn't work as I expected — both keys become required to parse successfully:

```js
ActivitySchema = z.object({
  amount: z.number(),
  type: z.enum([""deposit"", ""withdrawal""]),
  deposit: z.object({}).refine((d) => d.type == ""deposit"" && (""deposit"" in d)),
  withdrawal: z.object({}).refine((d) => d.type == ""withdrawal"" && (""withdrawal"" in d)),
})
```",,
1034833098,728,Support for frozen/readonly,"I would like to have a way to declare an object with the following restrictions:
- All properties of the inferred type should be (recursively) `readonly`
- Parsing an object should (recursively) `freeze` it

```ts
import * as z from ""zod"";

export const Vector2 = z.frozenObject({
  x: z.number(),
  y: z.number(),
});

export type Vector2 = z.infer<typeof Vector2>;

const foo: Vector2 = { x: 1, y: 2 };

// the following should not be allowed by the compiler
foo.x = 42;

const bar = Vector2.parse('{ ""x"": 1, ""y"": 2 }');

// the following should not be allowed by the compiler and throw at runtime (because the object is frozen)
bar.x = 42;
```",,
1031542187,718,How to do t.Mixed and t.UnknownType from io-ts in Zod?,"Hi! I am migrating a codebase from io-ts to Zod (much better API!). I am having some trouble figuring out how to recreate this io-ts type signature in Zod:

```ts
const Request = {
  async make(
    returnType: t.Mixed | t.UnknownType,
    method: HttpMethod,
    ...
  )
  ...
}
```

I'm not sure which Zod methods to use. `z.any() | z.unknown()` seems to make TS really angry in a way that `t.Mixed` does not:

```
This expression is not callable.
  Type '{ make(returnType: any): any; }' has no call signatures.ts(2349)
```",,
1030257341,716,`preprocess` result seems to not get passed to `refine` calls starting from the second one,"The issue is relevant for v 3.10.1

When I have a schema with `preprocess` configuration + two `refine`s, the first refine gets the processed model, whereas the second one receives the original one:
```ts
import * as zod from ""zod"";

const schema = zod
  .object({
    failureReasons: zod.preprocess(
      (val) => [val],
      zod.array(zod.object({ isDescriptionRequired: zod.boolean() }))
    )
  })
  .refine(({ failureReasons }) => {
    console.log(JSON.stringify(failureReasons));
    return failureReasons.length > 0;
  })
  .refine(({ failureReasons }) => {
    console.log(JSON.stringify(failureReasons));
    return failureReasons.some((reason) => reason.isDescriptionRequired);
  });

console.log(
  schema.safeParse({
    failureReasons: { isDescriptionRequired: false }
  })
);

// Output:
// [{""isDescriptionRequired"":false}] 
// {""isDescriptionRequired"":false} 
// Error in sandbox: 
// TypeError: failureReasons.some is not a function
```
If I remove the first `refine`, the error disappears.
[Sandbox](https://codesandbox.io/s/crazy-water-2iqkl?file=/src/index.ts)",,
1030255178,715,[BUG] Type instantiation is excessively deep and possibly infinite on latest TypeScript 4.5,"There is a new issue that appeared in TypeScript 4.5.0-dev.20211001 and exists until now.

To reproduce the error:

```bash
npm init -y
npm add zod
npm add -D typescript@next
echo 'import { z } from ""zod"";' > main.ts
echo '{""compilerOptions"":{""lib"":[""es2020""]},""include"":[""main.ts""]}' > tsconfig.json
npx tsc -p .
```

TypeScript output:

```
node_modules/zod/lib/helpers/partialUtil.d.ts:4:29 - error TS2589: Type instantiation is excessively deep and possibly infinite.

4         [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>>;
                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Found 1 error.
```

It affects the latest Zod (3.10.1), and also any other 3.x version. The issue appeared in https://github.com/microsoft/TypeScript/pull/41821 (producing a memory error), and later a check was added in https://github.com/microsoft/TypeScript/pull/46326 to prevent the infinite loop and give a meaningful message.

This is the same issue as #689 except that now we have an error message.

Demo code: https://github.com/mmvsk/zod-issue-715",,
1029568789,714,Zod 3.10.x is broken on node 12,"Repro:

```bash
$ docker run -ti --rm --entrypoint sh node:12-slim -c ""npm i zod@3.10.1 && node -e \""require('zod').number().parse('5')\""""

...

/node_modules/zod/lib/types.js:82
            path: params?.path || [],
                         ^

SyntaxError: Unexpected token '.'
    at wrapSafe (internal/modules/cjs/loader.js:915:16)
    at Module._compile (internal/modules/cjs/loader.js:963:27)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10)
    at Module.load (internal/modules/cjs/loader.js:863:32)
```",,
1029126471,713,`refine` acts inconsistently in 3.10,"Upon 3.10 the following [example](https://codesandbox.io/s/cold-cdn-d2sou?file=/src/index.ts) gives a false positive result:
```ts
const objectSchema = zod
  .object({
    length: zod.number(),
    size: zod.number()
  })
  .refine(({ length }) => length > 5, {
    path: [""length""],
    message: ""length greater than 5""
  })
  .refine(({ size }) => size > 7, {
    path: [""size""],
    message: ""size greater than 7""
  });

console.log(
  objectSchema.safeParse({
    length: 4,
    size: 8
  })
);          // { success: true, ...
```
The first `refine` (for `length`) is being ignored.",,
1023508962,706,Infer'd Type's properties are optional,"Hi,

I am new to using this lib, so hopefully this is something simple that I have misunderstood. I am trying to extract an inferred type from an object, I am not declaring that any of the properties are optional, but the returned type suggests all the properties are optional (as if I was using the `Partial` utility).



![image](https://user-images.githubusercontent.com/8988409/136825402-916d8fa8-92a5-4b63-aefb-e61268cfbae3.png)
Above is what I see when I copy the example in the docs.

If it helps, my version of TS is `4.4.3` and my version of Zod is `3.9.8`
",,
1021959762,698,Custom invalid type message on ZodUnion is being ignored,"Hi,

I'm using Zod version 3.9.8 and have the following setup:

```typescript
const NumberOrNonEmptyString = z.union( [
    z.number(),
    z.string().nonempty()
], {
    invalid_type_error: 'A custom message'
} );

NumberOrNonEmptyString.parse( true );
```

The expected behavior is that it would output ``A custom message`` as my custom error message. But instead it outputs ``Invalid input``. Thus my custom ``invalid_type_error`` is being ignored.
This is the full error object:

```json
ZodError: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""number"",
            ""received"": ""boolean"",
            ""path"": [],
            ""message"": ""Expected number, received boolean""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""boolean"",
            ""path"": [],
            ""message"": ""Expected string, received boolean""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [],
    ""message"": ""Invalid input""
  }
]
```

```
    at new ZodError (node_modules\zod\src\ZodError.ts:141:5)
    at handleResult (node_modules\zod\src\types.ts:83:19)
    at ZodUnion.ZodType.safeParse (node_modules\zod\src\types.ts:182:12)
    at ZodUnion.ZodType.parse (node_modules\zod\src\types.ts:169:25)
```",,
1018412585,690,`.refine` is being short circuited since 3.9.6,"In our app we used to rely on the `.refine`s execution being chained, e.g.
```ts
const objectSchema = zod
  .object({
    length: zod.number(),
    size: zod.number(),
  })
  .refine(({ length }) => length > 5, { path: ['length'], message: ""length greater than 5"" })
  .refine(({ size }) => size > 7, { path: [""size""], message: ""size greater than 7"" });

console.log(
  objectSchema.and(objectSchema).safeParse({
    length: 4,
    size: 4,
  })
);
```
would yield two errors for both length and size. However, this behaviour is broken by 3.9.6.
Is there a way to execute all refines that are defined on the schema?
[Sandbox](https://codesandbox.io/s/tender-kare-xxyoz?file=/src/index.ts)",,
1016572277,689,Typescript 4.5 Beta infinite loop leading to JS heap out of memory,"An issue appeared with TypeScript 4.5.0-dev.20211001 that made tsc go into an infinite loop leading to an out-of-memory error.

tsconfig.json:

```json
{
  ""compilerOptions"": {
    ""target"": ""es2020"",
    ""module"": ""commonjs"",
    ""moduleResolution"": ""node"",
    ""lib"": [""es2020""]
  },
  ""exclude"": [""node_modules""],
  ""include"": [""run.ts""]
}
```

package.json:

```json
{
  ""type"": ""commonjs"",
  ""scripts"": {
    ""start"": ""tsc -p .""
  },
  ""dependencies"": {
    ""zod"": ""^3.9.8""
  },
  ""devDependencies"": {
    ""typescript"": ""^4.5.0-beta""
  }
```

when using `tsc` directly, the following import cause the issue:

```ts
import { z } from ""zod"";
```

when using ts-node instead of tsc, this is the minimum necessary code to cause the issue:

```ts
import { z } from ""zod"";

const schema: z.ZodSchema<string> = z.string();
```

Demo code in: https://github.com/mmvsk/bug-zod-typescript-4.5.0-oct-01

The same code works until TypeScript 4.5.0-dev.20210930, and the issue was probably introduced with the following TypeScript PR: https://github.com/microsoft/TypeScript/pull/41821",,
1014968232,688,Major refinements regressions in 3.9.x,"Refinements have regressed in 3.9.x
```ts
import { z } from 'zod';

z
  .string()
  .refine(() => false)
  .transform(() => {
    throw new Error(""this shouldn't happen"") // in 3.9.x this throws, in 3.8.x it doesn't reach this branch
  })
  .safeParse("""") 
  ```

3.9.x - throws:
https://codesandbox.io/s/angry-hawking-qqx2q?file=/src/index.ts
 
3.8.x - doesn't throw:
https://codesandbox.io/s/elastic-hooks-eglbu?file=/src/index.ts


  
  ",,
1014574175,687,Error params are being ignored for array schema,"[Repro sandbox](https://codesandbox.io/s/cocky-grass-wlcv0?file=/src/index.ts)

```typescript
import { z } from ""zod"";

const schema = z.array(z.string(), { errorMap: () => ({ message: ""No"" }) });

schema.parse(undefined);
```

returns:
```javascript
[
  {
    ""code"": ""invalid_type"",
    ""expected"": ""array"",
    ""received"": ""undefined"",
    ""path"": [],
    ""message"": ""Required""
  }
]
```

but in practice, it should return the custom message given in `errorMap`, like the rest of the schemas.",,
1014502633,686,Type guard for parse function,"Hello,

I was excited to use `zod` to validate my objects in typescript. I quickly ran into a problem.
parse function does return the correct type but not as type guarded.

https://github.com/colinhacks/zod/blob/9648f3f632280614e07da9621af6e1a8440d678c/src/types.ts#L168
For type guards to kick in, this line should be written like:
`parse(data: unknown, params?: Partial<ParseParamsNoData>): data is Output`

This becomes problem when I try to make if-statements to make sense of what exact type I'm currently dealing with:
![image](https://user-images.githubusercontent.com/14369871/135768751-0288031d-5614-4043-9d14-efd7d8a8f9a6.png)


Could this be possible change? Or are there some unseen outliers why this is not the case currently?

Type guards: https://www.typescriptlang.org/docs/handbook/advanced-types.html",,
1014139505,685,3.9.*: refine not working inside a union,"In 3.9.5, refines inside of unions are evaluated but the errors are not resolved. Working fine in 3.8.x

```typescript
    const validator = union([
        object({
            type: literal('x'),
            value: string()
        }).refine(
          ({value}) => value === 'test', // < This lambda is called, but validation does not fail.
          {
              message: 'Some value invalid',
              path: ['value']
          }
        ),
        object({
            type: literal('y'),
            otherValue: string()
        })
    ]);
    expect(validator.safeParse({type: 'y', otherValue: 'test'}).success).toBe(true) // < good
    expect(validator.safeParse({type: 'x', value: 'test'}).success).toBe(true) // < good
    expect(validator.safeParse({type: 'x', value: 'fail'}).success).toBe(false) // < will fail in 3.9, pass in 3.8
```",,
1014119393,684,z.object: properties are optional by default?,"When I use `z.object`, the fields within the object seem to be optional by default. I would expect the opposite. Is  this the expected behavior, or is there something I'm missing? It doesn't seem to be the behavior demonstrated in the [documentation](https://github.com/colinhacks/zod#objects).

os: windows
npm version: 7.24.1
node version: v14.16.0
typescript version: 4.4.3
zod version: 3.9.5

[repro repo](https://github.com/dmacthedestroyer/zod-fields-bug)

## Repro steps
```
npm init
npm install typescript zod
touch index.ts
```

`index.ts`:
```
import { z } from ""zod"";

const shape = z.object({
  foo: z.string(),
  bar: z.number(),
});

type Shape = z.infer<typeof shape>;
````

VS Code indicates that foo and bar are both optional:
```
type Shape = {
    foo?: string;
    bar?: number;
}
```

I'd expect them to be _not_ optional:
```
type Shape = {
    foo: string;
    bar: number;
}
```

Love the library, by the way -- you're a legend :)",,
1012608663,680,Is there a way to type-check for an instantiated Primitive's type?,"Hello, is there a way to check if instantiated Primitive type is that type.
new Number() === number
new String() === string

I've had no luck. Here are some of my test cases
```
import * as s from 'superstruct'

// Checking for an empty object. Output true. This is correct
s.is({}, s.object({}))

// Checking for and empty object. Output false. This is correct
s.is({ propertyName: ""propertyValue"" }, s.object({}))

//  Checking for an object. Output true. I would like this to be false.
s.is(new Number(43), s.object())

//  Checking for number. Output false. I would like this to be true.
s.is(new Number(43), s.number())
```
I know why it would do this. It's an instantiated Number that has prototype of object.


I have ways to find out that these ones are a typeof number.
I figured if zod would like to support for this kind of type-checking in any other way.
I'm fine if earlier examples stays that way, because one can argue that instantiated Primitive's type is an object.

I would like to see a function that sees through the instantiated Primitive prototype and compare the real value inside.
Example:
```
s.typeof(new Number(43), 'number') // true
or
s.typeof(new Number(43), s.number()) // true

s.typeof(new Number(43), 'object') // false
or
s.typeof(new Number(43), s.object()) // false
```",,
1011850120,678,[PROPOSAL] Flavoured and branded types,"Yes, I know about https://github.com/colinhacks/zod/issues/3 but I couldn't find anything saying that you didn't want to support nominal types in Zod 😄 

# Type alias

A type alias is just a name given to an already existing type. These won't prevent assigning values between types.

```ts
// Those three types are all number underneath
type Age = number;
type DistanceInMeters = number;
type DistanceInMiles = number;

const age = 10;
const distanceInMeters = age;
const distanceInMiles = distanceInMeters;

// Those two types are all string underneath
type Name = string;
type DateISO8601 = string;

const name = ""Zod"";
const date = name;

// Easy to do with Zod
type TownName = z.string();
```

# Tag

A tag is a property in a type that is used to differentiate it from other types. They are used to create discriminated unions.

```ts
type Shape = {
  area: number;
} & ({ radius: number } | { length: number });

// distinguishing between a Circle and a Square is annoying

declare const shape: Shape;

if (""radius"" in shape) {
  console.log(""The radius is "" + shape.radius);
} else {
  console.log(""The length is "" + shape.length);
}

// and you can't use a switch or a Record to handle all the types of shapes
// which is why tags are useful

type Animal =
  | {
      tag: ""dog"";
      barkStrength: number;
    }
  | {
      tag: ""cat"";
      purrStrength: number;
    };

declare const animal: Animal;

switch (animal.tag) {
  case ""dog"":
    // you can use barkStrength here
  case ""cat"":
    // you can use purrStrength here
}

// Easy to do with Zod
const shapeSchema = z.union([
  z.object({
    tag: z.literal(""circle""),
    radius: z.number(),
  }),
  z.object({
    tag: z.literal(""square""),
    length: z.number(),
  }),
]);
```

# Flavoured types

Sometimes you don't want types to be interchangeable, such as `distanceInMeter` and `distanceInMiles`, so you could use flavoured type to prevent this. A flavoured type is a type with  tag to prevent mixing flavoured types between themselves

```ts
type DistanceInMeter = number & { readonly brand?: unique symbol };
type DistanceInMiles = number & { readonly brand?: unique symbol };
const distanceInMeter: DistanceInMeter = 10; // this works
const distanceInMiles: DistanceInMiles = distanceInMeter; // this won't compile
```

You can't do this with Zod, you have to create a type and have your Zod schema use this type

```ts
type Flavor<T,  FlavorT> = T & { _type?: FlavorT; };
type UUID = Flavor<string, 'UUID'>;
const uuid: z.Schema<UUID> = z.string().uuid() as any;
```

It would be easier just to be able to use Zod to do this

```ts
const uuidSchema  = z.string().uuid().flavour<""UUID"">();
type UUID = z.infer<typeof uuidSchema>;
const uuid: UUID = ""123e4567-e89b-12d3-a456-426614174000"";
```

The code shouldn't be too complex too

```ts
export interface ZodFlavourDef<T extends ZodTypeAny> extends ZodTypeDef {
  innerType: T;
  typeName: ""ZodFlavour"";
}

export type ZodFlavourType<
  B extends string,
  T extends ZodTypeAny = ZodTypeAny
> = ZodNominal<B, T>;

type ZodFlavourOutput<
  B extends string,
  T extends ZodTypeAny = ZodTypeAny
> = T[""_output""] & { readonly __flavour?: B };

export class ZodFlavour<
  B extends string,
  T extends ZodTypeAny = ZodTypeAny
> extends ZodType<ZodFlavourOutput<B, T>, ZodFlavourDef<T>, T[""_input""]> {
  _parse(
    ctx: ParseContext,
    data: any,
    parsedType: ZodParsedType
  ): ParseReturnType<T[""_output""]> {
    return this._def.innerType._parse(ctx, data, parsedType);
  }

  unwrap() {
    return this._def.innerType;
  }

  static create = <B extends string, T extends ZodTypeAny = ZodTypeAny>(
    type: T,
    params?: RawCreateParams
  ): ZodFlavour<B, T> => {
    return new ZodFlavour({
      innerType: type,
      typeName: ""ZodFlavour"",
      ...processCreateParams(params),
    }) as any;
  };
}
```

# Branded types

These are the same as flavoured types but they don't accept primitive and have to be build using `parse` for example

```ts
const uuidSchema  = z.string().uuid().brand<""UUID"">();
type UUID = z.infer<typeof uuidSchema>;
const uuid: UUID = ""123e4567-e89b-12d3-a456-426614174000""; // won't compile
const uuid2: UUID = uuidSchema.parse(""123e4567-e89b-12d3-a456-426614174000"");
```

It would be the same code as above except for the `?`

```ts
type ZodBrandOutput<
  B extends string,
  T extends ZodTypeAny = ZodTypeAny
> = T[""_output""] & { readonly __brand: B };
```",,
1010409473,673,[Question] using zod for hashed key (non static key),"Been searching for answers to no avail, so asking question here:

let's say we have the following definition in typescript:
```
type Food = {
  id: string,
  name: string,
  prince: int
}

type Order = {
  [orderId: string]: Food
}
```
// and order is passed in as array of object from `items`, so it's items: [...]
how can I write such validation (main problem is the `orderId` is a non-static key, the best I can come up with is:
```
items: z.array(
  z.object({
    ...
  })
)
```",,
1009591620,671,"ZodUnion gets parsed, despite being invalid","Hi!

Based on this simple example:

```typescript
const NumberOrNonEmptyString = z.union( [
    z.number(),
    z.string().nonempty()
] );

NumberOrNonEmptyString.parse( '' ); // Passes
```

It passes the ``.nonempty()`` check despite being passed an empty string.",,
1008528427,669,Alternating results when using `regex` inside an `object`,"Running the same schema `safeParse` method when a item is of type `regex` returns alternating results.

```ts
import { z } from 'zod'

const schema = z.object({
  number: z.string().regex(/^\d+$/g).nullish()
})

const data = {number: '123'}

console.log(
  schema.safeParse(data).success, // => true
  schema.safeParse(data).success, // => false
  schema.safeParse(data).success, // => true
  schema.safeParse(data).success, // => false
  schema.safeParse(data).success, // => true
  schema.safeParse(data).success, // => false
)
```",,
1007767408,668,Tuples in unions does not get validated since v3.9.1,"Following schema

```ts
const eventsSchema = z.union([
    z.object({
      eventName: z.literal('foo'),
      eventPayload: z.tuple([z.number().nonnegative(), z.number().nonnegative()])
    }).strict(),
    z.object({
      eventName: z.literal('bar'),
      eventPayload: z.string().email()
    }).strict()
]);
```

failed before `v3.9.1` with following data

```ts
const data = {
  ""eventName"": ""foo"",
  ""eventPayload"": [0, -60]
};
const parseResult = eventsSchema.safeParse(data);
// parseResult.success === true
```

but since `v3.9.1` `zod` does not validate the `-60` value anymore as `.nonnegative()`. Parsing is always successful whereas before `v3.9.1` it failed (which is the expected behaviour)",,
1007422600,665,Bug: TypeError: Cannot read property 'async' of undefined,"Zod v3.9.1.

Error and stack trace:
```
Exception has occurred: TypeError: Cannot read property 'async' of undefined

  at ZodEffects._parse (/mnt/runtime/node_modules/x/node_modules/y/node_modules/zod/src/types.ts:2777:31)
    at ZodObject._parse (/mnt/runtime/node_modules/zod/src/types.ts:1647:22)
    at ZodObject.ZodType._parseSync (/mnt/runtime/node_modules/zod/src/types.ts:148:25)
    at ZodIntersection._parse (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:2115:25)
    at /mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:1316:14
    at Array.forEach (<anonymous>)
    at ZodArray._parse (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:1313:10)
    at ZodArray.ZodType._parseSync (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:148:25)
    at ZodArray.ZodType.safeParse (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:181:25)
    at ZodArray.ZodType.parse (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:169:25)
 ```
 
 Offending line in source: https://github.com/colinhacks/zod/blob/master/src/types.ts#L3125.
 
 Modifying the compiled output in `lib` from
```
    ZodEffects.prototype._parse = function (ctx, data, parsedType) {
        var isSync = ctx.params.async === false;
```
to 
```
    ZodEffects.prototype._parse = function (ctx, data, parsedType) {
        var isSync = ctx.params?.async === false;
```
fixes the problem.
 
 Seems like just a small oversight somewhere. Anything immediately obvious?",,
1007186329,662,"Using Zod for a form, transforming recursive shape","On [stackoverflow](https://stackoverflow.com/questions/69329657/how-to-transform-a-recursive-generics-shape-typescript)


### I love the Zod parser but I may have gotten in over my head creating a form lib.

In the ideal end state, the input shape is transformed to create `{ fieldA: { value, onChange, errors } }`. It works for a single level, but it's not clear how to support arrays and nested objects.

# Can typescript transform recursive generics like this?

## Zod represents parsers like this:
```typescript
const schema = z
  .object({
    name: z.string().min(3, 'Too short.'),
    nested: z.object({
      name: z.string(),
    }),
    repeat: z.array(z.object({
      arrNest: z.string(),
    })),
  }).transform((v) => v.name);
```

## Then using type inference:
```typescript
const example = <Input extends { [v: string]: any }, Output extends unknown>(
  schema: z.ZodType<Output, any, Input>
) => {
  type Fields = {
    [P in keyof Input]: {
      value: Input[P];
    };
  };

  return ({} as unknown) as Fields;
};

export const typed = example(schema);
```

## Name has the desired type `{ value: string }` but repeat has:

[![VS Code infering type of repeat][1]][1]


  [1]: https://i.stack.imgur.com/caN4a.png

# Instead, I want to apply this recursively with Objects and Arrays

Then `types.repeat` would have type `{ arrNest: { value: string } }[]`


### Notes

The [zod object type](https://github.com/colinhacks/zod/blob/6c6c9691ec6d3266ca088e5a1cfb98cceef061bd/src/types.ts#L1447) is rather complicated..

but I am only concerned with the `Input`, represented as 
```typescript
export type ZodRawShape = { [k: string]: ZodTypeAny };
```

# Any thoughts on feasibility or direction welcomed!",,
1005776851,661,z.lazy in recursive types example turns all values unwantedly optional,"When copying your example from https://github.com/colinhacks/zod#recursive-types

```typescript
interface Category {
    name: string;
    subcategories: Category[];
}

// cast to z.ZodSchema<Category>
const Category: z.ZodSchema<Category> = z.lazy(() =>
    z.object({
        name: z.string(),
        subcategories: z.array(Category),
    })
);
```

it gives the strange error saying that at some point all values become optional which would violates the original interface:

```
TS2322: Type 'ZodLazy<ZodObject<{ name: ZodString; subcategories: ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'.   Types of property '_type' are incompatible.     Type '{ name?: string; subcategories?: Category[]; }' is not assignable to type 'Category'.       Property 'name' is optional in type '{ name?: string; subcategories?: Category[]; }' but required in type 'Category'.
```",,
1001358586,658,"Bug: ""Required"" Behavior Not Working ","### The Problem
It stands to reason that if I declare 
```js
const requiredSchemaA = schemaA.required();
```
 then
```js
requiredSchemaA.shape.someProp.isOptional() 
```
would be `false`. 

However, this is not necessarily the case. 



### Repro Steps 
Here is the playground.ts to reproduce
```js
const schemaA = z.object({
  someProp: z
    .string()
    .optional()
    .refine(() => true),
});

const requiredSchemaA = schemaA.required();

console.log(requiredSchemaA.shape.someProp.isOptional());
```


### Proposed Solution
Add a new type ```ZodRequired```. I realize a type like `ZodRequired<ZodOptional<ZodString>>` is a bit clumsy, but `ZodRequired` could successfully handle cases where ZodOptional is ""hidden"" by some other type (ie ZodEffects).  ",,
998606322,654,z.enum for as const numbers?,"This works nicely:
```ts
const VALUES = [""Salmon"", ""Tuna"", ""Trout""] as const;
const FishEnum = z.enum(VALUES);
// 'Salmon' | 'Tuna' | 'Trout'

```

But this does not work:
```ts
const VALUES = [1, 2, 3] as const;
const OrderEnum = z.enum(VALUES);
// 1 | 2 | 3
```
This is due to the requirement of having an array of strings, although a union of numbers work. 

Thoughts? 


",,
997999283,652,z.ZodType and z.ZodSchema do not seem to work as I expect,"Hi there!

I've discovered the lib recently and have a question that is probably silly.

I have an application that defines its domain with Typescript, which I want to be the single source of truth. This means I'm not interested in inferring static types from Zod, but the other way around. I want Zod to obey what Typescript dictates and want the TS compiler to let me know when any inconsistency arises. I assume the dual definition of types and parsers.

I've tried to achieve this with `z.ZodType<MyType>` and `z.ZodSchema<MyType>` with no success and I have not found a clue to follow from the readme of the project, which seems to be the only documentation available.

I've prepared a small dumb example that I hope will help you understand what I intend to do ([CodeSandbox here](https://codesandbox.io/s/zod-example-1oe9x?file=/src/index.ts)):

```typescript
import * as z from ""zod"";

type A = {
  foo: string;
  bar: string;
};

// This parser exactly matches interface A so we have no errors. So far so cool.
const AParser: z.ZodType<A> = z.object({
  foo: z.string(),
  bar: z.string()
});

///////////////////////////////////////////////////////////////

type B = {
  bar: string;
};

// Why I get no errors on a parser that does not match the type z.ZodType<B>?
const BParser: z.ZodType<B> = z.object({
  foo: z.string(),
  bar: z.string()
});
```

I have some experience with `io-ts`. Please find here a [CodeSandbox demonstrating the result I'd expect](https://codesandbox.io/s/io-ts-example-2rgc6?file=/src/index.ts).

Thx!!",,
997258339,649,Allow custom code in errorUtil,"Currently `ErrMessage` can be string or `{ message?: string; };` and this message goes into `errorMap` function. We could add possibility to pass typed ""code"" instead of message and inside errorMap we could check it to select message. By that applications could have one place to define all the message with type checking support and have translations along with it.

Here is the example of `errorUtil` file:
```
export declare namespace errorUtil {
    export interface Codes {
    }

    export interface CodeErrorProps {
    }

    export interface CodeError extends CodeErrorProps {
        code: keyof Codes;
    };

    type ErrMessage = CodeError | string | {
        message?: string;
    };

    const errToObj: (message?: ErrMessage | undefined) => {
        message?: string | undefined;
    };
    const toString: (message?: ErrMessage | undefined) => string | undefined;
}
```

Because they are interfaces we could have declaration merging and users can provide their own codes and operate with them in errorMap. 

This is just rough example to show the idea.",,
995478548,647,`z.function().default()` Sometimes Doesn’t make Type Optional,"As mentioned in #646, I really like this library all-in-all and am trying to integrate it where I can right now. While writing some custom `zod` -> `vue props` converter, I encountered the following behavior that at least to me looks like a bug.

## Reproduce

All these tests pass successfully. However, I don’t understand why that is. I think all `.toBe()`s should be `true`. However, 8 of them are somehow `false`. I only encountered this with `z.function`. The other types seem fine to me.

```ts
import { z } from 'zod'

describe('z.function().default() does not work with isOptional', () => {
	it('works with explicit optional', () => {
		const schema = z
			.function()
			.optional()
			.default(() => undefined)

		expect(schema.safeParse(undefined).success).toBe(true)
		expect(schema.isOptional()).toBe(true)
	})

	it('fails with z.function().default(() => undefined)', () => {
		const schema = z.function().default(() => undefined)

		expect(schema.safeParse(undefined).success).toBe(false) // should be true
		expect(schema.isOptional()).toBe(false) // should be true
	})

	it(""fails with z.function().default(() => 'anything')"", () => {
		const schema = z.function().default(() => 'anything')

		expect(schema.safeParse(undefined).success).toBe(false) // should be true
		expect(schema.isOptional()).toBe(false) // should be true
	})

	it('works with union hack with () => () => undefined', () => {
		const schema = z
			.union([z.function(), z.function()])
			.default(() => () => undefined)

		expect(schema.safeParse(undefined).success).toBe(true)
		expect(schema.isOptional()).toBe(true)
	})

	it('fails with union hack with () => undefined', () => {
		const schema = z
			.union([z.function(), z.function()])
			.default(() => undefined)

		expect(schema.safeParse(undefined).success).toBe(false) // should be true
		expect(schema.isOptional()).toBe(false) // should be true
	})

	it(""fails with union hack with () => 'anything'"", () => {
		const schema = z
			.union([z.function(), z.function()])
			.default(() => 'anything')

		expect(schema.safeParse(undefined).success).toBe(false) // should be true
		expect(schema.isOptional()).toBe(false) // should be true
	})

	it('works with z.number().default(1)', () => {
		const schema = z.number().default(1)

		expect(schema.safeParse(undefined).success).toBe(true)
		expect(schema.isOptional()).toBe(true)
	})

	it('works with z.object().default({})', () => {
		const schema = z.object({}).default({})

		expect(schema.safeParse(undefined).success).toBe(true)
		expect(schema.isOptional()).toBe(true)
	})
})
```

## Versions

**zod**: `3.8.2`
**TypeScript**: `4.3.5`",,
995182722,646,z.union.default Has Unexpected Type Error,"First of all, thanks for this excellent library. I’m currently tying too hard to integrate it everywhere I possibly can haha

I found a rather minor type issue. Not sure if I’m misusing it, but it seems to work as expected at run-time — just not at compile-time. When using `z.union`, using `.optional()` seems to not be possible, at least in this case that I encountered and simplified into an example. As far as I can tell, runtime seems to work as-expected after adding a `@ts-expect-error`.

## Reproduce

**Link**: [TS Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFApgHYCueA0sLcYhXF3AIIByASQCyPADJwAvAX7Cx+ADSduAMVEB5AOoBRAEqSCqzboUU0VAMYRaAZ3gAPfciUA6erWBWAFAG0lXZM4QAEYAVtTmMJ5IANasxABcKM4ANsAw1FAAhsme+JnuINn4AJTycMnUAObWiQEMIEEZnsXopX5JwWERUXCxbLUpaRnZuZjJEADuGSVlY5MZNUn1jVDNrYpcALrFLsTUmJn0yZFrEgB8cD19CQT5oEVlFdWJACytxZQUljbwAJ6OLjcHloPnaAU64UiMTiA1S6SyORYbGcMhEolK5SqizqjBWazQbW4HVCkKuMKScOGiLizkM2h0GLmUyg2OcyyaLQJGzg212+0Ox08pwuZP6cCRxBRgjRjyxr3eZCAA)

```ts
import { z } from ""zod"";

enum Kind {
    ANIMAL = ""ANIMAL"",
    FLOWER = ""FLOWER"",
}

const x = z
  .union([
    z.object({ kind: z.literal(""animal""), legs: z.number() }),
    z.object({ kind: z.literal(""flower""), flowers: z.number() }),
  ])
  .default(() => ({ kind: ""animal"", legs: 4 }));

const y = z
  .union([
    z.object({ kind: z.literal(Kind.ANIMAL), legs: z.number() }),
    z.object({ kind: z.literal(Kind.FLOWER), flowers: z.number() }),
  ])
  .default(() => ({ kind: Kind.ANIMAL, legs: 4 }));
```

### Expected Behavior

No type error is produced

### Actual Behavior

#### `x`

```
No overload matches this call.
  Overload 1 of 2, '(def: { kind: ""animal""; legs: number; } | { kind: ""flower""; flowers: number; }): ZodDefault<ZodUnion<[ZodObject<{ kind: ZodLiteral<""animal"">; legs: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>', gave the following error.
    Argument of type '() => { kind: string; legs: number; }' is not assignable to parameter of type '{ kind: ""animal""; legs: number; } | { kind: ""flower""; flowers: number; }'.
      Type '() => { kind: string; legs: number; }' is missing the following properties from type '{ kind: ""flower""; flowers: number; }': kind, flowers
  Overload 2 of 2, '(def: () => { kind: ""animal""; legs: number; } | { kind: ""flower""; flowers: number; }): ZodDefault<ZodUnion<[ZodObject<{ kind: ZodLiteral<""animal"">; legs: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>', gave the following error.
    Type 'string' is not assignable to type '""animal"" | ""flower""'.(2769)
```

#### `y`

```
No overload matches this call.
  Overload 1 of 2, '(def: { kind: Kind.ANIMAL; legs: number; } | { kind: Kind.FLOWER; flowers: number; }): ZodDefault<ZodUnion<[ZodObject<{ kind: ZodLiteral<Kind.ANIMAL>; legs: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>', gave the following error.
    Argument of type '() => { kind: Kind; legs: number; }' is not assignable to parameter of type '{ kind: Kind.ANIMAL; legs: number; } | { kind: Kind.FLOWER; flowers: number; }'.
      Type '() => { kind: Kind; legs: number; }' is missing the following properties from type '{ kind: Kind.FLOWER; flowers: number; }': kind, flowers
  Overload 2 of 2, '(def: () => { kind: Kind.ANIMAL; legs: number; } | { kind: Kind.FLOWER; flowers: number; }): ZodDefault<ZodUnion<[ZodObject<{ kind: ZodLiteral<Kind.ANIMAL>; legs: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>', gave the following error.
    Type '{ kind: Kind; legs: number; }' is not assignable to type '{ kind: Kind.ANIMAL; legs: number; } | { kind: Kind.FLOWER; flowers: number; }'.
      Type '{ kind: Kind; legs: number; }' is not assignable to type '{ kind: Kind.ANIMAL; legs: number; }'.
        Types of property 'kind' are incompatible.
          Type 'Kind' is not assignable to type 'Kind.ANIMAL'.(2769)
```

## Versions

**TypeScript**: `4.4.2`
**zod**: `3.8.2`",,
993777603,643,es6 - Cannot read property '_parse' of undefined,"Hey all ! Thanks for the good work.

In my project, I am using `zod@3.8.1` and for some technical limitations I need to manipulate `z` objects into an es6 codebase. More specifically the `pick` operator.

So I have my object definition in TS package (built to es6) :

```typescript
export const Model = z.object({
  id: z.string().uuid(),
  name: z.string()
})
```

And in my es6 code I want to use a subset of this `Model`. Naively I do the following

```javascript
import { Model } from '@mystuff/models'

const ModelSubset = Model.pick({
  name: true
})
```

The inferred type of `ModelSubset` looks right. But on the runtime, when I do this : 

```javascript
const myValidModel = ModelSubset.parse({
  name: 'Kikoo'
})
```

`zod` throws me : 

```
TypeError: Cannot read property '_parse' of undefined
```

Redefining the object in the es6 package works though.. 🤔 

So, what am I missing ?

Thank you for reading and be well !",,
993070469,641,Best practices: Use schema validation along classes,"Hello,

This issue is not related to a Zod problem, but I'm sure people using the lib can help me <3

This is a simple Schema (we have to imagine it is more complex):

```
export const PersonSchema = z.object({
    id: z.string(),
    firstname: z.string(),
    lastname: z.string()
});

export type PersonType = z.infer<typeof PersonSchema>;
```

On server side, when I get a POST request, I can validate the payload using:

```
const newPerson = PersonSchema.parse(payload);
```

Great, my noSQL database will stay clean !

But now, I want to use this on client-side. So I use the same method.

```
const newPerson = PersonSchema.parse(payload);
```

My front get a Person object now, but to display it, I would like to use a class method like this for example:

```
newPerson.getFullName();
```

But newPerson is not a class instance...

So far, I found those solutions:

**Solution 1:**

Create a class Person:

```
class PersonClass implements PersonType {
    id: ZodString['_output'];
    lastname: ZodString['_output'];
    firstName: ZodString['_output'];

    constructor(newPerson: PersonType) {
        this.id = newPerson.contactEmail;
        this.lastname = newPerson.lastname;
        this.firstname = newPerson.firstname;
    }

    getFullName() {
        return this.firstname + "" ""  + this.lastname;
    }
```

OR

```
class PersonClass implements PersonType {
    id: z.infer<typeof PersonSchema.shape.name>;
    lastname: z.infer<typeof PersonSchema.shape.name>;
    firstName: z.infer<typeof PersonSchema.shape.name>;

    constructor(newPerson: PersonType) {
        this.id = newPerson.contactEmail;
        this.lastname = newPerson.lastname;
        this.firstname = newPerson.firstname;
    }
    
    getFullName() {
        return this.firstname + "" ""  + this.lastname;
    }
}
```

I found this on the same subject: 

https://github.com/colinhacks/zod/issues/38

But the more Person will have attributes, the more the class size is also growing. And I will have to parse my object, then to make an instance of the class...

**Solution 2:**

I don't use classes, and I create a getFullName() methods like this:

```
const getFullName = (person: PersonType) => {return person.firstname + "" "" + person.lastname;}
```

So my question is:

**How and when do you use Zod in your projects ?**

Only to validate payloads ? How to use methods on parsed objects?",,
990820323,638,Wrong type inference when using refine function,"Hi, first of all thanks for this great library.

Unfortunately something went wrong after version 3.1.0 with the refine function.

Here is the code snippet:
```
import { z } from ""zod"";

const schema = z.object({
  date: z.date().refine((d) => true, ""Invalid."")
});

type t = z.infer<typeof schema>;

const test: t = {}; //should be invalid
const test2: t = { date: """" }; //should be invalid

const test3: t = { date: new Date() }; //OK
```
Using version 3.1.0 the inferred type is ok:
```
type t = { date: Date }
```
but using later versions (3.2.0-3.8.2) the inferred type is:

```
type t = { date?: any }
```

https://codesandbox.io/s/zod-refine-issue-v203y?file=/src/index.ts

Can you fix it?
Is there any workaround for this bug?

Thanks,
Balazs",,
989768978,636,"Error ""Intersection results could not be merged"" on array fields in zod 3.8.2","Consider the following example:
```ts
const arraySchema = zod.object({
  attachments: zod.array(zod.object({}))
});

console.log(
  arraySchema.and(arraySchema).safeParse({
    attachments: []
  })
);
```
I would expect a successful output, but the result is a `ZodError`:
```ts
ZodError: [
  {
    ""code"": ""invalid_intersection_types"",
    ""path"": [],
    ""message"": ""Intersection results could not be merged""
  }
]
```
At the same time a very similar object schema is parsed successfully:
```ts
const objectSchema = zod.object({
  attachment: zod.object({})
});

console.log(
  objectSchema.and(objectSchema).safeParse({
    attachment: {}
  })
);
```
[Here](https://codesandbox.io/s/heuristic-khayyam-62tpo?file=/src/index.ts:719-871) is a sandbox with zod 3.
[Here](https://codesandbox.io/s/wonderful-smoke-6osu7?file=/src/index.ts) is a sandbox with zod 2 which gives success for both cases.",,
989083221,635,.optional() and --exactOptionalPropertyTypes,"Currently, .optional() behaves like:

```typescript
const user = z.object({
  username: z.string().optional(),
});
type C = z.infer<typeof C>; // { username?: string | undefined };
```

This results in a type mismatch when you're using --exactOptionalPropertyTypes in TypeScript 4.4 and expecting type ```C```  to match an interface definition like:

```typescript
interface User {
  username?: string;
}
```

.partial(), .partialBy(), .deepPartial() all have the same issue.

It would be nice to unbundle the optionality of the key from the union type with undefined for the value.

I suggest that these methods be changed to specify the optional absence of the key by default, and perhaps accept an option to restore the old behavior of adding ```.or(z.undefined())``` to the value schema(s). This would unfortunately be a breaking change, but it makes more sense than the current behavior, especially as more projects adopt --exactOptionalPropertyTypes.

",,
986932829,628,Migrating to zod 3 - ZodType(?) issue,"We've been using zod 2 with great success, but now I'm having an issue migrating to zod 3. Here's the piece of code representing the error:
```ts
import * as zod from 'zod';

const schema = zod.object({
  videoDate: zod.string(),
});

class Editor<
  S extends zod.ZodType<zod.TypeOf<typeof schema>> = typeof schema,
> {
  constructor(public schema: S) {}
}

const advancedSchema = zod.intersection(schema,
  zod.object({
    videoDuration: zod.number(),
  })
    .refine(val => val.videoDuration > 5),
);

export class AdvancedEditor extends Editor<typeof advancedSchema> {      // the error pops here
  constructor(schema: typeof advancedSchema) {
    super(schema);
  }
}
```

This was legitimate in [zod 2 ](https://codesandbox.io/s/gifted-lumiere-ur9k9?file=/src/index.ts), but turned out to be prohibited in [zod 3](https://codesandbox.io/s/eager-cdn-7kute?file=/src/index.ts) yielding the following error:
```
Type 'ZodIntersection<ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }>, ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>>' does not satisfy the constraint 'ZodType<{ videoDate?: string; }, ZodTypeDef, { videoDate?: string; }>'.
  The types returned by '_parse(...)' are incompatible between these types.
    Type 'ParseReturnType<ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }> & ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>>' is not assignable to type 'ParseReturnType<{ videoDate?: string; }>'.
      Type 'OK<ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }> & ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>>' is not assignable to type 'ParseReturnType<{ videoDate?: string; }>'.
        Type 'OK<ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }> & ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>>' is not assignable to type 'OK<{ videoDate?: string; }>'.
          Type 'ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }> & ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>' has no properties in common with type '{ videoDate?: string; }'.ts(2344)
```
Can I follow the same approach now?",,
986479801,627,Ignore entry that does not respect a schema,"Hey there,

Is there a way to filter element of an array that does not match our schema? 

For example I have this schema:

```ts
enum BarType {
  Big = ""big"",
  Small = ""small"",
}

const schema = z.object({
  foo_id: z.string(),
  bars: z.array(
    z.object({
      id: z.string(),
      type: z.nativeEnum(BarType),
    }),
  ),
});
```

Is there a way to ignore in the `bars` entries all the type that are not valid `BarType` enum? 

Here a gist with a complete example: https://gist.github.com/armandabric/f88bf690ade47d292ef3cec11716d41f",,
985258373,626,Zod enums with any literals?,"Hi!

Is it possible to extend the functionality of zod enums to any literal, not just strings?

Examples of using:

```
z.enum([true, false, 'unknown'])
```

```
z.enum([400, 401, 404, 405, 500])
```",,
984866980,625,ZodSchema type issue,"I working on a typescript function which accepts zod schema and a model which will be validated. 

this is the schema which i will parse later in the code below

`export const postClient = z.object({
  max_budget: z.number().min(0),
  max_no_offer: z.number().min(0),
  expires_in: z.date(),
  discount: z.number().min(0),
  buy_quantity: z.number().min(0),
  get_quantity: z.number().min(0),
  expire_type: z.string().min(0),
  branches: z.array(zToObjectId),
  name: z.string(),
  type: z.string(),
  items: z.array(zToObjectId),
  name_ar: z.string(),
  items_options: z.array(zToObjectId).nullable(),
})`

I also created a type based on this schema
`export type OfferClientT = z.infer<typeof postClient>`


`export interface JSONValid<Model, Schema> {
  schema: ZodSchema<Schema>
  model: Model
}
`

`export function jsValidate<T = any, TT = any>({ data, console }: Args<JSONValid<T, T>>): Results<TT> {
  let bool: Boolean = false
  let report: ReportLog = { code: generateid(), message: """", err: null, valid: false, functionDetails: funcName() }
  let dataRt
  try {
    dataRt = data.schema.parse(data.model)
    bool = true
    report.valid = true
    report.message = ""Parsing zod schema was successful""
  } catch (err) {
    logging(err, console)
    report.message = ""Failed to validate the json schema using zod""
    report.err = err
    //TODO: send email with the err to me :>
  }
  return {
    bool: bool,
    data: dataRt,
    report,
  }
}`


`  const { bool, data, report } = jsValidate<OfferClientT, OfferClientT>({
    data: { model: req.body, schema: postClient },
    console: true,
  })
`

**The issue is here, whenever i try to add the zodschema into the schema key i get this error:**

Type 'ZodObject<{ max_budget: ZodNumber; max_no_offer: ZodNumber; expires_in: ZodDate; discount: ZodNumber; buy_quantity: ZodNumber; get_quantity: ZodNumber; ... 6 more ...; items_options: ZodNullable<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is missing the following properties from type 'ZodType<{ type?: string; max_budget?: number; max_no_offer?: number; expires_in?: Date; discount?: number; buy_quantity?: number; get_quantity?: number; expire_type?: string; branches?: (string | ObjectId)[]; name?: string; items?: (string | ObjectId)[]; name_ar?: string; items_options?: (string | ObjectId)[]; }, Zo...': _parseInternal, _parseInternalOptionalParams, _parseWithInvalidFallbackts(2739)
index.ts(22, 3): The expected type comes from property 'schema' which is declared here on type 'JSONValid<{ type?: string; max_budget?: number; max_no_offer?: number; expires_in?: Date; discount?: number; buy_quantity?: number; get_quantity?: number; expire_type?: string; branches?: (string | ObjectId)[]; name?: string; items?: (string | ObjectId)[]; name_ar?: string; items_options?: (string | ObjectId)[]; }, ...'

",,
983526891,622,import lazy schema from other file module cause ts 4023,"```
Exported variable '$ModelSchema' has or is using 
name 'IObjectPropertyDetails' from external module 
""~/packages/api/src/api/common/schema.schema"" 
but cannot be named.ts(4023)
```
If I split schemas and import other schema which contains lazy properties, ts cannot infer the property correctly. I have to declare using zodschema<X>, is there other way?",,
982860515,620,The refine() function for a boolean is causing compilation error,"I am coding a project with the following libraries:

    ""@hookform/resolvers"": ""^2.7.1"",
    ""@reduxjs/toolkit"": ""^1.6.1"",
    ""@testing-library/jest-dom"": ""^4.2.4"",
    ""@testing-library/react"": ""^9.5.0"",
    ""@testing-library/user-event"": ""^7.2.1"",
    ""@types/jest"": ""^24.9.1"",
    ""@types/node"": ""^12.20.16"",
    ""@types/react"": ""^16.14.11"",
    ""@types/react-dom"": ""^16.9.14"",
    ""@types/react-redux"": ""^7.1.18"",
    ""axios"": ""^0.21.1"",
    ""node-sass"": ""^6.0.1"",
    ""npm"": ""^7.20.0"",
    ""primeflex"": ""^2.0.0"",
    ""primeicons"": ""^4.1.0"",
    ""primereact"": ""^6.5.0"",
    ""react"": ""^17.0.2"",
    ""react-dom"": ""^17.0.2"",
    ""react-localization"": ""^1.0.17"",
    ""react-redux"": ""^7.2.4"",
    ""react-router-dom"": ""^5.2.0"",
    ""react-scripts"": ""^4.0.3"",
    ""react-transition-group"": ""^4.4.2"",
    ""typescript"": ""~4.1.5"",
    ""zod"": ""^3.8.1""

I defined a UserCreateDto to handle and validate the most basic data for a Create User form. I also created a customized errorMap.

user-create.dto.tsx:

```
import { z } from 'zod';
import Localize from '../../components/localize';
import errorMap from '../error.map';

z.setErrorMap(errorMap);

export const validationSchema = z
	.object({
		User: z.string().min(8, { message: Localize['Validation:UserName'] }),
		Email: z.string().email({ message: Localize['Validation:InvalidEmail'] }),
		Password: z.string().min(1, { message: Localize['Validation:Required'] }),
		confirm: z.string().min(1, { message: Localize['Validation:Required'] }),
		Birthday: z
			.date()
			.optional()
			.refine((data) => data !== undefined, {
				message: Localize['Validation:UndefinedDate'],
			}),
		Accept: z.boolean().refine((data) => data === true, { message: '' }),
	})
	.refine((data) => data.Password === data.confirm, {
		message: Localize['Validation:PassswordsNotMatching'],
		path: ['confirm'],
	});

type UserCreateDto = z.infer<typeof validationSchema>;

export default UserCreateDto;
```

error.map.tsx

```
import { z } from 'zod';
import Localize from '../components/localize';

const errorMap: z.ZodErrorMap = (issue, ctx) => {
	if (issue.code === z.ZodIssueCode.invalid_type) {
		if (issue.expected === 'string') {
			return { message: Localize['Validation:Required'] };
		}
		if (issue.expected === 'date') {
			return { message: Localize['Validation:Required'] };
		}
	}
	if (issue.code === z.ZodIssueCode.custom) {
		return { message: `less-than-${(issue.params || {}).minimum}` };
	}
	return { message: ctx.defaultError };
};

export default errorMap;
```

The error I get when I do either npm start or npm run build is this:

Failed to compile.

undefined
fork-ts-checker-webpack-plugin error in undefined(undefined,undefined):
Maximum call stack size exceeded  TSINTERNAL

The error disappears when I remove .refine((data) => data === true, { message: '' }) from the Accept boolean property in the validationSchema. I can also add it back to the validation after npm start completes the startup.
",,
982164153,619,zod/lib/external has no exported member 'infer',"I am having issues using `z.infer`. However, `z.TypeOf` (which looking at the types it appears `infer` is just an alias of `TypeOf`) is working.

```
const repaymentSchema = z.object({
  from: z.number(),
  to: z.number(),
  amount: z.string(),
});

export type Repayment = z.infer<typeof repaymentSchema>;
```

This results in the following error:
```
TSError: ⨯ Unable to compile TypeScript
src/splitwise/client.ts (11,27): Namespace '""/Users/dmmulroy/repos/ynab-splitwise-sync/node_modules/zod/lib/external""' has no exported member 'infer'. (2694)
```

Switching to the following works fine:

```
export type Repayment = z.TypeOf<typeof repaymentSchema>;
```



In vscode, the editor accurately infers the type when using `z.infer` but at compilation time it fails.

![infer working](https://user-images.githubusercontent.com/2755722/131260538-c329682a-5e9c-4909-9a9c-fdc38e83b7fc.png)

Here is my `tsconfig.json`:

```
{
  ""extends"": ""@tsconfig/recommended/tsconfig.json"",
  ""compilerOptions"": {
    ""outDir"": ""./dist"",
    ""allowJs"": true,
    ""noErrorTruncation"": true,
    ""strictNullChecks"": true
  }
}
```



",,
982074408,616,Feature: Extend ZodObject with modified version of existing element,"Hello, is it possible to extend the original shape but check that the keys are taken from origin. 
For example i have such shape in module scope:
```
const SomeData = z.object({
  test: z.string(),
  test1: z.number(),
})
```

Add i would like to add more rules to this object (the API can be smth different)
```
function MyForm() {
  const t = useTransition()
  const FormValues = SomeData.deepMerge({ test1: z => z.min(10, { message: t.form.numCheck }) })
  const form = useForm({ resolver: zodResolver(FormValues) })

  return <>{/* do smth with form */}</>
}
```
And the TS will autocomplete the `test1` prop.

The case when it is needed is when you want to use the localization in i.e. React components because usually the translations are available in React context and not in global scope. Technically i can use the translation from some global object and use it when defining SomeData, but the issue will be is that when i change the language the error message will be the same because they are hardcoded and cannot react the translation change.",,
981821285,615,Can't properly type `z.lazy` with an object validator that transforms fields,"I'm trying to validate an object (with a recursive structure, but the issue is reproducible without it) which transforms fields into something that doesn't exactly match the given schema, and I have a hard time figuring out how to do it.

Here's an example:

```ts
const validator: ZodSchema<{ 
  foo: string 
}> = z.lazy(() => z.object({
  foo: z.number().transform((num) => num.toString()),
}));

/**
* The types of '_input.foo' are incompatible between these types.  
* Type 'number' is not assignable to type 'string'.
*/

```

So I assumed that I got it wrong, and figured that the type given to `ZodSchema` should match validation _before_ transformation, but that also doesn't seem to work.

```ts
const validator: ZodSchema<{ 
  foo: number // <-- CHANGED FROM STRING 
}> = z.lazy(() => z.object({
  foo: z.number().transform((num) => num.toString()),
}));

/**
* The types of '_input.foo' are incompatible between these types.  
* Type 'string' is not assignable to type 'number'. // <-- REVERSED ERROR
*/

```

Did I understand something wrong here? How should I do this properly?
Thank you!

------
Using
Zod 3.8.1
Typescript 4.4.2",,
980872216,613,Tuple Behavior: strip by default,"# Problem
Currently the behavior of Tuples is unintuitive when used for function arguments. 

## Without Zod
In javascript, something like what is below is entirely valid
```js
function maxLength5(str) {
    return str.length <=  5
}

const filteredList = ['apple', 'orange', 'pear', 'banana', 'strawberry'].filter(maxLength5)
```

## With Zod
This is a wonderfully powerful capability. However, if the `maxLength` function was wrapped with zod type checking, the above example would fail with error
```js
const maxLength5  = z.function()
    .args(z.string())
    .returns(z.boolean())
    .implement((str) => {
       return str.length <=  5
    })

const filteredList = ['apple', 'orange', 'pear', 'banana', 'strawberry'].filter(maxLength5)
```

### Error 
```js
ZodError: [
  {
    ""code"": ""invalid_arguments"",
    ""argumentsError"": {
      ""issues"": [
        {
          ""code"": ""too_big"",
          ""maximum"": 1,
          ""inclusive"": true,
          ""type"": ""array"",
          ""path"": [],
          ""message"": ""Should have at most 1 items""
        }
      ],
      ""name"": ""ZodError""
    },
    ""path"": [],
    ""message"": ""Invalid function arguments""
  }
]
```

# Proposal
The default behavior for function argument tuples should instead be something analogous to stripping keys on objects. Any extra elements in a tuple should be removed and validation should pass so that the above example works as expected.",,
979590272,609,objects value doesn't get set to `default` when property is optional,"Hey there!

Given the following schema
```typescript
const schema = z.object({
   type: z.optional(z.enum([""switch"", ""checkbox""]).default(""switch"")),
})
```
when providing an empty object (`{}`) to the `parse` function, the result will be an empty object, instead of (what I'd expect) 

```typescript
{
  type: 'switch'
}
```

Is there a workaround for that? Or is this even a bug or is it just a limitation by zod's code-structure?

Thanks in regards!",,
979508820,608,Feature: Formalize Zod Extensions ,"There is a growing ecosystem around extending zod in various ways. This is awesome! However, these extensions are often awkward to work with. The underlying problem is that they cannot attach data to a zod type. I understand not wanting a general ""metadata"" property on zod types because this is ripe for abuse. However, could Zod be made extensible in some first class way?

Syntactically I was envisioning something like 

```js

const productNameSchema = z.string().ext.setMockFn(() => faker.commerce.productName())
const myProductName = productNameSchema.ext.mock()  // returns product name

// or 

const foo = z.date().ext.toFormikSchema()

```

where ext is an object which extensions add to.

Note: for typescript support to work with this, we would have to wrap Zod type in some way which would allow passing in Extensions (export would then be zod with no extensions). 

To construct your extended Zod version, you could do something like

```js
export const z = MakeZod([zodMockingExt, zodFormikExt, ...])

```

My hope would be that this could provide a definite pattern for how to extend zod leading to more consistency, a wider community, and perhaps even interoperable extensions. ",,
977191398,605,Thank you!,"@colinhacks and other contributors, thank you for creating and maintaining this library! 

I came across this lib ~a month after it was here on Github and I instantly loved the interface - the elegant usage and the powerful functionality and TS integration. So much that I made the decision to start using it in a production project from v1, in a project that already had `yup` included.

It really shows that this project receives a lot of love - with all the improvements, tests, benchmarks, github actions and fixes.

Apologies for opening an Issue for this, feel free to close it whenever you like :)",,
976693920,603,Incomplete error info with inner union,"Example:
```ts
import { z } from 'zod';

const a = z.object({
    letter: z.literal('a'),
});

const b = z.object({
    letter: z.literal('b'),
});

const c = z.object({
    letter: z.literal('c'),
});

const union = z.union([a, b, c]);

union.parse({
    letter: 'd',
});
```

I'll receive this error, where I can see possible issues for all union entries:
```ts
{
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""a"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected a, received d""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""b"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected b, received d""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""c"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected c, received d""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [],
    ""message"": ""Invalid input""
  }
  ```

But if I modify `c` slightly: 
```ts
const c = z.object({
    letter: z.literal('c').or(z.literal('C')),
});
```

I'll receive this error:
```ts
{
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""c"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected c, received d""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""C"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected C, received d""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [
      ""letter""
    ],
    ""message"": ""Invalid input""
  }
  ```
  
  As you can see, now issues provided only for `c`",,
976169332,601,object key constraint using enum,"Hi @colinhacks,

An awesome library. Thanks!

This is more of a question than a bug. I've to create an object, more like `z.object`. But I want to restrict the keys of that object based on an Enum. For instance,

```
const enum ReferenceEntity {
  TestA = ""testA"",
  TestB = ""testB""
}
```
Then in TS, I can define a  object like 
```
const obj = { [key in ReferenceEntity]: string }
```

How can I achieve this using `zod`? 

I've defined enum in `zod` using 
```
const ReferenceEntityZod = z.nativeEnum(ReferenceEntity);
```

How do I create `obj` now using `zod`?",,
976146079,600,"Error ""Intersections only support objects"" when using transformation and passthrough","Zod version 3.7.2.

Code sample to reproduce the issue

```typescript
const left = z.object({}).passthrough();
const right = z.object({
  id: z.string().transform((str) => parseInt(str))
});
const schema = z.intersection(left, right);
schema.parse({
  id: '123'
});
```

Throws an error
```
ZodError: [
  {
    ""code"": ""invalid_intersection_types"",
    ""path"": [],
    ""message"": ""Intersections only support objects""
  }
]
```

The error itself is not clear enough, since **I'm certainly intersecting objects**.

After debugging it on the source code I figured out that perhaps it happens because parsed type on the `left` is `{id: string}` and on the `right` is `{id: number}`.
So it considers the field `id` to have unmatched types. But the error does not have a reference to the field: `path` is empty.

At the same time `left` does not declare the type of `id` field, it just passes the unknown fields through, so I'd say it should have less ""priority"" in the intersection.

I'd like to request the improvement of the intersection algorithms.
Maybe it should intersect object shapes before parsing their field types?",,
975589174,598,operations to check subset and identity of types,"I find myself with the use case to check whether a Zod type is a subset of another Zod type, and also, to help implement it, whether a Zod type is identical to another Zod type. I saw in the code earlier versions of Zod had an `.is` operation that has been removed.

So given:

```typescript
const main = z.object({foo: z.string(), bar: z.string()});
const a = z.object({foo: z.string()});
const b = z.object({foo: z.number()});
const c = z.object({other: z.string()});
```

Then:

```
a.isSubset(main) // true, as foo is in main and the same type
b.isSubset(main) // false, as foo is not the same
c.isSubset(main) // false, as other is not present in main
```

This might get hairy with intersection types, though I'm not particularly concerned with this right now. Is anyone working on anything like this or is there a solution already?

",,
965635641,581,Factory function that takes any zod schema and returns parsed result with inferred type,"I'm trying to make a create validator factory function that basically formats valid or invalid parsed input according to a set interface. 

I can't figure out how to get the inferred type from any zod schema. Pretty sure it has to do with the `z.AnyZodObject` but don't know what to use in it's place:


```typescript

type ValidateResult<T> =
	| {
		isValid: true;
		validatedResult: T;
	  }
	| {
		isValid: false;
		errorType: string;
		message: string;
	  };

export const makeZodValidator = (schema: z.AnyZodObject) => {
	return (payload: {
		[key: string]: any;
	}): ValidateResult<z.infer<typeof schema>> => {
		try {
			const res = schema.parse(payload);  
			return {
				isValid: true,
				validatedResult: res,
			};
		} catch (error) {
			if (error instanceof z.ZodError) {
				return {
					isValid: false,
					errorType: 'Zod validation error',
					message: JSON.stringify(error.issues, null, 2),
				};
			}
		}
	};
};
```

I want `res` to be the inferred type of whatever schema I passed in but is any object instead:

<img width=""216"" alt=""image"" src=""https://user-images.githubusercontent.com/25183985/128953938-06a4756a-2f81-4d16-b933-1b26d208f9c1.png"">
",,
965596881,580,Custom message for z.enum?,"Whats the best way of achieving a custom message when using `z.enum(['string', 'literals'])`? I tried to work it out myself but had no luck; using the custom messages for the other validators has been amazing",,
965355223,579,Auto infer type?,"I just started checking this library out and I think it's a really nice utility. I noticed some possible unnecessary code where I will define ""schemas"" and export them, I also have to have a second `type` export. What I was hoping for was a way to chain an optional method that returns an _inferred_ `type` as well as the value object.

Here is my code:
![image](https://user-images.githubusercontent.com/5973579/128930561-eccc1bd9-dd52-4edd-b0c9-38476b774e77.png)

What I would like to do is something like this:
![image](https://user-images.githubusercontent.com/5973579/128930639-e1d3b956-0606-412c-8475-293962849a4f.png)
",,
963481353,577,Recursive type: Type instantiation is excessively deep and possibly infinite. ,"I'm running into a problem creating a parser for a fairly simple recursive type. The following errors with `Type instantiation is excessively deep and possibly infinite.  TS2589`:

```
type V = [V] | ""Null""

const V : z.ZodSchema<V> = z.lazy(() =>
  z.union([
    z.tuple([V]),
    z.literal(""Null"")
]))
```

However a loosely similar type works fine:

```
interface V {
  a: [V]
}

const V : z.ZodSchema<V> = z.lazy(() => 
  z.object({
    a: z.tuple([V])
  })
)
```

The use of the Tuple is significant, using an array works fine for both.

I'd be willing to work on a pr but I had a poke around and didn't get far in finding out what causes this, if you have any tips on what might be causing it I can take another look.",,
961183293,575,Catchall override shape properties on inferred typescript type,"Hi all!

With zod v3.5.1, running the following code throw a TS2322 typescript exception:

```typescript
import { z } from ""zod"";

const ZodEntity = z.object({
  name: z.string(),
}).catchall(z.number())

export type Entity = z.infer<typeof ZodEntity>;

const e01: Entity = {
  name: 'my_name'
}
```

Typescript error:
```
error TS2322: Type '{ name: string; }' is not assignable to type '{ [x: string]: number; name: string; }'.
  Property 'name' is incompatible with index signature.
    Type 'string' is not assignable to type 'number'.
```

I would expect the `catchall()` function to not alter the type definition for the property `name`. Is this a bug or am I doing things wrong ?

Thanks :)",,
959549226,572,Stack Trace in Async Zod Function,"Currently, async zod functions do not produce a useful stack trace when their validation fails. The trace generally contains only zod internals, looking something like this... 

```
Error: [
  {
    ""code"": ""invalid_arguments"",
    ""argumentsError"": {
      ""issues"": [
        {
          ""code"": ""too_small"",
          ""minimum"": 1,
          ""inclusive"": true,
          ""type"": ""array"",
          ""path"": [],
          ""message"": ""Should have at least 1 items""
        }
      ]
    },
    ""path"": [],
    ""message"": ""Invalid function arguments""
  }
]
    at new ZodError (/Users/USERNAME/PROJECT/node_modules/zod/lib/ZodError.js:75:28)
    at handleArgs (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:1786:23)
    at ZodFunction.<anonymous> (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:1817:49)
    at step (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:59:23)
    at Object.next (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:40:53)
    at fulfilled (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:31:58)
```

Async function validation should be reworked slightly to produce a more usable stack trace",,
958009772,571,Property 'toJSON' is missing in type 'ZodObject<...>',"With the help of this comment (https://github.com/colinhacks/zod/issues/392#issuecomment-826227242) I wrote a little helper function that looks like this:

```typescript
export default function validateSchema<T extends z.ZodTypeAny>(
    schema: T,
    payload: unknown
): z.infer<typeof schema> {
    const validation = schema.safeParse(payload);
    if (validation.success) {
        return validation.data;
    } else {
        console.log(error);
        throw error;
    }
}
```

After months I updated my zod version and now TypeScript complains with the following error whenever I want to invoke the function, even though it used to work:

```
Argument of type 'ZodObject<{ createdAt: ZodString; lsi1: ZodOptional<ZodString>; pk: ZodString; sk: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodTypeAny'.
  Property 'toJSON' is missing in type 'ZodObject<{ createdAt: ZodString; lsi1: ZodOptional<ZodString>; pk: ZodString; sk: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' but required in type 'ZodType<any, any>'.ts(2345)

base.d.ts(72, 14): 'toJSON' is declared here.
```

This is how I call `validateSchema`:

```typescript
const schema = z.object({
    createdAt: z.string(),
    lsi1: z.string().optional(),
    pk: z.string(),
    sk: z.string(),
});

validateSchema(schema, { some: ""payload"" });
```

How can I update `validateSchema` to work as intended?",,
957308205,567,Change z.Object by function,"Hello,
I'm trying to create a function to change a zod object dynamically and to use type infer after that:
```
export function changeSchema<T extends z.AnyZodObject>(schema: T) {
  schema.setKey('newKey', z.string());
  return schema;
}
const object = z.object({ key: z.string() });
const modifiedObject = changeSchema(object);
```
But the result not contains the added key `'newKey'`
Could you advise me on how to get it working?",,
956862445,566,Zod Template Literal Types,"TypeScript 4.1 introduced template literal types, so we could define types like: 

```ts
type DateString = `${number}-${number}-${number}`;
```

It would be very cool if Zod allowed us to infer literal types. I'm not sure extending the current `literal` for this purpose is the best approach, but perhaps a new `templateLiteral` method that might look like:

```ts
const dateString = z.templateLiteral(z.number(), z.literal('-'), z.number(), z.literal('-'), z.number());
```

The above isn't as clean as defining a template literal type in TypeScript, but Zod will need some way of understanding the literal sequence and I wonder if the above format would make sense for it.

Do you think supporting template literal type checks and inference using `z.infer` is something on the horizon? Thank you!",,
954567809,561,Create union from array,"I have an array of some codes (just a numbers) and I want to validate that object field contains one of them.
For example:
```
const HTTP_SUCCESS = [200,201];
```

In superstruct I can use `enums` function to do this:
```
const response = type({
   code: enums(HTTP_SUCCESS),
})
```

I tried to do something like:
```
const response = z.object({
    code: z.union(HTTP_SUCCESS.map(z.literal))
})
```
But this doesn't work because result of the map is an array, while z.union requires a tuple.",,
952733212,556,Zod not working when imported across packages,"We ran into an issue when upgrading from 3.2.0 to 3.5.1, that when we're importing Zod defined schemas across our package boundaries (which just means that Zod is installed multiple times, once in each package that uses it) Zod breaks and the validation doesn't actually run.

I've put together a small repo to reproduce this: https://github.com/krivachy/zod-object-bug

The setup is:
- There are two packages in the `packages/` directory
- packageA contains a validation: [zEmail](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageA/src/emailValidation.ts)
- packageB contains a model that uses zEmail: [models.ts](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageB/src/models.ts)
- test fails when it's imported, but passes when it's locally defined: [index.test.ts](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageB/index.test.ts)
- The same version of Zod is installed in both [packageA](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageA/package.json) and [packageB](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageB/package.json)

If we install Zod once at a root package.json level it seems to work, but we'd like to have our packages define their own dependencies.

Other libraries work perfectly fine this way, so I'm a bit confused as to why Zod breaks with this setup? Any advice would be much appreciated, thanks!",,
951161972,549,Unable to extend/merge schema when using `z.Schema<Type>` ,"Apologies if this is already been reported or is something that cannot be fixed, I wasn't able to find it in the issues.

Assume you have the below schema:
```ts
interface Person {
    firstName: string,
    middleName?: string,
    lastName?: string,
    age: number,
    email?: string   
}

interface Employee extends Person {
    employeeId: string,
    manager: string
}
```

If you wanted to construct the Employee Schema to extend the PersonSchema, you are unable to do so if you create your schema with the type `z.Schema<Person>` as the `.extend` method apparently does not exist on the type `z.Schema<Person>`.

[Example with `z.Schema` (TS Playground)](https://www.typescriptlang.org/play?target=99&jsx=0&module=1#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFwAdjAKZSYCGAxvXAAqMDOENiCnGFZgUHjAByzEPQBccCVFoBzADRCRIYMWIAbetNkB+BUtUaRcPcwlH6pxTGU11m4cxXy4NAK4gAI0ZLEXoQZmA9R3NXEQo0KloGJjYOAFFwPQgAT3oOegAPBhpiHi5efkErMLAs3PoASWIzZwt3OHCaT0YWlxV4qlZ+CXLxfgBlVgALMOYFZAA6SZnwgB5uMZoAPjgAXhQFiACAK3pWGAAKBHbMMTsZb0WYlQuAShDhbV0De3mF57ehzAMGA-GYejeH2stikDz+APe7W6fz8gUYgO0NAuAAZEdVwpF4a1XIDZpFARBgaCuhDXvE6RQhjQRhlajk8stZn9OWtWXU8jt9hs+DQecwFoVisQru0avzGs0DgioZ1ulAiX03nB6UA)

[Example without `z.Schema` (TS Playground)](https://www.typescriptlang.org/play?target=99&jsx=0&module=1#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFwAdjAKZSYCGAxvXAAqMDOENiCnGFZgUHjAByzEPQBccCVFoBzADRCRIYMWIAbetNkB+BUtUaRcPcwlH6pxTGU11m4cxXy4NAK4gAI0ZLEXoQZmA9R3NXEQo0KloGJjYOAFFwPQgAT3oOegAPBhpiHi5efkErMLAs3PoASWIzZwt3OHCaT0YWlxV4qlZ+CXLxfgBlVgALMOY4AF4UADoIAIArelYYAAoEdswxOxlvZCWYlW2AShDhbV0DewVT86uVsBhgfmY9K5vrWykxyeZ1arl+7W6wL8gUYr20NG2AAZru1ZpFgS9Lks0T8sRB3p8urj4pdBsN4Blajk8pMZuEFqM+DRabNsUV6CVdqjMtTGs1lpi-p1ulAMaCLpc4CSgA)",,
946124621,541,Intersection cannot be assigned to `Schema` type,"Since v3.3 it is not possible anymore to give an explicit type definition for schemas of intersection types.The following code fails to type check.

~~~typescript
import * as zod from ""zod""

interface Foo {
  foo: string;
}

const fooSchema = zod.object({
  foo: zod.string(),
});

interface Bar {
  bar: string;
}

const barSchema = zod.object({
  bar: zod.string(),
});

const interSchema: zod.Schema<Foo & Bar> = fooSchema.and(barSchema);
~~~

Typescript produces the following error
~~~plain
index.ts:19:14 - error TS2322: Type 'ZodIntersection<ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }>, ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<Foo & Bar, ZodTypeDef, Foo & Bar>'.
  The types returned by '_parse(...)' are incompatible between these types.
    Type 'ParseReturnType<ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ParseReturnType<Foo & Bar>'.
      Type 'OK<ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ParseReturnType<Foo & Bar>'.
        Type 'OK<ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'OK<Foo & Bar>'.
          Type 'ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'Foo & Bar'.
            Property 'foo' is missing in type 'ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' but required in type 'Foo'.

19 const interSchema: zod.Schema<Foo & Bar> = fooSchema.and(barSchema);
                ~~~~~~~~~~~
~~~

A workaround is to use `.merge`.

~~~typescript
export const interSchema2: zod.Schema<Foo & Bar> = fooSchema.merge(barSchema);
~~~

However, this requires `fooSchema` to be an object and is not possible if `fooSchema` itself is annotated with `Schema<Foo>`.",,
944906390,540,"[Question]: Typing advice for `superRefine()` methods on an obj, when the method provided is separated from the schema definition","Hello, new to TS and zod. Is it common practice to keep all logic coupled within the definition?

I am used to extracting out anything lengthy as may be the case for when using `.superRefine()`, but in that case I'm not sure what the advised approach is for handling typing to keep TS happy?

These are the two approaches I'm aware of, but perhaps there's a better way?

**Anonymous function has implicit typing from inference?:**
```ts
const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
}).superRefine(
  (zobj, ctx) => { ... }
)

type Dog = z.infer<typeof dogSchema>
```

**Redundantly define the type anyway? (or at least for the values of interest in zobj):**
```ts
// Required to duplicate type definition...?
type zDog = {
    name: string;
    neutered: boolean;
}
const refineDog = (zobj: zDog, ctx: z.RefinementCtx) => { ... }

const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
}).superRefine(
  refineDog
)

type Dog = z.infer<typeof dogSchema>
```

**Infer the type, but splits the schema into two stages:**
```ts
const _dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
})

// Better approach for large schemas?
type zDogRefine = (
   zobj: z.infer<typeof _dogSchema>,
   ctx: z.RefinementCtx
) => void
const refineDog: zDogRefine = (zobj, ctx) => { ... }

// Re-declaration of schema because type needed to be inferred to satisfy method provided to superRefine()
const dogSchema = _dogSchema.superRefine(refineDog)

type Dog = z.infer<typeof dogSchema>
```",,
944713708,537,Add .promise() to ZodType,"z.function() is remarkably useful for writing typesafe functions. Often these functions will be async, thus the return type will be a promise. Adding a .promise() method to the base class ZodType would enable syntax like 

```js
const getUsernameById z.function
    .args(number())
    .returns(z.string().promise())
    .implement(async id => {
        ...
        return username
    })
```

This would be a bit more ergonomic for the developer frequently writing async function definitions. ",,
941379330,533,"Inferred all object properties are optional, when use strict: true","zod version: ^3.5.1
ts version: ^4.3.5

I saw #121 #276 #289 #498

And I tried this code.

```json
{
  ""compilerOptions"": {
    ""target"": ""es5"",
    ""lib"": [""dom"", ""dom.iterable"", ""esnext""],
    ""allowJs"": true,
    ""skipLibCheck"": true,
    ""strict"": true, // <- changed
    ""strictNullChecks"": true, // <- added just in case
    ""forceConsistentCasingInFileNames"": true,
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""module"": ""esnext"",
    ""moduleResolution"": ""node"",
    ""resolveJsonModule"": true,
    ""isolatedModules"": true,
    ""jsx"": ""preserve""
  },
  ""include"": [""next-env.d.ts"", ""**/*.ts"", ""**/*.tsx""],
  ""exclude"": [""node_modules""]
}
```

```ts
const User = z.object({
  username: z.string(),
})

type UserType = z.infer<typeof User>
```

The result is here.

![Screen Shot 2021-07-11 at 14 42 40](https://user-images.githubusercontent.com/13712715/125184137-49505b80-e256-11eb-944f-3734c118cf18.png)

I expected

```ts
{username: string}
```

Is there some my mistake?",,
940409940,528,"Zod 3 regression ""Cannot read property '_parse' of undefined""","I have been trying to get more information, but I cannot isolate this bug.

```
TypeError: Cannot read property '_parse' of undefined
    at ZodObject._parse (/Users/ellis.berner/src/chatbot/node_modules/zod/src/types.ts:1492:22)
    at ZodObject.ZodType._parseSync (/Users/ellis.berner/src/chatbot/node_modules/zod/src/types.ts:102:25)
    at ZodObject.ZodType.safeParse (/Users/ellis.berner/src/chatbot/node_modules/zod/src/types.ts:125:25)
    at ZodObject.ZodType.parse (/Users/ellis.berner/src/chatbot/node_modules/zod/src/types.ts:113:25)
    at Object.queryBotUserInformation (/Users/ellis.berner/src/internal/src/internal.ts:86:69)
```

It appears when trying to _import_ Zod Schema's only, if I copy the Schema definitions over to the same file, the issue is alleviated. It's completely bizarre. 

v3.5.0

My schema, where Token and UserInfo are simple objects, that if I bring into the same file, (not imported) everything works. 

```ts
export const MetaData = z.object({
  token: Token,
  userInfo: UserInfo,
  selectedAccountId: z.string().optional(),
  locale: z.string().optional(),
});
```

What the heck is going on?
",,
938093174,522,Add Type Discriminator to ZodType,"Occasionally, users want to map a zod type to some other value. This problem comes up in mocking, getting defaults, generating ui from zod types, etc. Whenever a user is mapping zod types, it is useful to have an accurate typescript type for the result. For this to be possible, it seems to me that the typescript types for each option in ZodFirstPartySchemaTypes should be non-overlapping. This avoids situations like the following...

```js
import { z } from 'zod';

type myType = z.ZodAny extends z.ZodNull ? true : false; // true

const myValue = z.any() instanceof z.ZodNull; // false
```

Here, I believe ZodAny is meant to be a distinct type from ZodNull, but it is inferred as extending ZodNull.

My proposed fix is adding a type discriminator to the _def of all ZodFirstPartySchemaTypes. Something like, ```{ typeName: ""ZodString"" }```",,
937902232,520,Breaking change to typedef of `_refinement` & `superRefine` in 3.3.0,"After upgrading from `3.2.0` to `3.3.4` I started getting Typescript compilation errors on my `_refinement`-calls.
The new behavior seems to have been introduced in `3.3.0`, and also affects the `superRefine` method.

The behavior can be seen in the example you have in the README for `superRefine`:
```
const Strings = z.array(z.string()).superRefine((val, ctx) => {
  if (val.length > 3) {
    ctx.addIssue({
      code: z.ZodIssueCode.too_big,
      maximum: 3,
      type: ""array"",
      inclusive: true,
      message: ""Too many items 😡"",
    });
  }

  if (val.length !== new Set(val).size) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `No duplicated allowed.`,
    });
  }
});
```
This yields the following Typescript error on the method passed in to `superRefine`/`_refinement`:
`Argument of type '(val: string[], ctx: RefinementCtx) => void' is not assignable to parameter of type '(arg: string[], ctx: RefinementCtx) => boolean | Promise<boolean>'.
  Type 'void' is not assignable to type 'boolean | Promise<boolean>'.ts(2345)`

I can't see that this is mentioned in any changelog/readme, so it might be an unintentional change?

FYI, my Typescript version is `4.3.5`.",,
937545838,519,`infer` incorrectly marks property as `required` for `any().optional()` after upgrading to v3.3.4,"After upgrading from v3.2.0 to v3.3.4, for an object like ->
```
const TestSchema = z.object({
  options: z
    .object({
      message: z.string().optional(),
      convertOption: z.string().optional(),
      displayOrder: z.any().optional(),
    })
    .optional(),
})
```
and
`z.infer<typeof TestSchema>` 
results in 
`{options?: {message?: string | undefined, convertOption?: string | undefined, displayOrder: any} | undefined}` 
instead of marking `displayOrder?: any`

Using `number` or `string` instead of `any` marks it as optional correctly.",,
936490355,518,`infer` adds `[x: string]: any;` to type even for strict objects,"```
import { ObjectId } from 'mongodb';
import * as z from 'zod';

export const TestSchema = z.strictObject({
    _id: z.instanceof(ObjectId),
    test: z.string().nonempty(),
});

export type Test = z.infer<typeof TestSchema>;
```
results in:

```
export type Test = {
    [x: string]: any;
    _id: ObjectId;
    test: string;
};
```

Which is problematic for MongoDB `insertOne` operations, as they cannot successfully make the `_id` optional. When I handcraft the type to

```
export type Test = {
    _id: ObjectId;
    test: string;
};
```

it works fine. But that means I would need to add thousands of lines of code to our project.

Any idea on how we can solve this?

It worked fine with Zod 2.

Edit: The problem gets introduces with 3.3.x. I downgraded tp 3.2.0 and it works fine now.",,
936468388,517,How to I get the value of a ZodLiteral?,"I have an example union like this:

```typescript
const example = z.union( [
    z.literal( 'A' ),
    z.literal( 'B' )
] );
```

What would be the correct way to get all the options as a string array like `('A' | 'B')[]`?

Some of my attempts include:
```typescript
const exampleOptions = example.options.map( ( literal ) => literal._def.value );
const exampleOptions = example.options.map( ( literal ) => literal._type );
const exampleOptions = example.options.map( ( literal ) => literal._input );
const exampleOptions = example.options.map( ( literal ) => literal._output );
```

Are any of my attempts valid or is there perhaps a better way? What are the differences between those methods?",,
936406653,515,There is no way to determine that an error thrown is a `ZodError`,"In Zod v1, to determine whether a thrown error is an error thrown by Zod, I did `if (error.constructor.name === 'ZodError') {...}`.

In Zod v3, this is not possible anymore (at least when importing the module using ESM), because you minimize the source code, and the name of the constructor becomes `""n""` 😬.

Would love it if there was a way to know if the error is a Zod error. As a suggestion, have the `code` values all start with a `ZOD_ERROR` prefix, or have an `isZodError` field in the error, or perhaps even ensure that the constructor name will still be `ZodError`.

Currently, I'm working around this by a heuristic: checking that the error has a `path` property that is an array. 😱

BTW, kudos for adding ESM support! 🎉",,
936309696,513,[Question]: Usage of exclamation marks for ZodType readonly fields,"First of all, thank you for this amazing package 🙏 

I've been reading through your code and stumbled upon an unfamiliar syntax:

<img width=""466"" alt=""Screen Shot 2021-07-03 at 2 55 01 PM"" src=""https://user-images.githubusercontent.com/10621548/124364333-d79d5f80-dc0e-11eb-95d9-a6787c45ae97.png"">

What do the exclamation marks do? What is this syntax / token called?",,
935366890,510,question: contextual transforms,"Hi, so I have to design a parser that changes some values based on other values passed in. This is best illustrated with an example:

```ts
import { z } from 'https://deno.land/x/zod@v3.2/mod.ts'

const Percentage = z
  .string()
  .regex(/\d+%/)
  // I want transform to use .size.width or size.height here
  .transform((str) => parseFloat(str.slice(0, -1)) / 100)

const Pixels = z.string().regex(/\d+px/).transform(str => parseFloat(str.slice(0, -2)))

const Canvas = z.object({
  size: z.object({ width: z.number(), height: z.number() }),
  points: z.array(
    z.object({
      x: z.union(Pixels, Percentage),
      y: z.union(Pixels, Percentage),
    })
  ),
})

const canvas_data = Canvas.parse({
  size: { width: 200, height: 100 },
  points: [
    { x: '100%', y: '0%' },
    { x: '90%', y: '0%' },
    { x: '80%', y: '0%' },
  ],
})

console.log(canvas_data)
```

so what zod outputs is this:
```js
{
  size: { width: 200, height: 100 },
  points: [ { x: 1, y: 0 }, { x: 0.9, y: 0 }, { x: 0.8, y: 0 } ]
}
```

but in reality, I need the x and y values to be based off of width & height. E.g. 
```js
[ { x: 1 * 200, y: 0 * 100 }, { x: 0.9 * 200, y: 0 * 100 }, { x: 0.8 * 200, y: 0 * 100} ]
```

the obvious answer is to tack on some custom parsing logic _after_ the zod parsing step. The issue though is that in the example above, I have a union, inputs can be `100px` or `100%`. So for a secondary parser to know that we are dealing with a percentage rather than a pixel, I would need to tack on type info to the zod parser step:

```js
const Percentage = z
  .string()
  .regex(/\d+%/)
  .transform((str) => {
    const value = parseFloat(str.slice(0, -1)) / 100
    return { type: 'percentage', value }
  })

...
const canvas_data = Canvas.parse(...)
const parsed_points = canvas_data.points.map(p => {
  let x = p.x.value
  let y = p.y.value
  if (x.type === 'percentage') x = x * canvas_data.width
  if (y.type === 'percentage') y = y * canvas_data.height
  return { x, y }
}
```


instead, I was wondering if there is a better option that I can build off of zod. Essentially it would be great if I could use the already evaluated parts of a zod result in the transform step:
```ts
const PercentageX = z
  .string()
  .regex(/\d+%/)
  .transform((str, partial_resul) => {
    const value = parseFloat(str.slice(0, -1)) / 100
    return value * partial_result.size.width
  })
```
is something like this possible with zod?",,
935356839,509,bug: .transform() incorrectly changes ZodSchema,"the following snippet fails with error below. Adding a `.transform` method to a zod schema will alter the input type, when it should be only be altering the output type. The output type seems to correctly be just `number`.

```ts
import { z } from 'https://deno.land/x/zod@v3.2/mod.ts'

const percentage_parser = z.string().regex(/\d+%/).transform(str => parseFloat(str.slice(0, -1)) / 100)

function get_percentage(input: z.infer<typeof percentage_parser>) {
  return percentage_parser.parse(input)
}

const result: number = get_percentage('100%')
```

```
error: TS2345 [ERROR]: Argument of type 'string' is not assignable to parameter of type 'number'.
const result: number = get_percentage('100%')
```

here is a screenshot showing the full zod type declaration:

![screenshot(653)](https://user-images.githubusercontent.com/6627147/124212019-27b7dd00-dabc-11eb-9ec9-7e604499f694.png)
",,
935181277,508,Merge behavior substitute in zod 3?,"## Problem

Since `merge` method receives the same behavior than `extend` in `zod 3` I'm having some problems by merging two objects with same property key using `.and` intersection method. Look the following example:

```typescript
const Animal = z.object({
  properties: z.object({
    is_animal: z.boolean()
  })
});
const Cat = z.object({
  properties: z.object({
    jumped: z.boolean()
  })
}).and(Animal);

const cat = Cat.parse({ properties: { is_animal: true, jumped: true } });
assert.isDefined(cat.properties.jumped); // is not defined, only is_animal is defined
```
There's a way to get the same behavior of old `merge` from `zod 2` in `zod 3` considering this scenario? Using `zod 2` and `merge` method, the `properties` field is merged with both sub-fields.

**Version:** 3.2.0

## Workaround

The workaround that I found basically is something like this (but don't appear to be the best solution in the case you have more than one field):

```typescript
const Cat = z.object({
  properties: z.object({
    jumped: z.boolean()
  }).merge(Animal.shape.properties)
});
```",,
931802222,505,Zod 3 `transform` breaking change,"In version 2 we utilised `zod.transform` method to transform an object into an array, and validated each array item. Using `zod.array` directly resulted in parse error 'Expected an array, received object'.

Background: in Ember Data `hasMany` relations are essentially objects, but semantically they represent collections: they treat themselves as array-like structures with implementation of `map`, `filter` and others, and capable of returning a true array via `toArray` method.

Version 2 code:
```typescript
interface SyncHasMany<T> {
  // ...
  toArray(): T[];
}

function hasMany<T extends zod.ZodTypeAny>(itemSchema: T): zod.ZodTransformer<zod.ZodUnknown, zod.ZodArray<T>> {
  return zod.unknown().transform(
    zod.array(itemSchema),
    // In case it is hasMany we should convert it to plain Array so Zod can digest it.
    rel => Array.isArray(rel) ? rel as zod.TypeOf<T>[] : (rel as SyncHasMany<zod.TypeOf<T>>).toArray(),
  );
}
```

But in ver. 3 this approach is no longer available. The question is how can I achieve the same result now? I want zod to validate a `hasMany` relation using `zod.array(itemSchema)` schema as if the content of this relation was a plain array. ",,
931177763,504,"When using unions, .parse will not match to the correct type","Please see the example here: https://github.com/markhughes/zod-bug-minimum-repro

You will notice our union here:
https://github.com/markhughes/zod-bug-minimum-repro/blob/main/src/model.ts#L100-L112

We use this in our validator:
https://github.com/markhughes/zod-bug-minimum-repro/blob/main/src/validators.ts#L5-L15

Here is an example with the `accountId` key which would only match `CakeAcruSchema`:

https://github.com/markhughes/zod-bug-minimum-repro/blob/main/src/index.ts#L5-L31

When we run this, it seems to strip it out and revert to the base format:

```
$ ts-node src/index.ts
Starting test...
cakes in:
[{""cake"":{""accountId"":""f8abcccc"",""firmId"":""483e0314"",""icon"":""Acru"",""mixerId"":""787521c1"",""name"":""Default Cake"",""cakeId"":""ea4ededc"",""cakeType"":""Acru""},""recipients"":[{""firstName"":""Mark"",""lastName"":""Hughes"",""email"":""m@rkhugh.es"",""accessType"":1}]}]

cakes parsed:
[{""cake"":{""cakeId"":""ea4ededc"",""mixerId"":""787521c1"",""cakeType"":""Acru"",""name"":""Default Cake"",""icon"":""Acru""},""recipients"":[{""firstName"":""Mark"",""lastName"":""Hughes"",""email"":""m@rkhugh.es"",""accessType"":1}]}]    
Done in 2.85s.
```

However, if we go back to our union:
https://github.com/markhughes/zod-bug-minimum-repro/blob/main/src/model.ts#L100-L112


And move `CakeAcruSchema` under `CakeApplesSchema` - it seems to parse properly.

What has happened here? ",,
925452061,498,All object properties are optional by default,"```ts
const User = z.object({
  username: z.string(),
})

type User = z.infer<typeof User>
```
Current result
```ts
type User = {
  username?: string
}
```

Expected  result
```ts
type User = {
  username: string
}
```",,
920991727,496,Cannot use `extend` across multiple files,"I have a `lib/model` directory that contains all of my data model defined with `zod`. I prefer to define one data model per file and then import those data models for re-use across files, like so:

```typescript
// lib/model/resource.ts
import { z } from 'zod';

export const Resource = z.object({
  created: z.date(),
  updated: z.date(),
});
```

And then I can import and re-use that `Resource` object as a base model:

```typescript
// lib/model/account.ts
import { z } from 'zod';
import { Resource } from 'lib/model/resource';

export const Account = Resource.extend({
  id: z.string(),
  name: z.string(),
  phone: z.string().regex(/^(\+\d{1,3})\d{10}$/),
  email: z.string().email(),
});
```

But whenever I try to do that ☝️ (i.e. import and extend `Resource` in another file), I get the following TypeScript error in my IDE:

```
Property 'extend' does not exist on type 'typeof Resource'.
```

It's totally fine when I use `Resource.extend` in the same file that `Resource` is defined in (i.e. `lib/model/resource.ts`), but as soon as I try to use it outside of that file (e.g. in `lib/model/account.ts`), I get that ☝️ TypeScript error. I'm guessing this is because `zod` makes the `typeof Resource` only contain the keys that I defined (which makes sense and is the desired behavior when importing and using the data model normally... unless I am defining another data model that extends it OFC... which is my problem here). Is there a way that I can split my definitions over multiple files and avoid this TypeScript error?",,
920962882,495,"""semantic error TS2589: Type instantiation is excessively deep and possibly infinite"" with Zod 3.2","For a simple type such as:-
```
export const ZCustomer = z.object({
	name: ZString()
});
```
where ZString is:-
`export const ZString = () => z.string().min(1)`

I am getting a typescript error:-
> semantic error TS2589: Type instantiation is excessively deep and possibly infinite

I am using typescript 4.3.2 with Zod 3.2.0 in a tsdx 0.14.1 setup. Not sure what's wrong here.",,
920595926,493,Unknown fields are optional,"This looks like a spec bug, tsc's `unknown` means ""I don't care what's there as long as there's something"". Meanwhile with Zod:

```tsc
const x = z.object({ a: z.unknown() });
// type T = {a?: unknown}
type T = z.infer<typeof x>;
```

Do you agree that this is a bug? Should we fix it in place, or surface a new combinator in order not to break backwards compatibility?",,
915016793,487,Add a custom context field to ParseParams,"I would like to add an extra field called something like userContext to ParseParams which is passed to all parse and later refine calls. The idea behind this is allowing to set something like a API client as context which could be used with refine. Small example:

```
interface UserService {
  checkUniqueEmail(mail: string): Promise<boolean>;
}

const uniqueEmail = z.string().superRefine(async (mail, ctx) => {
  const userService = ctx.userContext as UserService;
  return await userService.checkUniqueEmail(mail);
});
```",,
913634512,486,Allow defining a different key into the final destination object after parsing,"Right now **zod** is becoming more and more an integral part of all my projects, however, there's still a pretty common use case that doesn't have a direct mapping in **zod**, basically, allowing to validate a different schema than the output one. 

Most of the times, in TypeScript codebases, interfacing with an API involves firing a `fetch` request and validating the received data to make sure it corresponds to the shape we're defining in our types. Zod is really great for this due to it's practically 1:1 equivalence with TS typings. However, sometimes, the types we receive from the request don't correspond directly to the types we've defined in our codebase (legacy code, different naming schemas, etc.) and that forces us to having to create yet another layer after validation to do processing. 

So I was wondering, if it'd be possible and zod architecture would allow to define a way to ""collect"" keys from the input data and ""assign"" them to another key in the resulting data. 

For example, let's imagine we're building a front-end app using TypeScript (camel case naming) and we request data to our back-end in Rails (snake case naming). Without the functionality described above, we have two solutions (without counting the one that is leaving the naming as is for obvious reasons):

 - Validate the data and then transform the data, so our validators will refer to something that doesn't really exist in the app
 - Transform the data and then validate having to transform loosely typed data.

However, adding this functionality to zod, we could do it in just one single step and correctly coupling these two non-independent descriptions thus also providing clarity of intent. 

An idea:

```ts
const UserSchema = z.object({
  firstName: z.fromKey('first_name').string()
});
```

The code above will validate that `first_name` is present and is a string, while at the same time, producing a `firstName` key with the correctly validated data.",,
912928915,485,Reduce library size [Question] [Enhancement],"At first — thank you for this awesome project.

Recently I debug my bundle and recognise that zod is almost the same as react-dom library and it's 114kb non gziped code. I use latest version of zod 3.1.0.

Used named import of all zod, but also tried something like `import { string } from 'zod'` with the same result

```
import { z } from 'zod';

export const linkShema = z.object({
  title: z.string(),
  link: z.string(),
});

```

Is it possible to remove at least unused parts of code from my bundle, because 100+ kb it's a lot.

<img width=""702"" alt=""image"" src=""https://user-images.githubusercontent.com/1213198/120937581-f34c3d80-c716-11eb-990f-c51c14f7bdaa.png"">
",,
912042567,484,feature request: 'shape'-like method for array(),"You can get the shape of an object schema but I don't see a way to get the schema for `array` items? Maybe:

- `array.shape`
- `array.unpack` (to follow the typescript terminology)
- `array.item` or `array.each`

I suppose the same could be asked about `record()`, etc.?",,
909050174,481,error throwing in custom json string validation,"I'm dealing with a case that json string inside json.  Below are the parsing code. 
And i'm using the zod v3 library.

```js
import * as z from 'zod';

class JsonStr<T extends z.ZodTypeAny> extends String {
  constructor (val: string, obj: T) {
    super(val)
    const valobj = JSON.parse(val)
    this.jsVal = obj.parse(valobj)
  }
  jsVal: ReturnType<T['parse']>
}

const jsonString = <T extends z.ZodTypeAny>(obj: T) => {
  return z.string().transform((val) => {
    return new JsonStr(val, obj);
  });
};

const USchema = z.object({
  type: z.literal(1),
  key1: z.string(),
  key2: jsonString(z.object({
    key2plus: z.string()
  })),
  // key2: number()
})
.or(
  z.object({
    type: z.literal(2),
    key1: z.string(),
    key2: z.string()
  })
)

const testData = [
  {
    type: 1,
    key1: 'key1',
    key2: JSON.stringify({
      key2plus: 'key2plus'
    })
  },
  {
    type: 2,
    key1: 'key1.1',
    key2: 'some random str'
  },
]

testData.forEach((v) => {
  const parsed = USchema.parse(v) // throws JSON.parse exception
  console.log(parsed)
})
```

**How to solve the error, many thanks!**

",,
906567440,476,"Migrating from zod 1 to zod 3, got `refine` stack depth error.","Hello! I updated zod from `^1.11.16` to `^3.1.0` and I get a stack depth error when using `refine`

```javascript
import * as z from ""zod"";
import zxcvbn from ""zxcvbn"";

const createUserSchema = z.object({
  firstName: z
    .string()
    .min(1, ""First Name is required"")
    .max(16, ""First Name is too long""),
  lastName: z
    .string()
    .min(1, ""Last Name is required"")
    .max(16, ""Last Name is too long""),
  email: z.string().email(""Must be a valid email""),
  password: z
    .string()
    .min(1, ""Must be a valid password"")
    .max(48, ""Password is too long"")
    .refine((password) => zxcvbn(password).score > 2, ""Password is weak""), // zxcvbn(string).score returns an integer from 0-4
  hearAboutUs: z
    .string()
    .regex(/^(none|ads|work|recommendation|other){1}$/, ""Invalid option"")
    .optional(),
});
```

```
error TS2321: Excessive stack depth comparing types 'ZodError<?>' and 'ZodError<?>'.

 14   password: z
                ~
 15     .string()
    ~~~~~~~~~~~~~
...
 17     .max(48, ""Password is too long"")
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 18     .refine((password) => zxcvbn(password).score > 2, ""Password is weak""),
```

Any help would be appreciated, thanks!

**EDIT**: The issue hasn't got anything to do with `refine` in fact, if I delete the `password` key, it still throws the same error. Perhaps PR #472 attempts to solve this, I'm using TS 4.2.4",,
906082444,475,"`nonNullable` method that disallows `null` and `undefined`, like typescript's `NonNullable`","It's great to see that `unwrap` now exists! Thanks for adding it,

I had trouble finding `unwrap`, and the name isn't intuitive to me. I worry I'll have trouble finding it again in the future, since I don't use zod very often.

What do you think of adding an alias for `unwrap` called `nonNullable`? It was the first thing that came to mind for me when I was searching for this feature since Typescript has a utility type called [`NonNullable`](https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype).",,
903019213,473,zod doesn't work with typescript `4.3.2`,see #472 ,,
900988680,467,Complex type coercion,"We have an issue where we are using Zod to apply strong typing practices to our API layer

Trouble we have is using complex object over GET, as everything becomes a string over the wire. 

Are we able to attempt deep object coercion with Zod? Something like:

```typescript
const schema = z.object({example: z.number()})

const data = {example: '100'}

const coersedData = scheme.coerce(data) // {example: 100}

const brokenData = {example: 'lemon'}

scheme.coerce(brokenData) // Error
```",,
899910344,465,Schema extension - Migrate to Zod v3 from Zod v2,"Hello,

Like we talked in issue #464 I created a new issue for some help with migrating some schema class extensions from Zod v2 to Zod v3.

This code may be not in the ideal form, but it works correctly and was well-tested in development and by qa.

In summary:

- Extended ZodString:
  - Reimplemented the Zod native methods `regex`, `email` and `url` to ignore `undefined` or `null` values;
  - Added the methods `cpfCnpj`, `cep` e `telefoneCelular` to validate data in Brazilian formats;
- Extended ZodArray to add the method `unique`, to validate if the array contains only unique elements.
- Created `ErrorMap` and reexported the types.

I tried to remake this class following the patterns of Zod v3 types but it didn't work.

I suggest to add in docs a topic about schema extensions.

Thanks.

```javascript
/* eslint-disable no-useless-escape */
/* eslint-disable no-control-regex */
import * as z from ""zod"";
import validarCpfCnpj from ""./validar-cpf-cnpj"";

const emailRegex =
  /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
const urlRegex =
  /^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/i;

class CustomString extends z.ZodString {
  regex = (regexp, message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return regexp.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""regex"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  email = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return emailRegex.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""email"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  url = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return urlRegex.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""url"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  cpfCnpj = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return validarCpfCnpj(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""cpf_cnpj"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  cep = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return /^\d{8}$/.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""cep"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  telefoneCelular = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return /^\d{10,11}$/.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""telefone_celular"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  static create = () => {
    return new CustomString({
      t: z.ZodTypes.string,
      validation: {}
    });
  };
}

class NonEmptyCustomArray extends z.ZodArray {
  unique = (mapFn = (e) => e, message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return new Set(data.map(mapFn)).size === data.map(mapFn).length;
      },
      {
        code: z.ZodIssueCode.custom,
        type: ""array"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );
}

class CustomArray extends z.ZodArray {
  unique = (mapFn = (e) => e, message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return new Set(data.map(mapFn)).size === data.map(mapFn).length;
      },
      {
        code: z.ZodIssueCode.custom,
        type: ""array"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  nonempty = () => {
    return new NonEmptyCustomArray({ ...this._def, nonempty: true });
  };

  static create = (schema) => {
    return new CustomArray({
      t: z.ZodTypes.array,
      type: schema,
      nonempty: false
    });
  };
}

export const string = () => CustomString.create();

export const number = z.number;

export const boolean = z.boolean;

export const object = z.object;

export const date = z.date;

export const union = z.union;

export const literal = z.literal;

export const record = z.record;

export const array = (schema) => CustomArray.create(schema);

export const enumeration = z.enum;

export const relation = () =>
  z.object({ id: z.union([z.number(), string()]) }).nonstrict();

export const errorMap = (error, ctx) => {
  if (error.message) return { message: error.message };

  switch (error.code) {
    case z.ZodIssueCode.invalid_type:
      if (error.received === ""undefined"") {
        return { message: ""Campo obrigatório"" };
      }

      break;

    case z.ZodIssueCode.too_small:
      if (error.type === ""string"" && error.minimum === 1) {
        return { message: ""Campo obrigatório"" };
      }

      break;

    case z.ZodIssueCode.nonempty_array_is_empty:
      return { message: ""Deve conter no mínimo um registro"" };

    case z.ZodIssueCode.too_big:
      return { message: `Máximo de ${error.maximum} caracteres` };

    case z.ZodIssueCode.invalid_string:
      if (error.validation === ""regex"") {
        return { message: ""Regex inválida"" };
      } else if (error.validation === ""email"") {
        return { message: ""E-mail inválido"" };
      } else if (error.validation === ""url"") {
        return { message: ""Site inválido"" };
      } else if (error.validation === ""cpf_cnpj"") {
        return { message: ""CPF/CNPJ inválido"" };
      } else if (error.validation === ""cep"") {
        return { message: ""CEP inválido"" };
      } else if (error.validation === ""telefone_celular"") {
        return { message: ""Telefone inválido"" };
      }

      break;

    case ""custom"":
      return { message: ""Não pode conter elementos duplicados"" };
  }

  return { message: ctx.defaultError };
};

export const validateSchema = async (schema, input) =>
  schema.safeParseAsync(input, { errorMap });
```",,
899874439,464,New feature - custom methods,"Hello,

It would be nice if Zod accepted adding custom methods to the chain, like this:

```javascript
import { z } from ""zod"";

z.string().startingWithA().parse(""B""); // error
```

The custom method would be like a `refine` but in the chain of methods of schema.

The use case would be more intuitive schemas, instead of importing `zod` and custom `refine` functions, I just import my custom schemas with the custom methods.

I use this for string functions like `cpfCnpj` (an SSN in my country), `phone`, etc.

I'm using Zod v2 and I managed to do this extending the `ZodString` class, but in Zod v3 the `ZodString` code changed and I couldn't make it work anymore, so I'm stuck in Zod v2.

Also extending the class would leave the code more susceptible to changes in the parent classes, like from Zod v2 to Zod v3, so a native solution would be better.

Thanks.",,
899134839,463,feature: prepare,"What do you think about adding a new `.prepare()` method
- problem:
```typescript
const emailSchema = z.string().email()
emailSchema.parse("" aaa@bbb.ccc ""); // throws Error
```
but - if trimmed - it's a valid email, I can accept it.

- solution:
 ```typescript
const emailSchema = z.string().email().prepare(v => v.trim())
// and more concisely
const trimmed = v => v.trim()
z.string(trimmed).email()
```

You can add a parameter (without breaking change) and/or a new method (i.e. prepare), both accept a value that is of type `T` just like transform

this is only a toy-example there're a lot of real use case

[edit]
this solution is inspired to .transform() but act before the validation.",,
898777306,461,Literal and enum validation errors contain input data,"Normally `ZodError` does not contain the actual value that was invalid. IMHO this is good - errors are often logged, and there are many situations where you don't want to log the value - the value could be sensitive (credit card number, personally identifiable information, password/secret token of some kind), or it might be unsafe to log (might be several gigabytes, contain newlines, NUL bytes, ANSI terminal escape sequences, HTML, ... - some of which might cause problems when viewing logs later). 

However, for `z.literal` and `z.enum`, the message does contain the input data:

````
> z.literal('Foo').parse('Bar')
Uncaught ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""Foo"",
    ""received"": ""Bar"",
    ""path"": [],
    ""message"": ""Expected Foo, received Bar""
  }
]
<snip>

> z.enum(['Foo','Bar']).parse('Bad')
Uncaught ZodError: [
  {
    ""code"": ""invalid_enum_value"",
    ""options"": [
      ""Foo"",
      ""Bar""
    ],
    ""path"": [],
    ""message"": ""Invalid enum value. Expected 'Foo' | 'Bar', received 'Bad'""
  }
]
<snip>
```

I would suggest aligning these two with the other errors (it looks like these are the only two exceptions), so that logged error messages can never contain the invalid input data itself.
",,
897485999,458,Cannot compile using tsc with typescript 4.2.4 in 3.0.1,"Running TSC on project consuming zod 3.0.1 with typescript 4.2.4 gives the following error on the types.d.ts:
```
> tsc

node_modules/zod/lib/types.d.ts:305:185 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>'.

305     static create: <T_1 extends ZodRawShape>(shape: T_1) => ZodObject<T_1, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:305:355 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>'.

305     static create: <T_1 extends ZodRawShape>(shape: T_1) => ZodObject<T_1, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:306:192 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>'.

306     static strictCreate: <T_1 extends ZodRawShape>(shape: T_1) => ZodObject<T_1, ""strict"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:306:362 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>'.

306     static strictCreate: <T_1 extends ZodRawShape>(shape: T_1) => ZodObject<T_1, ""strict"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:307:195 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>'.

307     static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1) => ZodObject<T_1, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:307:365 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>'.

307     static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1) => ZodObject<T_1, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:481:174 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>'.

481     object: <T extends ZodRawShape>(shape: () => T) => ZodObject<T, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:481:336 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>'.

481     object: <T extends ZodRawShape>(shape: () => T) => ZodObject<T, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:497:182 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>'.

497 declare const objectType: <T extends ZodRawShape>(shape: T) => ZodObject<T, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: 
objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:497:344 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>'.

497 declare const objectType: <T extends ZodRawShape>(shape: T) => ZodObject<T, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: 
objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:498:189 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>'.

498 declare const strictObjectType: <T extends ZodRawShape>(shape: T) => ZodObject<T, ""strict"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:498:351 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>'.

498 declare const strictObjectType: <T extends ZodRawShape>(shape: T) => ZodObject<T, ""strict"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Found 12 errors.
```",,
897033138,457,typescript doc comments?,"Hi, I am working on integrating zod into one of my current projects. In the past I have used a combination of declared typescript types and manual validation. Zod is obviously a lot nicer to use on the validation side, but there is one piece from declaring types that I cannot find a replacement for in zod. That is [doc comments](https://typedoc.org/guides/doccomments/)

E.g. if I have the following struct defined:
```ts
interface Media {
  /**
  * The location of the media file
  */
  filepath: string
}
```

what would the equivalent comment look like in zod? These are important for my project, which relies on deno's documentation generation for user docs (see here https://doc.deno.land/https/raw.githubusercontent.com/andykais/ffmpeg-templates/main/lib/template_input.ts#Template)",,
895334247,454,.extend after .refine,"```ts
const timespan = z.object({
    start: z.date(),
    end: z.date()
}).refine(startIsBeforeEnd)

const annotatedTimespan = timespan.extend({
    something: z.string()
})
// ^ Fails with error TS2339: Property 'extend' does not exist on type ...
```

I guess this is to do with it being difficult to define methods on a `ZodEffects` which may or may not be there depending on the first type parameter.",,
895218592,453,`.regex()` migration Zod 1 to 3,"Hi @colinhacks 

Congrats for the V3 🎉  ! That new version seems awesome 👏🏻 

I'm looking to update the zod resolver for react-hook-form and I don't know if it's an issue or not but I can't chain anymore `.regex`

```ts
import { z } from ""zod"";

const password = z
  .string()
  .regex(new RegExp("".*[A-Z].*""), ""One uppercase character"")
  .regex(new RegExp("".*[a-z].*""), ""One lowercase character"")
  .regex(new RegExp("".*\\d.*""), ""One number"")
  .regex(
    new RegExp("".*[`~<>?,./!@#$%^&*()\\-_+=\""'|{}\\[\\];:\\\\].*""),
    ""One special character""
  )
  .min(8, ""Must be at least 8 characters in length"");
```

👉🏻  https://codesandbox.io/s/angry-proskuriakova-5rqvw

Should I use the `.and` method ?
Thanks!",,
894187563,452,Missing index signature when using passthrough() and infer(),"I’ve tried to update my projects from using zod v1 to zod v3. Unfortunately it seems like `passthrough()` does’t work in the same way as `nonstrict()` did before.

Example:

```ts
const foo = z.object({ foo: z.string() }).passthrough();
type Foo = z.infer<typeof foo>;
```

The inferred type `Foo` is now `{ foo: string; }`, but since I want to allow unrecognized keys I would expect something like `{ foo: string; [key: string]: unknown; }`.

Example with zod v1:

```
const foo = z.object({ foo: z.string() }).nonstrict();
type Foo = z.infer<typeof foo>;
```

The inferred type `Foo` is here `{ [x: string]: any, foo: string }`. ",,
892776955,446,3.0.0-beta.4 is marking properties as optional,"```typescript
const authSchema = z.object({
  email: z
    .string()
    .email()
    .transform(z.string(), (x) => x.trim().toLowerCase()),
  password: z.string().min(8),
});
```

Calling `authSchema.safeParseAsync()` returns data as optional.

```typescript
const result: {
    success: false;
    error: ZodError;
} | {
    success: true;
    data: {
        email?: string;
        password?: string;
    };
}
```

Also, safeParse is not working correctly. `if (result.success)` is not given me the data property, if it is negated the error property doesn't come up either. `if (result.success === true)` is working however.

I'm using version `2.0.0-beta.30`",,
892703629,443,"[WIP] `Excessive stack depth comparing types 'ZodIntersection<?, U>' and 'ZodIntersection<?, U>'.`","This is a WIP issue. I believe Zod (beta 4) is causing huge performances problem in my project. 

Ressource: https://github.com/microsoft/TypeScript/issues/43249

The performance problem happened after updating VSCode, so that might be the reason why it's happening.

I'll keep this issue updated

EDIT: this took a few hours of my life, solved by editing my workspace's settings.json following https://github.com/microsoft/TypeScript/issues/43249 proposed resolution

```json
{
  ""typescript.tsdk"": ""../../node_modules/typescript/lib""
}
```",,
892632577,442,Error message order is incorrect,"Hi,

I notice that the error message ordering seems off. It always reports the `email` error first instead of `nonempty`.

```
const schema = z.object({
  email: z
    .string()
    .nonempty({ message: ""Email is required"" })
    .email({ message: ""Email is invalid"" })
});
console.log(schema.safeParse({ email: """" }));
```

I believe this is a regression as its works find in the last 2.** beta version.
https://codesandbox.io/s/ecstatic-sun-b1vk2?file=/src/index.ts",,
890607382,433,`parse` mutates object and adds a `times` property to it,"Hey there! I think I've got an edge case on using a combination of Zod's parse with recursive schema definition.

Basically, I have a schema that uses itself recursively in order to match against a JSON object. It parses correctly, however, I noticed that after parsing, it mutates the original object, adding a property `times` with the value as `NaN`.

Here's the example:

```ts
import assert from ""assert"";
import * as z from ""zod"";

export type None = undefined | null;
export namespace None {
  export const schema: z.ZodSchema<None> = z.union([z.undefined(), z.null()]);
}

export type Some = string | number | boolean;
export namespace Some {
  export const schema: z.ZodSchema<Some> = z.union([z.string(), z.number(), z.boolean()]);
}

export type Value = Some | Data | None;
export namespace Value {
  export const schema: z.ZodSchema<Value> = z.lazy(() => z.union([Some.schema, Data.schema, None.schema]));
}

export type Data = Record<string, unknown>;
export namespace Data {
  export const schema: z.ZodSchema<Data> = z.record(Value.schema);
}

const clone = (data: Object) => JSON.parse(JSON.stringify(data));

const data = {
  payload: {
    data: {},
  },
};

const original = clone(Object.freeze(data));

const result = Data.schema.parse(data);

assert.deepStrictEqual(original, result);
```

In this case the assertion fails due to `parse` have mutated this object, adding `times` to it:

```
  {
    properties: {
      data: {},
-     times: NaN
    }
  }
```

I took a look to try to understand why and it seems the culprit (or at least it's one step into fully understanding why) is this little part here:

https://github.com/colinhacks/zod/blob/1c51624d32756804a0b02a2e18eab31f9234ec1f/src/parser.ts#L133-L152

Basically, as my property is also named `data`, I think we must have some namespaces/variables conflict. When I test with changing `data` to `myData`, it works just fine.",,
883804637,430,Could Zod provide type guards for narrowing union types?,"I am using v3 branch and would like to ask if it is possible for Zod to provide type guards? This will be handy when dealing with union types:

```
const ASchema = z.object({a: z.string()});
type A = z.infer<typeof ASchema>;

const BSchema = z.object({b: z.string()});
type B = z.infer<typeof BSchema>;

const ABSchema = z.union([ASchema, BSchema])
const AB = z.infer<typeof ABSchema>;  // { a: string } | { b: string}


function f(x: AB) {
   if (ASchema.guard(x)) {
       x.a   // x is A
   } else {
       x.b 
   }
}
```
",,
881022247,429,Use existing interfaces and types to type check response from promise,"I understand the examples given for primitive types. But I quite dont understand a few things when I have to put all of them together.

If I have interfaces already do I have to use zodSchema to redeclare them? If yes, then this library would not be useful for existing big projects? Since everything have to be redeclared.

I'll give one example

```

interface Vehicle {
  name: string;
  model?: string;
  year: number;
}

interface Meta {
  id: string;
  url: string;
  description: string;
  meta: Meta;
}

interface Car extends Vehicle {
  supercar?: boolean;
  meta: Meta;
}

axios.get('....').then({data} => {
   // Validate that data is of type Car
})
```

So is validating the response from axios possible without declaring all the interfaces using zod types? Sorry if it seems like a newb question.",,
876312143,425,.nullable and .default,"EDIT: I see in https://github.com/colinhacks/zod/pull/421#issuecomment-830912340 it's not actually supposed to work this way... In which case I request that a ""default() for nulls"" or ""default() handles nulls"" be added, since I cannot figure out a way to do this without removing the null before passing to zod.

(Using 3.0.0-beta.1)

I expect `.nullable().default(...)` to not have `xxx | null` in the output type, in the same way that (redundancy aside) `.optional().default(...)` does not have `xxx | undefined`, but I'm not 100% sure my reasoning is correct.

Should `.default()` replace `null` values, so that `number().nullable().default(1) => number` or `number | null`?
Or does `.default()` only operate on `undefined`s?

Should the chaining order matter so that `number().nullable().default(1) => number` and `number().default(1).nullable() => number | null`?

Example:

```ts
// Given
export const PaginationInputSpec = z
  .object({
    page: z.number().default(1),
    perPage: z.number().default(100)
  })
  .nullable()
  .default({});

// I expect:
PaginationInputSpec.parse(undefined) => { page: number, perPage: number }
// AND
PaginationInputSpec.parse(null) => { page: number, perPage: number }

// but I get 
PaginationInputSpec.parse(...) => { page: number, perPage: number } | null
```

Is this a bug?

I can try to work around it with:
```ts
...
  .nullable()
  .transform((i) => i ?? undefined)
  .default({});
```
which removes the `| null` from the output type, but it DOESN'T ACTUALLY WORK AT RUNTIME, making the whole thing `undefined`.  I expected the ""inner"" defaults to then take effect, but they don't.

Using in a GraphQL API where input optionals can be entirely missing (`undefined`) or explicitly `null`.",,
876151183,424,[Question] How would you clamp values?,"I'm working on a pagination input parameter and I'm using the following, which should be easy to follow:

```ts
const PaginationInputSpec = z.object({
  page: z.number().min(1).default(1),
  perPage: z.number().min(1).max(1000).default(100)
}).optional()
```

However, if the input values are out of range for the `page` and `perPage`, I want to clamp them, not throw an error.  How would I do that?

Without zod I'd do it like this:
```ts
export function clampValues(pagination: PaginationParam | undefined): Required<PaginationParam> {
  const { page = 1, perPage = 100 } = pagination || {};

  return { page: Math.max(1, page), perPage: Math.min(1000, perPage) };
}
```

Should I rather not use zod for this?",,
875451578,423,Add docstrings to inferred type,"Given some code like:

```
import { z } from ""zod"";

const UserSchema = z.object({
  /**
   * The ""ame"" of the ""usern"" _not_ the ""name"" of the ""user""!
   **/
  username: z.string(),
});

interface UserInterface {
  /**
   * The ""ame"" of the ""usern"" _not_ the ""name"" of the ""user""!
   **/
  username: string;
}

type User = z.infer<typeof UserSchema>;

const foo: User = {
  username: """",
};

const bar: UserInterface = {
  username: """",
};
```

if I hover over `username: """"` of foo I don't see the docstring like I would when hovering over the username of bar

This is due to the fact that some of the mapped types are not quite homomorphic types (especially around addquestionmark) so typescript doesn't copy the metadata along to the new type. I think I might be able to change them into homomorphic types by using typescript 4.1's `[key in keyof T as ...]` syntax. 

Would you consider such a PR for merging? Are there any gotcha's that I should be aware of?",,
872685151,419,[V3] Support template literals,"Hello :wave: 

I recently encountered a case, where my schema returned a string, but a function accept only a TS template string

Here is an example showing the issue: https://codesandbox.io/s/snowy-river-n2ih2?file=/src/index.ts

![image](https://user-images.githubusercontent.com/3089715/116715026-9ef6c500-a9d6-11eb-87d2-04fe3a10fdc7.png)

Is there a way, currently or in the future, to be able to do this:

```ts
const str = z.template(`${z.number()}.${z.number()}.${z.number()}`)
type Str = z.infer<typeof str>
// => Str: `${number}.${number}.${number}`
```",,
871292384,418,Unknown keys are incorrectly permitted in Union types.,"(v3) This is similar to the issue in #311, but I'd like some input since Zod does not throw an error in my case at all.

Zod doesn't allow unknown keys in Object schemas. Is it possible to be strict on typing for Object Unions, to be consistent with Typescript?

```
const A = z.object({
          a: z.number()
});

const B = z.object({
          a: z.number(),
          b: z.string()
});
const AB = z.union([A, B]);
        const c = {
          a: 1,
          b: 2,
        };

AB.parse(c); // => returns { a: 1 } but should throw an error.
```

```
interface A {
  a: number;
}
interface B {
  a: number;
  b: string;
}

const b: A | B = {a: 1, b: 2} // Type 'number' is not assignable to type 'string'.
```",,
870036109,417,Using `default()` inside `lazy()` forces type to be optional,"This seems like a bug to me, but if I'm doing something wrong I'd be glad to know what the proper way is to handle this case.  If I do: 

```
const aSchema = z.object({
  name: z.string().nullable().default(null)
})

type A = z.infer<typeof aSchema>

// and typescript says:
type A = {
    name: string | null;
}
```

That type looks right to me.  But if I need a recursive type and I do:

```
type B = {
  name: string | null
, child: B | null
}

const bSchema: z.ZodSchema<B> = z.lazy(() =>
  z.object({
    name: z.string().nullable().default(null)
  , child: bSchema.nullable()
  })
)
```

Then I get a type inference error on `bSchema`:

```
Type 'ZodLazy<ZodObject<{ name: ZodOptional<ZodNullable<ZodString>, true>; child: ZodNullable<ZodType<B, ZodTypeDef, B>>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<B, ZodTypeDef, B>'.
  The types of '_input.name' are incompatible between these types.
    Type 'string | null | undefined' is not assignable to type 'string | null'.
      Type 'undefined' is not assignable to type 'string | null'.ts(2322)
```

I would expect to be able to still use `default()` with a non-optional field in this way.  It appears that `name` gets the `ZodOptional` with that `true` second type parameter is getting set with `default()`, and it's cleared out when using `z.infer<>` in the first case but not with the explicit type cast.

Zod version: 3.0.0-alpha.39
TypeScript version: 4.2.3",,
869687987,415,Add support for UUID v5,"It seems UUID v5 is not supported. Here's a simple test case:
```typescript
import * as z from 'zod'

const testUUID = 'b79cb3ba-745e-5d9a-8903-4a02327a7e09';
const schema = z.string().uuid()
schema.parse(testUUID)
```

Error output:
```json
ZodError: [
  {
    ""validation"": ""uuid"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid uuid"",
    ""path"": []
  }
]
```

Any chance to add support for this?",,
867249038,414,(v3) Refinements don't respect custom error map,"See codesandbox with example: https://codesandbox.io/s/silly-dirac-1q3j0?file=/src/index.ts

Instead, you must always use the refine function's second parameter, which is weird, inconsistent and doesn't seem intentional?

Thanks! The library is great.",,
866925946,411,Generate union from options array,"Hello. 😀

How do I validate a Union with a large quantity?

```ts
const fruitsMap = [
  { uid: 1, name: ""banana"" },
  { uid: 2, name: ""apple"" },
  // ... many many many
] as const;

const arrowUIds = fruitsMap.map((v) => v.uid);
type FruitsUidUnions = typeof arrowUIds[number];

type Entity = {
  uid: FruitsUidUnions;

  // ... many many many
  foo: string;
  bar: string;
};

const schema: z.ZodSchema<Entity> = z.object({
  // It's a lot of work.
  uid: z.union([z.literal(1), z.literal(2)]),
});

const schema2: z.ZodSchema<Entity> = z.object({
  // Type Error
  uid: z.union(arrowUIds),
  foo: z.string(),
  bar: z.string()
});

const schema3: z.ZodSchema<Entity> = z.object({
  // Type Error
  uid: z.union(arrowUIds as [z.ZodAny, z.ZodAny, ...z.ZodAny[]]),
  foo: z.string(),
  bar: z.string()
});

const isValidUid = (p: unknown): p is FruitsUidUnions =>
  arrowUIds.some((v) => p === v);
const schema4: z.ZodSchema<Entity> = z.object({
  // How about something like this?
  uid: z.validate().refine(isValidUid),
  foo: z.string(),
  bar: z.string()
});
```",,
864743905,408,Type coming through as optional when using z.infer<>,"The types are coming through as optional when z.infered
<img width=""261"" alt=""Screen Shot 2021-04-22 at 9 32 15 PM"" src=""https://user-images.githubusercontent.com/1079931/115691494-385c2080-a3b2-11eb-8134-9a08ce4f8458.png"">
<img width=""222"" alt=""Screen Shot 2021-04-22 at 9 32 28 PM"" src=""https://user-images.githubusercontent.com/1079931/115691515-3e520180-a3b2-11eb-8795-1bf4d3870f62.png"">
",,
863210798,407,Update comparison with Runtypes,"Hi, I'm a collaborator of https://github.com/pelotom/runtypes. Some descriptions about Runtypes in README.md have become wrong now 😉 

- Missing object methods: (~~pick~~, ~~omit~~, ~~partial~~, deepPartial, merge, ~~extend~~)
- Missing nonempty arrays with proper typing (`[T, ...T[]]`)
- ~~Missing lazy/recursive types~~
- Missing promise schemas
- ~~Missing union & intersection schemas~~
- Missing error customization
- ~~Missing record schemas~~ (their ""record"" is equivalent to Zod ""object"")


",,
860612246,405,How to know whether a field in zod schema is optional or not?,"Can I get information about the field in zod schema, I want to know if the field is required or not

```ts
export const phoneSchema = object({
  phone: string().refine(
    (phone) => isMobilePhone(phone, ""vi-VN""),
    ""Số điện thoại này không hợp lệ""
  ),
});
```",,
859621671,402,Existing object as omit function argument leads to schema being an empty object,"Hi there, 

I want to use `.omit` with the same argument on multiple schema declarations. To do this, I specify the fields to be omitted in an object and use that object for multiple `.omit` calls instead of writing the same `.omit` argument multiple times. However, when I do this, zod removes all properties from the object instead of only the ones I specified.

Here is an example:

```
import * as z from ""zod"";

// MyType1 has prop2 after omit as expected

const MyType1 = z
  .object({
    prop1: z.string(),
    prop2: z.number()
  })
  .omit({ prop1: true });

type MyType1 = z.infer<typeof MyType1>;

// MyType2 is empty!?!

const omitProps: { [prop: string]: true } = { prop1: true };

const MyType2 = z
  .object({
    prop1: z.string(),
    prop2: z.number()
  })
  .omit(omitProps);

type MyType2 = z.infer<typeof MyType2>;
```

What I expected to get is this
```
type MyType1 = {
    prop2: number;
}

type MyType2 = {
    prop2: number;
}
```

What I get instead is this
```
type MyType1 = {
    prop2: number;
}

type MyType2 = {}
```

I created a codesandbox of this example [here](https://codesandbox.io/s/zod-omit-problem-glfc9?file=/src/index.ts).",,
858160261,397,`.transform()` returning output types unioned with input types,"Hi there,

I've been excitedly looking to into using Zod as it provides great type-safety compared to yup, but also doesn't require a programming style shift like io-ts, which isn't so palatable for my team.

I have unfortunately hit a bit of snag with type inference of `transform()` which is currently limiting our ability to adopt this, though I do wonder if if I am misunderstanding the intent of this function.

I am trying to create a reusable Schema for for the `Decimal` class from `decimal.js`, which is pretty pervasive throughout our code-base.

I'd like it to accept `number`, `string` and `Decimal` instances as input but ultimately transform them into `Decimals`

Here is my attempt:

```typescript
import * as z from ""zod"";
import { Decimal } from ""decimal.js"";

// const decimal = (): z.Schema<Decimal> =>
const decimal = (): z.Schema<Decimal | string | number> =>
  z
    .instanceof(Decimal)
    .or(z.string())
    .or(z.number())
    .refine((value) => {
      try {
        return new Decimal(value);
      } catch (error) {
        return false;
      }
    })
    .transform((value) => new Decimal(value));
```
My expectation here would be that `refine` would trigger an error during parsing if input could not be converted to a Decimal and `transform` would ensure that the output is a `Decimal`.

However if I make the return type of this function with `z.Schema<Decimal>` I get a type error because the inferred type is actually `z.Schema<Decimal | string | number>`.

Am I misunderstanding what `transform` is supposed to be doing here?

Further, it's a little sad that I have to try and construct the `Decimal` instance to validate the input and then have to do it again in the `transform` call. I do understand that `refine` does not actually change the type of the input so this makes sense. Something I'd like to see is something like the following where where `refine` (or some new function?) accepts a type guard that informs the output type. (I have no idea if this is possible though):

```typescript
// const decimalIdeal = (): z.Schema<Decimal> =>
const decimalIdeal = (): z.Schema<Decimal | string | number | undefined> =>
  z
    .instanceof(Decimal)
    .or(z.string())
    .or(z.number())
    .transform((value) => {
      try {undefined
        return new Decimal(value);
      } catch (error) {
        return undefined;
      }
    })
    .refine((value): value is Decimal => value instanceof Decimal);
```
Note that the return type also includes `undefined` in order to type check now. It was this that lead me to believe that `transform` is returning the output type union-ed with the input type.

Many thanks for this library and any help you may be able to provide!

EDIT:

For what it's worth, the inferred type when using `TypeOf` is actually correct, so I've been able to test that the result of the Schema does type check with the following code:

```typescript
const _typeCheckDecimal: z.TypeOf<ReturnType<typeof decimal>> = {} as Decimal;
const _typeCheckDecimalReverse: Decimal = {} as z.TypeOf<ReturnType<typeof decimal>>;
```
But this will need to be done for any object schemas that use the `decimal` type above. It would be nice if the type could be ""correct"" at the declaration site too, if possible. 

",,
858048010,396,How to specify discriminant for union?,"I'm using zod for form input, and there is a single dropdown field that should determine the ""level"" of validation. Essentially, most fields can be empty until you mark the form as ""Published"", at which point, all the fields because required.

I had originally built out two schemas: the non-published schema, and the published schema, that extend from the optional schema and made the rest of the fields required. I then used `z.union([nonPublishedSchema, publishedSchema])` to represent the whole form schema.

Simplified Example: 
```typescript
const nonPublishedBookSchema = z.object({
  title: z.string().optional(),
  availability: z.enum([""Draft"", ""Review""]);
})

const publishedBookSchema = nonPublishedBookSchema.extend({
  title: z.string(),
  availability: z.enum([""Published""]);
})

export const schema = z.union([nonPublishedBookSchema, publishedBookSchema]);
```

However, the errors that come out of zod when flipping the dropdown to ""Published"" make it hard to determine what is truly incorrect about the form. If I have a field empty, the first part of the union error (for non-published) will tell me that the availability enum value is incorrect, and the second part of the union error (for published) will tell me that the field is required.

I'd like to be able to specify the availability field as a sort of switch between different schemas. Basically, i would associate a full schema with a value or a series of values, and the errors I'd like to get out of zod should be specific only to that schema. Is there some way to do this? I thought about doing a refinement at the root of the schema, but I wasn't sure.",,
857000191,395,[Question] how do you sujeest to validate table?,"I have a table which use an array of object for validation.
The problem is that when I validate the array it affects all rows.

``` js
export const PersonSchema = z.object({
  email: z.string().email(),
  givenName,
  familyName,,
}).array();
```

For example if I have a column of email, and it is valid on one row but invalid on the other both cell would show the error because the field name is 'email' on both.",,
856747612,393,Can we store extra data on a chema?,"Can we store some data on a schema like defaultValue for a schema, description of it, so that we can create a value with defaultValue with a method like
```javascript
z.object({
  id: z.string(),
  status: z.enum(['on', 'off']).default('on'),
}).create()
// and then get an object : {id: '', status: 'on'}
```
for form initialization.

or we can have a method like 
``` javascript
z.number().exra({
  title:  'GitHub Stars',
  defaultValue: 0,
})
```


",,
856344910,392,Type of a Schema ?,"Hi,
i would like to write a function that would accept a schema as a parameter.
```ts
const func = (schema:z.Schema<string>)=>{
   const result = schema.safeParse(""foo"");
}
```
However, the compiler says that `schema` has type   `ZodSchema<string, zod.ZodTypeDef, string> | ((_: unknown) => boolean)`
What is the correct type to use for the function ? ",,
855738293,391,"Feature request: "".maybe()"" type","Hi there, thanks for the excellent library, I'm using it on a variety of projects now! A problem I have come across recently is that while building schema for third-party REST APIs (ie. APIs which I have no control/influence over) I have to type non-mandatory properties like this:

```ts
/*
 * Generated from:
 * https://developer.zendesk.com/rest_api/docs/support/attachments#json-format
 */
export const attachmentResourceSchema = zod.object({
  // The content type of the image. Example value: ""image/png""
  content_type: zod.string().nullable().optional(),

  // A full URL where the attachment image file can be downloaded
  content_url: zod.string().nullable().optional(),

  // If true, the attachment has been deleted
  deleted: zod.boolean().nullable().optional(),

  // The name of the image file
  file_name: zod.string().nullable().optional(),

  // Automatically assigned when created
  id: zod.number().nullable().optional(),

  // If true, the attachment is excluded from the attachment list and the attachment's URL can be referenced within the comment of a ticket. Default is false
  inline: zod.boolean().nullable().optional(),

  // The URL the attachment image file has been mapped to
  mapped_content_url: zod.string().nullable().optional(),

  // The size of the image file in bytes
  size: zod.number().nullable().optional(),

  // An array of attachment objects. Note that photo thumbnails do not have thumbnails
  thumbnails: zod.array(zod.unknown()).nullable().optional(),

  // A URL to access the attachment details
  url: zod.string().nullable().optional(),
})
```

The use of both `.nullable()` _and `.optional()` is apparently necessary (I've cross-checked against many payloads). Sometimes the payload contains those nullified properties, and other times it omits them entirely (ie. they are undefined). Could there be a `.maybe()` method which consolidates these two validations? I would be open to alternative naming.

Thanks!",,
855346412,389,z.string().uuid() is unreliable,"```js
import * as z from 'zod';

const definitelyNotUUID = '4bf1b128-936b-4cc2-8ec9-0d69e5a97b48blablablawhatever';
const schema = z.string().uuid();
schema.parse(definitelyNotUUID) // no error at all
```

Intrestingly, with `definitelyNotUUID = 'test'` it works as expected.
Tested with zod v.1.11.13",,
855219835,388,TypeError: Cannot read property '_parseWithInvalidFallback' of undefined,"Zod v3.0.0-alpha.29
Typescript v4.2.4

Short repro:

```ts
import * as z from 'zod';

const geojsonPolygonSchema = z.object({
    type: z.literal('Polygon'),
    coordinates: z.array(z.array(z.tuple([z.number(), z.number()]))),
});

const geojsonMultiPolygonSchema = z.object({
    type: z.literal('MultiPolygon'),
});

const geojsonShapeSchema = z.union([geojsonPolygonSchema, geojsonMultiPolygonSchema]);

const value = {
    ""type"" : ""MultiPolygon"",
    ""coordinates"" : [[[
        [0, 1], [2, 3], [4, 5]
    ]]]
}
console.log(geojsonShapeSchema.safeParse(value));
```

Output:

```
TypeError: Cannot read property '_parseWithInvalidFallback' of undefined
  at Object.function (node_modules/zod/lib/types.js:1340:35)
  at _loop_1 (node_modules/zod/lib/PseudoPromise.js:143:44)
  at PseudoPromise.getValueSync (node_modules/zod/lib/PseudoPromise.js:161:17)
  at node_modules/zod/lib/PseudoPromise.js:102:62
  at Array.map (<anonymous>)
  at Object.function (node_modules/zod/lib/PseudoPromise.js:102:32)
  at _loop_1 (node_modules/zod/lib/PseudoPromise.js:143:44)
  at PseudoPromise.getValueSync (node_modules/zod/lib/PseudoPromise.js:161:17)
  at ZodTuple.ZodType._parseInternal (node_modules/zod/lib/types.js:285:33)
  at ZodTuple.ZodType._parseWithInvalidFallback (node_modules/zod/lib/types.js:154:32)
```
",,
852012955,386,[Question] Custom error message for invalid type,"Suppose this code:

`export const userSchema = z.object({
  id: z.string().nonempty(""Missing Parameter""),
  password: z.string().nonempty(""Missing Parameter"")
});`

If I want to have a custom invalid type error message, such as ""Field id does not have the correct type"", what can be done?
Neither the string or number functions have overloads for messages, meaning they don't accept a custom error message. Is there anything I can do to add this invalid type error message?

i.e.
`
z.string(""Invalid type for id"").nonempty(""Missing Parameter"")
`",,
851803326,385,Firebase integrations,"I'm using zod with applications build on firebase.

firebase database(ex. firestore) can define custom rules like this.

```rule
rules_version = ""2"";
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthenticated() {
      return request.auth.uid != null;
    }

    function isMe(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }

    match /users/{uid} {
      function validateUserData(data) {
        return 'name' in data && data.name is string
          && 'age' in data && data.age is number;
      }
      allow get: if isMe(uid);
      allow create: if isAuthenticated() && validateUserData(request.resource.data);
      allow update: if isMe(uid) && validateUserData(request.resource.data);
      allow delete: if isMe(uid);
    }
}
```

And in web application, 

```typescript
// schema defs
import * as z from 'zod'

export const UserSchema = z.object({
  name: z.string(),
  age: z.number(),
})
export type UserModal = z.infer<typeof UserSchema>

// user create form

// If you use react-hook-form, it looks like this
export const UserCreateForm = () => {
  const {} = useForm<UserModal>(
    resolver: zodResolver(UserSchema)
  )
  // ....
}
```

And my question is, what might be a hint for me to create a CLI that automatically creates firebase rules based on schema definitions in zod.
Here's a rough image of what it looks like.

```json
// config file
{
  ""inputPath"": ""./src/firestore-rule.ts"",
  ""outputPath"": ""./firestore.rules""
}
```

```typescript
// ./src/firestore-rule.ts
import { Model, funcDef, op } from 'firebase-zod' // This is the library I plan to implement in the future
import { UserSchema } from './schema'

const isAuthenticated = funcDef(({ request }) => op.notNull(request.auth.uid))

const isMe = funcDef(({ request, arg}) => {
  const uid = arg.create('uid')
  return op.and(isAuthenticated(), op.equals(request.auth.uid, uid))
})

export class UserModel extends Model {
  schema = UserSchema
  paths = ['users']
  
  get() {
    return isMe(this.ids[0])
  }
  create({ request }) {
    return op.and(isAuthenticated(), this.validate(request.resource.data))
  }
  update({ request }) {
    return op.and(isMe(this.ids[0]), this.validate(request.resource.data))
  }
  delete() {
    return isMe(this.ids[0])
  }
}
```

Then, I would like to convert this code into a firestore rule by hitting some commands.

Once this is done, we can synchronize the validation in firebase with the validation in zod. Also, firebase rules cannot be split into separate files, which makes the files larger and more obfuscated, but if we can manage them on typescript, we will be able to split the code.

I think I need to know more about zod to make this possible, but I'm not familiar with zod yet. So I'd be very happy if you could give me some hints on how to make this work.",,
851773878,384,How to use `instanceof` to class with private constructor,"first, I want to use zod with `firebase/firestore`. And there is [`FieldValue`](https://firebase.google.com/docs/reference/js/firebase.firestore.FieldValue) class use for `createdAt` or `updatedAt`.

So, I think like this to use zod with firebase
```typescript
import * as z from 'zod'
import firebase from 'firebase/app'

const ServerTimestampSchema = z.instanceof(firebase.firestore.FieldValue)

const UserSchema = z.object({
  name: z.string(),
  // ...
  createdAt: ServerTimestampSchema,
  updatedAt: ServerTimestampSchema
})
```

maybe, this works at run time, but typescript compiler throw this message.

```typescript
// ...
const ServerTimestampSchema = z.instanceof(firebase.firestore.FieldValue)
// Argument of type 'typeof FieldValue' is not assignable to parameter of type 'new (...args: any[]) => any'.
//  Cannot assign a 'private' constructor type to a 'public' constructor type.ts(2345)

// ...
```

If someone has any solutions, please tell me!!",,
849914721,378,Email validation extremely slow for a given string,"First of all, thank you for maintaining this library! It helps a lot with deploying uniform validation logic on both the server and the client.

Using zod v3, I decided to try some of the email addresses mentioned [in this article](https://www.netmeister.org/blog/email.html) and found out that the following string takes around **7 seconds to validate on a MacBook Pro from 2019.** The following string, even though not meant to be used as-is, caused the issue:

```
""put a literal escaped newline here\ <--""@domain
```

I noticed that the issue only happens when `@domain` is used at the end without a TLD (e.g. `.com`). Also, I noticed there’s a substantial loss of performance when specifying >20 chars before `\ `, as seen below in a minimalistic reproduction case:

```ts
import { z } from ""zod""; // @3.0.0-alpha.33

const Email = z.string().email();
const prevTime = performance.now();
try {
  Email.parse('""xxxxxxxxxxxxxxxxxxxxxxxxxxx\\ "".x');
} catch {}
console.log(`${performance.now() - prevTime}ms`);
```

A live demo of the issue is [available on CodeSandbox](https://codesandbox.io/s/brave-shockley-ny1q0?file=/src/index.ts).",,
847895733,376,[Feature Suggestion] String CSS selector,"Just a suggestion as it came up as a use-case for me today -

Currently, Zod string has secondary validators such as:

```typescript
z.string().url()
```

Would there be any interest in adding a validator for CSS selectors?

```typescript
z.string().selector()
// or
z.string().css()
```

I ended up using this package temporarily for reference: https://github.com/mdevils/css-selector-parse


## Psuedo example

I'm not super great with regex so this is only a start, but if it's something of interest I think it must be possible to write a matcher...  🤔

```typescript
// Basic start to regex pattern...
const cssRegex: RegExp = /(div|span|section|h1|h2|h3|h4|h5|h6|header|footer|nav){0,1}[#.]{1}[a-zA-Z][a-zA-Z0-9\-_]+/i
  
// Rule definition...
if (this._def.isCss && !cssRegex.test(ctx.data)) {
  ctx.addIssue({
    validation: ""css"",
    code: ZodIssueCode.invalid_string,
    message: this._def.isCss.message
  })
}

```
",,
845002183,372,Typecheck schemas against existing types,"### TL;DR
I would love to have a way to ensure that a Zod schema matches an existing type definition using the normal Typescript type checker. Below is an example of the desired functionality using one possible implementation stolen from [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-655879215).

```typescript
type Dog = {
  name: string
  neutered: boolean
}

//Passing ""Dog"" as a generic type parameter tells Typescript what the schema should look like
const dogSchema = z.object<Dog>({
  name: z.string().min(3),
  neutered: z.string(), //Error: string can't be assigned to boolean
});
```

### Introduction

I originally raised this suggestion in #53, but decided it probably needs its own issue. See my original comments [here](https://github.com/colinhacks/zod/issues/53#issuecomment-737550649) and [here](https://github.com/colinhacks/zod/issues/53#issuecomment-738110750). Based on the reactions to these comments, there are at least a few other people thinking along the same lines as I am. I will restate my thoughts below.

I want to start by saying that Zod is a really, really cool project. It is the best runtime validation system for typescript by far. I hope the following critiques are constructive. 

### My runtime validation requirements

I started implementing Zod in my project, and I went into this implementation assuming that Zod would meet the following two requirements:

1.  Zod schemas would provide run time checks of my data types. **[true]**
2.  Zod schemas would conform to my existing types, so that it is impossible to change the type without also changing the associated schema (and vice versa) . **[only sort of true]**

In order to get the effect of my second requirement, I discovered that I need to replace my existing code, eg...

```typescript
export interface A {
   readonly ID: number;
   delayEnd: number;
   userID: number;
   reason: string;
   taskID: number;
   initiationDate: number;
   days?: number;
   userName?: string;
}
```

...with something like this...

```typescript
export const aSchema = z.object({
   ID: z.number(), //Note that I've lost the functionality of `readonly` in this conversion
   delayEnd: z.number(),
   userID: z.number(),
   reason: z.string(),
   taskID: z.number(),
   initiationDate: z.number(),
   days: z.number().optional(),
   userName: z.string().optional()
});

//""A"" is generated from the schema
export type A = z.infer<typeof aSchema>;
```

This makes it so that if I change `aSchema`, `A` will automatically update to match, which gives me most of what I was looking for. But there are some serious problems with this solution.

### The Problems

The most obvious problem with the above code example is that it removes some really valuable typescript features: As just one example, the functionality of `readonly` has been lost in the conversion to `aSchema`. Perhaps it is possible to reintroduce that functionality with some fancy Typescript manipulation, but even if that is the case it is still not ideal.

Perhaps a more central problem, though, is that I need to strip out pretty much all of my current type definitions and replace them with Zod schemas. There are some tools out there that will do this work for you (issue #53 was originally and ultimately about building these sorts of tools), but the real issue for me isn't the work of refactoring: The real problem is that such a refactor puts Zod in charge of my type system, which is very undesirable. In my opinion, Typescript should be the master of typing, and Zod should be the master of validation. In the current system, Typescript is subordinated to Zod rather than the other way around.

To make sure my intent is clear, here are a few re-statements of this idea:
- I want to keep all my types as they are and create schemas that conform to them.
- I do not want to replace my existing type definitions with schemas; instead I want to create schemas that match my existing types. 
- I want to keep my type system in typescript and only use Zod to validate that objects fit my existing types. 

To put it a different way, Zod is advertised as ""Typescript first"", but right now it feels more like ""Zod first with Typescript as a close second"". I say that because, currently, if I want to maintain type consistency I have to write the Zod schemas first, then use them to generate types. To be truly ""Typescript first"", the schemas should conform to the types instead of the types being generated from the schemas.

### The `tozod` solution

A great idea that addresses these issues was introduced in [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-655879215), discussed in [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-655937376), then partially implemented in the  `tozod` library (see [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-664193624); the library can be found [here](https://www.npmjs.com/package/tozod)). The `tozod` utility allows me to write the following in place of the above code example:

```typescript
//My interface does not change
export interface A {
   readonly ID: number;
   delayEnd: number;
   userID: number;
   reason: string;
   taskID: number;
   initiationDate: number;
   days?: number;
   userName?: string;
}

//The use of toZod ensures that the schema matches the interface
export const aSchema: toZod<A> = z.object({
   ID: z.number(),
   delayEnd: z.number(),
   userID: z.number(),
   reason: z.string(),
   taskID: z.number(),
   initiationDate: z.number(),
   days: z.number().optional(),
   userName: z.string().optional()
});
```

This meets my requirements perfectly. It preserves my original types and has a schema that conforms to those types. It gives me the same strong typing as using `z.infer` would have, but it leaves Typescript in charge of defining my type system and still gives me all the benefits of runtime validation. It also preserves certain Typescript functionality that can't be modeled in Zod, like the `readonly` in `A`. I think this scenario gives the best of all worlds and is truly ""Typescript-first"". I realize that it is slightly more verbose than just having a schema, but I think the benefits are well worth it. It fits much better into the established Typescript paradigm. I could go on and on about why this is a better solution.

### The problem with `tozod`

There is just one problem with the `tozod` utility. I quickly discovered, and the author of `tozod` admits, that it is ""pretty fragile"" and can only handle the most basic types (see [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-664753908)). Even a simple union type will cause it to break. The `tozod` library was a great step in the right direction, but in its current state it is virtually unusable in real application environments.

### My suggestion

My suggestion is that we need something like `tozod`, preferably built into `Zod`, that allows schemas to be type checked against existing types in a real application environment. I don't know if this is feasible -- I'm not a Typescript expert, so it might not even be possible; but if it is possible, I think this change would be extremely beneficial.
",,
844618372,371,[Question] How can I get field type from Zod object (reflection like)?,"Assuming I'm having the following:

`
export const PersonSchema = z.object({
  email: z.string().email(),
  givenName: z.string(),
  birthday: z.date().optional(),
});
`

Can I check what's the type of specific field (reflection like)?
I'm passing it to a component via property  

`
{ schema: SchemaObjectDef<ZodRawShape> }
`
.i.e.
`
      <Formation
        schema={PersonSchema}
      />
`

Inside the component (Formation) I like to iterate on the schema definitions and get insight on each field.
For example to check whether it email, string, number, etc.

I'm doing kind of pattern matching and creating a dynamic subcomponent within the Formation control.
",,
841942656,368,Mocking,"Hi,

I have started working on a `zod-generators` companion library with aim of generate random values, both valid or invalid, given a zod field of any type.

As a middle ground between functional and unit testing, I often write fixtures for my models, specifically for messages (HTTP request bodies, queue messages). Since the model is shared between producer & consumer, I can write contractual tests as the generated fixtures are shared. I then test that my producer spits out a valid value, and then I check that the consumer is able to process my generated fixtures.

The idea here is to generate fixtures and more importantly random fixtures easier to generate. For example, if my model defines a string and a number, then I would have a function to generate permutations of what can be valid and what can't be valid.

I think the only issues we would see here is with refines (I think we can just apply transforms to the valid generated values) as they are business logic that we can't dynamically inspect.

I have a PoC with very basic support for `zod.boolean`, `zod.number` and `zod.string` here:
https://github.com/dipasqualew/zod-generators

I was just curious of your thoughts before I put more effort into this 🙂 

Cheers ",,
841458308,364,Circular dependency when running tsc,"Just ran `tsc` on latest `@next` and received:

```shell
node_modules/zod/lib/types.d.ts:314:14 - error TS2456: Type alias 'deoptional' circularly references itself.

314 declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U, any> ? deoptional<U> : T;
                 ~~~~~~~~~~

node_modules/zod/lib/types.d.ts:314:87 - error TS2315: Type 'deoptional' is not generic.

314 declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U, any> ? deoptional<U> : T;
                                                                                          ~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:339:49 - error TS2315: Type 'deoptional' is not generic.

339     required: () => ZodObject<{ [k in keyof T]: deoptional<T[k]>; }, UnknownKeys, Catchall, objectOutputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>, objectInputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>>;
                                                    ~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:339:128 - error TS2315: Type 'deoptional' is not generic.

339     required: () => ZodObject<{ [k in keyof T]: deoptional<T[k]>; }, UnknownKeys, Catchall, objectOutputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>, objectInputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>>;
                                                                                                                                   ~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:339:194 - error TS2315: Type 'deoptional' is not generic.

339     required: () => ZodObject<{ [k in keyof T]: deoptional<T[k]>; }, UnknownKeys, Catchall, objectOutputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>, objectInputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>>;
```",,
840962809,361,Error when transforming wrapped parser,"A picture is worth a thousand words:

<img width=""1239"" alt=""Screen Shot 2021-03-25 at 9 58 05 AM"" src=""https://user-images.githubusercontent.com/10621548/112484990-d37cbe80-8d50-11eb-939e-7be1b18db867.png"">

Context: I want to take some `ZodType<T>` (which I have aliased as `Parser<T>`) and wrap it inside a `{ data: T }` parser, which I then want to destructure using `transform` to extract the actual data of type `T`.

I don't really know what I'm doing wrong, but it seems like in the simple case (line 5 in the screenshot) it just works. 

What am I doing wrong here?

Version: 3.0.0-alpha.32
TypeScript Version: 4.2.2",,
840953395,360,Property with default() is mandatory in union,"Example:
Typescript version: 4.2.3
Zod version: 3.0.0-alpha.5
Current result: attrOne is mandatory for creating new object with type MyType
Expected result: attrOne is optional, doesnt have to fill to new object
```
export const schema = z
  .object({
    someAttribute: z.union([
      z.object({ type: z.enum(['One']), attrOne: z.string().default('aaa').optional() }),
      z.object({ type: z.enum(['Two']) })
    ])
  })
  .strict()

export type MyType = z.infer<typeof schema>

const myType: MyType = {
  someAttribute: {
    type: 'One'
  }
}
```
Current example works with Zod version 3.0.0-alpha.4
![image](https://user-images.githubusercontent.com/1267665/112483789-a55fa480-8d79-11eb-8bb7-89c49a0e35f5.png)
",,
840572250,359,"When properties have .default, zod infers properties as not optional even if I set .partial ","## Example
![Screen Shot 2021-03-25 at 11 13 59](https://user-images.githubusercontent.com/26219456/112423576-42b8d980-8d76-11eb-98e7-a8fe6d8209d9.png)
![Screen Shot 2021-03-25 at 11 14 05](https://user-images.githubusercontent.com/26219456/112423580-44829d00-8d76-11eb-8b0e-c0619adeb3a3.png)

## Expected behavior
```typescript
export const Foo = z.object({
  bar: z.string().default(''),
})

const FooPartial = Foo.partial()

type InferredFooPartial = z.infer<typeof FooPartial> //  { bar?: string | undefined }
```",,
840119184,358,Clearer way to have optional objects that use their key's defaults,"Take, for example, the following TypeScript interface, which describes what the parsed and validated version of a config schema should look like:

```ts
interface ParsedConfig {
    foo: {
        one: string;
        two: string;
    };
    bar: {
        three: string;
        four: string;
    };
}
```

Take, also, the following type, which describes what the user could provide to customize the configuration of a program:

```ts
type UserConfig = undefined | {
    foo?: {
        one?: string;
        two?: string;
    };
    bar?: {
        three?: string;
        four?: string;
    };
}
```

To accomplish this with Zod, the schema must look like:

```ts
const schema = z.object({
    foo: z.object({
        one: z.string().default('1'),
        two: z.string().default('2'),
    }).default({}),
    bar: z.object({
        three: z.string().default('3'),
        four: z.string().default('4'),
    }).default({}),
}).default({});
```

Note the use of `.default({})` throughout, which forces Zod into using the default values of the keys within the objects. Without `.default({})`, Zod would throw an error indicating that the objects were required if one of the objects was missing entirely. If you try to use `.optional()` instead, then you could end up with an object that won't fit the `ParsedConfig`, like:

```ts
{
    foo: undefined,
    bar: undefined,
}
```

As a new user, this took quite a bit of trial-and-error to discover this. To help make it more clear as to how to accomplish this, along with making it more obvious what's going on whenever someone reads this code in the future, it may be useful to add a built-in function that accomplishes what `.default({})` accomplishes.",,
839719190,357,Adding a `.required` helper on object (v3),"Hello,

Since we have an amazing `z.object().partial()` helper (https://github.com/colinhacks/zod/tree/v3#partial) to mimic the typescript `Partial<>` util, this could be nice have the symetrical `Required<>` util.

Ideally, I would like something like this:
### `.required`

Inspired by the built-in TypeScript utility type [Required](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype), the `.required` method makes all properties required.

Starting from this object:

```ts
const user = z.object({
  username: z.string().optional(),
});
// { username?: string | undefined }
```

We can create a required version:

```ts
const requiredUser = user.required();
// { username: string }
```",,
838750898,355,Types not correctly inferred when using transformers (v3),"I'm trying to achieve one thing, basically, coalescing all `null` values into `undefined` when receiving data from an external provider. Since it's really annoying to write all the code necessary in `zod` to understand that again and again:

```ts
const myString = z.string().optional().nullable().transform((v) => v ?? undefined)
```

I was trying to write a wapper to do that automatically. It looks like the following:

```ts
function _optional<T>(zod: z.ZodType<T>): z.ZodTransformer<z.ZodNullable<z.ZodOptional<z.ZodType<T>>>, T | undefined> {
  return zod.optional().nullable().transform((v) => v ?? undefined);
}
```

However, this works well for simple types (for example, the one above):

```ts
const myString = _optional(ts.string());

// this gets correctly inferred as `string | undefined` instead of `string | null | undefined`
type t = z.infer<typeof myString>;
```

But it doesn't work for complex types like objects:

```ts
const UserSchema = _optional(z.object({
  email: _optional(z.string()),
  name: _optional(z.string()),
}));

type User = z.infer<typeof UserSchema>;
```

In the example above, the type `User` gets incorrectly inferred as: 

```ts
// notice the extra null typings
type User  = {
  email: string | null | undefined;
  name: string | null | undefined;
} | undefined
```

instead of 

```ts
type User  = {
  email: string | undefined;
  name: string | undefined;
} | undefined
```

like in the simple example at the beginning.


### Solutions

I could see two solutions, first one, see why this errors is happening (I don't know enough about zod internals as to answer this question myself just yet) or the second one, try to provide a simpler/nicer API for when you need some sort of default. For example:

```ts
const myString = z.string('default value');

const UserSchema = z.object({
  email: z.string(),
  name: z.string(),
}, { email: 'default email', name: 'default email' });
```

Basically meaning that every `zod` validator would accept an extra parameter that would be the default value in case the validated value is `null` or `undefined` (using `??`) and if that parameter is present, mark the validator automatically as `.optional().nullable()`",,
837207817,354,"typescript vs ""plain javascript"" in README","Zod looks great. I tried to use it, but it appears it's not distributed as JavaScript, so it didn't work in my project. 

The ReadMe says `Plain JavaScript: works in browsers and Node.js` and also that it has [typescript requirement](https://github.com/colinhacks/zod#typescript-requirements), which seems at odds with the first statement.

Would you consider creating a JavaScript build that could be imported, so it works directly in JavaScript projects too please?",,
837180579,353,[Feature Request] Built-in string transformers with defaults 🤖,"> Edit: Just saw this main thread lol: https://github.com/colinhacks/zod/issues/264#issue-760041790 Sorry! 🙏

Not a bug, and definitely not urgent as there is already a workaround, but I thought this might be a useful addition one day.... 
I use Zod to parse all my `.env` vars which are always typed as strings, however naturally I want to convert them to various other types like booleans and numbers, while also providing a default value in the expected format.

Currently, I have just made a set of transformers that I export as `t` (similar to the `z` format) but it's kind of hacky compared to the way Zod natively works (in the sense that the PoC code below ""must"" have a default provided, not to mention a second import being required vs if it were available within `z`)...

### 🤖 Transformers

```typescript
// Zod Transformers

import { string } from ""zod""

import { ZodTransformerLoader, ZodTransformers } from ""../types""

/**
 * Transform strings to numbers with a default.
 * @type {ZodTransformer}
 */
export const numberString = (): ZodTransformerLoader<number> => {
  return {
    default: (def: number) =>
      string()
        .default(`${def}`)
        .transform((value: string): number => parseInt(value))
  }
}

/**
 * Transform booleans to numbers with a default.
 * @type {ZodTransformer}
 */
export const booleanString = (): ZodTransformerLoader<boolean> => {
  return {
    default: (def: boolean) =>
      string()
        .default(`${def}`)
        .transform((value: string): boolean => value === ""true"")
  }
}

/**
 * Export a transformer API similar to the z object in Zod.
 * @type {ZodTransformers}
 */
export const t: ZodTransformers = {
  numberString,
  booleanString
}

```


### 🌳 Environment Schema

```typescript
// Env schema

import { dotenv, EnvSchema, t } from ""../support/dotenv""
import { QueueEnvSchema } from ""./queue""
import { z } from ""zod""

/**
 * Defines the shape of the server env file.
 * @type {z.ZodObject}
 */
export const ServerEnvSchema = EnvSchema.extend({
  SERVER_PORT: t.numberString().default(8080),
  SERVER_HOST: z.string().default(""foo.bar.io"")
})
  .merge(QueueEnvSchema)
  .passthrough()

/**
 * Parses the env file.
 * @type {z.ZodObject}
 */
export const env: z.infer<typeof ServerEnvSchema> = ServerEnvSchema.parse(
  dotenv()
)
```",,
836989808,352,"[Feature Request] ""fallback()"" variation of default() that activates when invalid data is supplied? 🔄","Was wondering if there is a way to achieve a scenario whereby defaults become fallback values if validation fails on that line?

For instance: 

```typescript
describe(""weekday schema"", () => {
  let day: string | undefined
  let schema: ZodEnum<any>

  before(() => {
    schema = z.enum([""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday""])
  })

  beforeEach(() => {
    day = undefined
  })

  it(""tests default when set to invalid day"", () => {
    const defaultSchema = schema.default(""Monday"")
    try {
      day = defaultSchema.parse(""Sunday"")
    } catch (err) {
      day = undefined
    }
    // Would expect to fail...
    expect(day).to.equal(""Monday"")
  })

  it(""tests hypothetical fallback when set to invalid day"", () => {
    const fallbackSchema = schema.fallback(""Monday"")
    try {
      day = fallbackSchema.parse(""Sunday"")
    } catch (err) {
      day = undefined
    }
    // Would expect to pass...
    expect(day).to.equal(""Monday"")
  })
})
```",,
836326760,347,SyntaxError: Cannot use import statement outside a module,"When importing zod as an esm module, a syntax error is thrown:

```
import z from 'zod'
^^^^^^

SyntaxError: Cannot use import statement outside a module
```

# Reproduction steps

```sh
mkdir test
cd test
echo '{""type"":""module""}' > package.json
yarn add zod@3.0.0-alpha.9
echo ""import z from 'zod'"" > index.js
node index.js
```

```sh
$ node --version
v15.11.0
$ yarn --version
1.22.10
```

OS: Pop!_OS 20.10 x86_64 (basically Ubuntu 20.10)

# Possible fixes

I haven't pulled anything down to fix it just yet, but the thing it's complaining about is that in order for native esm modules to import other modules, you need to have `""type"": ""module""` in your package.json. I don't know off the top of my head what that will do to commonjs. When I tried just editing it directly in node_modules, the next issue that came up is that the imports inside of `lib/esm/` didn't have extentions, i.e. `import * as z from ""./external""` instead of `import * as z from ""./external.js""`.

I'll try pulling it down and document what I've tried here.",,
835386291,340,Deep Partial registering as full original Schema when type is inferred (post -alpha.7),"Post `-alpha7` release my Deep Partials are registering as the full type:

`TS2739: Type '{}' is missing the following properties from type '{ maxConnections: number; auth: ""none"" | ""iponly"" | ""nbname"" | ""strong""; logFormat: string; }': maxConnections, auth, logFormat, platform`


### Reproduction

```typescript
import { z } from ""zod""

export const TemplateOptionsSchema = z.object({
  maxConnections: z
    .number()
    .min(1)
    .max(65535)
    .default(env.PROXY_MAX_CONNECTIONS),
  auth: ProxyAuthSchema.default(env.PROXY_AUTH),
  logFormat: z.string().default(env.PROXY_LOG_FORMAT)
})

export const PartialTemplateOptionsSchema = TemplateOptionsSchema.deepPartial().passthrough()

export type PartialTemplateOptions = z.infer<typeof PartialTemplateOptionsSchema>

const  options: PartialTemplateOptions = {} // TS2739 error noted above...

```

### Issue

Was previously inferring the correct Deep Partial type when registering:

```typescript
export type PartialTemplateOptions = z.infer<typeof PartialTemplateOptionsSchema>
```


### Short Term Fix

Currently wrapping the type in `Partial<>`, but this seems counter to what would be expected:

```typescript
  options: PartialTemplateOptions = {} // Fail
  options: Partial<PartialTemplateOptions> = {} // Success
```

Just checking to see if this was intentional or unexpected behaviour?",,
835383137,339,Optional with Default failing type check (post -alpha.7),"Not sure if I'm just ""doing it wrong"" but this was working prior to the latest alpha7 release:

#### Fails type check
![image](https://user-images.githubusercontent.com/65471523/111712665-35957980-88a2-11eb-86d7-30aa396316b8.png)

#### Upstream `env` schema:
![image](https://user-images.githubusercontent.com/65471523/111712698-45ad5900-88a2-11eb-8ccc-7462abe12e87.png)

### Possible cause:

The issue appears to be because ` z.string().optional()` is now typing as `() => string | undefined` whereas it was previously typing as `string | undefined`.

`Type 'undefined' is not assignable to type '() => string | undefined'.`

```typescript
// Cause
const env = z.object({
  TOKEN: z.string().optional()
})
// Type Error
const problem = z.object({
  token: z.string().optional().default(env.TOKEN)
})

```

Ultimately just want to make sure this is intentional before I refactor to solve it.",,
835065872,337,guidance following removal of intersection,"Hi, with the removal of `intersection`, I'm wondering what the best way to represent base shapes with conditional extensions? From looking at the diff, I suppose the recommendation is to use `merge` or `extend`, but that isn't very ergonomic with union types...

For example, I have a schema that validates oidc-provider client configurations that looks like this:

```ts
const clients = array(
  intersection(
    object({
      client_id: string(),
      grant_types: array(string()),
      redirect_uris: array(string()),
      tos_uri: string().url(),
      policy_uri: string().url(),
    }),
    union([
      object({
        application_type: literal(""native""),
        token_endpoint_auth_method: literal(""none""),
      }),
      object({
        token_endpoint_auth_method: z
          .enum([""client_secret_basic"", ""client_secret_post""])
          .optional(),
        client_secret: string(),
      }),
      object({
        token_endpoint_auth_method: z.enum([""private_key_jwt""]),
        jwks: object({
          keys: array(
            object({
              kty: string(),
              kid: string(),
              n: string(),
              e: string(),
            })
          ),
        }),
      }),
    ])
  )
)
```

It's a little busy, but you can see that there's a base schema that intersects with a union type for all of the conditional variants.

Without `intersect`, it seems like every type in the union has to be explicitly extended:

```ts
const clientBase = {
  client_id: string(),
  grant_types: array(string()),
  redirect_uris: array(string()),
  tos_uri: string().url(),
  policy_uri: string().url(),
};
const clients = array(
  union([
    object({
      application_type: literal(""native""),
      token_endpoint_auth_method: literal(""none""),
    }).extend(clientBase),
    object({
      token_endpoint_auth_method: z
        .enum([""client_secret_basic"", ""client_secret_post""])
        .optional(),
      client_secret: string(),
    }).extend(clientBase),
    object({
      token_endpoint_auth_method: z.enum([""private_key_jwt""]),
      jwks: object({
        keys: array(
          object({
            kty: string(),
            kid: string(),
            n: string(),
            e: string(),
          })
        ),
      }),
    }).extend(clientBase),
  ])
);
```

We can't use `[].map()` over the union argument because `map` doesn't preserve the input length in the output type.

Is there another way of continuing to express this, or is the expectation that every entry in a union has to be manually extended?",,
833728876,333,How to achive yup's when() utility? ,"Hi, in [yup](https://github.com/jquense/yup#mixedwhenkeys-string--arraystring-builder-object--value-schema-schema-schema) there is a `when()` utility which allows users to ""adjust the schema based on a sibling or sibling children fields."" Is there a way to contruct such conditionals in `zod` schemas? I could not find such utility in the documentation. If it's by design, please let me know! I'd love to define a schema similar to the one below (`adminSecret` is conditionally optional):

```
import * as z from ""zod"";

interface User {
  id: string;
  isAdmin: boolean;
  adminSecret?: string;
}

const userSchema: z.ZodSchema<User> = z.object({
  id: z.string(),
  isAdmin: z.boolean(),
  adminSecret: z.string().when(""isAdmin"", (isAdmin, schema) => {
    return isAdmin ? schema : schema.optional();
  }),
});

const blob = {
  id: ""20ec0677-68d8-45b5-a522-16cff767ac6f"",
  isAdmin: true,
};

// should throw an error because
// the blob has no adminSecret !
const user = userSchema.parse(blob);
```",,
830135376,332,"A combination of union, transformer and default infers the wrong type","Hi,
I'm using v3.0.0-alpha.4 and encountered a case where adding a default causes the inferred type to be wrong.

Example:

```typescript
const schema = z.array(
  z.union([
    z.string().transform(name => ({ name })),
    z.object({ name: z.string() })
  ])
);

const schemaWithDefault = schema.default([]);

type Schema = z.infer<typeof schema>;
/* 
infers the correct type:
({
    name: string;
} | {
    name: string;
})[]
*/

type SchemaWithDefault = z.infer<typeof schemaWithDefault>;
/* 
infers the wrong type:
(string | {
    name: string;
})[]
*/
```

Any idea what's going on here?
Thanks!",,
823797036,327,Feature request: .exact type to prevent excess properties,"I’m migrating from io-ts to zod since I’d like a smaller package size, but one of the features I need is the `.exact` method. It’s a way to prevent an object from having more properties than the schema defines (or as Typescript calls it, “excess properties”).

~If this is a feature that you’d be interested in, I can submit a PR for it [just like I enhanced tsoa by adding an excess properties check into that library.](https://github.com/lukeautry/tsoa/issues/336) Or if zod already has something like this, I can’t add a PR enhance the docs. Or if zod already defaults to no excess properties, I can add to the readme for that.~

Update: I read the full readme and saw that zod does support this but doesn’t use the term exact or excess. I’ll submit a PR that adds those words to aid others in searching for these terms. Btw, bravo on taking this approach as the default! :)",,
817746744,326,self reference types,"Self-reference types are not rare and in each project, it is possible to have a bunch of them.
```typescript

interface Label {
  name: string,
  value: string,
}

interface Button {
  name: string,
  value: string,
}

type View = Container | Button | Label;

interface Container{
  name: string,
  children: View
}

```

I couldn't find a solution to implement this using `zod`.

```typescript
const labelSchema = z.object({
  name: z.string(),
  value: z.string(),
});

const buttonSchema = z.object({
  name: z.string(),
  value: z.string(),
});

const containerShcema = z.object({
  name: z.string(),
  children: z.union([labelSchema, buttonSchema, containerShcema]).array(),
});

```

This will cause compiler error for `containerSchema` inside union array:
**`Block-scoped variable 'containerShcema' used before its declaration.`**",,
813009465,319,Possibility to export a single bundled z object?,"This is obviously a quite low priority item as it's not a functional issue, but it would be great to allow importing a single `z` object with destructuring syntax.

For example: 

```typescript
import { z } from ""zod""
```

Alternatively, if that ends up bloating the regular `import * as z from ""zod""` default export, creating a secondary export location such as this would be equally as good:

```typescript
import { z } from ""zod/z""
```

### Example export

```typescript
// ./src/z.ts

import * as z from ""./index""

export { z }

```

Happy to do a PR if you are open to it, but thought I'd check first?
",,
808413234,315,Avoid upper level index import to avoid require cycle,"Hello, thanks for the amazing library.
I'm currently using the latest version of zod (3.0.0.-alpha-4) with react-native and I noticed a weird require cycle through my whole application:



> WARN     Require cycle: index.js -> src/Root.tsx -> src/routes/Router.tsx -> src/routes/stacks/Authentication.tsx -> src/screens/Authentication/index.ts -> src/screens/Authentication/SignInMail.tsx -> src/screens/Authentication/components/SignInForm.tsx -> node_modules/zod/lib/cjs/index.js -> node_modules/zod/lib/cjs/types/object.js -> node_modules/zod/lib/cjs/helpers/objectUtil.js -> index.js

I did some digging and I found this kind of import:

https://github.com/colinhacks/zod/blob/bb93ec5448d4b06ef3a458160e697babb2059980/src/helpers/objectUtil.ts#L3

I think it is somehow miss referencing this to my app package.json main script.
I tried renaming my entry point to something else but it still gave the warning.

thanks for your attention",,
802302644,313,Allow `z.function([z.string()])` rather than needing to use `z.tuple(...)` every time,"Minor convenience request:

I'd like to use zod as a very lightweight way of basically making typescript assertions ""real"". So my hope is that using `z.function(...)` is almost as little overhead as defining a vanilla typescript function. Situation now:

```ts
import * as z from 'zod'

export const myFunction = z.function(z.tuple([z.string()])).implement(str => console.log(str))
```

It'd be great if `z.function` auto-tuplified the inputs so we didn't have to use `z.tuple`:

```ts
import * as z from 'zod'

export const myFunction = z.function([z.string()]).implement(str => console.log(str))
```

I'd be happy to open a PR if you're open to the idea?",,
802238469,312,Update v2/beta instructions in readme,"Hi, love the library!

In the readme found at https://github.com/colinhacks/zod and https://npmjs.com/package/zod (places I'd usually expect to find ""blessed""/up-to-date docs), it says ""Zod 2 is recommended for all new projects"". On clicking through to the v2 branch, this seems to be very much not the case. The write up of why is very helpful, but it might be a good idea to update the v1 readme saying _v3_ is recommended for all new projects (with a brief explainer and/or link to issue on why v1 -> v3).

Or, if v1 is still the recommendation until v3 comes out of alpha/typescript 4.1 is more widely adopted, remove the message entirely?",,
801396240,311,Incorrect error for unions with literals,"**Description**
I use `zod@2.0.0-beta.30`
I want to use zod to parse structures like
```typescript
type T = { val: 'a', a?: string } | { val: 'b', b?: number }
```
but I get incorrect error when I tries to parse structure with incorrect field's type

**Demo**
```typescript
import * as z from 'zod'

const Schema = z.union([
  z.object({
    val: z.literal('a'),
    a: z.ostring()
  }),
  z.object({
    val: z.literal('b'),
    b: z.onumber()
  })
])

console.log(Schema.parse({
  val: 'a',
  a: 123         
}))
```

**Expected error**
```
Error: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""string"",
    ""received"": ""number"",
    ""path"": [
      ""a""
    ],
    ""message"": ""Expected string, received number""
  }
]
```

**Actual error**
```
Error: [
  {
    ""code"": ""invalid_literal_value"",
    ""expected"": ""b"",
    ""path"": [
      ""val""
    ],
    ""message"": ""Input must be \""b\""""
  }
]
```",,
800902507,309,error when using zod with skypack,"![image](https://user-images.githubusercontent.com/15090582/106842184-7feddd00-66de-11eb-887d-78338c7be7bd.png)
same error if runs in browser
```html
<!DOCTYPE html>
<html lang=""en"">
  <body>
    <script type=""module"">
      import z from 'https://cdn.skypack.dev/zod';
      z.string().parse('fish')
    </script>
    <script type=""module"">
      import * as z from 'https://cdn.skypack.dev/zod';
      z.string().parse('fish')
    </script>
  </body>
</html>
```",,
797262116,307,Open Zod to externally-defined combinators,"To define a `ZodTypeDef` instance, one must pick a member of the enum `ZodTypes`. This is a problem for users wishing to define their own instances of `ZodType`, which requires a `ZodTypeDef` instance.

The solution is to factor the centralized aspects of Zod such that every combinator owns its error reporting, parsing logic, etc.",,
794765540,301,Check if schema has a key,"**(zod v3)**

Could we add a way to check if a Zod object has a key (based on a string) at runtime?
e.g.:

```typescript
const Location = z.object({
  latitude: z.number(),
  longitude: z.number(),
});

Location.hasKey('foobar'); // false
Location.hasKey('latitude'); // true
```

... which would essentially just be:
```typescript
public hasKey(key: string): boolean {
  return this.shape[key] !== undefined
}
```

I'm not sure if something like this already exists, I've just been checking the shape.

---

To extend the question, is it possible to also do this with a `Schema`? (I'm aware `shape` doesn't exist on `Schema`, so this example doesn't work)
e.g.:

```typescript
import * as z from 'zod'

export const personSchema = z.object({
  firstName: z.string(),
  lastName: z.string(),
  email: z.string(),
  phoneNumber: z.string()
});

function hasKey(key: string, schema: z.Schema<any>): boolean {
  return schema.shape[key] !== undefined
}

console.log(hasKey('firstName', personSchema));
```

I have a use case where this would be very helpful; I'm hoping this is already possible, and I've just missed it in the documentation.

I've tried solving it by passing a Zod object into my use case via generics, but `ZodObject<T>` complains. I'm probably supposed to be using some other type?",,
791074196,295,safeParse method can return an ZodError object instead of success property,"Is it possible to return an ZodError object? like this:

```
const maybeData = stringSchema.safeParse(""billie"")

if (maybeData instanceof ZodError) {
  // handle error then return
}

// underneath the if statement, TypeScript knows
// that validation passed
console.log(maybeData)
```",,
787368422,294,produce module build for bundling and tree shaking support,"It would be nice if you could also produce and publish an ES module build of zod for bundler consumption. I can probably send a PR when I get the chance to.

[here is an article](https://rollupjs.org/guide/en/#what-is-tree-shaking) if you're not familiar with bundling and tree shaking. [Another article](https://rollupjs.org/guide/en/#publishing-es-modules) on how to point bundlers at the module build

Thanks for considering! (ps i dont use rollup lol)",,
786012549,291,[Feature Request] Using Typescript Decorators for Object Schemas,"Right now, we declare object schemas like this:
```js
const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
});
```
What if instead, we declared schemas with [decorators](https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators) so we didn't have to retype the associated class?
```js
class Dog {
    @zodProperty
    public name: string;
    @zodProperty
    public neutered: boolean;
    @zodProperty({ email: true })
    public email: string;
}


const myObj = { name: ""blabla"" } // Example request body
try {
    const myDog: Dog = getSchema(Dog.name).parse(myObj); // no need to rewrite schema, can use class multiple times
}
catch (err) {
}
```",,
786006683,290,v2: Using .default() with z.enum() disables .options,"Hi, thanks for this awesome library!

Stubled over this:

```typescript
    const myEnum = z.enum(['foo', 'bar', 'baz'])
    console.log(myEnum.options) // [ 'foo', 'bar', 'baz' ]
    const myEnumWithDefault = myEnum.default('bar')
    console.log(myEnumWithDefault.options)
```

The last line triggers:

```plain
error TS2339: Property 'options' does not exist on type 'ZodTransformer<ZodOptional<ZodEnum<[""foo"", ""bar"", ""baz""]>>, ZodEnum<[""foo"", ""bar"", ""baz""]>>'.

32     console.log(myEnumWithDefault.options)
                                     ~~~~~~~
```

I suppose that's a bug. Is there any other way to retrieve the list of possible options and using a default at the same time?

Thanks!",,
784211437,289,All properties is z.object are optional by default,"The docs state the following:

> // all properties are required by default

However, in the newest version you can do the following (same as the dog example):

```
const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
});

type Dog = z.infer<typeof dogSchema>;
/* 
erroneously equivalent to:
type Dog = { 
  name?: string; 
  neutered?: boolean;
}
*/

const fido: Dog = {
  name: 'Fido',
}; // This does not give any error
```

This seems to have broken in 1.2.4.

But even in version 1.2.3, you are able to do this:

```

const fido: Dog = {
  name: undefined,
  neutered: true,
}; // This does not give any error
```

Which shouldn't be possible, as the type is `string`.",,
780673127,286,.keyof,"I have an enum mapping an external status string to an internal status string:

```typescript
enum STATUS_MAP {
  pending = internal.Pending,
  engaged = internal.Pending,
  pickup_confirmed = internal.Pending,
  canceled = internal.Cancelled,
  on_route = internal.Pending,
  on_delivery = internal.Shipped,
  delivered_recipients_here = internal.Delivered,
  delivered_recipients_not_here = internal.Delivered,
}
```

If I understand correctly there is no combinator out of the box that takes this enum and returns a schema for the keys (`pending`, `engaged`, etc.) Am I correct?

If so, I'll try to implement such a combinator and submit it as a PR this week-end.",,
780622758,285,[Feature Request] Add ZodObject support to .pick & .omit,"As I understand it, `.pick` & `.omit` currently accept `Record<string, true | undefined>`. I think it would be useful if it accepted a zod value as well.

For example, if we start with 

```javascript
const A = z.object({ a: z.number(), b: z.string() });
const B = z.object({ c: z.string(), d: z.string() });
const AB = A.merge(B);
```

and wanted to get the `A` schema back from `AB` we need to do

```javascript
const A2 = AB.pick({ a: true, b: true });
```

 or something like this if we wanted to ensure we always got all properties from `A`
```javascript
const aKeys = Object.keys(A.shape).reduce((acc, key) => {
  acc[key] = true;
  return acc;
}, {} as Record<string, true>);
const A3 = AB.pick(aKeys);
```

Is there a reason the values must be `true`? Is ""truthy"" enough? That would allow `AB.pick(A.shape)`

I think `string[]` array is closest to TS `Pick`,
```typescript
type A = Pick<A, 'a' | 'b'>
const A = AB.pick(Object.keys(A.shape));
```

but that would be a breaking change. Is there an issue or any other docs/background about using object vs array as the second arg?

I only found `zod` yesterday and spent a little time reading docs and trying some examples, so I could be missing/misunderstanding something. I just wondered if we needed this new interface or if we could use an existing one.

Cheers on the great library.",,
775903670,277,How to properly configure TypeScript?,"Hey! Cheers for making zod. It's great! 🌟 

**Question**

How do I properly configure TypeScript to get strict type checking?

My `tsconfig.json` has `""strict"": true` using TypeScript `4.1.3`.

<details><summary>tsconfig.json</summary>

```js
{
  // see https://www.typescriptlang.org/tsconfig to better understand tsconfigs
  ""include"": [""src"", ""types""],
  ""compilerOptions"": {
    ""module"": ""esnext"",
    ""lib"": [""dom"", ""esnext""],
    ""target"": ""ESNext"",
    ""importHelpers"": true,
    // output .d.ts declaration files for consumers
    ""declaration"": true,
    // output .js.map sourcemap files for consumers
    ""sourceMap"": true,
    // match output dir to input dir. e.g. dist/index instead of dist/src/index
    ""rootDir"": ""./src"",
    // stricter type-checking for stronger correctness. Recommended by TS
    ""strict"": true,
    // linter checks for common issues
    ""noImplicitReturns"": true,
    ""noFallthroughCasesInSwitch"": true,
    // noUnused* overlap with @typescript-eslint/no-unused-vars, can disable if duplicative
    ""noUnusedLocals"": true,
    ""noUnusedParameters"": true,
    // use Node's module resolution algorithm, instead of the legacy TS one
    ""moduleResolution"": ""node"",
    // transpile JSX to React.createElement
    ""jsx"": ""react"",
    // interop between ESM and CJS modules. Recommended by TS
    ""esModuleInterop"": true,
    // significant perf increase by skipping checking .d.ts files, particularly those in node_modules. Recommended by TS
    ""skipLibCheck"": true,
    // error out if import and file system have a casing mismatch. Recommended by TS
    ""forceConsistentCasingInFileNames"": true,
    // `tsdx build` ignores this option, but it is commonly used when type-checking separately with `tsc`
    ""noEmit"": true
  }
}

```

</details>


However, I get non-strict results. Below screenshot should infer `str: string` without the `?`. 👇 


<img width=""415"" alt=""Screenshot 2020-12-29 at 14 48 20"" src=""https://user-images.githubusercontent.com/459267/103288534-58bc3580-49e5-11eb-99a5-bc11800cbff3.png"">


If you can't answer on the top of your head & need a reproduction example I can of course provide that!",,
774897986,276,object is marking all properties as optional,"I have this simple schema:

```typescript
let schema = z.object({
  email: z.string().email(),
  password: z.string()
})
```

When calling `safeParseAsync` on that schema, all keys in the `data` property are optional.

![Screen Shot 2020-12-26 at 13 12 29](https://user-images.githubusercontent.com/42145089/103155204-19d77700-477c-11eb-9467-024e1ef76a24.png)

I've tested this using both `latest` and `beta` version
",,
773730271,275,How to cast string to number?,"I have something like this:

```typescript
const params = z.object({
  id: z.number()
})
```

This fails immediately since id is a query string param and so is a string.
Then I tried:

```typescript
const params = z.object({
  id: z.transformer(z.string(), z.number(), x => Number(x))
})
```

But the compiler yells:

```
Type 'ZodObject<{ id: ZodTransformer<ZodString, ZodNumber>; }, ""passthrough"", ZodTypeAny, { id: number; }, { id: string; }>' is not assignable to type 'ZodType<{ id: number; }, ZodTypeDef, { id: number; }>'.
  The types of '_input.id' are incompatible between these types.
    Type 'string' is not assignable to type 'number'
```

What am I doing wrong?",,
772923691,274,Performance and benchmarks with others,"Hi

I saw this test results and it actually came after I had already looked into a issue with slow code where I discovered that zod was taking up 600 ms to parse 1000 json elements.

https://github.com/moltar/typescript-runtime-type-benchmarks

Zod is one of the slowest in the overview.

Normally speed is not a problem since I use zod on user input, but if you run a busy api endpoint this could be something important.

Did something experience something like it?",,
768401574,272,Please export ZodNonEmptyArray,"The `nonempty` method of `ZodArray` returns `ZodNonEmptyArray`, but it isn't exported. Can it be exported in `src/index.ts`, so we can write `ZodNonEmptyArray<Schema>` instead of `ReturnType<zod.ZodArray<Schema>['nonempty']>` when declaring a function returning the result of `nonempty` method?",,
763280589,267,"RFC: parse->parseSync, parseAsync->parse","I think the Yup-style method naming makes more sense, where the plain `.parse` method returns a promise and `.parseSync` returns synchronously (skipping over any async refinements). Transformers complicate things; I you have an async transformer somewhere in your schema, I think `.parseSync` will just have to throw.

A sub-proposal is to rename the `safeParse` methods to simply `parse` and `parse` methods to `unsafeParse`. When I use Zod in a project, the method I end up using most commonly is `.safeParseAsync` which is pretty verbose. I strongly prefer the ""safe"" version of the methods, since it makes it's cleaner than a try/catch block and gives you back a statically typed `ZodError` on failure. I also use a lot of async refinements so I'm in the habit of calling the async method. Depending on how others use Zod, it may be worthwhile to switch these naming conventions. Or at least find a better name than `.safeParseAsync`.

Clearly this is a breaking change, I'm curious if others think it's worth it. ",,
760541131,265,deepPartial does not work as expected with unions,"Consider the following: 

```typescript
const A = z.object({p1: z.string()});
const B = z.object({a: z.union([A, z.null()])});
const PB = B.deepPartial();
PB.parse({a: {}});
```

Running this yields the following error:
```
Error: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""a"",
              ""p1""
            ],
            ""message"": ""Required""
          }
        ]
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""null"",
            ""received"": ""object"",
            ""path"": [
              ""a""
            ],
            ""message"": ""Expected null, received object""
          }
        ]
      }
    ],
    ""path"": [
      ""a""
    ],
    ""message"": ""Invalid input""
  }
]
    at new ZodError (/Users/kagrama/dev/cisco/dna/team-center/cli/node_modules/zod/src/ZodError.ts:134:5)
    at ZodObject.parse (/Users/kagrama/dev/cisco/dna/team-center/cli/node_modules/zod/src/parser.ts:171:17)
```

Ideally `deepPartial` would recurse through unions, taking the `deepPartial` of the union's members, where applicable.  I know that I can change `B`'s definition to:

```typescript
const B = z.object({a: z.union([A.deepPartial(), z.null()])});
```

...but this would seem to defeat the purpose of `deepPartial`.  I've got schemas nested to various levels of depth, and it seems that with `deepPartial`'s current behavior, I would have to duplicate schema definitions to achieve what I want...",,
760041790,264,RFC: Refactoring transformers and Zod 3,"## TLDR 

Transformers are poorly designed. I want to reimplement them but there will be breaking changes. Under this proposal, Zod 2 will never come out of beta and we'll jump straight to Zod 3 with a better implementation of transformers. Skip to ""New Implementation"" for details.

The reason Zod 2 has been in beta for so long (well, one of the reasons anyway!) is that I’ve been increasingly unsatisfied with Zod’s implementation of transformers. Multiple issues have cropped up that have led me to re-evaluate the current approach. At best, transformers are a huge footgun and at worst they’re fundamentally flawed.

## Context

Previously (in v1) the ZodType base class tracked the inferred type in a generic parameter called `Type`. But transformers accept an Input of one type and return an Output of a different type. To account for this, `Type` was renamed to `Output` and a third generic property was added (`Input`). For non-transformers, `Input` and `Output` are the same. For transformers only, these types are different.

![Screen Shot 2020-12-08 at 5 09 36 PM](https://user-images.githubusercontent.com/3084745/101593584-03bc6f00-39a5-11eb-8a66-5e7e84103290.png)


Let's look at  `stringToNumber` as an example:

```ts
const stringToNumber = z.transformer(z.string(), z.number(), val => parseFloat(val));
```

For `stringToNumber`, Input is `string` and Output is `number`. Makes sense.

What happens when you pass a value into `stringToNumber.parse`?

1. The user passes a value into `stringToNumber.parse` 
2. The transformer passes this value through the `parse` function of its _input schema_ (z.string()). If there are parsing errors, it throws a ZodError
3. The transformer takes the output from that and passes it into the transformation function (`val => parseFloat(val)`)
4. The transformer takes the output of the transformation and validates it against the output schema (z.number())
5. The result of that call is returned

Here's the takeaway: for a generic transformer `z.transformer(A, B, func)`, where A and B are Zod schemas, the argument of `func` should be the `Output` type of A and the return type is the `Input` type of B. This lets you do things like this:

```ts
const stringToNumber = z.transformer(z.string(), z.number(), val => parseFloat(val));
const numberToBoolean = z.transformer(z.number(), z.boolean(), val => val > 25);
const stringToNumberToBoolean = z.transformer(stringToNumber, numberToBoolean, val => 5 * val);
```

## The problems with transformers

After implementing transformers, I realized transformers could be used to implement another much-requested feature: default values. Consider this:

```ts
const stringWithDefault = z.transformer(z.string().optional(), z.string(), val => val || ""trout"");
stringWithDefault.parse(""marlin"") // => ""marlin""
stringWithDefault.parse(undefined) // => ""trout""
```
Voila, a schema that accepts `string | undefined` and returns `string`, substituting the default ""trout"" if the input is ever undefined.

So I implemented the `.default(val:T)` method in the ZodType base class as below (partially simplified)

```ts
default(def: Input) {
  return ZodTransformer.create(this.optional(), this, (x: any) => {
    return x === undefined ? def : x;
  });
}
```

Do you see the problem with that? I didn’t. Neither did anyone who read through the [Transformers RFC](https://github.com/colinhacks/zod/issues/100) which I left open for comment for a couple months before starting on implementation.

Basically this implementation doesn’t work at all when you use it on transformers. 

> Side note: should the `.default` method for `stringToNumber` accept a number or a string? As implemented above it should accept a string (the `Input`). But already this is unintuitive to many people.

```ts
stringToNumber.default(""3.14"")

// EQUIVALENT TO
const defaultedStringToNumber = z.transformer(
  stringToNumber.optional(),
  stringToNumber,
  val => val !== undefined ? val : ""3.14""
)

defaultedStringToNumber.parse(""5"")
/* { ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""string"",
    ""received"": ""number"",
    ""path"": [],
    ""message"": ""Expected string, received number""
  }
] */
```

Let’s walk through why this fails. The input (""5"") is first passed into the transformer input (`stringToNumber.optional()`). This converts the string `""5""` to the number `5`. This is then passed into the transformation function. But wait: `val` is now `number | undefined`, but the transformer function needs to return a `string`. Otherwise, if we pass `5` into `stringToNumber.parse` it’ll throw. So we need to convert `5` back to `""5""`. That may seem easy in this toy example but it’s not possible in the general case. Zod can’t know how to magically undo  the transformation function. 

In practice, the current definition of `default` in ZodType shouldn’t have even been possible. The only reason the type checker didn’t catch this bug is because there are a regrettable number of `any`s floating around in Zod. It’s not a simple matter to switch them all to `unknown`s either; I’ve had to use `any` in several instance to get type inference and certain generic methods to work properly. I’ve tried multiple times to reduce the number of `any`s but I’ve never managed to crack it.

It’s possible this is a one-off issue. I could find some other way to implement `.default()` that doesn’t involve transformers. Unfortunately this isn’t even the only problem in Zod’s implementation.

## The `.transform` method

Initially the only way to define transformers was with `z.transformer(A, B, func)`. Eventually I implemented a utility function you can use like this:

```ts
z.string().transform(z.number(), val=>parseFloat(val));

 // equivalent to 
z.transformer(z.string(), z.number(), val=>parseFloat(val));
```

Some users were executing multiple transforms in sequence without changing the actual data type:

```ts
z.string()
  .transform(z.string(), (val) => val.toLowerCase())
  .transform(z.string(), (val) => val.trim())
  .transform(z.string(), (val) => val.replace("" "", ""_""));
```

To reduce the boilerplate here, it was recommended that I overload the method definition to support this syntax:

```ts
z.string()
  .transform((val) => val.toLowerCase())
  .transform((val) => val.trim())
  .transform((val) => val.replace("" "", ""_""));
```

If the first argument is a function instead of a Zod schema, Zod should assume that the transformation doesn’t transform the type. In other words, `z.string().transform((val) => val.trim())` should be equivalent to `z.string().transform(z.string(), (val) => val.trim())`. Makes sense. 

Consider using this method on a transformer:

```ts
stringToNumber.transform(/* transformation_func */);
```

What type signature do you expect for `transformation_func`? 

Most would probably expect `(arg: number)=>number`. Some would expect `(arg: string)=>string`. Neither of those are right; it’s `(arg: number)=>string`. The transformation function expects an input of `number` (the Output of `stringToNumber`) and a return type of `number` (the Input of `stringToNumber`). This type signature is a natural consequence of a series of logical design decisions, but the end result is dumb. Intuitively, you should be able to append `.transform(val => val)` to any schema. Unfortunately due to how transformers are implemented, that's not always possible.

## More complicated examples

The fact that I incorrectly implemented both `.transform` and `.default` isn't even the problem. The problem is that transformers make it difficult to write any generic functions on top of Zod (of which `.transform` and `.default` are two examples). Others have encountered similar issues. #199 and #213. are more complicated examples of how the current design of transformers makes it difficult to write any generic functions on top of Zod. Nested transformers in particular are a minefield.  

## A path forward

When I set out to implement transformers I felt strongly that each transformer should have a strongly defined input and output transformer. This led to me implementing transformers as a separate subclass of ZodType (ZodTransformer) in an attempt to make transformers compose nicely with other schemas. This is the root of the issues I’ve laid out above. 

Instead I think Zod should adopt a new approach. For the sake of differentiation I’ll use a new term ""mods"" instead of ""transformations"". Each Zod schema has a list of post-parse modification functions (analogous to Yup’s transform chain). When a value is passed into `.parse`, Zod will type check the value, then pass it through the mod chain. 

```ts
const schema = z.string()
  .mod(val => val.length)
  .mod(val => val > 100);

type In = z.input<typeof schema> // string
type Out = z.input<typeof schema> // boolean
```

Unlike before, Zod doesn’t validate the data type between each modification. We’re relying on the TypeScript engine to infer the correct type based on the function definitions. In this sense, Zod is behaving just like I intended; it’s acting as a reliable source of type safety that lets you confidently implement the rest of your application logic — including mods. Re-validating the type between each modification is overkill; TypeScript’s type checker already does that.

Each schema will still have an Input (the inferred type of the schema) and an Output (the output type of the last mod in the mod chain). But because we’re avoiding the weird hierarchy of ZodTransformers everything behaves in a much more intuitive way.

One interesting ramification is that you could interleave mods and refinements. Zod could keep track of the order each mod/refinement was added and execute them all in sequence:

```ts
const schema = z.string()
  .mod(val => parseFloat(val))
  .refine(val => val > 25, { message: ""Too short"" })
  .mod(val => `${val}`)
  .refine(val => /^\d+$/.test(val), { message: ""No floats allowed"" });
```

## Compatibility

I was using the ""mod"" terminology above to avoid confusion with the earlier discussion. In reality I would implement the ""mod chain"" concept using the existing syntax/methods: `.default`, `.transform`, etc. In fact I think I could switch over to the ""mod"" approach without any major API changes.

- `A.transform(func)`: instead of returning a ZodTransformer, this method would simply append `func` to the ""mod chain""
- `A.transform(B, func)`: this would return `A.transform(func).refine(val => B.safeParse(val).success)`
- `z.transformer(A, B, func)`: this could just return `A.transform(func).refine(val => B.safeParse(val).success)`
- `A.default(defaultValue)`: this is trickier but still possible. This function would instantiate `A.optional().mod(val => typeof val !== ""undefined"" ? val : defaultValue)`. Then all the mods of A would be transferred over to the newly created schema

Under the hood things would be working very differently but most projects could upgrade painlessly unless they explicitly use the ZodTransformer class in some way (which isn’t common).

I would still consider this to be a breaking change of course. If/when I make these changes, I plan to publish them as Zod v3. In this scenario Zod 2 would never leave beta, we’d jump straight to v3. 

This transformers issue has caused me a lot of grief and headaches but I’m confident in the new direction; in fact I already have most of it working. I want to put this out for feedback from the community. The issues I’m describing are pretty subtle and not many people have run into them, but I believe the current implementation is currently untenable.
",,
758165868,257,`play` script fails to run,"As mentioned [here](https://github.com/colinhacks/zod/issues/225#issuecomment-739452319), the `play` script is currently not functional in the `v2` branch. The error below occurs.

```
$ yarn play
yarn run v1.22.5
$ nodemon -e ts -w . -x ts-node src/playground.ts --project tsconfig.json
[nodemon] 2.0.2
[nodemon] to restart at any time, enter `rs`
[nodemon] watching dir(s): *.*
[nodemon] watching extensions: ts
[nodemon] starting `ts-node src/playground.ts --project tsconfig.json`
sh: ts-node: command not found
[nodemon] failed to start process, ""ts-node"" exec not found
[nodemon] Error
    at Bus.<anonymous> (./zod/node_modules/nodemon/lib/nodemon.js:156:25)
    at Bus.emit (events.js:327:22)
    at ChildProcess.<anonymous> (./zod/node_modules/nodemon/lib/monitor/run.js:167:11)
    at ChildProcess.emit (events.js:315:20)
    at Process.ChildProcess._handle.onexit (internal/child_process.js:275:12)
✨  Done in 0.32s.
```

To resolve this, simply adding `ts-node` to the dev dependencies should be enough. Though, `playground.ts` also appears to not be in a stable state either. The error below occurs.

```
Error: You can't call .parse on a schema containing async transformations.
```

Perhaps also putting playground in a stable state as well may be good for new developers coming in and being able to test out the library right away. A decision here should probably be made on whether this ticket should encompass both issues before a PR is sent in, though 🙂 ",,
758154999,256,TS Jest unsupported version warnings when running tests,"When running tests in the v2 branch the output below is noticed.

```
ts-jest[versions] (WARN) Version 4.0.5 of typescript installed has not been tested with ts-jest. If you're experiencing issues, consider using a supported version (>=2.7.0 <4.0.0). Please do not report issues in ts-jest if you are using unsupported versions.
```

This is due to a recent upgrade of the Typescript version without bumping the version for TS Jest. The following changes are recommended:

* Bump `ts-jest` from `25.2.1` to `26.4.4`
* Bump `jest` from `25.1.0` to `26.6.3`
* Bump `@types/jest` from `25.1.4` to `26.0.16`
* Change `tsConfig` key in `jest.config.json` to `tsconfig` (former is now deprecated)",,
756564980,248,Sending validator as first-class-function verifies badly,"See this code:

```typescript
import * as z from ""zod"";

const callback = (predicate: (val: string) => boolean) => {
  return predicate(""hello"");
};

console.log(callback(z.string().is)); // false!?
console.log(callback((value) => z.string().is(value))); // true
```
https://codesandbox.io/s/priceless-shadow-diu6n?file=/src/index.ts

Passing the `is` function seems to return a bad value, however, creating a callback (example 2) and using the `string.is` function within it works.

This seems wrong, and I don't even know how I could create this bug?

Btw, it doesn't matter what kind of schema I create, I just used string as an example. Any `is` function seems affected.

What's weird to me: passing `z.string().is` returns false, while passing `(value) => z.string().is(value)` returns true. They should be the same thing?

I used `    ""zod"": ""^2.0.0-beta.25""`",,
755634808,245,Question: How to validate a set of properties as required?,"Firstly, thanks for zod. I found some of the other tools in your comparison, but zod is the one that really seems to fit for my use case. Plus, I'm deeply impressed by the 3 letter name which was unused in npm and elsewhere! :-)

I have 3 properties, `foo`, `bar` and `baz`. If `bar` is present, then so must be `baz`. In other words, `bar` and `baz` must always be present or absent together. I couldn't figure out how to achieve this result in TypeScript, maybe I need union interfaces, I'm not sure. Is there a way to do it in zod?

I created a duplicate type that requires both `bar` and `baz` and I use that inside `.refine()` with a `.check()`, but I wonder if there's a clearer way to express what I'm trying to do?",,
755622818,244,Representing a function with additional properties,"Is it possible to represent a function that also has additional properties on it?

Thinking specifically of cases like [Storybook stories](https://github.com/storybookjs/storybook/blob/b8aa525731ac2933a2489da51e449f617236e093/lib/addons/src/types.ts#L255-L262):

```ts
// Simplified from the real type
interface Story<Args, StoryFnReturnType> {
  (args: Args): StoryFnReturnType;
  storyName?: string;
}
```

These are functions with some properties added to them. Something like

```js
function SomeFunc() {
  // ...
}

SomeFunc.storyName = ""hello there"";
```

I haven't been able to find any existing issues or documentation around this, but let me know if this has already been brought up. I also understand if this is too challenging or not a priority to implement.

Thanks!",,
755503516,243,Validation order 2.0.0-beta.25,"Hi, 

I've created a sandbox for a situation, when validation rules take strange order. 

Assuming having a schema like this 
`const formValuesSchema = z.object({
  name: z.string(),
  company: z.string(),
  email: z.string().email()
});`

I don't get an Invalid email error when email is filled, until the other fields are filled as well.
It happens on version 2.0.0-beta.25

https://codesandbox.io/s/elegant-drake-4ultm?fontsize=14&hidenavigation=1&theme=dark&file=/src/index.ts:27-137",,
754684077,241,Generic transformers?,"Thanks for a great library! Was doing some exploration for using, and was wondering if there was a way to make a ""generic"" transformer-like thing. I have a generic type called `Serialized` which basically maps a type that contains dates (recursively) to a type that swaps those properties for strings. This type is used for Postgres `to_json` and over-the-wire dates from API to client. It looks like:

```ts
export type Serialized<T> = {
  [P in keyof T]: T[P] extends Date
    ? string
    : T[P] extends Date | null
    ? string | null
    : T[P] extends any[]
    ? Serialized<T[P]>
    : T[P] extends any[] | null
    ? Serialized<T[P]> | null
    : T[P] extends object
    ? Serialized<T[P]>
    : T[P];
};
```

In my code, I'm currently manually creating schemas that `.extend` the base schema and replace the date(|null) properties with string(|null) manually, but I was wondering if there was a way to abstract that out such that I could, in essence, build up the `ZodObject._shape` dynamically?",,
753981473,239,"Refine is taking precedence over optional, nullable, nonempty","I've been using .regex for my validations and recently [saw a tip in the docs](https://github.com/colinhacks/zod#strings) to use validator.js for that so I went ahead and tried it out using refine, now the problem is refine seems to take precedence over optional, nullable, nonempty. 

```
import * as zod from ""zod"";

import isDate from 'validator/es/lib/isDate'
import toDate from 'validator/es/lib/toDate'

let test = zod.string().optional().nullable().refine(isDate, { message : ""Please use the format YYYY-MM-DD(e.g 1986-02-20, 1986/02/20)"" })
console.log(test.safeParse("""")) // error
console.log(test.safeParse(null)) // error
console.log(test.safeParse(undefined)) // error
```",,
752731786,238,Uncaught TypeError: Cannot convert a Symbol value to a number,"The following code sample will throw said error because after the validation failed the `refine` function is still called:

```ts
z.union([z.number(), z.string().transform(z.number(), Number.parseFloat)])
  .refine((v) => v >= 1)
  .parse(""foo"");
```

This is supposed to accept `5` or `""5""` and reject anything that is not parsable into a positive number. 

But the refine will be called even if the union parsing failed and then `v` will be `Symbol(""invalid_data"")`

```
> z.union([z.number(), z.string().transform(z.number(), Number.parseFloat)]).refine((v) => v >= 1).parse(""foo"");
Uncaught TypeError: Cannot convert a Symbol value to a number
    at repl:1:92
    at Object.check (/home/despairblue/git/wunderflats/api/node_modules/zod/lib/cjs/types/base.js:167:34)
    at ZodUnion.parse (/home/despairblue/git/wunderflats/api/node_modules/zod/lib/cjs/parser.js:892:41)
> 
```

Without the refine it works as expected:

```
> z.union([z.number(), z.string().transform(z.number(), Number.parseFloat)]).parse(""foo"");
Uncaught ZodError: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""number"",
            ""received"": ""string"",
            ""path"": [],
            ""message"": ""Expected number, received string""
          }
        ]
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""number"",
            ""received"": ""nan"",
            ""path"": [],
            ""message"": ""Expected number, received nan""
          }
        ]
      }
    ],
    ""path"": [],
    ""message"": ""Invalid input""
  }
]
    at new ZodError (/home/despairblue/git/wunderflats/api/node_modules/zod/lib/cjs/ZodError.js:73:28)
    at ZodUnion.parse (/home/despairblue/git/wunderflats/api/node_modules/zod/lib/cjs/parser.js:195:17) {
  issues: [
    {
      code: 'invalid_union',
      unionErrors: [Array],
      path: [],
      message: 'Invalid input'
    }
  ],
  addIssue: [Function],
  addIssues: [Function],
  flatten: [Function]
}
> 
```

Question regarding this. It seem `refine` function are not allowed to throw. ~~Does that mean a `refine` function **must** succeed?~~

Forget the last part as they can return `false` obviously. ",,
749938557,235,Parsing process.env safety,"_I do not speak English natively nor do I consider myself to have a good level. For this reason, I apologize if I make any mistakes and please keep it in mind when reading and interpreting my messages. I'm doing the best I can. Thanks a lot._

Hello, I want to parse process.env

process.env is a `Zod.record(Zod.string())`

```ts
import * as Zod from 'zod';

enum Environments {
  PRODUCTION = 'production',
  DEVELOPMENT = 'development'
}

const EnvironmentVariables = Zod
  .object(
    {
      NODE_ENV: Zod.enum([Environments.DEVELOPMENT, Environments.PRODUCTION]),
      PG_HOST: Zod.string(),
      PG_PORT: Zod.number().int(),
      PG_DATABASE: Zod.string(),
      PG_USERNAME: Zod.string(),
      PG_PASSWORD: Zod.string(),
      /** Add custom environment variables to parse */
    }
  )
  .nonstrict()
  .parse(
    Object.assign(
      {},
      process.env,
      {
        PG_PORT: Number(process.env.PG_PORT),
      }
    )
  );

export const Environment = Object.assign(
  {},
  EnvironmentVariables,
  {
    IS_DEVELOPMENT: EnvironmentVariables.NODE_ENV === Environments.DEVELOPMENT ? true : false,
    IS_PRODUCTION: EnvironmentVariables.NODE_ENV === Environments.PRODUCTION ? true : false,
  },
);
```

The problem with this, is that `[k: string]: any;` is `any` when I want to let it be `[k: string]: string;`

```ts
const EnvironmentVariables: objectUtil.Flatten<{
    NODE_ENV: Environments;
    PG_HOST: string;
    PG_PORT: number;
    PG_DATABASE: string;
    PG_USERNAME: string;
    PG_PASSWORD: string;
} & {
    [k: string]: any; // I want this to be [k: string]: string;
}>
```

How would you build it? Thanks!",,
748186232,234,Webpack error when building zod,"When building my (typescript) project with webpack (4.41.5) I get:

```
ERROR in ./node_modules/zod/lib/src/index.js
Module not found: Error: Can't resolve './ZodError' in '/my-project/node_modules/zod/lib/src'
 @ ./node_modules/zod/lib/src/index.js 136:9-30
 @ ./src/zod/zod.ts
 @ ./src/zod/index.ts
 @ ./src/index.ts
```
I am using zod 1.11.10.

I have made a repo to reproduce the error: https://github.com/mspoulsen/zod-error

Any ideas? Thanks!
",,
747813875,233,Function infer return type,"Currently, I'm trying a lot of type manipulation on Zod schema.

Just for the example, I have this:
```typescript 
function foo<T extends z.ZodSchema<any>>(bar: z.infer<T>) {
  return {} as z.infer<T>;
}

const schema = z.object({
  foo: z.number()
});

type SchemaType = z.infer<typeof schema>;

const obj: SchemaType = {
  foo: 15
};

const bar = foo(obj); // expected SchemaType, but it's any
```

I don't know if it's a limitation of typescript or zod or just a mistake, and if there is a solution.",,
745554488,230,Zod 2 - parseAsync breaks unions of objects,"```typescript
import * as z from 'zod';

const Schema = z.union([
    z.object({
        ty: z.literal('A'),
    }),
    z.object({
        ty: z.literal('B'),
    }),
]);

(async () => {
  const obj = { ty: 'A' };
  console.log(Schema.parse(obj));  // Works
  console.log(await Schema.parseAsync(obj));  // Works with 1.11.10, breaks with 2.0.0-beta.21
})();
```

With Zod 2.0.0-beta.21, the `parseAsync` call fails with

```json
{
  ""code"": ""invalid_literal_value"",
  ""expected"": ""B"",
  ""path"": [
    ""ty""
  ],
  ""message"": ""Input must be \""B\""""
}
```

The objects wrapping the literals are important. A schema of `z.union([z.literal('A'), z.literal('B')])` worked fine.",,
745247742,229,z.infer to extract schema as a type,"Hi, first of all.. awesome library! Was wondering how you get the schema as a type? In v1 you could do z.infer<...> but infer doesn't seemingly exist in beta, unless I'm missing something? ",,
744448967,227,Repo restructuring to remove circular dependencies,"### Related issues

- https://github.com/colinhacks/zod/issues/175#issuecomment-724316421
- https://github.com/colinhacks/zod/pull/226

### RFC

- [ ] `base`s shouldn't import other modules
  - for example, `src/types/base.ts` should be reconsidered
- [ ] api reused in other modules should be modularized, for example:
  - `src/parser.ts` should be split into two files
    - `src/parser/index.ts` & `src/parser/types.ts` so the circular dependency between ZodError & parser is removed
      - and a similar approach could be done on other instances of circular dependency",,
744442742,225,Batch repo enhancements,"Let me please propose batch of changes to the DX, so it'd be easier for others to contribute.
Please let me know what you would approve, so I'd know what to help you with :)

### Todo (Not started yet)

- [ ] add [automated releases generation](https://medium.com/p/44c015f38fd6) and make commits messages more strict
  - as a user of this library, it was a bit time consuming to browse commits to realize what changed between `beta` versions

### Completed
- [x] use `typescript-eslint` instead of `tslint`
  - it's been almost 2 years since the standard in TS linting is `ESLint`, [more info](https://eslint.org/blog/2019/01/future-typescript-eslint)
- [x] add `.log` files to `.gitignore`
  - for example, there's already a mistakenly uploaded `yarn-error.log`
- [x] bump prettier & use community defaults
  - let's use the defaults, so it's more likely to please higher % of contributors
- [x] ~~add `.npmignore` to exclude unrelated files from the deployed package~~
  - improve the `files` + `exclude` instead
- [x] remove empty `dependencies` object from package.json
- [x] add `husky` to add `git` hooks
  - it's important to automatically prevent issues like in #218 from happening, when there are bunch of unrelated formatting changes
    - at least automatic code formatting should be in place
- [x] add official funding references of your GitHub sponsors link to the `package.json`
  - I suggest to start with the use described in [this PR from react-virtual](https://github.com/tannerlinsley/react-virtual/pull/78/files)
",,
743244862,224,Zod [V2] - Transforms are not called when using .output,"Hi @colinhacks 

When calling `parse` / `parseAsync` on a schema that uses `.output`, the transform isn't actually run. For example:

```typescript
const name = zod.string().transform(val => val.toUpperCase());
const result = await name.parse('Ross');
```

`result` returns `ROSS` as expected, however

```typescript
const name = zod.string()
                .transform(val => val.toUpperCase())
                .output; // <--- Append .output (then later, if this were an object I can `omit()` etc);

const result = await name.parse('Ross');
```

Appending `.output` and running the above returns `Ross`. The transform isn't called. I'm running `2.0.0-beta.21`",,
742632852,222,"Bug: Inconsistent ""Expected never, received array"" in v2","**Environment:**

> Node 12.18.2
> Webpack 4.44.2
> Zod 2.0.0-beta.21


```json
// tsconfig.json
// target: commonjs2
{
  ""compilerOptions"": {
    ""module"": ""commonjs"",
    ""target"": ""es2019"",
    ""lib"": [""es2020""],
    ""strict"": true,
    ""noImplicitAny"": true,
    ""strictNullChecks"": true,
    ""noImplicitThis"": true,
    ""alwaysStrict"": true,
    ""noImplicitReturns"": true,
    ""noFallthroughCasesInSwitch"": false,
    ""inlineSourceMap"": true,
    ""inlineSources"": true,
    ""experimentalDecorators"": true,
    ""emitDecoratorMetadata"": true,
    ""strictPropertyInitialization"": false,
    ""typeRoots"": [""./node_modules/@types"", ""./typings""]
  },
  ""include"": [""src/**/*""],
  ""exclude"": [""node_modules"", ""**/*.test.ts"", ""**/*.it.ts""]
}
```

**Error**

I'm experiencing the following error when the parser encounters an **unknown field**: `Expected never, received array`. 

The weirdest thing is that this does not happen in local development, but it only happens when files are bundle with webpack and production mode.

**Expected result**

According to v2 doc: _By default Zod object schema strip unknown keys from the output._

**Code**

Here's a snippet of code that I have:

```typescript
const atAgencySchema = z
  .object({
    agencyId: z.string(),
    market: z.enum(['X', 'Y', 'Z']),
    name: z.string(),
  })

// ...
const record = { agencyId: 'id', market: 'Y', name: 'yo', skills: ['1'] } 
atAgenciesSchema.parse(record) // throws ""Expected never, received array""
```

**Workaround**

Reverted back to v1, and used `nonstrict()`",,
740684239,219,Function Type Error,"@colinhacks Can you take a look at this?

```ts
import * as z from 'zod';

export type Data = boolean | null | number | string | undefined | { [key: string]: Data } | Data[];

export type Input = { [key: string]: z.Schema<Data> };
export type Output = z.Schema<Data | void>;
export type IO<I, O> = { input: I; output: O };

export function fn<I extends Input, O extends Output>(io: IO<I, O>) {
  return z.function(z.tuple([z.object(io.input)]), z.promise(io.output));
}

// ReturnType<typeof fn> doesn't work properly
type Fns = { [key: string]: ReturnType<typeof fn> };

export function createSchema<T extends Fns>(fns: T) {
  return fns;
}

export const UserSchema = createSchema({
  getMessage: fn({ // Type Error
    input: { name: z.string() },
    output: z.string(),
  }),
});
```",,
739390782,217,Can't use omit after calling transform,"Hi,

I've noticed that it's not possible to call `.transform` and then call `.omit`. Is this expected?

In the example below `const user` is invalid beacuse `omit` does not exist.

```typescript
export class Example {
  schema = zod.object({
    id: zod.number(),
    name: zod.string()
  }).transform((data) => data); //<-- just to illustrate the point

  create(name: string): zod.infer<Example['schema']> {
    const user = this.schema.omit({ id: true }).parse({ name });
    return this.db.save(user);
  }
}
```",,
737911987,216,Access to current object when using defaults,"Hi,

I'm trying to set a default value, depending on the value of another property within an object, for example:
- If `dataTypes` contains 'type_one', `responseTypes` should default to 'one'
- If `dataTypes` does not contain 'type_one', `responseTypes` should default to empty

```typescript
const myScheam = zod.object({
  dataTypes: zod.array(zod.enum(['type_one', 'type_two'])).nonempty(),
  responseTypes: zod.array(zod.enum(['one']).optional())
})
```
I can't see any way to do this using defaults / a transformer as I don't have access to the current object being parsed.

Is this currently not possible? (Using Zod 2.0.0-beta.20)

Thanks!",,
737757024,215,ESM module in Zod 2 beta causing runtime error,"With Zod 2.0.0-beta.20:

![Screenshot](https://i.imgur.com/0kYAYgU.png)

With Zod 1.11, no error.

Only seems to happen when using the object type
```ts
// no crash
z.string();
z.date();
// crashes
z.object({});
z.object({
  id: z.string(),
});
```
",,
736268013,214,"Feature request: Add ""Did you mean X?""","When misspelling a property in an object type, I get such an error right now:
```
Error: 1 validation issue(s)

  Issue #0: unrecognized_keys at 
  Unrecognized key(s) in object: 'errorrFormat'

    at new ZodError (/root/code/runtime-validation/node_modules/zod/src/ZodError.ts:124:5)
```
It would be great, if a ""Did you mean `errorFormat`?"" could be shown.

[In Prisma Client, we're using `js-levenshtein` for that purpose](https://github.com/prisma/prisma/blob/32b25e4ca23d068e123548454b0461ea60cb4999/src/packages/client/src/runtime/utils/common.ts#L190) (after comparing all the 500 levenshtein implementations on NPM 😄  )

",,
736079426,213,Feature Request: Allow generating an object with a full set of defaults that may not validate,"I am looking to use zod as a way to validate user configuration files for a command line utility.  It looks like a great fit compared to what we are doing now, but I am having trouble with one aspect.

The workflow we use is:

- Allocate an initial set of defaults in a nested object  (note: this isn't fully filled in so won't validate the schema)
- Pass to a user provided configuration function (ex. app.config.js) that extends the configuration
- Fill in final settings based upon combination of user and defaults
- Validate final config with schema.  (looking for extra properties, validation checks, etc)

My problem is that in this model I don't see a way to use zod to create the initial defaults object.  I know I could create it as a plain old javascript object separate from the schema, but I was hoping to take advantage of the .default() methods within the schema to have the schema be self describing without having a separate large defaults object.

So my hope was to make something like this work:

```javascript
const ConfigSchema = z.object({
   /** The name to use. */
   name: z.string().default('blah'),

   /** Another nested part. */
   nested: z
      .object({
         value: z.number(),
         val2: z
            .string()
            .nullable()
            .refine((v) => v && v.length === 5, 'Must be length 5.'),
      })
      .default({
         value: 20,
         val2: null,
      }),
});

type ConfigType = z.infer<typeof ConfigSchema>;

describe('zod', () => {
   it('validates a good value', () => {});

   it('can provide defaults to override', () => {
      // We can build a set of default values that don't validate yet
      const default_results = ConfigSchema.safeParse({});  // <--- Need something here to just get defaults
      const cfg = default_results.data;

      expect(cfg.nested.val2).toEqual(null);

      // then: user modifies it with config overrides
      cfg.nested.val2 = '12345';

      // and: now it can validate
      const results = ConfigSchema.safeParse(cfg);
   });
});
```

Is anything like this possible or practical as a feature in zod?  I think it is effectively a SafeParse that doesn't do any checks, but instead just sets the default values on the object passed in.",,
736036467,212,How to define two objects that depends on each other (circular references)?,"In typescript youre able to create two types that depends in each other, ex:

```ts
type ObjectA = {
  b: ObjectB;
};

type ObjectB = {
  a: ObjectA;
};
```
But a similar pattern doesn't work with zod
```ts
const zObjectA = z.object({
  b: zObjectB,
});

const zObjectB = z.object({
  a: zObjectA,
});
```
`- error TS7022: 'zObjectA' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.`
",,
735418268,211,Request for help: typed Zod combinator with dynamic field name,"I apologize, this is almost certainly not the correct place to ask, but I'm not sure where else.

I asked [this question](https://stackoverflow.com/questions/64665779/typed-zod-combinator-with-dynamic-key) on Stack Overflow, reproducing it below.

___

My XML to JSON library emits `{MyKey: T}` for one-element lists, and `{MyKey: T[]}` for multi-element lists. The corresponding TypeScript type is `type XmlJsonArray<T, element extends string> = Record<element, T | T[]>`. I've used the following to implement it as a Zod schema:

```typescript
const XmlJsonArray = <T, element extends string>(element: element, schema: z.Schema<T>) => {
  // TODO what is the idiomatic approach here?
  const outerSchema: Record<element, z.Schema<T | T[]>> = {} as any;
  outerSchema[element] = z.union([schema, z.array(schema)]);
  return z.object(outerSchema);
};
```

Is there a way to do this without using `any`?",,
734578141,210,Lack of flexibility and escape hatches,"I am in the process of turning huge dynamically loaded config (that wasn't validated before and was simply huge `interface`) into a `zod` schema. I am running into some issues related to the fundamental lack of flexibility in zod. It seems like in some scenarios I cannot turn off validation in zod entirely. 

Code like this:
```typescript
interface Worker {
	doWork: (services: Service): Promise<void>;
}
```

`services` here is a complicated object with a variety of dependencies and I simply don't want to validate it in any way. I am fine with assuming that function provided by the user is correct. Also I don't want to suffer a performance impact by using `args` and `returns`. It seems like it's not possible to express this in any way in zod.

1) Using `z.function()` will end up being inffered as `() => unknown`.

```typescript
z.object({doWork: z.function()})
``` 

2) Using `z.any()` ends up being inferred as *optional* property which is not what I wanted ie.

```typescript
z.object({doWork: z.any().refine(v => v instanceof Function)})
```

is:

```
{
	doWork?: any
}
```

It would be cool to have some way to override type inferred by zod to anything else (it would also allow simple implementation for opaque types). For example:

```typescript
z.object({doWork: z.function().cast<((services: Service) => Promise<void>)>()})
```",,
730432892,202,protected _refinement field in ZodType breaks cross package schema usage,"- package A (has dependency on zod)
```ts
import * as z from 'zod';

export const s = z.object({
    id: z.string(),
});
```
- package B (also has dependency on zod)
```ts
import { s } from 'package A';
import * as z from 'zod';

const makeValidator = <T>(schema: z.ZodType<T>) => {
    return (thing) => schema.safeParse(thing);
};

export const validator = makeValidator(s); // line 26
```
- error on `line 26`:
```
Property '_refinement' is protected but type 'ZodType<Type, Def>' is not a class derived from 'ZodType<Type, Def>'
```

I think this issue is caused by this typescript limitation https://github.com/microsoft/TypeScript/issues/7755

I have found the following workaround to get structural typing to work again
```ts
type SafeParseResult<T> =
    | {
          success: true;
          data: T;
      }
    | {
          success: false;
          error: z.ZodError;
      };

interface ZodParser<T> {
    safeParse(thing: unknown): SafeParseResult<T>;
}

const makeValidator = <T>(schema: ZodParser<T>) => {
    return (thing) => schema.safeParse(thing);
};

export const validator = makeValidator(s); // ok
```

Another workaround is to have package A declare a peerDependency on `zod`, but that's  a pain.

A nice solution would be to export an interface to make working with schemas in a generic fashion easier. I think schemas should all implement a unique interface, similar to ZodType<T> but without the protected/private components.",,
729571831,199,Zod 2: nested transforms don't work,"I'm trying to use Zod to parse data that has arrays nested in an object like this (don't blame me, from a third party :D):

```ts
const classes = {
  elements: [
    {
      students: {
        elements: [{ id: 1 }, { id: 2 }, { id: 3 }],
      },
    },
    {
      students: {
        elements: [{ id: 4 }, { id: 5 }, { id: 6 }],
      },
    },
  ],
};
```

I can write a parser like this, that works as expected, but there's a lot of boilerplate:

```ts
const studentSchema = z.object({
  id: z.number(),
});

const classesSchema = z.object({
  elements: z.array(
    z.object({
      students: z.object({
        elements: z.array(studentSchema),
      }),
    }),
  ),
});

classesSchema.parse(classes); // works
```

I wrote a helper function, that builds the array schema and uses transforms to remove it from the parsed data:

```ts
export const transformArray = <T extends z.ZodTypeAny>(childSchema: T) => {
  const schema = z.object({
    elements: z.array(childSchema),
  });

  return z.transformer(schema, z.array(childSchema), (val) => val.elements);
};

const classTransformSchema = z.object({
  students: transformArray(studentSchema),
});

classTransformSchema.parse(classes.elements[0]); // works
```


However if I try to use this to parse the whole object, it compiles and has the correct return type, but at runtime throws an error:

```ts
const classesTransformSchema = transformArray(classTransformSchema);

classesTransformSchema.parse(classes); // throws `invalid_type` error
```

* Zod 2.0.0-beta.16
* TypeScript 4.0.3",,
724744927,196,Not getting infer in TS types,"![image](https://user-images.githubusercontent.com/19697099/96473797-b26aeb80-124f-11eb-8148-beb229a62018.png)

I am on the beta version of Zod and I'm facing this error from TypeScript.

This is my `tsconfig.json`

```json5
{
  ""compilerOptions"": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */
    /* Basic Options */
    // ""incremental"": true,                   /* Enable incremental compilation */
    ""target"": ""ES2018"" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */,
    ""module"": ""commonjs"" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */,
    ""lib"": [
      ""ESNext""
    ] /* Specify library files to be included in the compilation. */,
    // ""allowJs"": true,                       /* Allow javascript files to be compiled. */
    // ""checkJs"": true,                       /* Report errors in .js files. */
    // ""jsx"": ""preserve"",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */
    // ""declaration"": true,                   /* Generates corresponding '.d.ts' file. */
    // ""declarationMap"": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */
    ""sourceMap"": true /* Generates corresponding '.map' file. */,
    // ""outFile"": ""./"",                       /* Concatenate and emit output to single file. */
    ""outDir"": ""./dist"" /* Redirect output structure to the directory. */,
    // ""rootDir"": ""./src"" /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */,
    // ""composite"": true,                     /* Enable project compilation */
    // ""tsBuildInfoFile"": ""./"",               /* Specify file to store incremental compilation information */
    // ""removeComments"": true,                /* Do not emit comments to output. */
    // ""noEmit"": true,                        /* Do not emit outputs. */
    // ""importHelpers"": true,                 /* Import emit helpers from 'tslib'. */
    // ""downlevelIteration"": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    ""isolatedModules"": true /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */,
    /* Strict Type-Checking Options */
    ""strict"": true /* Enable all strict type-checking options. */,
    ""noImplicitAny"": true /* Raise error on expressions and declarations with an implied 'any' type. */,
    ""strictNullChecks"": true /* Enable strict null checks. */,
    // ""strictFunctionTypes"": true,           /* Enable strict checking of function types. */
    // ""strictBindCallApply"": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // ""strictPropertyInitialization"": true,  /* Enable strict checking of property initialization in classes. */
    // ""noImplicitThis"": true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    ""alwaysStrict"": true /* Parse in strict mode and emit ""use strict"" for each source file. */,
    /* Additional Checks */
    // ""noUnusedLocals"": true,                /* Report errors on unused locals. */
    // ""noUnusedParameters"": true,            /* Report errors on unused parameters. */
    // ""noImplicitReturns"": true,             /* Report error when not all code paths in function return a value. */
    // ""noFallthroughCasesInSwitch"": true,    /* Report errors for fallthrough cases in switch statement. */
    /* Module Resolution Options */
    // ""moduleResolution"": ""node"",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // ""baseUrl"": ""./"",                       /* Base directory to resolve non-absolute module names. */
    // ""paths"": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // ""rootDirs"": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    // ""typeRoots"": [],                       /* List of folders to include type definitions from. */
    // ""types"": [],                           /* Type declaration files to be included in compilation. */
    // ""allowSyntheticDefaultImports"": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    ""esModuleInterop"": true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */,
    // ""preserveSymlinks"": true,              /* Do not resolve the real path of symlinks. */
    // ""allowUmdGlobalAccess"": true,          /* Allow accessing UMD globals from modules. */
    /* Source Map Options */
    // ""sourceRoot"": """",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // ""mapRoot"": """",                         /* Specify the location where debugger should locate map files instead of generated locations. */
    // ""inlineSourceMap"": true,               /* Emit a single file with source maps instead of having a separate file. */
    // ""inlineSources"": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */
    /* Experimental Options */
    // ""experimentalDecorators"": true,        /* Enables experimental support for ES7 decorators. */
    // ""emitDecoratorMetadata"": true,         /* Enables experimental support for emitting type metadata for decorators. */
    /* Advanced Options */
    ""skipLibCheck"": true /* Skip type checking of declaration files. */,
    ""forceConsistentCasingInFileNames"": true /* Disallow inconsistently-cased references to the same file. */
  },
  ""include"": [
    ""src/**/*""
  ]
}
```",,
724043335,194,z.infer not required by default?,"![image](https://user-images.githubusercontent.com/4253551/96373779-e20aec80-1198-11eb-87e6-61b065330b77.png)

I'm using Typescript 4.0.3 and zod 1.11.9",,
723091768,192,v2.0.0-beta.12: Cannot find module <...>/node_modules/zod/[]]./lib/src/index.js'.,"After upgrading to `v2.0.0-beta.12` I started getting the following error:

```
Cannot find module <...>/node_modules/zod/[]]./lib/src/index.js'.
```

Caused by this line:
https://github.com/vriad/zod/blob/v2/package.json#L5

It seems that the main field in the package.json file was very recently changed from:

```
""main"": ""./lib/src/index.js"",
```
to

```
""main"": ""[]]./lib/src/index.js"",
```

",,
722834341,191,Missing type for discriminated union result of safeParse,"Maybe I am doing something incorrectly here.

If I have an array of results from `safeParse`, and I want to filter on the successful ones and then use the `data` from each, I need a type to pass to the `Array.filter` function. Zod does not export a type like this, because the appropriate type is only defined inline: 
https://github.com/vriad/zod/blob/d1ae8e3538167a41e13ab6cfc2466ef3ca69e63a/src/types/base.ts#L69

I defined a type that takes the `typeof` of a schema as input, and can then be passed to `.filter` to allow this behavior.

The type is:
```
type ZodSafeParseSuccess<T extends zod.ZodSchema<T['_input']>> = { success: true; data: zod.infer<T> };
```
And assuming `parseResult` is the output of calling `safeParse` on an input (say objects retrieved from a database or sent by a client), here is example usage:
```
  [parseResult]
    .filter(
      (result): result is ZodSafeParseSuccess<typeof someSchema> => result.success === true,
    )
    .map((result) => result.data);
```

Here, in the `.map` tsc will know that `data` exists and infer its type correctly based on the schema. 

An appropriate `ZodSafeParseError` type could easily be derived similarly.

Looking forward to feedback - was there an easier way to do this, or should this be closed as a reference for how to fix, or should I open a PR and add this type definition into Zod?",,
718632595,188,type infer of schema.default() not optional automatically?,"![image](https://user-images.githubusercontent.com/33362998/95657702-80cd8400-0adb-11eb-91fd-cab5a52e4265.png)

> Equivalently you can express this using the built-in .default() method, available on all Zod schemas. The default value will be used if and only if the schema is undefined.

Should schema be optional when default is defined? ",,
714600379,181,How to relate two object fields?,"What is the best way to relate two objects fields in a schema?

Ex: 

```ts
enum AnimalType {
  Cow,
  Cat,
}

const cowSchema = z.object({
  moo: z.string(),
});

const catSchema = z.object({
  meow: z.string(),
});

const animalSchema = z.object({
  animalType: z.nativeEnum(AnimalType),
  animalData: z.union([cowSchema, catSchema]),
});
```

I want to parse the object in a way that if the user sets the animalType to Cat, zod will parse animalData using the catSchema. Is it possible to do this without using the refine mehtod?",,
714034849,180,v2 beta: Type 'Shape' does not satisfy the constraint 'ZodRawShape',"When compiling with `zod@2.0.0-beta.9` on TypeScript `4.0.3`, I get this error:

```
node_modules/zod/lib/src/helpers/partialUtil.d.ts(11,39): error TS2344: Type 'Shape' does not satisfy the constraint 'ZodRawShape'.
node_modules/zod/lib/src/helpers/partialUtil.d.ts(11,94): error TS2344: Type '{ [k in keyof Shape]: DeepPartial<Shape[k]>; }' does not satisfy the constraint 'ZodRawShape'.
  Type 'DeepPartial<Shape[k]>' is not assignable to type 'ZodTypeAny'.
    Type '{ object: Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptional<...> : never; rest: ReturnType<...>; }[S...' is not assignable to type 'ZodType<any, any, any>'.
      Type '{ object: Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptional<...> : never; rest: ReturnType<...>; }[S...' is not assignable to type 'ZodType<any, any, any>'.
        Type '{ object: Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptional<...> : never; rest: ReturnType<...>; }[S...' is not assignable to type 'ZodType<any, any, any>'.
          Type '{ object: Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptional<...> : never; rest: ReturnType<...>; }[S...' is not assignable to type 'ZodType<any, any, any>'.
            Type '(Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptio...' is not assignable to type 'ZodType<any, any, any>'.
              Type 'ReturnType<Shape[k][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                Type 'unknown' is not assignable to type 'ZodType<any, any, any>'.
                  Type 'ReturnType<Shape[keyof Shape][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                    Type 'unknown' is not assignable to type 'ZodType<any, any, any>'.
                      Type 'ReturnType<Shape[string | number | symbol][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                        Type 'unknown' is not assignable to type 'ZodType<any, any, any>'.
                          Type 'ReturnType<Shape[string][""optional""]> | ReturnType<Shape[number][""optional""]> | ReturnType<Shape[symbol][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                            Type 'ReturnType<Shape[string][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                              Type 'unknown' is not assignable to type 'ZodType<any, any, any>'.
node_modules/zod/lib/src/helpers/partialUtil.d.ts(12,45): error TS2344: Type 'Shape[k]' does not satisfy the constraint 'ZodTypeAny'.
  Type 'Shape[keyof Shape]' is not assignable to type 'ZodType<any, any, any>'.
    Type 'Shape[string] | Shape[number] | Shape[symbol]' is not assignable to type 'ZodType<any, any, any>'.
      Type 'Shape[string]' is not assignable to type 'ZodType<any, any, any>'.
```

- `zod@1.11.9` compiles fine
- When looking at `node_modules/zod/lib/src/helpers/partialUtil.d.ts(11,39)` I see red squiggles in VS Code. I suspect it could be a type error in the library.

My `tsconfig.json`:
```
{
  ""compilerOptions"": {
    ""module"": ""CommonJS"",
    ""target"": ""ES2019"",
    ""strict"": true,
    ""outDir"": ""dist"",
    ""esModuleInterop"": true
  },
  ""include"": [""src""]
}
```
",,
713224877,179,Failed async refinement causes other `issues` to not be returned,"When using the new `safeParseAsync` an async validation failure causes the `issues` array to only contain the async failure, the other errors are not included in the returned value.  Is this expected? The failing test is posted below.
```
import * as z from 'zod'

test('testing zod', () => {
  expect.assertions(2)
  const base = z.object({
    hello: z.string(),
    foo: z.number()
      .refine(async (data) => {
        return false
      }, {message: ""invalid""})
  })
  const result = base.safeParseAsync({hello: 3, foo: 3})

  return result.then(r => {
    expect(r.success).toBe(false)
    if (r.success === false) 
      expect(r.error.issues.length).toBe(2) // <--- `issues` has length of 1 here
  });
});
```",,
713070385,178,[Feature Request]: Ability to provide a message to types,"I am currently using Blitz.js which uses zod for validation on the server and on the client. Everything works perfectly exept one small thing. When I want to customize the error message ""Required"" that is thrown by z.string() or other similar functions, there is not a good way to to it. With min() i can just provide the message as a prop, for z.string() I either have to provide a custom ZodErrorMap or avoid using zod for this. Would it be possible to change the string method to exept a message prop like this?
```typescript
z.string({message: ""Email is a required field.""})
```
or
```typescript
z.string(""Email is a required field."")
```",,
710779966,176,"Type 'ZodTransformer<ZodAny, ZodBoolean>' is not assignable to type 'ZodTypeAny'","Is this error meant to be correct? If so I feel like I just missed something fundamental in how to use transforms.

I am using the transforms I created in [pip-types](https://github.com/bamboocreativenz/pip-types/blob/8918d7721383aaac5a39ea07b88077db244b4bdc/src/boolean.ts#L120), though in the new project I updated zod to `""zod"": ""^2.0.0-beta.9""` and can compile and run the tests.

The code: 

```
export const surveyRecordTransform = z.object({
  name: z.string(),
  archive: zToBoolean,
  ... (100 more such lines)
})
```

I would then use this:

```
const typedSurveyRecord = surveyRecord.parse(data)
```

And i get this error (from VSCode type checking)

```shell
(property) Archive: ZodTransformer<ZodAny, ZodBoolean>
Type 'ZodTransformer<ZodAny, ZodBoolean>' is not assignable to type 'ZodTypeAny'.
```

<details>
<summary>Rest of error :)</summary>

```
  Types of property 'parse' are incompatible.
    Type '(x: unknown, params?: ParseParams) => boolean' is not assignable to type '(x: unknown, params?: ParseParams) => any'.
      Types of parameters 'params' and 'params' are incompatible.
        Type 'import(""...node_modules/zod/lib/src/parser"").ParseParams' is not assignable to type 'import(""...node_modules/zod/lib/src/parser"").ParseParams'.
          Types of property 'seen' are incompatible.
            Type '{ schema: any; objects: { data: any; error?: any; times: number; }[]; }[]' is not assignable to type '{ schema: ZodType<any, ZodTypeDef, any>; objects: { input: any; error?: ZodError; output: any; }[]; }[]'.
              Type '{ schema: any; objects: { data: any; error?: any; times: number; }[]; }' is not assignable to type '{ schema: ZodType<any, ZodTypeDef, any>; objects: { input: any; error?: ZodError; output: any; }[]; }'.
                Types of property 'objects' are incompatible.
                  Type '{ data: any; error?: any; times: number; }[]' is not assignable to type '{ input: any; error?: ZodError; output: any; }[]'.
                    Type '{ data: any; error?: any; times: number; }' is missing the following properties from type '{ input: any; error?: ZodError; output: any; }': input, outputts(2322)
base.d.ts(29, 5): The expected type comes from this index signature.
```

</details>


I do realise that I am trying to compose my transform within another Zod object and thinking about this now I realise this may not have been how I am meant to use it.

ie make a bunch of coercion transforms and then use these in Zod Objects to then use on incoming Api data to both map and coerce the types and provide static typing for development... AND very LOUD errors should the coercion fail. #my-little-dream

",,
710608434,175,Generate an ESM bundle,"Hello! Would you be open to a pull request adding an ESM bundle? This would require roughly two changes:

1) add a build script `build:esm`, building the project using a slightly modified `tsconfig.json` and outputting to `dist/esm` (or similar).
2) add a `module` field to `package.json` pointing to `dist/esm/index.js`.

If you are keen I am happy to PR :)

Thanks for the library!",,
710435023,174,In V2 how to get `parseAsync` to collect errors for all fields?,"Firstly, thanks for this great lib! I'm wondering how to collect errors for all fields in the new `parseAsync` method?  It seems to stop collecting after the first error.
```
import * as z from 'zod'

const schema = z.object({
  username: z.string().nonempty(),
  password: z.string().nonempty(),
});

schema.parseAsync({username: '', password: ''})
  .then(() => {})
  .catch(e => {
    if (e.errors.length !== 2) {
      throw 'Expected two errors'
    }
  })
```",,
709295377,168,Usage in JavaScript,"Hi,

Can this library be used with pure JavaScript (no TypeScript)?

I read the documentation and despite the **strictNullChecks** requirement and types, it doesn't says can't be used with JavaScript.

I made a test here in a mixed JavaScript/TypeScript project without **strictNullChecks** and it worked.

I was thinking about using the library in a pure JavaScript project, so I would like to see your opinion and recommendations on the matter, possibly mentioning in the docs.

Thanks.",,
707778778,166,Zod 2 beta 5: applying transform() to arrays ,"Hi,

I'm trying to use `.transform()` on a string array to remove possible duplicates.
This is my schema:
```ts
DummyInput = z.object({
  pokemonTypes:
    z.array(string())
    .nonempty()
    .transform(cleanDuplicateStringsFromArray)
})
```
The function signature is `(array: string[]) => string[]`. Seems right - take an array of strings and transform it to itself.. although I get an error: 
```
TS2345: Argument of type '(array: string[]) => string[]' is not assignable to parameter of type '(arg: [string, ...string[]]) => string | Promise<string>'.   Type 'string[]' is not assignable to type 'string | Promise<string>'.     Type 'string[]' is not assignable to type 'string'.
```

Am I missing something here?",,
706227292,163,[Feature Request]: zod2 access to refinementData,"in zod2 there's no way anymore to access the refinementData.  

This can be very convenient when we want to reuse the info to display hints in the GUI (e.g. _The password must have between 5 and 10 characters_, ..)

We could simply add the refinement data as a property to the check function: e.g. in `base.ts`: 

```ts
refinement = (
    check: (arg: Output) => any,
    refinementData: MakeErrorData | ((arg: Output) => MakeErrorData),
  ) => {
    const augmentedCheck = (val, ctx) => {
      if (!check(val)) {
        ctx.addError(
          typeof refinementData === 'function'
            ? refinementData(val)
            : refinementData,
        );
      }
    };
    augmentedCheck.refinementData = refinementData;
    return this._refinement(augmentedCheck);
  };
```

Then we can simply loop over all `ZodTypeDef.checks` and check the `refinementData` property is set",,
706032122,161,Zod 2 beta 5: parse() adds optional fields with 'undefined' as a value,"Hi @vriad,

I've upgraded to Zod 2 beta and it works cool.

The first bug I've met now, is that if you send an object without certain optional fields, `.parse()` adds them with undefined value.

For instance, my schema looks like that (simplified):
```ts
export const SNamedEntity = z.object({
  _id: string().refine(validateUUID),
  name: z.string().max(100),
  createdAt: string().refine(validateDateString).optional(),
  updatedAt: string().refine(validateDateString).optional(),
  isActive: boolean().optional(),
});
```
And the object I send to it has only `_id` and `name`. However, when I set a breakpoint after I `.parse()` this object with the with the above schema, I see that all of the optional fields are present there now: 

```js
{ 
  _id: '5f6418f13b179e3da326a1aa',
  name: ""John Doe"",
  createdAt: undefined,
  updatedAt: undefined,
  isActive: undefined,
}
```

It freaks out Mongo, it thinks that I'm trying to overwrite its internal createdAt field with undefined and throws me an error.

Interestingly, if I send a valid date in createdAt field, mongo is totally allright with that (it ignores it as it should). Only `undefined` trips it :)
",,
705215298,159,.safeParse() and generics,"Hi,

I have a quick question.

I want to wrap `safeParse()` into a utility method, that gets an `unknown` object, `ZodObject` and returns the parsed data if succeeded, like this:

```
export const shapeObject = (object: unknown, zodObject: AnyZodObject) => {
  const validationResult = zodObject.safeParse(object);
  if (validationResult.success) {
    return validationResult.data;
  } 
  
  return null;
}
```

The question is, what is the correct way to type such a method? Can I somehow use generics to know what will it return?

Thanks,",,
704910090,158,[Proposal] Attaching metadata to schema,"I am proposing to add `.meta()` method that allows attaching metadata to schema

## Proposed way it would work
Basic usage:
```ts
const schema = z.string().meta({ some: ""data"" })

schema.meta // => { some: ""data"" }
```
Multiple `.meta` calls would merge (shallowly) with previous metadata and overwrite repeated fields:
```ts
const schema = z.string()
  .meta({ foo: 1, bar: 2, nested: { prop: ""data"" }})
  .meta({ baz: 3, nested: { otherProp: ""data"" }})
  .meta({ foo: 4 })

schema.meta // => { foo: 4, bar: 2, baz: 3, nested: { otherProp: ""data"" }}
````
`.meta` would have following signature:
```ts
meta(metadata: Record<string, any>): this
```
## Use cases:
One of the uses cases i can think of is generating forms from schema. Imagine library that does that, more or less in following way:
```jsx
// from this schema
const schema = z.object({
  username: z.string(),
  age: z.number().min(18),  
})
// this is generated form:
<form>
  <input type=""text"" name=""username"" />
  <input type=""number"" name=""age"" />
</form>
```
Now, let's say we want to use certain component (assuming React here) for certain field. For example we want to use `FancyPhoneNumberField` component for `phone` field:
```jsx
// from this schema
const schema = z.object({
  username: z.string(),
  age: z.number().min(18),
  phone: z.string().meta({ formgenComponent: FancyPhoneNumberField })
})
// this is generated form:
<form>
  <input type=""text"" name=""username"" />
  <input type=""number"" name=""age"" />
  <FancyPhoneNumberField name=""phone"" />
</form>
```
_Of course library like this would probably add much more props but this is minimal version to understand use case_

There are probably many other cases where attaching metadata would be useful.

 I am willing to implement and document this if gets accepted
",,
701882808,153,Support parametrisable schemas,"It would be cool to be able to do something like this:

```ts
export type Foo<T> = {
  name: string
  value: T
}

const fooSchema = <T>(valueSchema: z.ZodSchema<T>): z.ZodSchema<Foo<T>> => z.object({
  name: z.string(),
  value: valueSchema
})
```

(In fact it would be even cooler to be able to use `z.infer` on the `ReturnType<typeof fooSchema>`, but TypeScript is not yet capable of this -- see https://github.com/microsoft/TypeScript/issues/40542)

The above code produces the following compile error, which I have to be honest, is beyond my understanding:
```
error TS2322: Type 'ZodObject<{ name: ZodString; value: ZodType<T, ZodTypeDef>; }, { strict: true; }, { [k in keyof ({ [k in undefined extends T ? ""value"" : never]?: { name: string; value: T; }[k] | undefined; } & { [k in Exclude<...> | Exclude<...>]: { ...; }[k]; })]: ({ [k in undefined extends T ? ""value"" : never]?: { ...; }[k] | und...' is not assignable to type 'ZodType<Foo<T>, ZodTypeDef>'.
  Types of property '_type' are incompatible.
    Type '{ [k in keyof ({ [k in undefined extends T ? ""value"" : never]?: { name: string; value: T; }[k] | undefined; } & { [k in Exclude<""name"", undefined extends T ? ""value"" : never> | Exclude<...>]: { ...; }[k]; })]: ({ [k in undefined extends T ? ""value"" : never]?: { ...; }[k] | undefined; } & { [k in Exclude<...> | Exclu...' is missing the following properties from type 'Foo<T>': name, value

45 const fooSchema = <T>(valueSchema: z.ZodSchema<T>): z.ZodSchema<Foo<T>> => z.object({
                                                                              ~~~~~~~~~~
46   name: z.string(),
   ~~~~~~~~~~~~~~~~~~~
47   value: valueSchema
   ~~~~~~~~~~~~~~~~~~~~
48 })
   ~~
```",,
701880273,152,Specific Optional Type,"I was just playing around with various things, and I noticed optional-ness is reapplied to things depending on how you write it, for example if I write it this way (see below), `message` is ""double optional"" since that is what the code says it is. But double optional doesn't have any meaning - so it can be flattened.

so i have this union which makes sense given the code below

`    message: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodUndefined]>, z.ZodUndefined]>;`

can it become:  `    message: z.ZodUnion<[z.ZodString, z.ZodUndefined]>;`

Optional is not just a union with undefined though, it also includes ""missing"" / ""not there at all"". So there seems to be something that is not being captured currently.

Unions also seem to be a weak point in the error messaging which is otherwise top notch. Having a specific optional - lets you give the error message for the optional type instead of the union which i think is a pretty big deal.

Right now all unions (so all optionals) give the same error:

```
[Error: 1 validation issue(s)

     Issue #0: invalid_union at message
     Invalid input
   ]
```
vs a non-optional of the same

```
[Error: 1 validation issue(s)

     Issue #0: invalid_type at message
     Expected string, received number
   ]
```

This difference only make sense if you know that optional was being represented by a union with undefined in which we no longer know which option in the union is our type.

Code i was experimenting with is below for reference

```ts
const ErrorBase = z
    .object({
        message: z.string(),
        stack: z.string(),
    })
    .partial();

export const ErrorType = ErrorBase.extend({
    name: z.string(),
    code: z.number(),
    context: z.record(z.any()),
    cause: ErrorBase,
}).partial();
```

",,
700825040,150,Error message formatting,"Currently, the error message is generated with `./index` as a separator when joining the path segments of an error, making the message quite difficult to read (especially when you have many path segments).

`[0, 'status']` gives: `Issue #1: invalid_enum_value at 0./indexstatus`

I feel this should either be `/` or `, `, or is there a specific reason for this? It looks like part of an import path, so maybe some editor shenanigans?",,
700711451,149,Optional support for tuples,"I have tried everything I can think of - however something is preventing me from writing a function type for variable number of parameters.

I can very easily write a tuple in typescript that support a variable number of elements

```ts
    type OneOrTwo = readonly [number, Record<string, string>?] 

    const one: OneOrTwo = [1] as const;
    const likeOne: OneOrTwo = [1, undefined] as const
    const two: OneOrTwo = [1, {}] as const;
```

However I cannot figure out how to do the same with zod.

```ts
const contract = {
    parms1: z.tuple([z.number()]),
    parms2: z.tuple([z.number(), z.record(z.any()).optional()]),
    ret: z.string(),
};

const p2 = z.tuple([z.number(), z.record(z.any()).optional()]) 
const u = z.union(contract.parms1, contract.parms2); // type error

p2.parse([1] as const) // too_small
u.parse([1] as const) //  invalid_union
```

It appears that it is not supported - what is involved in supporting it?

Note that since my use case is function schemas - i need to support:

```
[1]
[1, {}]
[1, undefined]
```",,
699504391,148,"Pass context to parse methods, to use it in refinements","Hello,

I'm using Zod in the backend, and GraphQL.

I have the following code:

```typescript
// zod schema
const CREATE_SCHEMA = z.object({
  cliente: z.number()
  // other properties...
});

// GraphQL resolver
const resolver: Resolvers = {
  Mutation: {
    createChequeDevolvido: (parent, { input }, context) => {
      CREATE_SCHEMA.safeParse(input);
      // persist validated input in database...
    }
  }
};
```

The `cliente` property is an id to the table `cliente`, and I want to validate if it exists.

So it would look like this (using Objection.js):

```typescript
// zod schema
const CREATE_SCHEMA = z.object({
  cliente: z.number().refine(async arg => Cliente.query().where(""id"", arg).first(), {
    message: ""Cliente não existe no banco de dados.""
  });
  // other properties...
});
```

But I need to add the `tenant` key to that query, but the `tenant` key is only avaliable in the `context` argument within the GraphQL resolver.

In Joi, you can pass a `context` property in the `validate` methods. This `context`is a bag of values to be used in the validation schemas.

By having something like that in Zod, we pass a `context` option in the `parse` methods, and this `context`is avaliable as a parameter in the `refine`method, and other places if necessary.

I think that would solve my problem. Something like this:

```typescript
// zod schema
const CREATE_SCHEMA = z.object({
  cliente: z.number().refine(async (arg, context) => Cliente.query()
      .where(""id"", arg)
      .where(""tenant"", context.tenant)
      .first(), {
    message: ""Cliente não existe no banco de dados.""
  });
  // other properties...
});

// GraphQL resolver
const resolver: Resolvers = {
  Mutation: {
    createChequeDevolvido: (parent, { input }, context) => {
      CREATE_SCHEMA.safeParse(input, {
        context: {
          tenant: context.tenant // the context here is the GraphQL context
        }
      });
      // persist validated input in database...
    }
  }
};
```

In short, this would add the possibility of using external, runtime values in validations.

What do you think?

Sorry if this was in docs or in another issue, but I couldn't find it.

Thanks.

",,
697273255,146,bi-directional virtuals population issue,"Hi,

Thanks for your work - Typegoose makes life with Mongo and Typescript a breeze :)

I have a strange issue (probably, because I'm trying to do a strange thing).
In my use case, Users can follow each other, and these relations contain additional properties - so I moved them to the separate model Followship. 

Followship has `followerId` and `followeeId` (both IDs of Users) to define the relation. What I want is an ability to pull the Followships separately and populate Users in them, and also an ability to pull Users with their Followships populated.

So here is how my models look:

User:
```typescript
@modelOptions({
  schemaOptions: {
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
})
export class User {

  @prop({ required: true })
  public name!: string;

  @prop({unique: true})
  public email!: string;

  @prop()
  public password!: string;

  // 
  @prop({
    ref: Followship,
    type: Followship,
    localField: '_id',
    foreignField: 'followeeId',
    justOne: false
  })
  public followers?: Ref<Followship>[];

  @prop({
    ref: Followship,
    type: Followship,
    localField: '_id',
    foreignField: 'followerId',
    justOne: false
  })
  public followees?: Ref<Followship>[];

  public static getById(this: ReturnModelType<typeof User>,
                        id: string
  ): Promise<DocumentType<User> | null> {
    return this.findById(id)
      .select('name email address')
      .populate('followees')
      .populate('followers')
      .exec();
  }
}
```

Followship:
```typescript
@modelOptions({
  schemaOptions: {
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
})
export class Followship {
  @prop({ required: true })
  followerId!: ObjectID;

  @prop({ required: true })
  followeeId!: ObjectID;

  @prop({
    ref: User,
    localField: ""followerId"",
    foreignField: ""_id"",
    justOne: true
  })
  public follower?: Ref<User>;

  @prop({
    ref: User,
    localField: ""followeeId"",
    foreignField: ""_id"",
    justOne: true
  })
  public followee?: Ref<User>;

  @prop()
  seeFirst!: boolean;

  public static getFollowersOfUser(this: ReturnModelType<typeof Followship>,
                                   userId: string
  ): Promise<DocumentType<Followship>[]> {
    return this.find({ followeeId: userId })
      .populate({ path: ""follower"" })
      .exec();
  }
}
```

The issue is the following:
When I call `User.getById()`, I get the User object correctly populated with followers and followees (is there a better term for it in English btw?). But when I call `Followship.getFollowersOfUser()`, I get the array of Followships - with `follower: null`.
Debug mode shows, that `Followship.getFollowersOfUser()` tries to find the User ids in the Followship collection, and obviously fails:
```
Mongoose: followships.find({ followeeId: ObjectId(""5f5836e2de810118a26bddba"") }, { projection: {} })
Mongoose: followships.find({ _id: { '$in': [ ObjectId(""5f56808196a0b238cf32fcff"") ] } }, { skip: undefined, limit: undefined, perDocumentLimit: undefined, projection: {} })
```

The thing is, that if I remove the virtual fields from User model, `Followship.getFollowersOfUser()` returns just fine:
```
Mongoose: followships.find({ followeeId: ObjectId(""5f5836e2de810118a26bddba"") }, { projection: {} })
Mongoose: users.find({ _id: { '$in': [ ObjectId(""5f56808196a0b238cf32fcff"") ] } }, { skip: undefined, limit: undefined, perDocumentLimit: undefined, projection: {} })
```

Am I doing something wrong, or is there a workaround for this? Except using only the User's virtuals",,
696814704,145,valid object fails to be parsed when using z.intersection,"I tried following the intersection example in your README:

```typescript
const HasId = z.object({
    id: z.string(),
});
  
const BaseTeacher = z.object({
    name: z.string(),
});
  
const Teacher = z.intersection(BaseTeacher, HasId);

type Teacher = z.infer<typeof Teacher>;

const t: Teacher = { // compiles ok
    id: '123',
    name: 'hello'
};

Teacher.parse(t); // => throws
console.log('ok');
```
prints the following:
```
2 validation issue(s)

  Issue #0: unrecognized_keys at
  Unrecognized key(s) in object: 'id'

  Issue #1: unrecognized_keys at
  Unrecognized key(s) in object: 'name'
```

if I replace the `Teacher` zod definition with:
```typescript
const Teacher = z.object({
    id: z.string(),
    name: z.string()
});
```
then the object is validated ok.

Am I doing something wrong ? I'm using the latest 1.11.5 version on TS 4.0.2",,
692428224,142,Some questions,"Hello,

I'm giving a try of your lib in my project, and it looks quite nice.

I have some questions, sorry if this is not the best place to do it, but I didn't find a tag in stackoverflow...

1 - Can I use this lib in the backend and frontend, or just in one of two?

2 - I'm trying to do the following rule:
The **bank** property (an object) of an object (a React form) is required.
But I don't care about **bank** properties, just if it is informed (not undefined) or not, because it comes from an autocomplete component.

I'm doing like this:

```typescript
z.object({
  bank: z
    .object({
      id: z.union([z.number(), z.string()])
    })
.nonstrict(),
```

Is this the best way?

3 - How to extend this lib with custom methods?
For example, a string validation method to validate CPF (a SSN like number in my country).
I did a refine and it worked well, but I'm thinking about extending the schema, like this:

```typescript
z.string().cpf()
```

Can I just reexport zod with my custom methods like this:

```typescript
const CustomZod = {
  string: () =>
    z.string().refine(
      arg => validateCPF(arg),
      { message: ""CPF inválido"" }
    )
};
```

Is this the best way?

4 - I'm using Formik, and in Formik the validation function receives an object of values and must return an object with the error messages, one message for each key. I'm doing like this:

```typescript
const validateZod = (values: unknown): object => {
    const parsingResult = props.validationSchema.safeParse(values);

    if (parsingResult.success) {
      return {};
    }

    const flattenedErrors = parsingResult.error.flatten();

    const errors = {};

    for (const [key, value] of Object.entries(flattenedErrors.fieldErrors)) {
      errors[key] = value[0];
    }

    return errors;
  };
```

Is this the best way?

5 - I want to add a functionality to add asterisks to required fields in Formik.
So basically I would need to read the Zod schema passed to form, and check what fields of schema are required to put the asterisk.
Basically a reverse engineering of sorts.
How can I do that with Zod?

Thanks a lot.",,
691829186,140,[Request] Support for nested pick masks,"First of all, thank you @vriad for your passion for addressing code/API quality problems.

Speaking of subject, let's say we have complex nested schema. For particular function we want to select the only fields we care about:

```typescript
const LocalPizzaClient = User.pick({
  firstName: true,
  contactInfo: {
    phoneNumber: true,
  },
  address: {
    street: true,
    building: true,
  }
});
```

Would it possible be to extend `.pick(...)` function to support nested masks? As an option, the extended mask notation also may not care of whether the nested field is object or array of objects.",,
689780447,133,Use nonstrict with unknown instead of any,"Currently when `.nonstrict()` is used, `[k: string]: any` appears on the inferred type. Is it possible to use `[k: string]: unknown` instead? The problem of using `any` is that TypeScript allows you to do anything on any property. If you have a typo on the property name, an unexpected `undefined` will appear at runtime. If `unknown` is used, at least TypeScript can report an error when you try to use it or assign it to a different variable.

This feature request is similar to https://github.com/vriad/zod/issues/104. I am not sure if this issue will be considered a duplicate of it, but I think `.nonstrict()` will be much safer to use if it uses `unknown` instead of `any` by default.",,
689503574,131,z.number not working properly when used with z.record,"I basically have a data structure called rawNcdcConfig which is a record made up of rawServices. Within a rawService, I want a required number field called port.

Example:

```typescript
const rawServiceSchema = z.object({
  configPath: z.string(),
  port: z.number().positive(),
  realApi: z.string().url(),
  rateLimit: z.number().positive().optional(),
})
const rawNcdcConfigSchema = z.record(rawServiceSchema)

const rawDataToParse = {
  Config1: {
    configPath: './my-file.yml',
    port: 5001,
    realApi: 'http://example.com',
  },
  Config2: {
    configPath: './my-file.yml',
    port: 5002,
    realApi: 'http://example.com',
  },
  // this one is missing a port so I expect a validation error to be thrown
  'Another Config': {
    configPath: './my-file.yml',
    realApi: 'http://example.com',
  },
}

const parsedData = rawNcdcConfigSchema.parse(rawDataToParse)
console.dir(parsedData)
```

Output:
![image](https://user-images.githubusercontent.com/20561445/91768039-f12be000-ebd4-11ea-85b6-a9195b43cd2a.png)

If I parse the ""Another Config"" object directly using the `rawServiceSchema`, it throws as expected:

```typescript
const parsedData = rawServiceSchema.parse(rawDataToParse['Another Config'])
console.dir(parsedData)
```

Output: 
![image](https://user-images.githubusercontent.com/20561445/91768331-5a135800-ebd5-11ea-8179-c61ec60ea0e7.png)

Is this a bug or am I doing something wrong?",,
689094538,130,IE11 support,"Hi!

Which browsers are officially supported by zod? 
Is it possible to add ie11 support? now zod breaks because it needs `Array.prototype.find`
https://github.com/vriad/zod/blob/d1ae8e3538167a41e13ab6cfc2466ef3ca69e63a/src/parser.ts#L92",,
685354845,127,Failed to validate union objects,"First of all: thanks for great contribution to this package, it's really awesome.

However, I ran into an issue when I try to validate a union of objects, which simply looks like this:

```js
const extensions = z.object({
  name: z.string(),
})

const dog = z.object({
  extensions
});

const cat = z.object({
  extensions
});

const animal = z.union([dog, cat]);

// it should output type error because name is ought to be type of string
const validateResult = animal.parse({ extensions: { name: 123 } });  
```
**And I expected the `validateResult` to contain errors but instead it didn't.**

And when I changed the code to:

```diff
- const extensions = z.object({
-   name: z.string(),
- })

const dog = z.object(
-  extensions
+  extensions: z.object({
+    name: z.string(),
+  })
});

const cat = z.object({
-  extensions
+  extensions: z.object({
+    name: z.string(),
+  })
});

const animal = z.union([dog, cat]);

// it should output type error because name is ought to be type of string
const validateResult = animal.parse({ extensions: { name: 123 } });  
```
**It surprisingly worked!!**

Really need your help. Appreciate it!",,
682619019,125,ZodUnion didn't import when using babel-jest,"I get an error when accessing nullable method when using babel-jest. I've discovered that the error is due to the ZodUnion file not being imported correctly.

TypeError: Cannot read property 'create' of undefined at ZodNumber.ZodType.nullable (node_modules/zod/src/types/base.ts:114:62)

if i use explicit imports, imports will work fine.

I created PR: https://github.com/vriad/zod/pull/124",,
682227695,123,Strip unknown keys from object schemas by default,"Hi!

First of all, looks like a great job you did with this library. Looks very clean and developer friendly, and has some features I'm missing from io-ts.
Actually, I extended io-ts with some of them your library offers out of the box, but before I would jumping into and trying whether your library would work in my project, I'd like to ask something in advance to see if I could achieve it with it:
**Is there a way to 'export' a structure (object) that way Zod would delete the keys that are masked out (with `omit`)?**

The use case: I'd like to use Zod to serialize ('export') and unserialize (parse) custom structures (actually React component states, but could happen for multiple other use cases). But sometimes, there are data in the component state which is needed for runtime, but not needed (and I don't want) to serialize/unserialize.

At unserialization, masking is OK, it will ignore the not needed ones if I create a new 'masked' type.
But at serialization... I have the full data structure, and if I serialize it, it would contain all, even masked data as well. That's what I don't want.

An example based on a doc example:

```
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
});

const NoIDRecipe = Recipe.omit({ id: true });
type NoIDRecipe = z.infer<typeof NoIDRecipe>;

const data: Recipe = { id: 1, name: 'test', ingredients: ['x', 'y', 'z'] };

const serializable = NoIDRecipe.<serialize/export/clean?>(data);
```

Here, I'd like to make a copy of the 'data' variable, but with the NoIDRecipe schema, and in the copy (serializable) structure I want the 'id' keys to be removed, based on the schema (as NoIDRecipe doesn't contain it).
Is it possible somehow?

",,
680569819,119,ZodErrorCode not importing correctly,"I get an error when accessing string methods when using React Native with Expo. I've discovered that the error is due to the ZodError file not being imported correctly.

`TypeError: undefined is not an object (evaluating '__1.ZodErrorCode.invalid_string')`

The import is currently `import { ZodErrorCode } from '..'` at zod/src/types/string.ts.

Changing it to `import { ZodErrorCode } from '../ZodError'` fixes the issue.

This works fine in other environments, maybe the babel config that Expo uses is messing things up.",,
679745918,118,Export InvalidUnionError type,"I am currently making a utility function for a use case to specially handle union errors. The error object is a bit nested in my situation so feeling the need for that. **Can `InvalidUnionError` be exported as a type from the library?** Otherwise finding it a bit difficult to deal with it in TS.

For instance, I have:

```ts
function findUnionError(zodError: zod.ZodError): ZodSuberror | undefined {
  return zodError.errors.find(err => {
    return err.code === zod.ZodErrorCode.invalid_union;
  })
}
```

It will be great if I can do:

```ts
function findUnionError(zodError: zod.ZodError): InvalidUnionError | undefined {
  return zodError.errors.find((err) => {
    return err.code === zod.ZodErrorCode.invalid_union;
  }) as InvalidUnionError | undefined;
}
```

Because later I need to access the `.unionErrors` property and can't do it:

![image](https://user-images.githubusercontent.com/25290212/90334191-8467f180-dfe9-11ea-8757-703c98dbfb83.png)

I am again needing to do:

```ts
function something(err: zod.ZodError): void {
  const errorItem = findUnionError(err);
  if (errorItem !== undefined && errorItem.code === zod.ZodErrorCode.invalid_union) {
    // do something with errorItem.unionErrors
    errorItem.unionErrors
  }
}
```

which feels like a little extra steps.",,
679555973,117,Detailed errors for union schema,"I'd like to have more information or even TS-like details for union errors (Add a flag to parse?):

My types:
```
export const T = z.union([
  A, B, C
])
```
So what I currently get from this is:
```
     Error: 1 validation issue(s)

  Issue #0: invalid_union at 
  Invalid input
```
What I'd like to get is something more similar to this:

```
'{ t: 1 }' is not assignable to parameter of type '{ a: number } | { b: number }'
```

Is this sensible|doable|easy|hard?",,
676335106,116,type with fixed values,"is there a way to convert a typescript type with fixed values to a zod schema? 

some components from external libraries contain props with  types like below:
```js
type AcceptedValues = 1|2|3|4|5|6|7|8|9|10|11|12;
```

I would like to validate data so I can pass it to the component.
Here is what I tried:
```js 
type AcceptedValues = 1|2|3|4|5|6|7|8|9|10|11|12;
const mynumber = zodNumber().positive().min(1).max(12);

export const validateNumber = (data: unknown): AcceptedValues => { 
	try {
		return mynumber.parse(data);
	} catch (error) {
		if (error instanceof ZodError) {
			console.log(error.errors);
		}
	}
	return 12;
};
```
The error of the first return in validateNumber: `Type 'number' is not assignable to type 'AcceptedValues'.`


",,
676109790,115,"Custom refine path should override, not extend","In the absence of proper async validation my current approach can be described as such.

1) I'm adding new fields in the form (one per async action)
2) I'm filling those fields asynchronously on change and on submit
3) I'm validating the form synchronously after 2)

```js
import * as Z from ""zod""

let schema = Z.object({
  fromAccount: Z.object().nonstrict(), // dynamically loading select field
  toAccount: Z.object().nonstrict(), // dynamically loading select field
  relationsAreUnique: Z.boolean().refine(Boolean, {
    message: ""Testimonial was already given"",
    path: [""toAccount""],
  })
})

...
schema.parse({
  fromAccount: {id: ""1""},
  toAccount: {id: ""2""},
  relationsAreUnique: await isAccountAccountPairUnique({fromAccount: ""1"", toAccount: ""2""})
})
```

It kinda works. The problem is that `path` option for `relationsAreUnique` does not produce `[""toAccount""]`  path.
It actually produces `[""relationsAreUnique"", ""toAccount""]`. So I can't straightforwardly use it in the form rendering layer.

Maybe such hacks will disappear in newer Zod. But we aren't there yet. 
Intuitively, I expected `path` to be a full path (since it's an array).",,
676101548,114,Custom messages for type validations,"I want to translate form messages. 

```
...
  toAccount: Z.object({message: ""Gimme object!""}),
```

^ `message` is unused and the result (for e.g. `null`) is default:

```
Expected object, received null
```

In [the sources](https://github.com/vriad/zod/blob/master/src/types/boolean.ts) I see that custom messages are not supported for basic type parsing/validation like `boolean`, etc. 
But they should be (for I18n at the very least).",,
674198996,112,Validation of unions containing merged objects failing,"First of all: i really like this package (especially because of the typescript type integration)

However, I ran into an issue where i was validating a union of objects, which were based on the same `base` object. This object had some properties defined and the validation of those properties doesn't work correctly.

Given the following code:
``` ts
const base = z.object({
  id: z.string(),
});

const type1 = base.merge(
  z.object({
    type: z.literal(""type1""),
  })
);
const type2 = base.merge(
  z.object({
    type: z.literal(""type2""),
  })
);

const union1 = z.union([type1, type2]);
const union2 = z.union([type2, type1]);

const value1 = {
  type: ""type1"",
};

const value2 = {
  type: ""type2"",
};

console.log(""value1"", value1);
console.table([
  [""type1 directly"", type1.check(value1)],
  [""z.union([type1, type2])"", union1.check(value1)],
  [""z.union([type2, type1])"", union2.check(value1)],
]);

console.log(""value2"", value2);
console.table([
  [""type2 directly"", type2.check(value2)],
  [""z.union([type1, type2])"", union1.check(value2)],
  [""z.union([type2, type1])"", union2.check(value2)],
]);
```
In the example objects above, the `id` props is left out completely

You get the following output:
``` sh
  console.log
    value1 { type: 'type1' }

  console.log
    ┌─────────┬───────────────────────────┬───────┐
    │ (index) │             0             │   1   │
    ├─────────┼───────────────────────────┼───────┤
    │    0    │     'type1 directly'      │ false │
    │    1    │ 'z.union([type1, type2])' │ false │
    │    2    │ 'z.union([type2, type1])' │ true  │
    └─────────┴───────────────────────────┴───────┘

  console.log
    value2 { type: 'type2' }

  console.log
    ┌─────────┬───────────────────────────┬───────┐
    │ (index) │             0             │   1   │
    ├─────────┼───────────────────────────┼───────┤
    │    0    │     'type2 directly'      │ false │
    │    1    │ 'z.union([type1, type2])' │ true  │
    │    2    │ 'z.union([type2, type1])' │ false │
    └─────────┴───────────────────────────┴───────┘
```

The first line in the table shows the expected result (false) but as you can see the unions aren't consistent in their result.

If i pass in an object where type is set to something that doesn't match any of the allowed values then validation works correctly. This means that check will return `false` no matter which order the `z.objects` are passed to `z.union`",,
672727863,110,Typings not compatible with TS 3.8,"When using zod, typescript check will throw an error:

```
/node_modules/zod/lib/src/index.d.ts(42,418): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(42,1044): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(42,1590): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(42,2216): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(64,422): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(64,1048): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(64,1594): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(64,2220): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(49,312): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(49,776): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(49,1154): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(49,1618): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(52,312): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(52,776): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(52,1154): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(52,1618): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
```

- Typescript: `3.8.3`
- Zod: `1.10.1`",,
670440394,106,RFC: Make object schemas nonstrict by default,"Zod's policy of disallowing any unknown keys by default is confusing and probably not worth it. It also makes the inferred types incorrect:

```ts
const A = z.object({
  a: z.string(),
});

const B = z.object({
  b: z.string(),
});

const AB = z.intersection(A, B);


type AB = z.infer<typeof Teacher>;
// { a: string; b: string };
```
The actual inferred type here should be never because no data will properly pass validation.

If anyone has a reason why object schemas **should** be strict by default, speak now!
",,
669636020,105,Generic for parsing objects,"Really enjoy the library! Thank you for the work!

To easier debug when a parse fails, I made a small wrapper like this:
```
function parse(parser, obj) {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```

The problem is that typescript can not infer this function.

I tried multiple combinations but can not seem to get it right.

I looked through issues already mentioning generic and did fine one small example: https://github.com/vriad/zod/issues/93 but it did not help fully.

```
function parse<K, T extends z.ZodType<K, any>>(parser: T, obj): K {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```
```
function parse<T extends z.ZodType<any, any>, K typeof T>(parser: T, obj): K {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```
```
interface Schema<T> {
  parse: (data:unknown): T;
  check: (data:unknown): data is T;
}
function parse<T extends Schema<K>>(parser: T, obj) {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```

```
interface SchemaVal {
  parse<K>(data: unknown): K;
}

function parse<T extends SchemaVal>(parser: T, obj): K {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```


",,
669525260,104,Typed key signature for object schemas,"In TypeScript, one can do this
```ts
type MyType = {
  requiredKey1: string;
  requiredKey2: number;
  [extraKeys: string]: string;
};
```
such that `requiredKey1` and `requiredKey2` are required and additional keys with `string` values can also be added.

Is there a way to achieve this with Zod?

It seems that `.nonstrict()` only supports the values being `any`, as shown in the doc:
```ts
const dogSchemaNonstrict = dogSchema.nonstrict();

type NonstrictDog = z.infer<typeof dogSchemaNonstrict>;
/*
{
  name: string; 
  neutered: boolean;
  [k:string]: any;
} 
*/
```

Is it possible to support requiring specific type for nonstrict object? Maybe add an optional parameter to `.nonstrict()`? Something like this:

```ts
const dogSchemaNonstrict = dogSchema.nonstrict(z.number());

type NonstrictDog = z.infer<typeof dogSchemaNonstrict>;
/*
{
  name: string; 
  neutered: boolean;
  [k:string]: number;
} 
*/
```

---

(While `Record` with `.refine` can certainly achieve the functionality, inferring its TypeScript type will lose the information of the required fields (and their values' types).)",,
667493741,103,Create a zod type from a TS enum,"Right now if you want to create a type from a TS enum, you have do something like the following:

```ts
enum PlantLifecycle {
  Evergreen = 'EVERGREEN',
  Deciduous = 'DECIDUOUS',
  SemiDeciduous = 'SEMI_DECIDUOUS'
};

const lifecycle = z.union([
  z.literal(PlantLifecycle.Deciduous),
  z.literal(PlantLifecycle.Evergreen),
  z.literal(PlantLifecycle.SemiDeciduous),
]);
```

There should be an easier way of doing this, like:
```ts
enum PlantLifecycle {
  Evergreen = 'EVERGREEN',
  Deciduous = 'DECIDUOUS',
  SemiDeciduous = 'SEMI_DECIDUOUS'
};

z.enum(PlantLifecycle);
```",,
665986408,101,Error stack trace should not include Zod internals,"Currently the stack trace includes Zod internals like this:

```diff
ZodError: event.data.new.title: Invalid input: expected string, received undefined
-    at new ZodError (/Users/b/c/infra/node_modules/zod/lib/src/ZodError.js:36:28)
-    at ZodObject.parse (/Users/b/c/infra/node_modules/zod/lib/src/parser.js:142:17)
    at exports.handler (webpack-internal:///./functions/hasura/eventCreated.ts:41:39)
    at InProcessRunner.run (/Users/b/c/infra/node_modules/serverless-offline/dist/lambda/handler-runner/in-process-runner/InProcessRunner.js:100:16)
    at processTicksAndRejections (internal/process/task_queues.js:97:5)
    at async process.<anonymous> (/Users/b/c/infra/node_modules/serverless-offline/dist/lambda/handler-runner/child-process-runner/childProcessHelper.js:39:14)
}
```

But what I want is this:
```
ZodError: event.data.new.title: Invalid input: expected string, received undefined
    at exports.handler (webpack-internal:///./functions/hasura/eventCreated.ts:41:39)
    at InProcessRunner.run (/Users/b/c/infra/node_modules/serverless-offline/dist/lambda/handler-runner/in-process-runner/InProcessRunner.js:100:16)
    at processTicksAndRejections (internal/process/task_queues.js:97:5)
    at async process.<anonymous> (/Users/b/c/infra/node_modules/serverless-offline/dist/lambda/handler-runner/child-process-runner/childProcessHelper.js:39:14) 
}
```

#### Version

```
zod: 1.9.0
```
",,
665705565,100,RFC: Transformations (e.g. casting/coercion),"⚠️ Update: this approach has been abandoned in Zod 3 for a more Yup-like ""transform chain"" approach.

This is the proposed API for implementing data transformation functionality in Zod.

## Proposed approach

No need to over complicate things. The problem to solve is how Zod should handle/support transformations from type A to type B. So I propose the creation of a new class `ZodTransformer`. This class is a subtype of `ZodType` (so you can use it like any other schema — `.refine`, `.parse`, etc).

Internally, instances of this class will have these properties
- `input: ZodType`: an input schema
- `output: ZodType`: an output schema
- `transformer: (arg: T['_type']) => U['_type']`: a transformer function

There is only one transformer function, not a ""transform chain"" like in Yup (👋 @jquense). This makes it easier for Zod to statically type the function. Any sort of functional composition/piping can be done using libraries external to Zod.

You would create an instance using the `ZodTransformer.create` static factory method (aliased to `z.transformer`):

## Usage

Coercing a string into a number.

```ts
const stringToNumber = z.transform(z.string(), z.number(), (data)=>parseFloat(data));
type stringToNumber = z.infer<typeof stringToNumber>; // number

stringToNumber.parse(""12"") // => 12 (number)
```

## `.input/.output`

```ts
stringToNumber.input; // ZodString
stringToNumber.output; // ZodNumber
```

## `.transform` method

~~Every ZodTransform instance will have a `.transform` method. This method lets you easily chain transforms, instead of requiring many nested calls to `z.transform()`.~~

Every _ZodType_ instance (the base class for all Zod schemas) will have a `.transform` method. This method lets you easily create a ZodTransform, using your current schema as the input:

```ts
const trimAndMultiply = z.string()
  .transform(z.string(), x =>x.trim())
  .transform(z.number(), x => parseFloat(x))
  .transform(z.number(), num => num * 5);

console.log(trimAndMultiply.parse(' 5 ')); // => 25
```
## ~~`.toTransformer` function~~

⚠️ Edit: This section is no longer relevant since the `.transform` method has been moved to the base ZodType class instead of only existing on ZodTransform.

As you can see above, the first method call is `.transformer` (which is a factory function that returns a ZodTransform). All subsequent calls are to `.transform()` (a chainable method on the ZodTransformer class).

To make the syntax for defining chains of transforms more consistent, I propose a `toTransformer` function:

```ts
const stringTransformer = z.transformerFromSchema(z.string());

// equivalent to
const stringTransformer = z.transformer(z.string(), z.string(), x => x);
```

With this you could rewrite `trimAndMultiply` like so:

```ts
const trimAndMultiply = z.toTransformer(z.string())
  .transform(z.string(), z.string(), x =>x.trim())
  .transform(z.number(), x => parseFloat(x))
  .transform(z.number(), num => num * 5)
  .refine(x => x > 20, 'Number is too small');
```

~~## `.clean`~~
This section is now irrelevant and will now be implemented by overloading `.transform()`

⚠️ I really don't like the name ""clean"" for this; if you have any better ideas please make suggestions.

There will be redundancy if you are chaining together transforms that don't cast/coerce the type. For instance:

```ts
z.toTransformer(z.string())
  .transform(z.string(), val => val.trim())
  .transform(z.string(), val => val.toLowerCase())
  .transform(z.string(), val => val.slice(0,5))
```

I propose a `.clean` method that obviates the need for the redundant `z.string()` calls. Instead it uses `this.output` as both the input and output schema of the returned ZodTransform.

```ts
z.toTransformer(z.string())
  .clean(val => val.trim())
  .clean(val => val.toLowerCase())
  .clean(val => val.slice(0,5))
```
## .default

Transformations make the setting of default values possible for the first time.

```ts
z.string().default('default_value');

// equivalent to
z.transformer(z.string().optional(), z.string(), x => x || ""default_value"");
```

## Complications

### Separate input and output types
There are some tricky bits here. Before now, there was no concept of ""input types"" and ""output types"" for a Zod schema. Every schema was only associated with one type. 

Now, ZodTransformers have different types for their inputs and outputs. There are issues with this. Consider a simple function schema:

```ts
const myFunc = z.function()
  .args(z.number())
  .returns(z.boolean())
  .implement(num => num > 5);

myFunc(8);
```

This returns a simple function that checks if the input is more than 5. As you can see the call to `.implement` automatically infers/enforces the argument and return types (there's no need for a type signature on `num`).

Now what if we switch out the input (`z.number()`) with `stringToNumber` from above?

```ts
const myFunc = z
  .function()
  .args(stringToNumber)
  .returns(z.boolean())
  .implement(num => num > 5);

myFunc(8); // works
myFunc(""8""); // throws
```

It's not really clear what should happen here. The function expects the input to be a number, but the transformer expects a string. Should myFunc(""8"") work? 

### Type guards

1. I hadn't really considered how this will impact type guards. Like I mentioned under ""Complications"" in the original RFC, each schema is now associated with both an input and output type. For schemas that aren't ZodTransformers, these are the same. Type guards can _only_  be used to verify the input type:

```ts
const stringToNumber = z.transformation(z.string(), z.number(), parseFloat);
const data = ""12"";

if(stringToNumber.check(data)){
  data; // still a string
}
```

I think perhaps typeguards aren't really compatible with any sort of coercion/transformation and it might be better just to get rid of them. @kasperpeulen

### Unions

Not sure how I didn't see this issue before.

Consider a union of ZodTransformers:

```ts
const transformerUnion = z.union([
  z.transformer(z.string(), z.number(), x => parseFloat(x)),
  z.transformer(z.string(), z.number().int(), x => parseInt(x)),
])
```

What should happen when you do `transformerUnion.parse('12.5')`? Zod would need to choose which of the transformed values to return. 

One solution is to have union unions return the value from the first of its child schemas that passes transformation/validation, in the order they were passed into `z.union([arg1,arg2,etc])`. In the example above it would return the float, and never even execute `parseInt`.

Another solution is just to disallow passing transformers in unions (and any other types that would cause problems) 🤷‍♂️


## Design consideration

One of my design considerations was trying to keep all data mutation/transformation fully contained within ZodTransformers. This leads to a level of verbosity that may be jarring. Instead of adding a `.default()` method to every Zod schema, you have to ""convert"" your schema into a ZodTransformer first, then you can use its `.default` method yourself.

## Try it

Most of this has already been implemented in the alpha branch, so you can play around with it. Open to any questions or concerns with this proposal.  🤙 

`yarn add zod@alpha`

Tagging for relevance: @krzkaczor @ivosabev @jquense @chrbala @jakeginnivan @cybervaldez @tuchk4 @escobar5 

",,
665692124,99,Inferred recursive types without casting,"Interesting in more information on what is holding back nested types from being simpler?  I can't seem to think of what it could be as I can model and infer things on a pretty insanely sophisticated level -- but I am sure I am just not understanding a piece of the chain here.  
",,
665559290,97,Allow Custom Errors on any value?,"Any reason not to allow defining the last argument for any value as an error message to allow overriding the error message for that property easily?  The current method is not really ideal, especially when you have many string props but need different errors.

A couple nice ways to handle it:

### Allow Last Param to be Error Message

> Would also accept a custom error that it would throw instead of ZodError (similar to Joi)

```typescript
const TestSchema = z.object({
	three: z.literal('hi').optional(),
	one: z.number(),
	two: z.literal(3, 'that isnt 3 dummy'),
	four: z.string('string not whatever you gave!'),
	five: z.date()
})
```

### Add a `.error()` option like Joi

```typescript
const TestSchema = z.object({
	three: z.literal('hi').optional(),
	one: z.number(),
	two: z.literal(3).error(new Error('that isnt 3 dummy')),
	four: z.string().optional().error(new Error('string not whatever you gave!')),
	five: z.date()
})
```

---

For the VSCode extension I am working on, these styles add the benefit that jsdoc can be used to transfer over error messaging easily:

![](https://media2.giphy.com/media/kHIevgJMwj1pGRCxEl/giphy.gif)
",,
665537870,96,Demand for VSCode Extension?,"Was playing around with VSCode and Zod based on #53 -- seeing if there is enough demand for this to put time into the concept.  It is slow in the preview as I built that out in about 1 hour, but seems it could be nice - and make it easier to use Zod since you wouldn't really need to even learn all the specifics - you could just create your TypeScript Type then translate it.

It utilizes the TypeScript Compiler API to read the AST and infer from there.

> Since this is just using the TypeScript compiler API - this could pretty easily become a browser tool as well which you could just paste in your type and get a valid zod schema out from it.

> On that note, this is more of a Typescript Plugin than a VSCode Extension - since the vscode part of it is just providing the menu option to run the TS Compiler and it uses the TS Compiler to build Typescript Code. 

```typescript
export const generatePrimitive = ({ kind, name, props, zodImportValue }: {
  kind: ts.SyntaxKind;
  name: string;
  zodImportValue: string;
  props: { isOptional: boolean; errorMessage: undefined | string; isNullable?: boolean }
}) => {
  let flags = '';

  if (props.isOptional) {
    flags += '.optional()';
  }
  if (props.isNullable) {
    flags += '.nullable()';
  }

  let errorMessage = props.errorMessage ? wrapQuotes(props.errorMessage) : '';

  switch (kind) {
    case ts.SyntaxKind.NumericLiteral:
      return `${zodImportValue}.literal(${name})${flags}`;
    case ts.SyntaxKind.StringLiteral:
      return `${zodImportValue}.literal(${wrapQuotes(name)})${flags}`;
    case ts.SyntaxKind.StringKeyword:
      return `${zodImportValue}.string()${flags}`;
    case ts.SyntaxKind.BooleanKeyword:
      return `${zodImportValue}.boolean()${flags}`;
    case ts.SyntaxKind.NullKeyword:
      return `${zodImportValue}.null()${flags}`;
    case ts.SyntaxKind.UndefinedKeyword:
      return `${zodImportValue}.undefined()${flags}`;
    case ts.SyntaxKind.NumberKeyword:
      return `${zodImportValue}.number()${flags}`;
    case ts.SyntaxKind.AnyKeyword: 
      return `${zodImportValue}.any()${flags}`;
    case ts.SyntaxKind.BigIntKeyword:
      return `${zodImportValue}.bigint()${flags}`;
    case ts.SyntaxKind.VoidKeyword:
      return `${zodImportValue}.void()${flags}`;
    case ts.SyntaxKind.ClassKeyword: {
      if (name === 'Date') {
        return `${zodImportValue}.date()${flags}`;
      }
      // TODO : Handle Class & InstanceOf based on symbol & import detection context
    }
    default:
     return `${zodImportValue}.any(${errorMessage})`;
  }
};
```

![](https://media2.giphy.com/media/QakVCETUNihvcuMv73/giphy.gif)

---

The code above just uses strings to build it which was easier in this case.  For those potentially interested, to move to using the TypeScript Compiler / AST to build it all, the generated type in the gif would be something like:

```typescript
[
  ts.createVariableStatement(
    undefined,
    ts.createVariableDeclarationList(
      [ts.createVariableDeclaration(
        ts.createIdentifier(""TestSchema""),
        undefined,
        ts.createCall(
          ts.createPropertyAccess(
            ts.createIdentifier(""z""),
            ts.createIdentifier(""object"")
          ),
          undefined,
          [ts.createObjectLiteral(
            [
              ts.createPropertyAssignment(
                ts.createIdentifier(""three""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createCall(
                      ts.createPropertyAccess(
                        ts.createIdentifier(""z""),
                        ts.createIdentifier(""literal"")
                      ),
                      undefined,
                      [ts.createStringLiteral(""hi"")]
                    ),
                    ts.createIdentifier(""optional"")
                  ),
                  undefined,
                  []
                )
              ),
              ts.createPropertyAssignment(
                ts.createIdentifier(""one""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createIdentifier(""z""),
                    ts.createIdentifier(""number"")
                  ),
                  undefined,
                  []
                )
              ),
              ts.createPropertyAssignment(
                ts.createIdentifier(""two""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createIdentifier(""z""),
                    ts.createIdentifier(""literal"")
                  ),
                  undefined,
                  [ts.createNumericLiteral(""3"")]
                )
              ),
              ts.createPropertyAssignment(
                ts.createIdentifier(""four""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createIdentifier(""z""),
                    ts.createIdentifier(""string"")
                  ),
                  undefined,
                  []
                )
              ),
              ts.createPropertyAssignment(
                ts.createIdentifier(""five""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createIdentifier(""z""),
                    ts.createIdentifier(""date"")
                  ),
                  undefined,
                  []
                )
              )
            ],
            true
          )]
        )
      )],
      ts.NodeFlags.Const
    )
  ),
  ts.createTypeAliasDeclaration(
    undefined,
    undefined,
    ts.createIdentifier(""Test""),
    undefined,
    ts.createTypeReferenceNode(
      ts.createQualifiedName(
        ts.createIdentifier(""z""),
        ts.createIdentifier(""infer"")
      ),
      [ts.createTypeQueryNode(ts.createIdentifier(""TestSchema""))]
    )
  )
];
```

-->

```typescript
const TestSchema = z.object({
	three: z.literal('hi').optional(),
	one: z.number(),
	two: z.literal(3),
	four: z.string(),
	five: z.date()
})

type Test = z.infer<typeof TestSchema>;
```",,
660451580,94,Is Typescript 3.4+ not supported?,"Can not pass the unit tests with typescript 3.7

Is it planned to support only 3.9+ again ((now in beta)), but not previous versions? ",,
655811097,87,Asynchronous validations,"There's support for validating [promise types](https://github.com/vriad/zod#promises), but I don't see a way to create async validators.

What I'm thinking of is something like this:

```js
const foreignKey = z.string().refine(idExistsAsync, {
  message: ""ID not found"",
});
foreignKey.parseAsync(""1234"")
```

Where ``idExistsAsync`` is some function that asynchronously checks some backend to make sure that the value is valid. It returns a promise. Of course this would mean that the entire schema becomes async, so there are some other concerns here when async values are used as fields on objects.",,
654622971,82,[bug] Cannot parse objects intersection,"# Description

I have following description for `ShapeEntity`
```typescript
import * as z from ""zod"";

const SquareData = z.object({
  type: z.literal(""square""),
  data: z.object({
    width: z.number(),
    height: z.number(),
  }),
});
const CircleData = z.object({
  type: z.literal(""circle""),
  data: z.object({
    radius: z.number(),
  }),
});

const ShapeData = z.union([SquareData, CircleData]);
const ShapeEntity = z.intersection(z.object({ id: z.string() }), ShapeData);
type ShapeEntity = z.infer<typeof ShapeEntity>;
```

When I try to parse valid circle, zod fails
```typescript
try {
  let circle = {
    id: ""id"",
    type: ""circle"",
    data: { radius: 123 },
  };
  ShapeEntity.parse(circle);
  console.log(""circle success"");
} catch (error) {
  console.log(error.message);
  // Left side of intersection: Unexpected key(s) in object: 'type', 'data'
  // Right side of intersection: 
  //     union option #0: Unexpected key(s) in object: 'id'
  //     union option #1: Unexpected key(s) in object: 'id'
}
```

# Workaround
It can work if I redefine type as union of merged parts
```typescript
const ShapeEntityBase = z.object({ id: z.string() });
const ShapeEntity = z.union([
  ShapeEntityBase.merge(SquareData),
  ShapeEntityBase.merge(CircleData),
]);
```
But it does not feel native, because in typescript I define type as `Base & (Opt1 | Opt2)`, not as `(Base & Opt1) | (Base & Opt2)`
",,
650649819,77,Is there a way to define a schema for a function that returns void?,"First of all, zod is awesome.  I would recommend adding it to the awesome-typescript list(s) as an alternative to io-ts.

I'm trying to define a schema for a function that does not return a value.  Example:

```typescript
function foo(): void {}
```

Currently I am using `z.unknown` for `returnType`:

```typescript
const FooSchema = z.function(z.tuple([]), z.unknown())
```

This works, but is it the correct way to do it?  Should there be a void type for function schemas?

",,
642830423,74,Error reporting is useless when using z.function().implement(),"I have multiple functions written with `z.function().implement()` that call each other and one of them was returning `undefined` instead of the an object fitting its return type. It took me about an hour to find the exact function that was throwing due to error messages like these that do not tell you anything about which object schema or function is throwing:

```
TypeError: Cannot convert undefined or null to object at Function.keys (<anonymous>)

      at ZodObject.parse (node_modules/zod/src/parser.ts:90:32)
      at Object.<anonymous> (node_modules/zod/src/parser.ts:268:35)
      at step (node_modules/zod/lib/src/parser.js:32:23)
      at Object.next (node_modules/zod/lib/src/parser.js:13:53)
      at fulfilled (node_modules/zod/lib/src/parser.js:4:58)
```

```
Non-object type: undefined

      at new ZodError (node_modules/zod/src/ZodError.ts:10:5)
      at Function.ZodError.create (node_modules/zod/src/ZodError.ts:17:19)
      at Function.ZodError.fromString (node_modules/zod/src/ZodError.ts:35:21)
      at ZodObject.parse (node_modules/zod/src/parser.ts:84:51)
      at Object.<anonymous> (node_modules/zod/src/parser.ts:268:35)
      at step (node_modules/zod/lib/src/parser.js:32:23)
      at Object.next (node_modules/zod/lib/src/parser.js:13:53)
      at fulfilled (node_modules/zod/lib/src/parser.js:4:58)
```

I am writing in TS, so this might be related to the TS compiler, but the errors are still useless if they don't tell you which schema or function is throwing.",,
642345725,73,Unions and enums from an array,"I might be missing something, but it seems this is currently not possible, but would be a great time/code saver:

```typescript
const STATUSES = ['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed'];
const StatusSchema = z.union(STATUSES.map(z.literal));
const StatusSchema2 = z.enum(STATUSES);
```
",,
641252782,71,Correct way to use a third party Class/type in a Zod schema object?,"I'm trying to do this, but TypeScript complains:

```js
  z.object({
    slug: z.string().min(1).max(255),
    title: z.string().max(255),
    timeStart: Timestamp,
  })
```

Error:
```
Type 'typeof Timestamp' is missing the following properties from type 'ZodType<any, ZodTypeDef>': _type, _def, parse, is, and 5 more.
```

I basically want to make a schema that asserts that `timeStart` is an instance of the class `Timestamp` (which itself is a class I imported from a third party library).

How can I do this? Sorry if it's obvious.

Thank you for writing this library by the way, it's by far the best solution for TypeScript runtime checking I've found (and I've tried many).",,
641227086,70,Support anyCase()/ignoreCase() for literals,"It would be great to have support for anyCase/ignoreCase for literals/enums. 
Example use case would be an API that accepts String enum and doesn't care about case.",,
637697341,67,Union errors path,"I was wondering why errors path is inlined within the message when using union types:
```typescript
try {
    const parser = z.array(
      z.union([
        z.object({ messages: z.array(z.string().nonempty()) }),
        z.string(),
      ]),
    );

    parser.parse([{ messages: [''] }]);
  } catch (e) {
    // eslint-disable-next-line no-console
    console.log('errors: ', JSON.stringify(e.errors));
  }
```
gives:
```
[{""path"":[0],""message"":""\n\tunion option #0: messages.0: Value cannot be empty string\n\tunion option #1: Non-string type: object""}]
```

But why not (?)
```
[{""path"":[0, ""messages"", 0],""message"":""Value cannot be empty string""}]
```",,
635428335,66,Readonly fields,Typescript allows to declare fields as readonly. Is there any workaround to add readonly property to interface infer-ed from zod schema?,,
635208420,65,How to best mix required and optional properties?,"I expected this to work:

```ts
const AnObjSchema = z.object({
  file: z.string(),
  author: z.string().optional(),
  tags: z.array(z.string()).optional(),
});

type AnObj = z.infer<typeof AnObjSchema>;
// type AnObj = {
//   file?: string; // should not be optional
//   author?: string;
//   tags?: string[];
// }
```

Alas, property `.file` is not required in the inferred type. Do I have to do an intersection type of two object types?",,
631253659,62,Generating an object from schema,"This may not be a feature that makes sense to build, but it would be incredibly useful.

A normal workflow is to create a schema for your form state, generate a type, and then write the same object over again to use as the initial form state:

```
const formSchema = z.object({
  name: z.string(),
  email: z.string(),
});

type FormState= z.infer<typeof formSchema>

const initialFormState: FormState = {
  name: '',
  email: '',
 };

const [formState, setFormState] = useState<FormState>()
```

And now as your form grows so do these 2 objects.

I would love to be able to do something like this:
```
const formSchema = z.object({
  name: z.string().default(''),
  email: z.string().default(''),
});

type FormState= z.infer<typeof formSchema>

const initialForm = z.generate(formSchema);

const [formState, setFormState] = useState<FormState>(initialForm)
```

Currently I have a utility function I wrote that does this, it's not recursive and not very robust, but it does what I need and as a result my code is much cleaner. Everything can be updated simply by changing the Zod schema. Any thoughts on a feature like this?
",,
628087199,59,Unexpected missing key errors with intersections/unions that conflict with inferred type,"I'm getting `.parse` errors that seem incorrect with a schema similar to this one:

```typescript
z.intersection(
    z.object({
      user: z.object({
        email: z.string(),
        firstName: z.string(),
        lastName: z.string()
      }),
      org: z.object({ name: z.string()})
    }),
    z.union([
      z.object({
        provider: z.literal(""email""),
        emailVerificationToken: z.string(),
      }),
      z.object({
        provider: z.enum([""github"", ""gitlab""]),
        externalAuthSessionId: z.string(),
      }),
    ])
 )
```

But when using `.parse` or `.check` on an object that matches the inferred type, I get missing key errors.

So with a seemingly valid object like this one (that type checks fine with the inferred type):

```typescript
{
  user: { email: ""example@email.com"", firstName: ""Test"", lastName: ""User""},
  org: { name: ""Test Org"" },
  provider: ""email"",
  emailVerificationToken: ""token""  
}
```

I get the error:
```
Left side of intersection: Unexpected key(s) in object: 'provider', 'emailVerificationToken'\nRight side of intersection: \n\tunion option #0: Unexpected key(s) in object: 'org', 'user'\n\tunion option #1: Unexpected key(s) in object: 'org', 'user', 'emailVerificationToken'
```

Is this a bug or am I misunderstanding something about how intersections and unions work in zod?
",,
627513907,56,"ZodObject methods (pick, omit, partial, etc.) for intersections and unions of objects","I've been converting lots of TS types to zod. It's going pretty smoothly. Again, thanks for the _excellent_ work on this lib! But some of the types are fairly complex with nested intersections and unions of object types, and I find myself really wishing I could use the ZodObject methods on these types, especially `pick`, `omit`, and `partial`.

So for a zod definition like this:

```typescript
const schema = z.intersection(
  z.object({key1: z.string()}), 
  z.union([
    z.object({key2: z.string()}),
    z.object({key3: z.string()}),
  ])
);
```

I'd love to be able to do:

```typescript
schema.pick({key1: true, key3: true});
schema.omit({key2: true});
schema.partial();
```

And same for other structures: unions of objects, unions of intersections, etc.

It seems like it could be doable to call them recursively through all levels of nesting with the appropriate subset of keys as long as every intersection/union resolves to an object? Maybe type inference is an issue?

I'm getting around this by breaking up complex types into many constituent ZodObject schemas, and then re-composing them using the object methods as needed, but it would be a lot easier to just call the methods directly on the full schema.",,
619589352,52,proper mechanism to integrate with 3rd party types,"# problem

```ts
import { Bananas } from '@fruit/banana'
import * as z from 'zod'
const schema = z.object({
  apple: z.string(),
  banana: z.doSomethingWith3pType() // z.object({}) ??
})
const myType = z.infer<typeof schema> // { apple: string, banana: ???? }
```

what the best way to get my 3p schema in? assuming because types have been compiled away, getting my 3p schema may not be possible, _but_, is there a mechanism to put my type into the schema, and get it reflected back out?",,
617058502,50,Union errors don't point to actual problem,"When trying to parse a union type you get a very generic error that doesn't tell you what actually went wrong.

```ts
import * as z from 'zod';

enum ContactType {
    Address = 'ADDRESS',
    Phone = 'PHONE',
}

const addressSchema = z.object({
    kind: z.literal(ContactType.Address),
    address: z.object({
        streetAddress: z.string(),
        city: z.string(),
        stateOrProvince: z.string(),
        zipCode: z.string(),
    }),
});

const phoneSchema = z.object({
    kind: z.literal(ContactType.Phone),
    phone: z.string(),
});

const contactSchema = z.union([ addressSchema, phoneSchema ]);

const data = {
    kind: ContactType.Address,
    address: {
        streetAddress: '123 Fake Street',
        city: 'Springfield',
        stateOrProvince: 'OH',
        // Missing zipCode
    },
};

contactSchema.parse(data);
```

This will give you:
```
Error parsing union.
Received: {
  ""kind"": ""ADDRESS"",
  ""address"": {
    ""streetAddress"": ""123 Fake Street"",
    ""city"": ""Springfield"",
    ""stateOrProvince"": ""OH""
  }
}
Expected: object OR object
```

If you change the last line to `addressSchema.parse(data);` you get something useful:
```
`address.zipCode`: Non-string type: undefined
```

It would be nice if this worked more like TypeScript itself does when type checking unions and told you why each possible type in the union failed to work. Perhaps something like:
```
object: Unexpected key(s) in object: 'address'
object: `address.zipCode`: Non-string type: undefined
```

Even better would be if it could give something more useful than `object` for the names of these but I'm not sure how you'd accomplish that without adding some means of providing metadata for types.",,
614958816,49,z.function can not be used with z.object,"version: 1.0.9 | 1.2.5 | 1.5.0

When using z.function with z.object like this:
```
const MouseEvents = z.object({
    onClick: z.function(z.tuple([z.number()]), z.undefined())
})
```
Type error throws:
![image](https://user-images.githubusercontent.com/3960056/81444778-4cf7d680-91aa-11ea-9f2e-396a0427e5c1.png)
",,
613768937,47,Can you provide an example of how to do { stripUnknown: true }?,"I'm wondering how to do this option from yum:

`stripUnknown`:remove unspecified keys from objects.

I can pluck or omit, but what if I only want to pick the properties on the ZodObject?

For example:

```
const Animal = z.object({
 name: z.string(),
}),
export type Animal = z.infer<
  typeof Animal
>;
```

But, it so happens that an object such as `{ name: 'tommy', kind: 'cat' }` comes along.  How do I only validate the properties on Animal and drop others like `kind`? 

Since I am returned the same object and .nonstrict allows me to still verify the keys I care about, I would like to be able to drop the unknown keys that are on the object.  

The zod object Animal has a .toJSON which return the shape and I can get keys this way:

`Animal.toJSON().shape['0']`

",,
612075808,45,Type inference issue for Object schemas,"First, Thank you very much for your awesome work 👍 

I figured out when I'm using `z.infer` on an object schema, the inferred type has all the object's attributes optional. According to the doc, all the attributes should be required.

Example from the doc:
```typescript
const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
});

type Dog = z.infer<typeof dogSchema>;

/* 
equivalent to:
type Dog = { 
  name:string; 
  neutered: boolean;
}
*/
```

But this is what I get:
```
type Dog = {
    name?: string;
    neutered?: boolean;
}
```

I'm using zod `1.5.0` and I've also tried with `1.3.0` but keep getting the Dog type with optional attributes.

Thanks for your help!",,
611377888,43,Type inference incorrectly sets all fields as optional by default,"Zod version: 1.5.0
TS version: 3.8.3

The type inference does not seem to be working properly, making all values of objects to be optional by default.

Let me take this code derived from the readme:

```ts
import * as z from ""zod"";

const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
});

type T = z.TypeOf<typeof dogSchema>;  // -> { name?: string, neutered?: boolean }

const dog: T = {};  // -> Compiles without error
```

The expected behavior would be a compilation error deriving from `name` and `neutered` to be required.",,
611172281,42,Value transformation / object mapping,"Hey! I just tried `zod` and I quite enjoy it so far, great job! I have a feature request/discussion. 

Problem: I would like my schema to not only validate data but transform it as well. A particular use case is that I would like to specify a mapping in my object schema. 

One could imagine a type `z.stringAsNumber()` which would parse strings like `""123""` to a number `123`. Something like this is totally possible with `io-ts`.

Or even more powerful case. Where object validation could remap keys:

```typescript
const envSchema = z.object({
  SERVER_HOST: z.string(),
  PUBLIC_S3_URL: z.string(),
  PRIVATE_BACKEND_URL: z.string(),
})
```

This schema is used to validate environment variables. It would be cool if I could specify a key mapping to end up with renamed keys in a parsed object for example (example API)

```typescript
const envSchema = z.object({
  serverHost: { value: z.string(), key: 'SERVER_HOST' },
  publicS3: { value: z.string(), key: 'PUBLIC_S3_URL' }
  privateBackendURL: { z.string(), key: 'PRIVATE_BACKEND_URL' }
})
```

I feel like this is a very common situation. Of course, it can be done manually after schema validation but I believe that it would be cool to support this one way or another. WDYT @vriad? Is this something that you want to support eventually?",,
610953283,41,JSON utility type,"I just found myself needing a generic type for any valid JSON and put this together:

```ts
type Literal = boolean | null | number | string;
type Json = Literal | { [key: string]: Json } | Json[];

const Literal = Zod.union([Zod.boolean(), Zod.null(), Zod.number(), Zod.string()]);
const Json: Zod.ZodType<Json> = Zod.lazy(() =>
  Zod.union([Literal, Zod.array(Json), Zod.record(Json)])
);
```

Putting this in an issue for anyone who might be on the lookout or if the library might want to integrate a higher-level utility constructs like this.",,
606630379,39,discriminated union regression between 1.0.9 and 1.3.0,"The following schema

```typescript
export const CellResultsAPIValidator = z.union([
  z.object({
    kind: z.literal(""error""),
    error: z.object({
      message: z.string(),
      type: z.string(),
    }),
  }),
  z.object({
    kind: z.literal(""results""),
    results: z
      .array(
        z.union([
          z.object({
            kind: z.literal(""data""),
            data: z.tuple([z.string(), z.string(), z.string()]),
          }),
          z.object({
            kind: z.literal(""error""),
            error: z.tuple([z.string(), z.string(), z.object({})]),
          }),
          z.object({
            kind: z.literal(""skipped""),
          }),
        ])
      )
      .nonempty(),
  }),
]);
```

no longer validates the following

```
{ Error: Type mismatch in union.
Received: {
  ""kind"": ""results"",
  ""results"": [
    {
      ""kind"": ""error"",
      ""error"": [
        ""InvalidReferenceError"",
        ""object type or alias 'User' does not exist"",
        {
          ""65521"": ""7"",
          ""65522"": ""11"",
          ""65523"": ""1"",
          ""65524"": ""8""
        }
      ]
    }
  ]
}

Expected: object OR object
    at new ZodError (/Users/yury/dev/edge/tutorial/node_modules/zod/lib/src/ZodError.js:20:28)
    at Function.ZodError.create (/Users/yury/dev/edge/tutorial/node_modules/zod/lib/src/ZodError.js:66:21)
    at Function.ZodError.fromString (/Users/yury/dev/edge/tutorial/node_modules/zod/lib/src/ZodError.js:71:25)
    at ZodUnion.parse (/Users/yury/dev/edge/tutorial/node_modules/zod/lib/src/parser.js:159:39)
```

after upgrading from 1.0.9 to 1.3.0",,
605504853,38,Generate class from object schema,"Just like function implementation, it would be interesting to create an object `implement(readonly: bool)` method, that would create an anonymous class having the following functionality:

- Has a `constructor(t?: Type)` that validates the object
- Defines getters and setters (if not readonly)
- May offer `assign(other: Partial<Type>)` or `with(other: Partial<Type>)`, that respectively assign or copies the object and assign values, then runs validation

This would help creating ES6 classes inheriting from this base class, with validation built-in:

```ts
class MyUser extends userSchema.implement() {
    set password(pw: string) {
        this.passwordDigest = hash(pw);
    }
}
```

There are a few unknowns for this: specifically, in case of nested objects that have an implementation, it would be great to return an instance of that implementation rather than a bare object. Some mapping between `ZodType` and implementation could theoretically be passed to Implement.",,
602910174,36,Type-checking methods do not accept `unknown`,"As of version `1.2.5`, the `parse`, `is` and `check` methods on `ZodType` expect to receive an argument which is _already_ of the schema's type. This is surprising to me; at version `1.0.15` I was passing `unknown` values to these functions, since the input is of unknown type (typically from IO) and the functions are being called explicity to _discover_ whether the value matches the type.

Since I don't want to incorrectly-type the values before they are checked, it seems the only option here is to use `any`, which from my point of view is strictly worse than `unknown`.

Is there a downside I'm not seeing to permitting `unknown` as input to these functions?",,
602868429,35,Support for other primitives,Are there plans to support other primitives such as Promise and BigInt?,,
601664736,34,Optional Properties was broken,"It was worked  in 1.0.9 , but broken in 1.2.3 .

```js
export const stackProps = z
    .object({
        direction: Direction.optional(),
        horizontalAlign: Alignment.optional(),
        verticalAlign: Alignment.optional(),
        wrap: z.boolean().optional(),
        grow: z.boolean().optional(),
        shrink: z.boolean().optional(),
    })

type PropType = z.TypeOf<typeof stackProps>
```
![image](https://user-images.githubusercontent.com/3960056/79527081-4f7a7b00-8099-11ea-86a1-1bd318708d01.png)
![image](https://user-images.githubusercontent.com/3960056/79527175-818bdd00-8099-11ea-9ab1-8059f9a6b830.png)
",,
595510568,31,Parser logs to the console,"When using the library to parse values, I'm seeing a lot of logs to the console of this form:

    seen string before: undefined

They seem to be coming from this line in `parser.ts`: https://github.com/vriad/zod/blob/f154275fafd1cd105dcfe4bc63f37313057b3171/src/parser.ts#L24

Is this intended behaviour, or was this shipped by mistake?",,
592462618,27,Cannot find module 'zod'.,"My tests seem to be failing after the upgrade. Any ideas?

https://github.com/moltar/typescript-runtime-type-benchmarks/pull/155

https://github.com/moltar/typescript-runtime-type-benchmarks/pull/155/checks?check_run_id=553968076
",,
589651001,25,Basic Zod Example does not compile,"I tried to use Zod and cannot get even the most basic example from the documentation to compile.

Here is the code:

```
import zod from 'zod';
zod.object({
  name: zod.string(),
  neutered: zod.boolean(),
});
```

Using typescript 3.8.3 with tsConfig:

```
{
  ""compilerOptions"": {},
  ""include"": [""src/**/*""]
}
```

Finally the message typescript provides:

```
node_modules/zod/lib/types/object.d.ts:46:43 - error TS2344: Type '{ [k in Exclude<keyof Params, ""strict"">]: Params[k]; } & { strict: false; }' does not satisfy the constraint 'ZodRawShape'.
  Property 'strict' is incompatible with index signature.
    Type 'false' is not assignable to type 'ZodAny'.

46     nonstrict: () => ZodObject<T, Flatten<{ [k in Exclude<keyof Params, ""strict"">]: Params[k]; } & {
                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
47         strict: false;
   ~~~~~~~~~~~~~~~~~~~~~~
48     }>>;
   ~~~~~

```
",,
588210456,24,Cannot find module './ZodError',That file doesn't exist.  Did you forget to include it?,,
586563979,23,Type guards vs Zod,"Hi!

I am wondering what are the differences between Zod and typescript type guards. What are the pros/cons/limits/purposes for each.",,
584620584,20,Include src in compiled package,"My webpack throwing a lot of warnings about sourcemaps.
```
WARNING in ./node_modules/zod/lib/types/string.js
Module Warning (from ./node_modules/source-map-loader/index.js):
(Emitted value instead of an instance of Error) Cannot find source file '../../src/types/string.ts': Error: Can't resolve '../../src/types/string.ts' in '/Users/okhomenko/brightback/brightback-server/src/main/webpack/node_modules/zod/lib/types'

WARNING in ./node_modules/zod/lib/types/object.js
Module Warning (from ./node_modules/source-map-loader/index.js):
(Emitted value instead of an instance of Error) Cannot find source file '../../src/types/object.ts': Error: Can't resolve '../../src/types/object.ts' in '/Users/okhomenko/brightback/brightback-server/src/main/webpack/node_modules/zod/lib/types'
```

It's trying to merge sourcemaps from zod and can't find source typescript files.
@vriad Could you please include src as part of the published package? 
",,
581268772,13,TypeScript has a capital S,"Typescript → TypeScript

Sorry, pet peeve of mine. Cool library! :)",,
581059556,11,Added to typescript-runtime-type-benchmarks,"Hey @vriad, the package looks great.

I added it to the benchmark repo.

https://github.com/moltar/typescript-runtime-type-benchmarks",,
580799542,9,Is published package not transpiled?,"I'm developing a aws lambda based application, that means I cannot direcly use typescript code when deploying, when I tried to deploy a lambda using zod, my webpack process failed with the following error:

```
Error: TypeScript emitted no output for /Users/osp/dev/strestsaas/server/node_modules/zod/index.ts. By default, ts-loader will not compile .ts files in node_modules.
You should not need to recompile .ts files there, but if you really want to, use the allowTsInNodeModules option.
```

I think the published version of the package should not directly link to .ts files in order for transpiled projects to work, right?",,
580797395,8,Enum validation support?,"Is it possible right now? related to #3 

example:

```typescript
enum Foo {
  BAR = 'BAR',
  BAZ = 'BAZ'
}
let e = z.enum(Foo);

e.parse(""LOL""); // throws
```",,
580603096,7,Can't build in my project with strictPropertyInitialization: true,"Because zod isn't compiled when it's distributed in npm, my TS compiler tries to compile it. However, my project has `strict: true` in its config options, with no strict flags turned off, and so it ends up failing to build because zod has `strictPropertyInitialization` set to false. I get a handful of errors like `Property 'schema' has no initializer and is not definitely assigned in the constructor`

I currently can only use this library in my app if my strict compile options are set to what zod has, which is definitely not preferable. (And that's a shame because I _really_ like the idea of this and I too was _this_ close to trying to write my own library after being unhappy with the status quo.)

I think it would help a lot if the project was actually pre-compiled, and the JS + .d.ts files were distributed in npm, instead of the raw TS files.

(Also, side note that is kind of related to my above suggestion: I run our app using ts-node, and I get `Cannot use import statement outside a module` when ts-node tries to import zod. I'm pretty sure that this would also be fixed by releasing the compiled code instead of the raw TS.)",,
580396482,5,Is it possible to add support for literal types and discriminated unions?,"It would be cool if the variation of the below code is allowed:

```typescript
const CellText = z.object({
  kind: ""text"",
  body: z.string(),
});

const CellCode = z.object({
  kind: ""code"",
  code: z.string(),
});

const Schema = z.array(
  z.object({
    category: z.string(),
    cells: z.array(z.union([CellText, CellCode])).nonempty(),
  })
);
```",,
580296739,3,Branded types,"Feature request: branded types 
This issue can be the primary discussion ground for implemented branded types.

**Option 1:** 
Replicating io-ts's symbol trickery to create types like NonZeroNumber or Email (it might be difficult to do that one while remaining ergonomic)

I don't love all the boilerplate associated with `io-ts` branded types (i.e. `interface PositiveBrand { readonly Positive: unique symbol }`).

**Option 2** 

It may be able to include string/number validators as a literal generic argument of the ZodString/ZodNumber classes, like so:

```
const num: z.number({ max: 5 }) // => z.ZodString
const max5: z.number({ max: 5 }) // => z.ZodString<{ max: 5 }>
```

That way the validations being enforced are easy to see with a glance at the type definition. This would only work for built-in validators I believe (?). This is also different, in that validations are registered at the instance level instead of the class level. ",,
580274793,2,Type assertions,"I've been thinking a lot about validation libaries and I share your frustration with Yup. Yup does not get everything right. I'm scared about to introducing io-ts is it has a high a cognitive overhead, but I really love what io-ts does.

I think I'll experiment with this libarary a bit, but in terms of io-ts features do you think zod could be improve with these features?

* built in type guards - i.e.  io-ts's `is()` method on codecs.
* built in type assertions - (maybe call it `assert()`) using the new assertion function types in typescript 3.7 (io-ts doesn't actually have this probably because it wants us to use `Either` instead of exceptions)
* branded types - doing io-ts's symbol trickery to create types like `NonZeroNumber` or `Email` 
  * it might be difficult to do that one while remaining ergonomic",,
