issue_id,issue_number,issue_title,issue_body,comment_id,comment_body
2676714216,2863,Uncaught Error: Maximum update depth exceeded (implementing Tic Tac Toe Example from the docs) ,"Hello,

I am new to zustand. I was trying out the Tic Tac Toe implementation from the docs. I just copy pasted the useGameStore function from the docs page : [https://zustand.docs.pmnd.rs/guides/tutorial-tic-tac-toe#lifting-state-up](https://zustand.docs.pmnd.rs/guides/tutorial-tic-tac-toe#lifting-state-up)
and i got this Error: 
![Screenshot 2024-11-20 231459](https://github.com/user-attachments/assets/949204ad-d7ec-4585-8692-0cc7865c28fb)

The actual code i have written for your reference: 

``` import './index.css'
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

const useGameStore = create(
  combine({ squares: Array(9).fill(null) }, (set) => {
    return {
      setSquares: (nextSquares) => {
        set((state) => ({
          squares:
            typeof nextSquares === 'function'
              ? nextSquares(state.squares)
              : nextSquares,
        }))
      },
    }
  }),
)

function App() {
  const [squares, setSquares] = useGameStore((state) => [
    state.squares,
    state.setSquares,
  ])
  return (
    <>
      <div className='flex justify-center items-center h-[100vh] w-[100vw]'>
        <div className=''>
          <h1 className='text-4xl text-center'>Tic Tac Toe</h1>
          <br />
          <div className='grid grid-cols-3 h-[300px] w-[300px] border border-solid'>
          </div>
        </div>
      </div>
    </>
  )
}

export default App 
```
### My dependencies: 
```
  ""dependencies"": {
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""zustand"": ""^5.0.1""
  },
```

Please help. I am new to state management and a newbie trying to learn
",2489246339,"@venkatmidhunmareedu my bad I need to update the tutorial to be compatible with v4 and v5, but in a nutshell we need stable selector results, we have two options:

this one

```ts
const squares = useGameStore(state => state.squares)
const setSquares = useGameStore(state => state.setSquares)
```

or this one using `useShallow`

```ts
const [squares, setSquares] = useGameStore(useShallow((state) => [
  state.squares,
  state.setSquares,
]))
```

on v4 and v5 no stable selector results could cause performance issues, on v4 that is not optimized and could hide some issues but does not mean that does not happen on v4, on v5 that is more visible"
2676714216,2863,Uncaught Error: Maximum update depth exceeded (implementing Tic Tac Toe Example from the docs) ,"Hello,

I am new to zustand. I was trying out the Tic Tac Toe implementation from the docs. I just copy pasted the useGameStore function from the docs page : [https://zustand.docs.pmnd.rs/guides/tutorial-tic-tac-toe#lifting-state-up](https://zustand.docs.pmnd.rs/guides/tutorial-tic-tac-toe#lifting-state-up)
and i got this Error: 
![Screenshot 2024-11-20 231459](https://github.com/user-attachments/assets/949204ad-d7ec-4585-8692-0cc7865c28fb)

The actual code i have written for your reference: 

``` import './index.css'
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

const useGameStore = create(
  combine({ squares: Array(9).fill(null) }, (set) => {
    return {
      setSquares: (nextSquares) => {
        set((state) => ({
          squares:
            typeof nextSquares === 'function'
              ? nextSquares(state.squares)
              : nextSquares,
        }))
      },
    }
  }),
)

function App() {
  const [squares, setSquares] = useGameStore((state) => [
    state.squares,
    state.setSquares,
  ])
  return (
    <>
      <div className='flex justify-center items-center h-[100vh] w-[100vw]'>
        <div className=''>
          <h1 className='text-4xl text-center'>Tic Tac Toe</h1>
          <br />
          <div className='grid grid-cols-3 h-[300px] w-[300px] border border-solid'>
          </div>
        </div>
      </div>
    </>
  )
}

export default App 
```
### My dependencies: 
```
  ""dependencies"": {
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""zustand"": ""^5.0.1""
  },
```

Please help. I am new to state management and a newbie trying to learn
",2489309585,"Hey @dbritto-dev , Thanks for helping out. 
The first one 
```
const squares = useGameStore(state => state.squares)
const setSquares = useGameStore(state => state.setSquares)
```

worked out for me. As for the second one, Their are two types of useShallow i can find.
First one:
```
import { useShallow } from 'zustand/shallow'
``` 
Second one:
```
import { useShallow } from 'zustand/react/shallow'
```
Both of them worked for me. But why two? 
Also VS code doesn't give any auto completion like this:

![Screenshot 2024-11-21 000704](https://github.com/user-attachments/assets/c335a6ff-b8cd-40bb-9ff6-0ddf8dd11782)

But once you manually type any of above two import statements, it recognizes:

![image](https://github.com/user-attachments/assets/50310285-4862-406f-a4c5-ed37c11cbe99)

As for the discussion [https://github.com/pmndrs/zustand/discussions/2204](https://github.com/pmndrs/zustand/discussions/2204), it is said that this would be resolved in version 5. 

"
2676714216,2863,Uncaught Error: Maximum update depth exceeded (implementing Tic Tac Toe Example from the docs) ,"Hello,

I am new to zustand. I was trying out the Tic Tac Toe implementation from the docs. I just copy pasted the useGameStore function from the docs page : [https://zustand.docs.pmnd.rs/guides/tutorial-tic-tac-toe#lifting-state-up](https://zustand.docs.pmnd.rs/guides/tutorial-tic-tac-toe#lifting-state-up)
and i got this Error: 
![Screenshot 2024-11-20 231459](https://github.com/user-attachments/assets/949204ad-d7ec-4585-8692-0cc7865c28fb)

The actual code i have written for your reference: 

``` import './index.css'
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

const useGameStore = create(
  combine({ squares: Array(9).fill(null) }, (set) => {
    return {
      setSquares: (nextSquares) => {
        set((state) => ({
          squares:
            typeof nextSquares === 'function'
              ? nextSquares(state.squares)
              : nextSquares,
        }))
      },
    }
  }),
)

function App() {
  const [squares, setSquares] = useGameStore((state) => [
    state.squares,
    state.setSquares,
  ])
  return (
    <>
      <div className='flex justify-center items-center h-[100vh] w-[100vw]'>
        <div className=''>
          <h1 className='text-4xl text-center'>Tic Tac Toe</h1>
          <br />
          <div className='grid grid-cols-3 h-[300px] w-[300px] border border-solid'>
          </div>
        </div>
      </div>
    </>
  )
}

export default App 
```
### My dependencies: 
```
  ""dependencies"": {
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""zustand"": ""^5.0.1""
  },
```

Please help. I am new to state management and a newbie trying to learn
",2489423581,@venkatmidhunmareedu interesting I'll look into that
2640828193,2838, Error when building a React application with Zustand.,"'m encountering an error when building a React application with Zustand. During development (yarn start), everything runs smoothly without issues. However, when running the production build (yarn build), I receive the following error:

`Attempted import error: 'createJSONStorage' is not exported from 'zustand/middleware'.`

```
import { createJSONStorage, persist, StateStorage } from 'zustand/middleware'
import { create } from 'zustand/react'
import { immer } from 'zustand/middleware/immer'

const zustandStorage: StateStorage = {
  setItem: (name, value) => {
    return storage.set(name, value)
  },
  getItem: (name) => {
    const value = storage.getString(name)
    return value ?? null
  },
  removeItem: (name) => {
    return storage.delete(name)
  },
}

...

    {
      name: 'chat-storage', 
      storage: createJSONStorage(() => zustandStorage), 
    },
```

This is my package.json
![image](https://github.com/user-attachments/assets/dc33559c-e1b3-4bba-980d-741fb4b08e29)

Please help me resolve it
Thanks",,
2596974176,2800,Mapping an array in useStore causes an infinite loop. I want to confirm if this is a bug.,"```typescript
const filterData = useTestStore(
    useShallow((state) =>
      state.data
        // The following line of code causes an infinite loop:
        // .map((item) => ({ ...item, name: 'name: ' }))
        .filter((item) => item.status === 1)
    )
  );
```

```typescript
// store.ts
import { create } from 'zustand';

type State = {
  data: { name: string; status: 0 | 1 }[];
};
type Action = {
  setData: (newData: State['data']) => void;
};
type Store = State & Action;

const initState: State = {
  data: [{ name: 'jack', status: 1 }],
};

export const useTestStore = create<Store>()((set) => ({
  ...initState,
  setData: (newData) => {
    set({
      data: newData,
    });
  },
}));
```

Repository to reproduce the issue:
[https://stackblitz.com/edit/vitejs-vite-8cvrr3?file=src%2Ftest%2Findex.tsx](https://stackblitz.com/edit/vitejs-vite-8cvrr3?file=src%2Ftest%2Findex.tsx)
",,
2586931668,2789,Zustand 5 is too good.,"Saying this is a piece of art is an understatement - this library is in the upper echelon with things like Zod, tRPC or even Typescript itself or linters. Thank you Poimandres, @dai-shi .

I ported my app to 5.0 (clean, without use-sync-external-store), and couldn't be happier of the results.
- in particular removing the cause of 'recursion' errors (if you know you know) has added stability to states and made the app faster and more resilient, and proved a great investment for UX!

I couldn't find a way to comment on the release itself, so here is to you!
🎊 Congrats to the Zustand team!!! 🥇 

(and you can safely close this ticket :)",2412481633,So nice to hear that! (Let's keep this open for a while.)
2586931668,2789,Zustand 5 is too good.,"Saying this is a piece of art is an understatement - this library is in the upper echelon with things like Zod, tRPC or even Typescript itself or linters. Thank you Poimandres, @dai-shi .

I ported my app to 5.0 (clean, without use-sync-external-store), and couldn't be happier of the results.
- in particular removing the cause of 'recursion' errors (if you know you know) has added stability to states and made the app faster and more resilient, and proved a great investment for UX!

I couldn't find a way to comment on the release itself, so here is to you!
🎊 Congrats to the Zustand team!!! 🥇 

(and you can safely close this ticket :)",2415817815,"@dai-shi My comment could be off-topic. 

Initially, I believed that zustand was React specific because the `create` returned a hook.
But zustand is very good with vanilla JavaScript. The ability to create stores using `createStore` and use with React or just JavaScript and DOM is outstanding. I am used to a pattern where I create stateful services (like sdk) for front-end that would return store, actions and selectors and they could be paired with JS or React. Subscriptions also helped me avoid using `useEffect` when UI is not a concern with the effect.
"
2586931668,2789,Zustand 5 is too good.,"Saying this is a piece of art is an understatement - this library is in the upper echelon with things like Zod, tRPC or even Typescript itself or linters. Thank you Poimandres, @dai-shi .

I ported my app to 5.0 (clean, without use-sync-external-store), and couldn't be happier of the results.
- in particular removing the cause of 'recursion' errors (if you know you know) has added stability to states and made the app faster and more resilient, and proved a great investment for UX!

I couldn't find a way to comment on the release itself, so here is to you!
🎊 Congrats to the Zustand team!!! 🥇 

(and you can safely close this ticket :)",2437344081,"> Saying this is a piece of art is an understatement - this library is in the upper echelon with things like Zod, tRPC or even Typescript itself or linters. Thank you Poimandres, @dai-shi .
> 
> I ported my app to 5.0 (clean, without use-sync-external-store), and couldn't be happier of the results.
> 
> * in particular removing the cause of 'recursion' errors (if you know you know) has added stability to states and made the app faster and more resilient, and proved a great investment for UX!
> 
> I couldn't find a way to comment on the release itself, so here is to you! 🎊 Congrats to the Zustand team!!! 🥇
> 
> (and you can safely close this ticket :)

absolutely agree!.I think zustand is the most perfect store library for React.~ I love it!"
2586931668,2789,Zustand 5 is too good.,"Saying this is a piece of art is an understatement - this library is in the upper echelon with things like Zod, tRPC or even Typescript itself or linters. Thank you Poimandres, @dai-shi .

I ported my app to 5.0 (clean, without use-sync-external-store), and couldn't be happier of the results.
- in particular removing the cause of 'recursion' errors (if you know you know) has added stability to states and made the app faster and more resilient, and proved a great investment for UX!

I couldn't find a way to comment on the release itself, so here is to you!
🎊 Congrats to the Zustand team!!! 🥇 

(and you can safely close this ticket :)",2463125464,"Indeed, thank you so much for this lib <3 "
2586931668,2789,Zustand 5 is too good.,"Saying this is a piece of art is an understatement - this library is in the upper echelon with things like Zod, tRPC or even Typescript itself or linters. Thank you Poimandres, @dai-shi .

I ported my app to 5.0 (clean, without use-sync-external-store), and couldn't be happier of the results.
- in particular removing the cause of 'recursion' errors (if you know you know) has added stability to states and made the app faster and more resilient, and proved a great investment for UX!

I couldn't find a way to comment on the release itself, so here is to you!
🎊 Congrats to the Zustand team!!! 🥇 

(and you can safely close this ticket :)",2483701333,I will screenshot this issue in my ADR for choosing zustand as state managment library :D
2586931668,2789,Zustand 5 is too good.,"Saying this is a piece of art is an understatement - this library is in the upper echelon with things like Zod, tRPC or even Typescript itself or linters. Thank you Poimandres, @dai-shi .

I ported my app to 5.0 (clean, without use-sync-external-store), and couldn't be happier of the results.
- in particular removing the cause of 'recursion' errors (if you know you know) has added stability to states and made the app faster and more resilient, and proved a great investment for UX!

I couldn't find a way to comment on the release itself, so here is to you!
🎊 Congrats to the Zustand team!!! 🥇 

(and you can safely close this ticket :)",2485215231,❤️ 
2526306983,2741,[Feedback Request] Does Zustand v5-rc work for you?,"## How to Install

```bash
npm i zustand@next
```

## Migration Guide

https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md

## How to respond

Add comments to this issue or add reactions to this issue comment.

👍 : I've tested v5-rc and it works fine for me.
👎 : I've tested v5-rc and found an issue. < Comment below!
👀 : I'll try it later.",2362028584,"typescript error when using with immer middleware and slice pattern.
error location Inside Immer callback, where function arguments are being spread (...a)
[reproducible example](https://codesandbox.io/p/sandbox/zustand-v5-z7d2fd)
```
Types of parameters 'shouldReplace' and 'replace' are incompatible.
Type 'true' is not assignable to type 'false'.
```"
2526306983,2741,[Feedback Request] Does Zustand v5-rc work for you?,"## How to Install

```bash
npm i zustand@next
```

## Migration Guide

https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md

## How to respond

Add comments to this issue or add reactions to this issue comment.

👍 : I've tested v5-rc and it works fine for me.
👎 : I've tested v5-rc and found an issue. < Comment below!
👀 : I'll try it later.",2365025077,"Everything works with the RC. I tried previous versions, and the only additional step I needed to take was to avoid having a fallback to empty arrays. With the React compiler, there was an issue with react.Ref when I created the Store context. However, that was fixed by the React team some weeks ago."
2526306983,2741,[Feedback Request] Does Zustand v5-rc work for you?,"## How to Install

```bash
npm i zustand@next
```

## Migration Guide

https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md

## How to respond

Add comments to this issue or add reactions to this issue comment.

👍 : I've tested v5-rc and it works fine for me.
👎 : I've tested v5-rc and found an issue. < Comment below!
👀 : I'll try it later.",2373133018,"> @wuarmin would you mind creating a minimal repro on stackblitz? I'd be happy to help

Buh, I'm pretty busy at the moment. I will try, but I probably won't be able to do this repro this week.


> It seems like unstable selector result. I wonder why it doesn't happen in development.

Yes, it was pretty sobering when I deployed and then nothing worked anymore. I searched for a long time until I found out that zustand had something to do with it. 

This is the zustand store that triggers the error in the prod area, among other things:

```js
import { create } from ""zustand"";
import { useQuery, keepPreviousData } from ""@tanstack/react-query"";
import { gql } from ""graphql-request"";
import { apiClient } from ""@/features/query"";
import { Order } from ""@/graphql/fragments"";

const query = gql`
  query FilteredOrders($after: String, $first: Int, $query: OrdersQueryInput!) {
    filteredOrders(after: $after, first: $first, query: $query) {
      totalCount
      nodes {
        ...Order
      }
    }
  }
  ${Order}
`;

export const statusCategories = [
  { id: ""all"", name: ""Alle"" },
  { id: ""action_required"", name: ""Aktion erforderlich"" },
];

const afterForPage = (page, itemsPerPage) => String((page - 1) * itemsPerPage);

const pageParams = (page, itemsPerPage) => ({
  after: afterForPage(page, itemsPerPage),
  first: itemsPerPage,
});

const paginationFilterState = (set, get) => ({
  filterItems: { statusCategory: ""action_required"" },
  filters: [],
  sort: [{ id: ""id"", desc: true }],
  rowSelection: {},
  page: 1,
  actions: {
    applyFilters: (filters) => set({ filters, page: 1 }),
    applyFilterItem: (id, value) => {
      const newFilterItems = { ...get().filterItems, [id]: value };
      if (!value) {
        delete newFilterItems[id];
      }
      set({ filterItems: newFilterItems, page: 1 });
    },
    goToPage: (page) => set({ page, rowSelection: {} }),
    sort: (sort) => set({ sort }),
    applyRowSelection: (rowSelection) => set({ rowSelection }),
  },
});

const useQueryStore = create(paginationFilterState);

const useFilter = () =>
  useQueryStore(({ filters, filterItems }) => {
    return {
      ...filters.reduce((acc, { id, value }) => ({ ...acc, [id]: value }), {}),
      ...filterItems,
    };
  });
export const useFilterItems = () =>
  useQueryStore(({ filterItems }) => filterItems);
export const useFilters = () => useQueryStore(({ filters }) => filters);
export const usePage = () => useQueryStore(({ page }) => page);
export const useRowSelection = () =>
  useQueryStore(({ rowSelection }) => rowSelection);
export const useSort = () => useQueryStore(({ sort }) => sort);
export const useQueryActions = () => useQueryStore((state) => state.actions);

export function useOrders({ itemsPerPage = 100 } = {}) {
  const filter = useFilter();
  const page = usePage();
  const sort = useSort();

  return useQuery({
    queryKey: [""orders"", ""list"", filter, sort, page, itemsPerPage],
    placeholderData: keepPreviousData,
    queryFn: async () => {
      return apiClient
        .rq(query, {
          ...pageParams(page, itemsPerPage),
          query: { filter, sort },
        })
        .then((data) => ({
          totalPages: Math.ceil(data.filteredOrders.totalCount / itemsPerPage),
          records: data.filteredOrders.nodes,
        }));
    },
  });
}
```

@dai-shi Do you see a problem.

Thanks"
2526306983,2741,[Feedback Request] Does Zustand v5-rc work for you?,"## How to Install

```bash
npm i zustand@next
```

## Migration Guide

https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md

## How to respond

Add comments to this issue or add reactions to this issue comment.

👍 : I've tested v5-rc and it works fine for me.
👎 : I've tested v5-rc and found an issue. < Comment below!
👀 : I'll try it later.",2375370858,"re: @mehimanshupatil @dai-shi 

Minimal example - works in v4, breaks in v5

```ts
import { create, StateCreator } from ""zustand"";
import { immer } from ""zustand/middleware/immer"";

interface Slice1 {
  foo: string;
}

interface Slice2 {
  bar: string;
}

const createSlice1: StateCreator<Slice1, [], [], Slice1> = (set) => ({
  foo: ""test"",
});

export const useBoundStore = create<Slice1 & Slice2>()(
  immer((...a) => ({
    ...createSlice1(...a),
  }))
);
```

Fix in v5:

```ts
const createSlice1: StateCreator<Slice1 & Slice2, [], [], Slice1> = (set) => ({
```

The first parameter of StateCreator now requires the entire correct type of the store. I think this is a bug?

Is the StateCreator's first parameter supposed to contain the entire type of the store?  

Counterpoint: the example for slices pattern in the docs does not include the entire store type (is missing the SharedSlice type) which works in v4 but does not work in v5 if you are using immer.
https://zustand.docs.pmnd.rs/guides/typescript#slices-pattern

I unfortunately don't have the bandwidth in the next two weeks to investigate why. Help is appreciated!"
2526306983,2741,[Feedback Request] Does Zustand v5-rc work for you?,"## How to Install

```bash
npm i zustand@next
```

## Migration Guide

https://github.com/pmndrs/zustand/blob/main/docs/migrations/migrating-to-v5.md

## How to respond

Add comments to this issue or add reactions to this issue comment.

👍 : I've tested v5-rc and it works fine for me.
👎 : I've tested v5-rc and found an issue. < Comment below!
👀 : I'll try it later.",2375618467,"@dbritto-dev 

https://github.com/pmndrs/zustand/blob/6b29015c3b9fdf5a5aa08b69811044f90c0f8d1b/docs/guides/typescript.md?plain=1#L416

Should that be `BearSlice & FishSlice & SharedSlice`?"
2423427004,2652,enums not working,"<img width=""1440"" alt=""Screenshot 2024-07-22 at 19 47 52"" src=""https://github.com/user-attachments/assets/babc2938-f837-4bd8-98cd-471956cd1643"">
",2243539402,"@dbritto-dev I dont think I can use zustand in ts playground. I can send u the code and u can copy it

`import { create } from ""zustand"";
import { format } from ""date-fns"";

import { createSelectors } from ""../lib/createSelectors"";

type State = {
  value: ""first"" | ""second"";
};

type Actions = {
    setValue: (value: ""first"" | ""second"") => void;
};

const initialState = {
    value: ""first"",
};

const calendarStore = create<State & Actions>()((set) => ({
  ...initialState,
    setValue: (value: ""first"" | ""second"") => {
        set((state) => ({ ...state, value }));
    },
}));

export const useCalendarStore = createSelectors(calendarStore);
`"
2407620941,2645,Usage of import.meta.env,"I've noticed a small issue with how the [`(import.meta.env ? import.meta.env.MODE : undefined)`](https://github.com/pmndrs/zustand/blob/33cd0c0dd15307a98d859b7993c4160fa6f98b0b/rollup.config.js#L69C18-L69C70) condition is processed in code built by Vite. In short, `import.meta.env` in this condition gets replaced by a reference to an object containing all environment variables. Here's a snippet from a [fresh Vite app using zustand](https://stackblitz.com/edit/vitejs-vite-ralspn?file=src%2FApp.tsx):

![](https://github.com/user-attachments/assets/0c5f12a0-485b-4a85-93e8-c63704ace403)
```js
var Bd = { BASE_URL: ""/"", MODE: ""production"", DEV: !1, PROD: !0, SSR: !1 };
const Ki = (e) => {
  let n;
  const t = new Set(),
    r = (v, m) => {
      const p = typeof v == ""function"" ? v(n) : v;
      if (!Object.is(p, n)) {
        const g = n;
        (n =
          m ?? (typeof p != ""object"" || p === null)
            ? p
            : Object.assign({}, n, p)),
          t.forEach((w) => w(n, g));
      }
    },
    l = () => n,
    s = {
      setState: r,
      getState: l,
      getInitialState: () => c,
      subscribe: (v) => (t.add(v), () => t.delete(v)),
      destroy: () => {
        (Bd ? ""production"" : void 0) !== ""production"" &&
          console.warn(
            ""[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.""
          ),
          t.clear();
      },
    },
    c = (n = e(r, l, s));
  return s;
};
```


As you can see, the condition and the warning are still present even though the code was built with `MODE: ""production""`. For some apps, this might not be an issue, but if you have many environment variables or some very long ones, it could be problematic. Depending on how many zustand modules end up in the bundle, you can get 4-5 of these objects, and each will contain all environment variables.

Would you consider using only `process.env.NODE_ENV` to check the environment? Most tools support it out of the box, whereas `import.meta.env` is a Vite-specific feature, though I wish it were standard.",,
2400712521,2640,"""useEffect"" is not exported by ""node_modules/react/index.js""","I have built an R3F app using Astro.js. When running dev it works properly. I am trying to export it to a static website using build but I get the below error. I am not using zustand directly but it is a dependency for the below

├─┬ @react-three/drei@9.108.3
│ ├─┬ tunnel-rat@0.1.2
│ │ └── zustand@4.5.4
│ └── zustand@3.7.2
├─┬ @react-three/fiber@8.16.8
│ └── zustand@3.7.2 deduped
├─┬ leva@0.9.35
│ └── zustand@3.7.2 deduped
└─┬ r3f-perf@7.2.1
  └── zustand@4.5.4



""useEffect"" is not exported by ""node_modules/react/index.js"", imported by ""node_modules/zustand/esm/index.js"".
file: node_modules/zustand/esm/index.js:1:44

1: import { useReducer, useRef, useDebugValue, useEffect, useLayoutEffect } from 'react';",,
2392147617,2632,Documentation incorrect: Usage with React Contexts,"Dear all,

After reading a lot of blogposts on this, and the docs, the way I see it, there are two ways of combining Zustand with a react context:
1. Using a normal, global store, and attaching the reference to the context - prevents anyone outside of the context from using the store (by normal means at least)
2. Using a local store, exposed to the children, through a react context - adds the superpower to create a new context on every mount/navigation etc.

There are many blogposts talking about this, and most notable discussion here is https://github.com/pmndrs/zustand/discussions/730 

There is also a section of the readme that briefly mentiones this, here https://github.com/pmndrs/zustand?tab=readme-ov-file#react-context

**Problems I'd like to fix:**
1. The readme segment is incorrect code. Needs additional brainpower in order to be understood or used.
2. The segment from the readme is never mentioned in the docs website, at all.

Here is a copypaste of the Readme code, so that we can hopefully discuss it here:

```ts
import { createContext, useContext } from 'react'
import { createStore, useStore } from 'zustand'

const store = createStore(...) // vanilla store without hooks

const StoreContext = createContext()

const App = () => (
  <StoreContext.Provider value={store}>
    ...
  </StoreContext.Provider>
)

const Component = () => {
  const store = useContext(StoreContext)
  const slice = useStore(store, selector)
  ...
```",2210549264,"For reference, here is a full working example. The example shows a simple version of using a local Zustand store in a context (2), where if the Zustand element which renders the context is unmounted, a new state will be assigned on the very next mount.

```tsx
import { createContext, useContext } from ""react"";
import { createStore, useStore, type StoreApi } from ""zustand"";

type StoreState = { count: number; inc: () => void; dec: () => void; };

const StoreContext = createContext<StoreApi<StoreState>>(
  undefined as unknown as StoreApi<StoreState>,
);

export function Zustand() {
  const store = createStore<StoreState>((set, get) => ({
    count: 0,
    inc: () => set((state) => ({ count: state.count + 1 })),
    dec: () => set((state) => ({ count: state.count - 1 })),
  }));

  return (
    <div className=""flex gap-4"">
      <button onClick={() => store.getState().dec()}>-</button>
      <StoreContext.Provider value={store}>
        <Child />
      </StoreContext.Provider>
      <button onClick={() => store.getState().inc()}>+</button>
    </div>
  );
}

function Child() {
  const localStore = useContext(StoreContext);
  const count = useStore(localStore, (state) => state.count);
  return <div>Count: {count}</div>;
}
```

~P.S. One thing I'm unsure about is the difference between `zustand` and `zustand/vanilla`. It seems to work the same regardless of where I import from. Haven't had the time to look, but sounds like its just a proxy export. Anyway, the original Readme comment imports `zustand` but then mentions: `createStore(...) // vanilla store without hooks` which causes a bit of confusion.~"
2392147617,2632,Documentation incorrect: Usage with React Contexts,"Dear all,

After reading a lot of blogposts on this, and the docs, the way I see it, there are two ways of combining Zustand with a react context:
1. Using a normal, global store, and attaching the reference to the context - prevents anyone outside of the context from using the store (by normal means at least)
2. Using a local store, exposed to the children, through a react context - adds the superpower to create a new context on every mount/navigation etc.

There are many blogposts talking about this, and most notable discussion here is https://github.com/pmndrs/zustand/discussions/730 

There is also a section of the readme that briefly mentiones this, here https://github.com/pmndrs/zustand?tab=readme-ov-file#react-context

**Problems I'd like to fix:**
1. The readme segment is incorrect code. Needs additional brainpower in order to be understood or used.
2. The segment from the readme is never mentioned in the docs website, at all.

Here is a copypaste of the Readme code, so that we can hopefully discuss it here:

```ts
import { createContext, useContext } from 'react'
import { createStore, useStore } from 'zustand'

const store = createStore(...) // vanilla store without hooks

const StoreContext = createContext()

const App = () => (
  <StoreContext.Provider value={store}>
    ...
  </StoreContext.Provider>
)

const Component = () => {
  const store = useContext(StoreContext)
  const slice = useStore(store, selector)
  ...
```",2210990483,@markomitranic in a nutshell zustand (react) and zustand/vanilla (pure javascript or vanilla javascript)
2335175607,2583,onRehydrateStorage is invoked before storeage.getItem,"## Summary

These are the logs for the below store
```
onRehydrateStorage {count: 0, _hasHydrated: false, increment: ƒ, setHasHydrated: ƒ}
storage.setItem food-storage {""state"":{""_hasHydrated"":true},""version"":0}
storage.getItem food-storage
storage.getItem value {""state"":{""_hasHydrated"":true},""version"":0}
storage.setItem food-storage {""state"":{""count"":0,""_hasHydrated"":true},""version"":0}
```

Because onRehydrateStorage is called before storage.getItem, the store is always reset with default data.

For the following store:
```
export const useCount = create()(
  persist(
    (set, get) => ({
      count: 0,
      _hasHydrated: false,
      increment: () => {
        set({ count: get().count + 1 });
      },
      setHasHydrated: (value: boolean) => {
        set({ _hasHydrated: value });
      },
    }),
    {
      name: ""food-storage"", // name of item in the storage (must be unique)
      storage: createJSONStorage(() => ({
        getItem: async (name) => {
          console.log(""storage.getItem"", name);
          const value = localStorage.getItem(name);
          console.log(""storage.getItem value"", value);
          return value;
        },
        removeItem: (name) => localStorage.getItem(name),
        setItem: (name: string, value) => {
          console.log(""storage.setItem"", name, value);
          return localStorage.setItem(name, value);
        },
      })),
      // (optional) by default the 'localStorage' is used
      onRehydrateStorage: (data: any) => {
        console.log(""onRehydrateStorage"", data);
        data.setHasHydrated(true);
      },
    }
  )
);
```


## Link to reproduction
https://codesandbox.io/p/sandbox/zustand-repro-pyys3x - see App.tsx and look at console logs


## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",2157792568,"@jeffreyyoung Did you resolve this? I've ran into the exact same thing so it would be good to know what you did.

UPDATE: I figured it out, I needed to set it in the returned function"
2303599165,2560,"devtools with option `serialize.immutable` does not deserialize state from devtools correctly (broken redux devtools ""Jump"" / ""Revert"" etc.)","## Summary

redux-devtools provides a `serialize` option: https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md#serialize.
You can provide the `immutable-js` library to the `serialize.immutable` field to: ""automatically serialize/**deserialize** immutablejs via [remotedev-serialize](https://github.com/zalmoxisus/remotedev-serialize).""

This works fine for serializing: redux-devtools will show `ImmutableSet` if zustand store was created with this option.
However, it breaks with deserializing during `JUMP_TO_ACTION`, `REVERT` and other devtools options, when used with zustand.

With zustand, the state doesn't get deserialized correctly, so the next time the store is used, the code will receive the wrong data type.
This problem does not occur with redux.

I believe this should work:
- Support for jumping to states was added in #590 by @Aslemammad 
- Support for devtools `serialize` option was added in #540 by @marcoSven 

## Link to reproduction

https://github.com/JayFoxRox/zustand/tree/immutable-bug/examples/demo
All changes are in this commit: https://github.com/JayFoxRox/zustand/commit/80f0765a59278c3629a9eb0d5a89a88a1320dd45

specifically, this is using:

```ts
import { devtools } from 'zustand/middleware'

outStore = devtools(inStore, {
  serialize: {
    immutable: Immutable
  }
})
```

My reproduction is based on the zustand demo.
To show the problem, the number counter has been replaced by a growing `Immutable.Set`.
To display it, I `JSON.stringify` the `Immutable.Set` (Immutable handles JSON stringification, so it shows as array).

The demo creates 2 stores; one for redux and one for zustand; each with devtools.

The counter button has been duplicated:
- on the left there is a button for the redux store.
- on the right there is a button for the zustand store.

The stores both work until the devtools are used to jump.
When jumping, the redux store continues to work, but the zustand store breaks.
Once the state is broken, JSON stringification shows a JS object which represents the serialized JSON encoding in the redux-devtools.

Here's a video:

https://github.com/pmndrs/zustand/assets/360330/a846e5ae-b047-429a-be7a-8585077ebaba

## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.
    - (No. But reproduction provided and no questions)

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.
    - (No. GitHub repo provided instead to avoid account creation)

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
    - (Exists with JS and TS; reproduction only created for JS, but real application where bug occured is TS)
",,
2300300237,2555,Persist middleware keeping old versions of functions around. Breaking apps when deploying to prod,"## Summary

I'm using the persist middleware to keep data available through multiple browser tabs. I recently made some changes to my store that uses the persist middleware. Mainly, I'm no longer exporting the entire store but just custom hooks as described here: https://tkdodo.eu/blog/working-with-zustand#only-export-custom-hooks. After I made this change I noticed my local browser environment was unable to find the new function changes I made. I checked localStorage and saw the new functions were not there but the old ones still were. This is the root of the issue. In dev land I simply cleared my localStorage and continued on. When I deployed the changes though, I naively assumed the browser storage would get recreated with a new build which it did not. As a result, user's saw the function not found error when trying to execute code that attempted to use it. 

This doesn't seem like a bug really so my question is, how should I be maintaining a persisted store? I should be able to make changes to functions/state and have it not brick prod once deployed. Is there a way to clear localStorage when store changes are made? Is that even the right move? Also wondering what the best way to test something like this would be? Our E2E test pipeline didn't pick up the error bc cypress creates new browser windows for every tests (therefore side stepping this issue).

Any guidance would be appreciated. 



## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.
- Not sure how to repo this with a sandbox since its depended on localStorage functionality 
",,
2271679438,2520,"import { create ,WritableDraft} from ""zustand""","import { create ,WritableDraft} from ""zustand""
",2085537187,"模块 """"zustand"""" 没有导出的成员 ""WritableDraft""。
"
2260143180,2505,Setting nested state make the other states change (their values didn't change),"## Setting nested state make the other states change (their values didn't change)

## Link to reproduction

https://codesandbox.io/p/sandbox/amazing-rhodes-6yp8c5?file=%2Fsrc%2FApp.tsx

Please view the console, you can see that the components that watch `count` re-render even though `count` is the same. Refresh the page in code sandbox make it work as expected but on my real machine it doesn't.
Here is my console log no matter how many times I reload the page
<img width=""159"" alt=""image"" src=""https://github.com/pmndrs/zustand/assets/62872729/4e158798-df22-4797-9a89-2df692c6cc62"">
(I'm using vite btw)
I did some research and found out that this piece of code was the problem, look at `count` in the useLayoutEffect dependencies, but I still think it's a bug cause the watched state literally didn't change
```tsx
const count = useTestStore((state) => {
  return state.count;
});
const setNest1 = useTestStore((state) => {
  return state.setNest1;
});

useLayoutEffect(() => {
  setNest1({ key: ""nest2"", value: { value1: 1 } });
}, [setNest1, count]);
```

## Check List

Please do not ask questions in issues.

- [ x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
2258729134,2502,Typescript + Slices = trouble,"## Summary
Lots of errors trying to implement slices with the code from docs, i.e the slices pattern found here:
https://docs.pmnd.rs/zustand/guides/typescript

## Link to reproduction
https://docs.pmnd.rs/zustand/guides/typescript


## Check List

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.
https://docs.pmnd.rs/zustand/guides/typescript

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
2239382709,2482,State updated in one component but not in another one,"Hi, I ran into an issue with a state not being updated between the two components. The store.ts looks like this:
`import { create } from 'zustand';`

`type State = {
    island_id: string
}`

`type Action = {
    setIsland_id: (island_id: State['island_id']) => void
}`

`export const useStore = create<State & Action>((set) => ({
    island_id: '',
    setIsland_id: (island_id) => set(() => ({ island_id: island_id })),
})); `

Then, in one component, I set the value based on e.target.value: 

`const island_id = useStore((state) => state.island_id);`

  `const setIsland_id = useStore((state) => state.setIsland_id);`

`   const handleIslandChange = (e) => {
      setIsland_id(e.target.value);
      for (const [key, value] of Object.entries(islandIds)) {
        if (value === e.target.value) {
          setIslandThingId(+key);
        }
      }
    }`

and in the return statement:

` <Form.Select aria-label=""Default select"" id=""select-island"" onChange={handleIslandChange}>`
            `<option value={islandIds[1]}>Sustainable Buildings Demo</option>`
            `<option value={islandIds[4]}>North District</option>`
            `<option value={islandIds[5]}>Southeast District</option>`
    `</Form.Select>`

The state in this component is indeed being updated (I can see the state changing in the console.log and react components tab, however, in the second component, which is supposed to reuse the island_id state from the first component , the value is an empty string (what I initially set in the store.ts) and it is not being updated no matter how many times I update the state in the first component. Here is the code in the 2nd component: 

`const island_id = useStore((state) => state.island_id);`

  `React.useEffect(() => {
    console.log(island_id); 
  }, [island_id]);`

I'm fairly new to zustand and other global state management libraries so any help would be appreciated! 
",,
2215996331,2449,The value I save to storage with persist is delayed when the page refreshes.,"## Summary
When I refresh the page with the value I saved to localstorage with persist, it takes the old value for 1 second and then shows the new value. Is there any way to avoid this 1 second delay?

My example code is below;

use-store.js
```
'use client';

import { useState, useEffect } from 'react';

const useStore = (store, callback) => {
  const result = store(callback);
  const [data, setData] = useState();

  useEffect(() => {
    setData(result);
  }, [result]);

  return data;
};

export default useStore;
```

use-template.js
```
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const initialStates = {
  templateStatus: false,
};

const useTemplate = create(
  persist(
    (set) => ({
      ...initialStates,
      setTemplateStatus: () => {
        set((state) => ({ templateStatus: !state.templateStatus }));
      },
    }),
    {
      name: 'template-status',
    }
  )
);

export default useTemplate;
```

component.js
```
'use client';

import useStore from './store/use-store';
import useTemplate from './store/use-template';

export default function Home() {
  const templateStatus = useStore(
    useTemplate,
    (state: any) => state.templateStatus
  );
  const setTemplateStatus = useTemplate((state) => state.setTemplateStatus);
  return (
    <main className=""flex min-h-screen flex-col items-center justify-between p-24"">
      <div className=""mb-32 grid text-center lg:max-w-5xl lg:w-full lg:mb-0 lg:grid-cols-4 lg:text-left"">
        <p>template status: {templateStatus ? 'true' : 'false'}</p>
        <button onClick={setTemplateStatus}>change template status</button>
      </div>
    </main>
  );
}
```


## Link to reproduction
https://stackblitz.com/edit/stackblitz-starters-jjsutv?file=app%2Fpage.tsx



## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
2212344851,2443,Argument of type '(state: ClientStore) => Client | undefined' is not assignable to parameter of type 'ClientStore | Partial<ClientStore> | ((state: ClientStore) => ClientStore | Partial<ClientStore>)'.   Type '(state: ClientStore) => Client | undefined' is not assignable to type '(state: ClientStore) => ClientStore | Partial<ClientStore>'.     Type 'Client | undefined' is not assignable to type 'ClientStore | Partial<ClientStore>'.       Type 'undefined' is not assignable to type 'ClientStore | Partial<ClientStore>'.ts(2345),"HELP ME: 
import create from ""zustand"";
import { Client } from ""./types"";

interface ClientStore {
  clients: Client[];
  addClient: (client: Client) => void;
  getClientById: (clientId: string) => Client | null;
}

export const useClientStore = create<ClientStore>((set) => ({
  clients: [],
  addClient: (client) =>
    set((state) => ({ clients: [...state.clients, client] })),
  getClientById: (clientId) => {
    const client = set((state) =>
      state.clients.find((c: Client) => c.id === clientId)
    );
    return client || null;
  },
}));
",,
2200468986,2428,"Immer Middelware Typescript error: Exported variable 'useMyStore' has or is using name 'WritableDraft' from external module ""../node_modules/immer/dist/immer"" but cannot be named.","When I add an array property of a custom type like `Cites: City[]`, the build fails with the error above. But if I use `City: any[]`, or a singular property like string or even a singular custom type `city: City`, it works fine. 

Here is how I configured my store 

`export const useMyStore = create<MyStore>()(
  immer((set, get) => ({
   ...
 }))
`
I'm using Vite for the build. 
",,
2178695677,2401,Persist storage : values are converted to strings before replacer,"## Summary

I am trying to use `persist` with dates.

Bug: values are converted to strings before replacer function so I cannot convert it back to date because I couldn't apply `type: 'date'` to convert it to date in `reviver`

## Link to reproduction

[Code sandbox](https://codesandbox.io/p/sandbox/bug-zustand-replacer-hjg9xw?file=%2Fsrc%2FApp.js%3A21%2C23)

![image](https://github.com/pmndrs/zustand/assets/48047952/62772854-76d9-45cc-a55a-65facb64eb8c)

## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
2164825183,2381,Cant user Array of Map type to store data ,"```ts
import { Collection, CollectionItem, ContainerNode } from ""./types"";
import { create } from ""zustand"";

import { devtools } from ""zustand/middleware"";

type State = {
  collection: Collection;
  user: string;
};

type Actions = {
  addContainerNode: () => void;
  removeContainerNode: (idx: number) => void;
};

const n = new Map<string, ContainerNode>();
n.set(""lol"", {
  title: ""new"",
  content: ""new"",
});
const initialCollection = [n];

export const useCollectionStore = create<State & Actions>()(
  devtools((set) => ({
    user: ""dasked"",
    collection: initialCollection,
    addContainerNode: () =>
      set((state) => {
        const temp = [...state.collection, n];
        return { ...state, collection: temp };
      }),

    removeContainerNode: (idx) =>
      set((s) => {
        const temp = s.collection.filter((_, i) => i != idx);
        return { ...s, collection: temp };
      }),
  })),
);
```

the collection is empty object in state , but it should be some sort of map ! 
i'm not sure how to get the behavior i want
![image](https://github.com/pmndrs/zustand/assets/63857530/c02b09b3-a06b-4542-bfb4-c3d60046c98d)

i want to store array of Map in my collection in store.
",,
2159225753,2367,type WithoutCallSignature<T>,"### Issue

https://github.com/pmndrs/zustand/blob/827d5aacafa1974fff012955ea6f24fde51dc7ef/src/context.ts#L35

What does exactly this type does. For my understanding, it returns the exact same type as provided.

### Suggestion

To match the name of the type, it implementation should be as
```typescript
type WithoutCallSignature<T> = {
  [K in keyof T as T[K] extends Function ? never : K]: T[K];
};
```",,
2150577336,2356,Re-render issue while performing open and setOpen using shadcn,"### Discussed in https://github.com/pmndrs/zustand/discussions/2354
**_I'm sorry this was resolved or closed by @dbritto-dev before solving the actual problem_**

<div type='discussions-op-text'>

<sup>Originally posted by **Akshaypmna18** February 22, 2024</sup>
https://stackoverflow.com/questions/77826561/shadcn-reusuable-dialog-component-called-twice-renders-update-form-only

I have implemented a reusable dialog component using **Shadcn** in my todo app. However, I'm encountering an issue where the component is not working as needed. The add form and update form opens only after clicking twice. And when we click the pencil icon immediately after adding a todo it will pop add form instead of update form. I'm using **zustand** for state management.

Dialog Component

``` 
export default function DialogModal({ children, id, text }) {
  const { handleTodo, todo, setTodo, isOpen, setIsOpen } = useTodo(
    (state) => state
  );
  return (
    <Dialog open={isOpen} onOpenChange={() => setIsOpen()}>
      <DialogTrigger>{children}</DialogTrigger>
      <DialogContent className=""max-w-[400px]"">
        <DialogHeader>
          <DialogTitle className=""bold text-[calc(1.25rem+.5vw)]"">
            <big>{id ? ""Update Task"" : ""Add Task""}</big>
          </DialogTitle>
        </DialogHeader>
        <Input
          className=""font-[poppins]""
          placeholder=""Enter the task...""
          defaultValue={text}
          onChange={(e) => setTodo(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === ""Enter"") handleTodo(todo.trim(), id);
          }}
        />
        <DialogFooter>
          <Button
            className=""text-[calc(1rem+.5vw)] mx-auto w-[min(90%,10rem)]""
            onClick={() => handleTodo(todo.trim(), id)}
          >
            {id ? ""Update"" : ""Add""}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```
If I set 'setIsOpen(!isOpen)' the dialog component only shows the latest todo

update todo

```
     <DialogModal id={id} text={text}>
      <ToolTipComp Content={() => <ToolTipContent />}>
        <Pencil2Icon
          onClick={() => setIsOpen(true)}
          className=""min-h-[1.5rem] min-w-[1.5rem] cursor-pointer hover:text-rose-500""
        />
      </ToolTipComp>
    </DialogModal>
```

add todo

```
    <DialogModal>
      <Button
        onClick={() => setIsOpen(true)}
        className=""font-[poppins] fixed right-[calc(2.5rem+1vw)] bottom-[calc(3rem+1vh)] text-[calc(2rem+1vw)] rounded-full h-[calc(2.5rem+1vw)] w-[calc(2.5rem+1vw)]""
      >
        +
      </Button>
    </DialogModal>
```

[demo](https://aks-to-do.vercel.app/)

[dialog component code](https://github.com/Akshaypmna18/to-do/blob/main/src/components/dialogModal/DialogModal.jsx)

[add todo code](https://github.com/Akshaypmna18/to-do/blob/main/src/features/todos/addTodo/AddTodo.jsx)

[update todo code](https://github.com/Akshaypmna18/to-do/blob/main/src/features/todos/list/TodosEle.jsx)

[zustand store code](https://github.com/Akshaypmna18/to-do/blob/main/src/store.jsx)

[video for better understanding](https://drive.google.com/file/d/1KWMQ76oWjI_DZ4gjLrlbLDV7_dzKA2wb/view?usp=drive_link)

Use devices with a width below 640 pixels or adjust it in the browser.
</div>

[video after @dbritto-dev 's contribution ](https://drive.google.com/file/d/1pjYqV1RK2ci8soWlLOQ-QuxJlb3euQHf/view?usp=sharing)
",,
2148332732,2352,Re-render issue while performing open and setOpen using shadcn,"https://stackoverflow.com/questions/77826561/shadcn-reusuable-dialog-component-called-twice-renders-update-form-only

I have implemented a reusable dialog component using **Shadcn** in my todo app. However, I'm encountering an issue where the component is not working as needed. The add form and update form opens only after clicking twice. And when we click the pencil icon immediately after adding a todo it will pop add form instead of update form. I'm using **zustand** for state management.

Dialog Component

``` 
export default function DialogModal({ children, id, text }) {
  const { handleTodo, todo, setTodo, isOpen, setIsOpen } = useTodo(
    (state) => state
  );
  return (
    <Dialog open={isOpen} onOpenChange={() => setIsOpen()}>
      <DialogTrigger>{children}</DialogTrigger>
      <DialogContent className=""max-w-[400px]"">
        <DialogHeader>
          <DialogTitle className=""bold text-[calc(1.25rem+.5vw)]"">
            <big>{id ? ""Update Task"" : ""Add Task""}</big>
          </DialogTitle>
        </DialogHeader>
        <Input
          className=""font-[poppins]""
          placeholder=""Enter the task...""
          defaultValue={text}
          onChange={(e) => setTodo(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === ""Enter"") handleTodo(todo.trim(), id);
          }}
        />
        <DialogFooter>
          <Button
            className=""text-[calc(1rem+.5vw)] mx-auto w-[min(90%,10rem)]""
            onClick={() => handleTodo(todo.trim(), id)}
          >
            {id ? ""Update"" : ""Add""}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```
If I set 'setIsOpen(!isOpen)' the dialog component only shows the latest todo

update todo

```
     <DialogModal id={id} text={text}>
      <ToolTipComp Content={() => <ToolTipContent />}>
        <Pencil2Icon
          onClick={() => setIsOpen(true)}
          className=""min-h-[1.5rem] min-w-[1.5rem] cursor-pointer hover:text-rose-500""
        />
      </ToolTipComp>
    </DialogModal>
```

add todo

```
    <DialogModal>
      <Button
        onClick={() => setIsOpen(true)}
        className=""font-[poppins] fixed right-[calc(2.5rem+1vw)] bottom-[calc(3rem+1vh)] text-[calc(2rem+1vw)] rounded-full h-[calc(2.5rem+1vw)] w-[calc(2.5rem+1vw)]""
      >
        +
      </Button>
    </DialogModal>
```

[demo](https://aks-to-do.vercel.app/)

[dialog component code](https://github.com/Akshaypmna18/to-do/blob/main/src/components/dialogModal/DialogModal.jsx)

[add todo code](https://github.com/Akshaypmna18/to-do/blob/main/src/features/todos/addTodo/AddTodo.jsx)

[update todo code](https://github.com/Akshaypmna18/to-do/blob/main/src/features/todos/list/TodosEle.jsx)

[zustand store code](https://github.com/Akshaypmna18/to-do/blob/main/src/store.jsx)

[video for better understanding](https://drive.google.com/file/d/1KWMQ76oWjI_DZ4gjLrlbLDV7_dzKA2wb/view?usp=drive_link)

Use devices with a width below 640 pixels or adjust it in the browser.
",,
2146229118,2351,Can't use persist with context implementation mentioned in the docs for Next.js,"### Discussed in https://github.com/pmndrs/zustand/discussions/2350

<div type='discussions-op-text'>

<sup>Originally posted by **1Mouse** February 21, 2024</sup>
my code is the same as docs https://docs.pmnd.rs/zustand/guides/nextjs#app-router
I want to `prevent hydration errors when using persist middleware`

### store file
``` tsx 
import { devtools, persist } from ""zustand/middleware"";
import { createStore } from ""zustand/vanilla"";

export type MainStoreState = {
  selectedPropertyId: number | undefined;
  selectedBusinessOwnerId: number | undefined;
  selectedBusinessOwnerName: string | undefined;
};

export type MainStoreActions = {
  updateSelectedPropertyId: (id: number) => void;
  updateSelectedBusinessOwner: (id: number, name: string) => void;
};

export type MainStore = MainStoreState & MainStoreActions;

export const initMainStore = (): MainStoreState => {
  return {
    selectedPropertyId: undefined,
    selectedBusinessOwnerId: undefined,
    selectedBusinessOwnerName: undefined,
  };
};

export const defaultInitState: MainStoreState = {
  selectedPropertyId: undefined,
  selectedBusinessOwnerId: undefined,
  selectedBusinessOwnerName: undefined,
};

export const createMainStore = (
  initState: MainStoreState = defaultInitState
) => {
  return createStore<MainStore>()(
    devtools(
      persist(
        set =>
          ({
            ...initState,
            updateSelectedPropertyId: (id: number) => {
              set(state => ({ ...state, selectedPropertyId: id }));
            },
            updateSelectedBusinessOwner: (id: number, name: string) => {
              set(state => ({
                ...state,
                selectedBusinessOwnerId: id,
                selectedBusinessOwnerName: name,
              }));
            },
          }) satisfies MainStore,
        {
          name: ""main-store"", // name of the item in the storage (must be unique)
          skipHydration: true, // do not rehydrate this store after a full page load, we will rehydrate it manually
        }
      )
    )
  );
};
```

### provider file 
``` tsx
""use client"";

import { type ReactNode, createContext, useContext, useRef } from ""react"";

import { type StoreApi, useStore } from ""zustand"";

import {
  type MainStore,
  createMainStore,
  initMainStore,
} from ""@/stores/mainStore"";

export const MainStoreContext = createContext<StoreApi<MainStore> | null>(null);

export interface MainStoreProviderProps {
  children: ReactNode;
}

export const MainStoreProvider = ({ children }: MainStoreProviderProps) => {
  const storeRef = useRef<StoreApi<MainStore>>();
  if (!storeRef.current) {
    storeRef.current = createMainStore(initMainStore());
  }

  return (
    <MainStoreContext.Provider value={storeRef.current}>
      {children}
    </MainStoreContext.Provider>
  );
};

export const useMainStore = <T,>(selector: (store: MainStore) => T): T => {
  const mainStoreContext = useContext(MainStoreContext);

  if (!mainStoreContext) {
    throw new Error(`useMainStore must be use within MainStoreProvider`);
  }

  return useStore(mainStoreContext, selector);
};
```

### the docs say that we can use this hook for nextjs 
``` tsx
// useStore.ts
import { useState, useEffect } from 'react'

const useStore = <T, F>(
  store: (callback: (state: T) => unknown) => unknown,
  callback: (state: T) => F,
) => {
  const result = store(callback) as F
  const [data, setData] = useState<F>()

  useEffect(() => {
    setData(result)
  }, [result])

  return data
}

export default useStore 
```
but that hook doesn't work with array destructuring syntax 
``` tsx
const [
    selectedPropertyId,
    updateSelectedPropertyId,
    selectedBusinessOwnerId,
    selectedBusinessOwnerName,
    updateSelectedBusinessOwner,
  ] = useMainStore(state => [
    state.selectedPropertyId,
    state.updateSelectedPropertyId,
    state.selectedBusinessOwnerId,
    state.selectedBusinessOwnerName,
    state.updateSelectedBusinessOwner,
  ]);
```

### so I went to try the other solution with skipHydration: true 
### and manually hydrate at the subscribed component inside useEffect 
``` tsx
useEffect(() => {
    useMainStore.persist.rehydrate();
  }, []);
```

but I get this error Property 'persist' does not exist on type '<T>(selector: (store: MainStore) => T) => T'.ts(2339)</div>",,
2138066274,2341,should useShallow add into the documents?,"## Summary
I find this api in source code.But I don't found it in the documents

## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
2048188191,2260,shallow not support nested object,"## Bug
shallow not support nested object

## Minimum reproduction
```
import { shallow } from 'zustand/shallow'

const a = { a : {  b : 1 } }
const b = { a : {  b : 1 } }
shallow(a,b)         // ==>false , except true
```


## Details
```
  const keysA = Object.keys(objA)
  if (keysA.length !== Object.keys(objB).length) {
    return false
  }
  for (let i = 0; i < keysA.length; i++) {
    if (
      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||
      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])    // if objA[keysA[i] is not a simple type ,will return false
    ) {
      return false
    }
  }
```
",,
2017539691,2220,Is there any chance to simplify types?,https://github.com/pmndrs/zustand/blob/50a8677dba4acecc1e313dcb08d4cf2ac1ab918c/src/middleware/devtools.ts#L39,,
1998730912,2198,The app hanging when initializing the store with and array of objects.,"## Summary

Hello and thank you for the amazing work you are doing!
I am working on a RN project:

``` 
 ""dependencies"": {
    ""@types/react"": ""~18.2.14"",
    ""expo"": ""~49.0.13"",
    ""immer"": ""^10.0.3"",
    ""react"": ""18.2.0"",
    ""react-native"": ""0.72.6"",
    ""typescript"": ""^5.1.3"",
    ""zustand"": ""^4.4.2""
  },
  ""devDependencies"": {
    ""@babel/core"": ""^7.20.0""
  }
```


I have an issue with state initialisation when working with an array of objects.

If I initialise the array directly in the store the app keeps hanging in the splash screen and I don't get any error message.
This is a minimal code

```
import { create } from ""zustand"";
import { immer } from ""zustand/middleware/immer"";

export interface TaskModel 

interface TasksState {
  tasks: {
    id: string;
    name: string;
    energy: number;
    done: boolean;
    active: boolean;
  }[];
}

export const useTaskStore = create(
    immer<TasksState>(() => ({
      tasks: [
          {
            id: ""0"",
            name: ""Hi"",
            energy: 10,
            active: true,
            done: false,
          },
          {
            id: ""1"",
            name: ""Hello"",
            energy: 10,
            active: true,
            done: false,
          },
      ],
    }))
);
```

Usage in the page:

```
  const {tasks} = useTaskStore();

 <FlatList
      data={tasks}
      keyExtractor={(item) => item.id}
      renderItem={renderItem}
    />
```

### What I have tried?

I tried initializing the store when the first page is mounted and it's partially working as I can see the list but It creates another issue and the expo icons are not displayed anymore.
I feel like I am causing a crush somewhere but I am unable to get the logs!

I have tried working with Map and it's exactly the same behaviour.
I tried without immer but it's not the issue.

Do you know what can be the issue? I don't even have a clue what can cause this!
Thank you again for this amazing tool!

## Link to reproduction
It's a big app and a link to production would be hard to provide, sorry for that!


## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1981936029,2186,I can't update state with new data from Tanstack Query,"## Summary
Hey! Thank you for awesome library ❤️ 
I have a form. When I update the form, onSuccess returns the new updated data. I don't understand why my state isn't updating. I don't know why its not updating, because i have the same logic inside useEffect and it works


## Link to reproduction
```
updateStore(
  {
    id: store.id,
    ...data
  },
  {
    onSuccess: (data) => {
    // if i set store like this, not working
    setStore(data.response.ressult.store)
     
    // if i set store like this, works
    setStore({
        ...store,
        ...data,
      });

      Notice.Success(data.result.message);
    },
  }
);

```

**Store**
```
interface StoresState {
  store: IStore | null;
  setStore: (store: IStore | null) => void;
}

export const useStoresStore = create<StoresState>()(
  persist(
    (set) => ({
      store: null,
      setStore: (store) => set(() => ({ store })),
      clearStore: () => set({ store: null }),
    }),
    {
      name: ""stores-zsg"",
    }
  )
);

```



## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1977161145,2180,Reset store not working on log out,"## Summary

I use zustand for all my projects. This library helps me a lot keeping things simple , powerful. Thanks a lot for maintaining #Zustand

App is not resetting the store after calling clearStorage. If i provide timeout , things are working. I need to know if this is the right way to clear storage and reset the store. 

On log out i'm clearing the store and reloading the app. At first i thought store was not cleared because app didn't restart. So added RNRestart. but still things are not working. With timeout it works. 

Do i need to manually reset each slice , even after clearing the storage?


## Link to reproduction

```
  const onLogOut = async () => {
    RNQueryClient.clear();
    RNQueryClient.invalidateQueries();
    useCustomStore.persist.clearStorage();
    useCustomStore.persist.rehydrate();
    RNRestart.restart();
  };
```

If i add timeout then it works,

```
  const onLogOut = async () => {
    RNQueryClient.clear();
    RNQueryClient.invalidateQueries();
    useCustomStore.persist.clearStorage();
    setTimeout(() => {
      useCustomStore.persist.rehydrate();
      RNRestart.restart();
    }, 400);
  };
```

## Version
React Native : 
```
 ""zustand"": ""^4.4.4""
 ""react-native"": ""0.72.6"",
```",,
1974609337,2175,Type problem with persist,"## Summary
Code I've written for 4.4.4  which is working very fine,  gave typescript error on 4.4.5

argument of type 'StateCreator<useCartType, [], [[""zustand/persist"", useCartType]]>' is not assignable to parameter of type 'StateCreator<useCartType, [], [never, unknown][]>'. Type 'StateCreator<useCartType, [], [[""zustand/persist"", useCartType]]>' is not assignable to type '{ $$storeMutators?: [never, unknown][] | undefined; }'. Types of property '$$storeMutators' are incompatible. Type '[[""zustand/persist"", useCartType]] | undefined' is not assignable to type '[never, unknown][] | undefined'. Type '[[""zustand/persist"", useCartType]]' is not assignable to type '[never, unknown][]'. Type '[""zustand/persist"", useCartType]' is not assignable to type '[never, unknown]'. Type at position 0 in source is not compatible with type at position 0 in target. Type 'string' is not assignable to type 'never'.


## Link to reproduction

[https://github.com/nerkn/ecommerce-Frontend/blob/main/src/hooks/useCart.ts
](https://github.com/nerkn/ecommerce-Frontend/blob/main/src/hooks/useCart.ts)

## Check List
 
- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.
comment of  muammed

[https://stackoverflow.com/questions/77402109/zustand-and-typescript-persist-function-cannot-be-implemented](https://stackoverflow.com/questions/77402109/zustand-and-typescript-persist-function-cannot-be-implemented)

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.

",,
1969560518,2160,Is there a way to reset data when switching routes? The previous method cannot take effect#1192,"## Summary



## Link to reproduction



## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1966472444,2155,"The reactNode is stored in the store, sometimes causing the component to lose update.","## Summary
As shown in the figure, when I put the children into sotre, there seems to be a problem with the childen taken out, and I cannot use it under control. 


<img width=""633"" alt=""image"" src=""https://github.com/pmndrs/zustand/assets/124666577/701e157a-5756-4ead-9295-7a354fc5d31f"">

I have three questions
1. Items do not pass in pageProvider, but directly pass in tabs, then both switches work normally.  Is this a zustand problem?



## Link to reproduction
https://stackblitz.com/edit/react-r32udm-pvtuoe?file=PageLayout.tsx


## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1965267718,2153,"with immer midderware, Array type wrong","## an immer store, can't use Arrray.sort, but TS check escaped.





## [Link to reproduction](https://stackblitz.com/edit/stackblitz-starters-ebbhts?file=src/App.tsx)



## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1960375506,2145,Unnecessary Renders Triggered by a Hook after Migrating to Zustand,"## Subject: 
Unnecessary Renders Triggered by a Hook after Migrating to Zustand

## Description:
I'm currently in the process of migrating from Redux to Zustand, and I'm facing an issue with a specific hook that triggers unnecessary renders. To ensure a smoother transition and optimize performance, I'm seeking guidance on how to migrate this hook while avoiding the problem of unnecessary renders.


## Hooks before migration

```
import { createSelector } from '@reduxjs/toolkit';
import { stateSelector } from 'app/store/store';
import { useAppSelector } from 'app/store/storeHooks';
import { defaultSelectorOptions } from 'app/store/util/defaultMemoizeOptions';
import { useMemo } from 'react';


export const useNames = (nodeId: string) => {
  const selector = useMemo(
    () =>
      createSelector(
        stateSelector,
        ({ state }) => {
          // This has undergone complex calculations and relevant omissions have been made for code safety
          return 11
        },
        defaultSelectorOptions
      ),
    [nodeId]
  );

  const names = useAppSelector(selector);

  return names;
};


```
```
// app/store/util/defaultMemoizeOptions.ts

import { isEqual } from 'lodash-es';

export const defaultSelectorOptions = {
  memoizeOptions: {
    resultEqualityCheck: isEqual,
  },
};
```

## Results after migration

```
import { useMemo } from 'react'
import useFlowStore from '@/store/flow/useFlow'

export const useNames = (nodeId: string) => {
  const nodes=useFlowStore(state=>state.nodes)
  const nodeTemplates=useFlowStore(state=>state.nodeTemplates)

  const names = useMemo(() => {
     // This has undergone complex calculations and relevant omissions have been made for code safety
      //  Used nodeTemplates and nodes
     return 11
  }, [nodeId, nodeTemplates, nodes])
  return names
}

```


",,
1945238141,2123,123e,"## Summary



## Link to reproduction



## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1941033609,2116,Resetting Multiple Stores Example Doesn't Work with the Currying Required Elsewhere for Typescript Support,"Something is wrong with the documentation on how to reset all stores with respect to the currying needed for Typescript support:

https://docs.pmnd.rs/zustand/guides/how-to-reset-state

As is my existing code that has the extra currying () doesn't create the store properly using the example create() function. I was able to get around it by rewriting my code to not curry in my stores and to replicate the currying inside the custom create, which is actually probably better in my case because now I'm enforcing that my stores use persist and that they implement a reset function, but probably loses the extensibility desired by the example:

```
export const createPersistingStore = <T extends ResettableState>(
  f: StateCreator<T, [], [['zustand/persist', unknown]]>
) => {
  const store = _create<T>()(f);
  resetters.push(() => {
    store.getState().reset();
  });
  return store;
};
```",,
1939129730,2113,"When the set operation is executed in the 「then callback」, the 「set operation」 takes nearly a hundred times longer.","## When the set operation is executed in the 「then callback」, the「set operation」 takes nearly a hundred times longer.
In a new umi framework，Add a button to the page and add a handle to the button to test the time consumption of the 「set operation」.

### Print time-consuming code(Store)
```TypeScript
import {create} from ""zustand"";
export const useStore = create<any>()((set, get) => ({
  loading: false, 
  setLoading: (loading: boolean) => {
    console.time('time--set')
    set({ loading })
    console.timeEnd('time--set')
  },
}))
```

### UI code
```TSX
return (
  <div>
    <div>{String(loading)}</div>
    <Button type=""primary"" onClick={testSetHandle}>setLoading</Button>
  </div>
);
```

### Experiment 1
Handle code：
```TypeScript
const testSetHandle = useCallback(async () => {
  setLoading(!loading)
}, [loading])
```
Time consuming printing：
![set0](https://github.com/pmndrs/zustand/assets/42869166/027ce227-9f31-4655-afe4-aa911708bb6d)

### Experiment 2
Handle code：
```TypeScript
const testSetHandle = useCallback(async () => {
  await sleep(3000);
  console.log('sleep 3000')
  setLoading(!loading)
}, [loading])
```
Time consuming printing：
![set1](https://github.com/pmndrs/zustand/assets/42869166/2e697f8c-cff1-41f8-ac92-92e19f14ff12)


### Experiment 3
Handle code：
```TypeScript
const testSetHandle = useCallback(async () => {
  await sleep(3000);
  console.log('sleep 3000')
  await sleep(2000);
  console.log('sleep 2000')
  setLoading(!loading)
}, [loading])
```
Time consuming printing：
![set2](https://github.com/pmndrs/zustand/assets/42869166/8ce28fbb-9c53-4f57-bf2d-21e9c86de92f)


### Experiment 4
Handle code：
```TypeScript
const testSetHandle = useCallback(async () => {
  await sleep(3000);
  console.log('sleep 3000')
  await sleep(2000);
  console.log('sleep 2000')
  await sleep(1000);
  console.log('sleep 1000')
  setLoading(!loading)
}, [loading])
```
Time consuming printing：
![set3](https://github.com/pmndrs/zustand/assets/42869166/0a106ec1-71e9-4cbe-bdac-2f82230b8e47)


### Experiment 5
Handle code：
```TypeScript
const testSetHandle = useCallback(async () => {
  await sleep(3000);
  console.log('sleep 3000')
  await sleep(2000);
  console.log('sleep 2000')
  await sleep(1000);
  console.log('sleep 1000')
  await sleep(2000);
  console.log('sleep 2000')
  setLoading(!loading)
}, [loading])
```
Time consuming printing：
![set4](https://github.com/pmndrs/zustand/assets/42869166/8bbc1c15-f82c-456e-9138-e689911e3b9f)


### Conclusions and conjectures
If there is an await statement before the set operation, the set operation will take longer. And the more awaits, the more time it takes. From experiments, we can find that there seems to be a threshold for the number of awaits. In the example, if there are more than 2 awaits, the time consumption will jump directly to 30ms.In our actual project, due to factors such as store size, a simple set operation will take 200+ms. The essence of await is the syntactic sugar of 「.then callback」, so it is reasonable to speculate that it is related to the number of nesting of 「.then」.Please suggest some solutions, thank you very much

## Link to reproduction
The code is relatively simple to reproduce，code repository is no longer provided


## Check List

Please do not ask questions in issues.

- [X] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions/2019) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [X] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1926750393,2101,devtools.d.ts node_modules/zustand/middleware/devtools.d.ts:33:42 - error TS2312: An interface can only extend an object type or intersection of object types with statically known members.,"## Summary

A change between zustand 4.4.1 and zustand 4.4.2 seem to broke something in `middleware/devtools.d.ts` 👀 

> node_modules/zustand/middleware/devtools.d.ts:33:42 - error TS2312: An interface can only extend an object type or intersection of object types with statically known members.

```bash
npm run build
```
```
> vite-zustand-config-issue@0.0.0 build
> tsc && vite build

node_modules/zustand/esm/middleware/devtools.d.ts:33:42 - error TS2312: An interface can only extend an object type or intersection of object types with statically known members.

33 export interface DevtoolsOptions extends Config {
                                            ~~~~~~


Found 1 error in node_modules/zustand/esm/middleware/devtools.d.ts:33
```

## Link to reproduction

Project that reproduces issue:

https://github.com/GabLeRoux/vite-zustand-config-issue
There is a github action that builds the project. You can see it's failing on the `main` branch.

I've created a PR on that same project that demonstrate that this issue doesn't happen when freezing the version to 4.4.1:
https://github.com/GabLeRoux/vite-zustand-config-issue/pull/1

## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1923425996,2096,Error: Can't resolve 'react' in '[...]/node_modules/zustand/esm',"## Summary

Since 4.4.2 I am getting unexpected build failures in an application that has `zustand` only as a subdependency:

```
./node_modules/zustand/esm/shallow.mjs:1:0-31 - Error: Module not found: Error: Can't resolve 'react' in '/home/runner/work/juice-shop/juice-shop/frontend/node_modules/zustand/esm'
```

## Link to reproduction

As I am not using `zustand` directly, I unfortunately can't deliver one. But adding `zustand` to my direct dependencies as `""zustand"": ""4.4.1""` solves the build issue.

* Sample failing build: https://github.com/juice-shop/juice-shop/actions/runs/6386342437
* Passing build after adding direct dependency on pinned 4.4.1: https://github.com/juice-shop/juice-shop/actions/runs/6389517851",,
1908794949,2073,"during the delay it does not change the state, it waits until the requests are all finished, then it returns","## Summary

package version:

""next"": ""13.2.1"",
""react"": ""18.2.0"",
""zustand"": ""4.4.1"",
""react-dom"": ""18.2.0"",

const useStore = create((set, get) => ({
 todos: [],
 loading: false,
 error: null,
 fetchTodos: async () => {
   set({ loading: true })
   try {
     const response = await fetch(SERVER_URI)
     if (!response.ok) throw response
     set({ todos: await response.json() })
   } catch (e) {
     let error = e
     // custom error
     if (e.status === 400) {
       error = await e.json()
     }
     set({ error })
   } finally {
     set({ loading: false })
   }
 }
}))

after going to the page through the spa the state { loading: true } does not change and immediately shows { loading: false }
actions is called in getInitialProps (to the server)
",,
1904287513,2066,Usage of  Updating multiple stores,"## Summary
Hello，I tried to use the Slices pattern following the documentation

![image](https://github.com/pmndrs/zustand/assets/129132865/f78ab335-530f-41ac-bfe4-b453d012359f)
Updating multiple stores seems inconsistent with actual usage

i found a way from [#2045](https://github.com/pmndrs/zustand/discussions/2045)

It seems that using get() is correct?

## Link to reproduction
[https://codesandbox.io/s/recursing-proskuriakova-qmyz2n?file=/store/zustand.ts](https://codesandbox.io/s/recursing-proskuriakova-qmyz2n?file=/store/zustand.ts)
",,
1903706745,2063,Typescript issue when using createStore + persist,"## Summary
Issue happens when **vanilla** store is used with **persist** middleware and inside state we have **boolean** values. At `createStore` call typescript throws an error `Type 'boolean' is not assignable to type 'false'` when we provide initial state. If value is any other type than boolean- no error happens
![image](https://github.com/pmndrs/zustand/assets/16834152/089b028c-8612-4471-ad1f-d2252821d1e9)


## Link to reproduction
https://codesandbox.io/s/laughing-mclaren-84v8tw?file=/src/index.ts
",,
1890233044,2044,"Slices patterns, access multiple slices: data cannot be accessed ","## Summary

Using your multiple slices pattern, I tried to add a slice which acts on other slices, as in your docs:
https://docs.pmnd.rs/zustand/guides/slices-pattern#updating-multiple-stores
When I want to create a function acting on data in the slices then the default values are returned instead of the actual data.
Accessing the functions in the slices (as in your example) works fine, but how to access the data?
Also tried to add a `get` parameter when creating the slices according to
https://docs.pmnd.rs/zustand/recipes/recipes#read-from-state-in-actions
but this did not work for slices, they do not seem to get the `get` parameter.

## Link to reproduction

https://codesandbox.io/s/silly-tamas-2rp6gx?file=/src/store/index.ts

Reset works, but Calc sum always displays 0.

## Check List

Please do not ask questions in issues.

- [ x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1864718378,2005,Unit tests documentation needed to add example，TypeError: getSnapshot is not a function,"## Summary
In the docs on how to write unit tests，An example is the create method
https://docs.pmnd.rs/zustand/guides/testing
I used createStore, useStore in my project，and made a simple modification to the example, but it didn't work, and an error was reported when executing the unit test
TypeError: getSnapshot is not a function
Modified mock code
```
import * as zustand from 'zustand'
import { act } from '@testing-library/react'
import { vi } from 'vitest'

const { createStore: actualCreate, useStore } = await vi.importActual<typeof zustand>('zustand')

// a variable to hold reset functions for all stores declared in the app
export const storeResetFns = new Set<() => void>()

// when creating a store, we get its initial state, create a reset function and add it in the set
export const createStore = (<T extends unknown>() => {
  return (stateCreator: zustand.StateCreator<T>) => {
    console.log('stateCreator', stateCreator)
    const store = actualCreate(stateCreator)
    console.log('store', store)
    const initialState = store.getState()
    storeResetFns.add(() => {
      store.setState(initialState, true)
    })
    return store
  }
}) as typeof zustand.createStore

// reset all stores after each test run
afterEach(() => {
  act(() => {
    storeResetFns.forEach(resetFn => {
      resetFn()
    })
  })
})
export { useStore }
```
Create store code
```
import { createStore, useStore } from 'zustand'

const createMyStore = (state: typeof intialState = intialState) => {
  return createStore<AppState, [['zustand/devtools', never], ['zustand/immer', never], ['zustand/persist', AppState]]>(
    devtools(
      immer(
        persist(
          (set, get) => ({
            ...state,
            increase: () =>
              set(state => {
                state.counter++
              }),

          }),
          { name: 'xxx', partialize: state => ({ ...state, error: '' }) }
        )
      )
    )
  )
}
const MyStoreContext = createContext<ReturnType<typeof createMyStore> | null>(null)

export const AppStoreProvider: FC<{ children: React.ReactNode; data?: typeof intialState }> = ({ children, data }) => {
  const store = createMyStore(data || intialState)
  // console.log('===========', store)

  return <MyStoreContext.Provider value={store}>{children}</MyStoreContext.Provider>
}

export function useAppStore(): AppState
export function useAppStore<T>(selector: (store: AppState) => T, equalityFn?: (left: T, right: T) => boolean): T
export function useAppStore<T>(selector?: (store: AppState) => T, equalityFn?: (left: T, right: T) => boolean) {
  const store = useContext(MyStoreContext)

  if (!store) {
    throw new Error('MyStoreContext is not provided !')
  }
  //eslint-disable-next-line  @typescript-eslint/no-explicit-any
  return useStore(store, selector as any, equalityFn)
}

```
When using createStore, useStore, how is the mock code written?

## Link to reproduction



## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1847514315,1989,Performance Disruption: Lag Caused by 'set' Method Impacts User Experience,"## Summary
When I use the `set` method in React, it causes significant lag, which can be quite disruptive to the user experience. This delay hampers the overall responsiveness of the application and can lead to frustration for users who expect smooth and seamless interactions. The noticeable slowdown in performance can potentially deter users from engaging with the application and may even impact its usability in critical scenarios. Therefore, addressing this lag issue with the set method is essential to ensure a satisfactory and efficient user experience.
## Link to reproduction

[57665bb2-e3a4-423a-a78e-1dd0e8c3ec34.webm](https://github.com/pmndrs/zustand/assets/76555623/1fc962ea-6df8-4d7b-a40f-b69f912595aa)


## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1786314243,1914,I have problems with selecting data from store,"So i read https://docs.pmnd.rs/zustand/recipes/recipes#selecting-multiple-state-slices

package.json
```
""next"": ""^13.4.7"",
""ramda"": ""^0.28.0"",
""react"": ""18.2.0"",
""zustand"": ""^4.3.6""
```

nodejs 16.18.1

I have store something like
``` typescript
type TList = { [key: string]: { id: string; name: string; } }
type TItem = { [key: string]: { id: string; data: string[]; someField: any; listId: string; } }

type TStore = {
  list: TList;
  item: TItem;
  something: any;
}

const store = create<TStore>()({
  list: {},
  item: {},
  something: null,
})
```

I made custom hook, like
``` typescript
const useGetSomething = () => {
  const {
    list,
    item,
  } = useStore(state => ({
    list: state.list,
    item: state.item,
  }))
  
  // other operations with list and item
  
  return someObject
}
```
With that example i will get rerender in my component that using useGetSomething() when someone updates any attributes in store.
So i added **shallow**, but it didnt work for some reasons.
``` typescript
const {
  list,
  item,
} = useStore(state => ({
  list: state.list,
  item: state.item,
}), shallow)
```
I still dont get any rerender in my component.

I was trying to use:
``` typescript
const list = useStore(state => state.list)
const item = useStore(state => state.item)
```
And this:
``` typescript
const item = useStore(state => state.item, (a, b) => equals(a, b))
```
I getting always true when comparing a and b
I even was tried `JSON.stringify(a) === JSON.stringify(b)` for comparing 

And this:
``` typescript
const item = useStore(state => state.item, () => false)
```
Still no result => rerender when data is changed.
Wanted result get component rerender on list and item updates only.

I'm doing something wrong?",,
1782516866,1910,Web Storage API & Safari,"## Summary
Using the [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API) for persisting storage (specifically for browser extensions), @andyhails and I discovered that there is a bug in `createJSONStorage` for Safari that causes it to stringify and persist store functions (e.g. `foo()`) as objects (e.g. `foo: {}`).

This does not exist as an issue for Firefox, Chrome, or other Chromium browsers.

We found this bug to be extremely inconsistent between builds for Safari through xCode and throughout runtime, however, did find a fix through a custom `createJSONStorage`.

## Proposal
Filter functions out from being in the persisted store. Zustand handles this just fine, combining the persisted store of strings, booleans, and objects with the non-persisted store which includes those functions no longer being persisted.

`createJSONStorage.ts`
```ts
import { PersistStorage, StateStorage, StorageValue } from 'zustand/middleware';
import { StoreState } from '@/store/index';

/**
 * createJSONStorage - our own version of zustand's createLocalStorage middleware.
 *
 * There is a bug in zustand's createLocalStorage middleware for Safari that causes it to stringify and
 * persist StateStore functions (e.g. foo()) as objects (e.g. foo: {}).
 *
 * Overriding the createJSONStorage middleware with our own version that filters out functions from the state
 * mitigates this issue.
 */

/**
 * Parses a string into a StorageValue.
 * @param str
 */
const parse = (str: string | null): StorageValue<StoreState> => (str ? JSON.parse(str) : null);

/**
 * Filters out properties that cannot be persisted to storage (e.g. functions).
 * This is usually handled by the browser well but for some reason in Safari there are side effects.
 *
 * @param state
 */
const statePropertiesOnly = (state: StoreState) =>
  Object.fromEntries(
    Object.entries(state)
      .filter(([_, value]) => typeof value !== 'function'),
  );

export default (getStorage: () => StateStorage): PersistStorage<StoreState> => ({
  getItem: name => {
    const item = getStorage().getItem(name);
    return item instanceof Promise ? item.then(parse) : parse(item);
  },
  setItem: (name, newValue: StorageValue<StoreState>) =>
    getStorage().setItem(name, JSON.stringify(statePropertiesOnly(newValue.state))),
  removeItem: name => getStorage().removeItem(name),
});
```",,
1765255658,1884,get []  sometimes,"```jsx
import dayjs from 'dayjs'
import { create } from 'zustand'
import { StateStorage, createJSONStorage, persist } from 'zustand/middleware'

type State = {
  pinned: boolean
  sortOrder: string[]
  date_range: string[]
  gameId: string
}

type Actions = {
  setAppStore: (newState: Partial<State>) => void
}

// define the initial state
const initialState: State = {
  pinned: false,
  sortOrder: ['days7', 'week', 'month', 'day', 'hour', 'cost_money', 'install'],
}

export const useAppStore = create<State & Actions>()(
  persist(
    (set) => ({
      ...initialState,
      setAppStore: (newState) => {
        return set(newState)
      }, 
    }),
    {
      name: 'zustand-appstore', // name of the item in the storage (must be unique)
      storage: createJSONStorage(() => localStorage), // (optional) by default, 'localStorage' is used
    }
  )
)

```

Page.tsx
```jsx
  const appStoreSortOrder = useAppStore((state) => state.sortOrder)
console.log(appStoreSortOrder) //  sometimes is []

```",,
1762671024,1878,[persist] custom Localstorage with expiry is not work,"https://codesandbox.io/s/zustand-state-with-url-hash-demo-forked-5q6gfq?file=/src/store/index.ts


Set the expiration time to 2 milliseconds, but get count after 2ms, the same value as before",,
1740470104,1835,Call custom function into store method,"## Summary

I have a `useAlert` hook that returns a `show` function.

## Link to reproduction

```jsx
// Component.tsx
const Component = ()=>{
  const { show } = useAlert();
  const { updateAction } = useStore();

  ....
}

// store.ts
const useStore = create<MyType>((set, get) => ({
  updateAction: async()=>{
     const result = await fetch(...);
     show(""My success message""); 
 }
}));
```
How can I call the show function inside my store? I have tried in a thousand ways but I have not been able to.",,
1728350552,1828,Values from Maps won't be persisted on react-native (AsyncStorage),"```
export const useDocumentState = create(
  persist(
    immer((set, get) => ({
      // DOCUMENT STATES

      state1: new Map([
        [""88"", ""value1""],
        [""89"", ""value2""],
      ]),
      state2: ""hello"",
   

      initAll: () => {
        const newStates = new Map([
          [""88"", ""value1""],
          [""89"", ""value2""],
        ])

        console.log(newStates.has(""88"")) 

        return set({
            state1: newStates,
            state2: ""world"",
	 })
      },

    })),
    {
      name: ""@DOCUMENT_STATES"",
      storage: createJSONStorage(() => AsyncStorage),
    },
  ),
)
```

## Summary
I found a bug where values which are stored in a Map, won't persist using AsyncStorage on react-native.
In an example, I'm calling the initAll function, which stores two values state1 and state2.

When I restart the app, I can successfully retrieve the the new value from state2 (String), whereas state1 appears to be an empty Object / and not even a Map:

 ""state1"": {}


This also leads to a crash when calling newStates.has(""88""):
 TypeError: iterator method is not callable


https://github.com/pmndrs/zustand/pull/1763 doesn't seem to fix it for me.
",,
1708526278,1806,UseBoundStore / WithReact TS error,"Summary
I'm getting this TS error when attempting to type our store 
""Type 'StoreApi<ShopState>' does not satisfy the constraint 'WithReact<StoreApi<object>>'.
  Type 'StoreApi<ShopState>' is not assignable to type 'StoreApi<object>'.
    Type '{}' is missing the following properties from type 'ShopState': order, setOrder""

```js
import create, { StoreApi, UseBoundStore } from 'zustand';
import { persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

interface ShopState {
  order: number;
  setOrder: (order: number) => void;
}

export interface Market {
  id: number;
  currencyPair: string;
}

const markets: { [keyof: number]: UseBoundStore<StoreApi<ShopState>> } = {};
const useMarketStore = (market: Market) => {
  if (!markets[market.id]) {
    const ms = create<ShopState>()(
      immer((set, get) => ({
        order: 0, // set default value for order
        setOrder: (order: number) => {
          set((state) => {
            state.order = order;
          });
        },
      }))
    );
    markets[market.id] = ms;
  }

  return markets[market.id];
};
```
This very much seems like a typing issue, or an issue with versioning. I just can't figure it out. 

## Repro
https://codesandbox.io/s/zen-sound-qjemzy?file=/src/App.tsx

## Check List

Please do not ask questions in issues.

- [x ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1706782303,1801,Next js 13 Server/Client Error for ClassName,"Hello, I am using zustand for the first time. I get an error when defining a class according to the value I get from the state.

**state.tsx;**

```
import { create } from ""zustand"";

type AppActions = {
  setSidebar: (payload: any) => void
}

const initialStates = {
  sidebar: typeof localStorage !== ""undefined"" ? !!localStorage.getItem('sidebar-folded') : false,
  sidebarMenu: false,
}

export type AppState = typeof initialStates;

const useAppStore = create<AppState & AppActions>((set) => ({
  ...initialStates,
  setSidebar: (payload: any) => set((state) => ({ sidebar: payload }))
}));

export default useAppStore;
```

**sidebar-component;**

```
import useAppStore from ""@/store/useAppStore"";

export default function Sidebar() {
  const sidebar = useAppStore(state => state.sidebar);
  const sidebarMenu = useAppStore(state => state.sidebarMenu);
  const isMobile = useMediaQuery('(max-width: 1200px');

  return (
    <aside className={`${styles.sidebar_wrapper} ${sidebar && !isMobile ? 'app-sidebar folded' : 'app-sidebar'}`}>
      <div className=""app-sidebar-row app-sidebar-header"">
        <Brand />
      </div>
      <div className=""app-sidebar-row app-sidebar-body"">
      <ScrollArea className=""scroll-bar"" scrollbarSize={6}>
        <SidebarMenu />
      </ScrollArea>
      </div>
      <div className=""app-sidebar-row app-sidebar-footer"">
        
      </div>
    </aside>
  )
}
```

**Warning: Prop `className` did not match. Server: ""sidebar_sidebar_wrapper__0TzWU app-sidebar"" Client: ""sidebar_sidebar_wrapper__0TzWU app-sidebar folded""**

![Screen Shot 2023-05-12 at 04 20 55](https://github.com/pmndrs/zustand/assets/5020002/5c0adb75-56b3-45ff-ace1-a4b53e86ec06)

I tried with-zustand in the next js examples but I still had the same problem.
",,
1689594128,1784,Replace flag resulting in setValue is not a function,"## Summary
First of all thank you for this library.
I have persisted state with replace hook to clear the state. Once clearState function is called, the setValue (or any other function from store) is resulting in `not a function` error.
Versions: 
 -  ""next"": ""13.3.1"",
 - ""zustand"": ""^4.3.7""


## Link to reproduction
https://github.com/Badhan-abhishek/zustand-repro


## Check List

Please do not ask questions in issues.

- [X] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [X] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. 

  - Note sure if github counts

Please check this if you're filing an issue regarding TypeScript.

- [] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1686642160,1778,"Type-issue using ""set"" in a custom TypeScript middleware","## Summary

I'm trying to create a middleware using TypeScript to automate some tasks. I'm facing a **type-only** issue when using `set({ ... })` inside the middleware. 
The problem seems related to TS not able to infer the type of the `set()` argument. 

In the [CodeSandbox](https://codesandbox.io/s/relaxed-hellman-ih8qs9?file=/src/store.ts:1116-1176) you can see that i can't use `set({ bears: nextState.bears });` or `set({ bears: 2 });` because TS complains with:

```
Argument of type '{ bears: T[""bears""] | undefined; }' is not assignable to parameter of type 'T | Partial<T> | ((state: T) => T | Partial<T>)'.
//
Argument of type '{ bears: 2; }' is not assignable to parameter of type 'T | Partial<T> | ((state: T) => T | Partial<T>)'.
```

I don't understand _why_ `{ bears: <number> }` is not assignable so maybe something that can be improved in the Zustand type-system?

**Note:** `exactOptionalPropertyTypes` is [enabled in the CodeSandbox](https://codesandbox.io/s/relaxed-hellman-ih8qs9?file=/tsconfig.json:129-173).


Might be related to:
 
  - https://github.com/pmndrs/zustand/issues/1723
  - https://github.com/pmndrs/zustand/discussions/1770#discussioncomment-5726475

Thank you so much for this library 🙌 

## Link to reproduction

See the [store.ts in this CodeSandbox](https://codesandbox.io/s/relaxed-hellman-ih8qs9?file=/src/store.ts:1116-1153)

## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [codesandbox](https://codesandbox.io/s/relaxed-hellman-ih8qs9?file=/src/store.ts:1116-1153) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1649439446,1726,Using Suspense alongside Zustand crashes the app,"## Summary

Hi Folks, I'm running into a problem when using Zustand parallel with React Suspense in a NextJS app.

### Minimal Example:

```javascript
import { Suspense, useEffect } from 'react';
import { create } from 'zustand';

const useMyStore = create(() => {
  return { count: 420 };
});

export default function SuspenseAndZustand() {
  const store = useMyStore();

  useEffect(() => {
    // only crashes when setting the state here
    useMyStore.setState({ count: 9000 });
  }, []);

  return (
    <div>
      <p>store count: {store.count}</p>
      {/* works as expected when removing the suspense block */}
      <Suspense>Crash.</Suspense>
    </div>
  );
}
```

This causes the app to crash with:

```
Unhandled Runtime Error
Error: This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition.
```

When removing the (unrelated) suspense block, everything works as expected.

",,
1648958627,1723,`set` type is too lax and allow setting invalid state,"## Summary
Hi, first of all big thanks for all the hard work put into creating this library!

TBH I'm not sure if this should be considered a bug. I guess it's a design decision, but because of it, it is possible to set state that does not match types defined with typescript.

The cause of the problem is the ability to pass partial state to `set`. Lets consider types below:
```
type A = {
  type: ""a"";
};

type B = {
  type: ""b"";
  prop: string;
};

type State = A | B;
```
When transitioning from `A` to `B` it's possible to do `set({type: 'b'})`. This will lead to invalid state since we did not define `prop`. Unfortunately typescript will not catch that since it tests for `Partial<A | B>`.


## Link to reproduction
https://codesandbox.io/s/charming-nobel-6gqez5?file=/src/App.tsx


## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1637230846,1710,TypeError: store.getState is not a function,"## Summary
Hello,

I am following [this guide](https://docs.pmnd.rs/zustand/guides/testing) in order to achieve resetting state between my tests.

My project is in React Native and I am using jest for testing.

Unfortunately, it is not clear in the docs how should I use the store created in `zustand.ts` file in `__mocks__` folder. I suppose that just by adding it, it will work automatically. Is this correct?

The code of `zustand.ts` file is this:
```
// eslint-disable-next-line import/no-extraneous-dependencies
import { act } from '@testing-library/react-native';
import { StateCreator } from 'zustand';

const { create: actualCreate } = jest.requireActual('zustand');

// a variable to hold reset functions for all stores declared in the app
const storeResetFns = new Set<() => void>();

// when creating a store, we get its initial state, create a reset function and add it in the set
export const create = <S>(createState: StateCreator<S>) => {
  const store = actualCreate(createState);
  const initialState = store.getState();
  storeResetFns.add(() => store.setState(initialState, true));
  return store;
};

// Reset all stores after each test run
beforeEach(async () => {
  await act(() =>
    storeResetFns.forEach(resetFn => {
      resetFn();
    })
  );
});

```

I get this error: TypeError: store.getState is not a function

<img width=""573"" alt=""Screenshot 2023-03-23 at 12 04 14 PM"" src=""https://user-images.githubusercontent.com/15989223/227170160-92f7e363-c0bd-49e2-b35d-a2805abedcc3.png"">

My store and tests setup is like this:

```
type State = {
  passengers: number;
  actions: {
    addPassenger: () => void;
    removePassenger: () => void;
  };
};

export const useStore = create<State>()(set => ({
  passengers: 1,
  actions: {
    addPassenger: () => set(state => ({ passengers: state.passengers + 1 })),
    removePassenger: () => set(state => ({ passengers: state.passengers - 1 }))
  }
}));

export const usePassengers = () => useStore(state => state.passengers);

// ... and then in my test file

test('1 passenger has been added as a default selection', () => {
  const { result } = renderHook(() => usePassengers());

  expect(result.current).toBe(1);
});


```

I also looked at [previous issues](https://github.com/pmndrs/zustand/issues?q=is%3Aissue+TypeError%3A+store.getState+is+not+a+function+is%3Aclosed), but there is not any obvious solution to this.

Based on [this proposal](https://github.com/pmndrs/zustand/issues/271), alternatively I have to do a manual reset for each one of the test files I write, which is not ideal.

Is there any idea how I can fix this type error?



## Link to reproduction


## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1633170357,1705,"""import.meta"" is not available in the configured target environment (""es2017"") and will be empty","## Summary

When I build my assets I see a dozen of these warnings:

`▲ [WARNING] ""import.meta"" is not available in the configured target environment (""es2017"") and will be empty`



## Link to reproduction



## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1625347393,1693,How to use derived/computed state?,"I'm fairly new to Zustand and really loving it so far, but I've come to a grinding halt when I try to figure out how to derive state. I've set up a really simple example here: https://codesandbox.io/s/cool-volhard-z2c1jh?file=/src/App.js

This is the store
```js
export const useStore = create((set) => ({
  people: [
    {
      name: ""James"",
      age: 23
    },
    {
      name: ""Paul"",
      age: 18
    },
    {
      name: ""Brian"",
      age: 50
    },
    {
      name: ""Aaron"",
      age: 20
    }
  ]
}));
```

What I'm trying to achieve is to have the store map over the ```people``` and display that in two lists, one unordered and one ordered by age. The problem is that when I try to sort the ordered array, it sorts the state as a whole and turns both lists into ordered ones.

What I want to achieve is this:
![image](https://user-images.githubusercontent.com/48878155/225296934-8924854f-4793-4f4f-90c1-43bec76aa204.png)

But, like I said, when I sort the array I get this (the state itself sorts and modifies both):
![image](https://user-images.githubusercontent.com/48878155/225297085-a6c7fc4f-0890-4af3-b573-7929cbb2f79a.png)

If anybody can help with this problem I will be very grateful. Thank you 😊
",,
1624187839,1691,The argument passed to `onRehydrateStorage` and `onHydrate` is always `undefined` during first hydration,"## Summary

The argument passed to `onRehydrateStorage` and `onHydrate`, which is [supposed to be `state: S`](https://github.com/pmndrs/zustand/blob/962f83e01599257aa6eceaaa993965a0e296d359/src/middleware/persist.ts#L105) (where `S` is the state type), is always `undefined` **during the first hydration**. This occurs for both the old and new persist implementations using either synchronous or asynchronous storage APIs.

The reason this happens is that calling `get()` within the first few lines of `hydrate` always returns the initial value of `state`, declared in the `createStoreImpl` function, which is `undefined`. It will always be `undefined` in this case because the store's `state` value doesn't get updated until [`createState` returns](https://github.com/pmndrs/zustand/blob/962f83e01599257aa6eceaaa993965a0e296d359/src/vanilla.ts#L101), which is _after_ the `persist` middleware (and `hydrate` function) returns.

There are two potential fixes for this:
1. Update the argument passed to `onRehydrateStorage` and `onHydrate` to be `get() ?? configResult`, so these callbacks have the latest _available_ state passed to them.
2. Change the type signatures of `onRehydrateStorage` and `onHydrate` to reflect that the `state` argument can be `undefined`.

I've opened a PR which implements the first approach, but please let me know if approach 2 (or some other resolution) is better.

## Link to reproduction

https://codesandbox.io/s/zustand-4-3-x-bug-forked-j8hqh5?file=/src/App.js

## Check List

Please do not ask questions in issues.

> N/A - The issue is reproducible and I've opened a PR to fix it.

- [X] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [X] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [X] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1623764710,1690,Zustand,"## Summary



## Link to reproduction



## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.",,
1622778683,1688,State updates within the 'onRehydrateStorage' callback using a synchronous storage API get dropped,"## Summary

Updating a store's state within the `onRehydrateStorage` callback when using a synchronous storage API results in the state update getting overwritten by the persisted state. The overwritten state update will still get persisted, however, resulting in a scenario where (1) the update failed to be applied to the current in-memory store and (2) the in-memory state and the persisted state do not match.

This issue is caused by [the return value of `createState`](https://github.com/pmndrs/zustand/blob/962f83e01599257aa6eceaaa993965a0e296d359/src/vanilla.ts#L101) (which in the synchronous case is [`stateFromStorage`](https://github.com/pmndrs/zustand/blob/962f83e01599257aa6eceaaa993965a0e296d359/src/middleware/persist.ts#L347)) overwriting [state updates within the 'onRehydrateStorage' hook](https://github.com/pmndrs/zustand/blob/962f83e01599257aa6eceaaa993965a0e296d359/src/middleware/persist.ts#L303). The in-callback updates do _initially_ update the current state (and get persisted) via [`set` and `setItem`](https://github.com/pmndrs/zustand/blob/962f83e01599257aa6eceaaa993965a0e296d359/src/middleware/persist.ts#L398-L399), but they then get lost because [`stateFromStorage` is never updated to reflect those changes](https://github.com/pmndrs/zustand/blob/962f83e01599257aa6eceaaa993965a0e296d359/src/middleware/persist.ts#L294-L306).

This doesn't occur in the asynchronous case because the `createState` function immediately returns, setting the initial state to `undefined`. Then, when the hydration promises resolve during subsequent event loop ticks, they never get overwritten because the `createState` method already returned.

I believe this is also the root cause of #1527 - I tested that issue (using the sandbox provided) without `partialize` defined but it still had the same problem.

## Link to reproduction

I forked the sandbox from #1527 and isolated the issue described above. Feel free to toggle between (1) synchronously and asynchronously updating the state within `onRehydrateStorage` and (2) `localStorage` and `asyncStorage` to see how synchronous/asynchronous APIs affect the issue.

https://codesandbox.io/s/zustand-4-3-x-bug-forked-45m5jq?file=/src/App.js

## Check List

Please do not ask questions in issues.

- [X] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

> N/A - I've got a reproducible example and opened a PR to fix.

- [X] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [X] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1613762643,1684,jsx in store function throws error with vitest and testing-library,"## Summary

I use `react-hot-toast` to dispactch a toast after setting the state in a store function:

```typescript 
export const useJobStore = create<JobStore>()(
  persist(
    (set, get) => ({
      lastDoneJob: undefined,
      completeJob: (jobKey: JobMapKeys) => {
          // ... logic

          set((state) => ({
            // ...state 
          }));

          toast(<ToastJobMessage/>, {
            icon: <SomeIcon />,
            duration: 3000,
          });
      },
    }),
    {
      name: 'levelStore',
    }
  )
);
```

this works all well on the page but when i run my testsuite with `vitest` and `testing-library`
I get the following error

![image](https://user-images.githubusercontent.com/53531653/223468938-1e810342-bb98-484f-b1b3-31f343b7b219.png)

for reproduction please run the `test` script in the codesandbox

I also opened an issue on [`vitest`](https://github.com/vitest-dev/vitest/issues/2973) since I don't know yet if it is a problem with `zustand` or `vitest`

## Link to reproduction

https://codesandbox.io/p/sandbox/tender-villani-qzjxge

## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1608415363,1671,Two Stores called in a Parent and Child Component conflict,"## Summary
I have created two stores, called store.js and websiteStore.js with two hooks, respectively useStore and useWebsite. When I call useWebsite in a Parent Component, I cannot use useStore in the Child Component, it simply doesn't work. If I remove the useWebsite and replace it with useStore, it starts working.
Sorry for the mediocre explanation, but that is it.

## Link to reproduction

Don't have

## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1585880293,1639,Broken build in remix with cloudflare-workers. Use of import.meta.env.,"## Summary

I'm trying to use Zustand with Remix and Cloudflare Workers, but I'm running into an error. I also encountered the same error when using Jotai.

The error message I'm seeing is:
```
 ((_a = import.meta.env) == null ? void 0 : _a.MODE) !== ""production"" && console.warn(
                  ^^^^

SyntaxError: Cannot use 'import.meta' outside a module
```

## Link to reproduction

Minimal remix setup from `npx create-remix@latest` and zustand.
https://github.com/mxck/remix-zustand-import-meta-error


## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1582046436,1627,Dependency Injection Pattern (state init with props) breaks Typesafety,"## Summary
When following the pattern on [zustand documentation](https://docs.pmnd.rs/zustand/guides/initialize-state-with-props) typesafety can be broken.

E.g. when you have a store with type 
```ts
{ bears: number }
```
And you pass to `initProps` 
```ts
{ bears: undefined }
```
`bears` will become `undefined`, but the type says its `number` !  


## Link to reproduction
[Link](https://codesandbox.io/s/serverless-wave-22zqbj?file=/src/store.ts)


## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1581863714,1625,"Cannot import ""create"" as named import.","## Summary
If I try to import `create` from `zustand` as a named import, as described in the docs, an error is thrown:
```javascript
import { create } from ""zustand""
```
```txt
Uncaught SyntaxError: ambiguous indirect export: create bear-store.js:1:9
```

## Workaround
```javascript
import create from ""zustand""
```
but this is marked as deprecated:
```javascript
export declare const create: Create;
/**
 * @deprecated Use `import { create } from 'zustand'`
 */
declare const _default: Create;
export default _default;
```

## Reproduction
```javascript
//bear-store.js
import { create } from ""zustand"";

const useBearStore = create((set) => ({
  bears: 0,
  fish: 0,
  actions: {
    increasePopulation: (by) =>
      set((state) => ({ bears: state.bears + by })),
    eatFish: () => set((state) => ({ fish: state.fish - 1 })),
    removeAllBears: () => set({ bears: 0 }),
  },
}))

export const useBears = () => useBearStore((state) => state.bears)
export const useFish = () => useBearStore((state) => state.fish)
export const useBearActions = () => useBearStore((state) => state.actions)
```

```javascript
import { useBearActions } from ""./bear-store"" // error is thrown in application
```
## Environment
Vite.js
zustand 4.3.3

Thanks

",,
1580879374,1620,Immer `setState` infers state from `getState`,"## Summary

The Immer middleware infers the type `nextStateOrUpdater` for `setState` from `getState`:

```ts
type StoreImmer<S> = S extends {
    getState: () => infer T;
    setState: infer SetState;
} ? SetState extends (...a: infer A) => infer Sr ? {
    setState(nextStateOrUpdater: T | Partial<T> | ((state: Draft<T>) => void), shouldReplace?: boolean | undefined, ...a: SkipTwo<A>): Sr;
} : never : never;
```

This is typically not a problem unless you're using a middleware like [chrisvander/zustand-computed](https://github.com/chrisvander/zustand-computed), where the state returned by `getState` *differs* from what is allowed to be set via `setState`. In the case of the computed middleware, `getState` returns additional keys beyond what the user is allowed to modify.

## Link to reproduction

[Playground Link](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgYygUwIYzXAvnAMyghDgCIAvAVwGcYMA7AEzIChRJZE4m0A3GBAgAbGnkLFSlWvWYB6EMCZNhaAO4Z0bDtHhJQINFHFES5anUZMFSles1o5Bo9vC7uyEmCrYmJyeYyVgC0nuA+aCysrDAAnmA4AMqC6HAAvIiscCgQVAwwAFxwDFQgAEZGWXDADMhFABQAlOkAfHB8EEpVvHVwTa3tnUysuNFxCXAAwl4RTMnQOBkIVZ55MIkAjkUl5ZWjrAR5yDDAEAw54djJWGj1lthF8+iNRdOXkU84y9noMFRQ52+2Rya02RXuaAAdKt8nAAFRwuAAJgANFVRvtPAw6HBaGhPukUOgbgAeT4tJr1br8QQiGhU4EXby+BmMvo0NAwZppNr1IFskH5IoARjRAuyNV6-R5cA5MHqd3o2G5vKQMMKsqVUPVcAA1HBhXhGo0xeKeg0VbLOQqIZa+YKNRDoblYcEDUaTVVGbhPQKwsz8VqvXBGlVQ6HWFicXjPgBJECGYwZVCYbBklJoCmNVm8ARCUSs7L+2aF4HOKA2zl2-ls9Ui00CyUW1rBgVym1ay018VwORyOBoAAeGHAqjgamAMAAFnB44m4IplKoNOhW+KnTrdRlhWvvb6zWgpZb24qbtWHeCtc61nA3Yaffu94-gcWrkHGaHsuHojGM5C5dc2D2uqYIGgADGBRq9v2RjEFArC-gsc5GP+nKAbcaouusWzgZBPrQbKU65MIfhThgfA4LB0BAA)

## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1575476369,1607,Huge console warn in unit tests,"## Summary
I'm getting a huge list of `console.warn` for every created store in my repository when running my tests. The log looks like this:
```
 console.warn
    [zustand devtools middleware] Please install/enable Redux devtools extension

      24 | };
      25 |
    > 26 | export const myStore = create<myStore>(
         |                                        ^
      27 |   devtools((set) => {
```

zustand version: `""zustand"": ""^3.6.9""`


## Link to reproduction (none)



## Check List

Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.

Please check this if you're filing an issue regarding TypeScript.

- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1556780464,1573,Any way to make zustand rerender my useeffect from another jsx file while using a button from an outside component or another tab of the page ? ,,,
1552742568,1566,Zustand persist with AsyncStorage,"## Summary

using storage instead of getStorage causes error.

here is my code:

```
import { createJSONStorage, persist } from 'zustand/middleware'
import { Info } from '../types/info'
import { Store } from '../types/store'
import AsyncStorage from '@react-native-async-storage/async-storage'

const useMainStore = create<Store>()(
    persist(
        (set, get) => ({
            data: '',
        }),
        {
            name: 'main-storage',
            storage: createJSONStorage(() => getStorageType())
        }
    )
)

export const getStorageType = () => {
    const isBrowser = typeof window !== 'undefined' //browser or react-native
    return !isBrowser ? AsyncStorage : window.localStorage
}
```

## Link to reproduction

just change getStorage with storage as described in documentation.
",,
1551825753,1563,Error with zustand exports in parcel production builds,"## Summary

A new error occurred in production builds using `zustand@4.3.2` and [`parcel`](https://github.com/parcel-bundler/parcel). This error does not occur in `zustand@4.3.1` and is probably related to #1531.

The following error is displayed in the console when serving a production build:
```
Uncaught TypeError: (0 , i.create) is not a function
    at app.js:3:22
```
Development server works fine.

This issue is similar to #1475.

## Link to reproduction

https://github.com/nicobohne/zustand-parcel-reproduction
https://codesandbox.io/p/github/nicobohne/zustand-parcel-reproduction/main

## Check List

Please do not ask questions in issues.

- [X] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue, or already discussed in other media.

Please include a minimal reproduction.

- [X] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction.
",,
1537684548,1551,Persist states are inconsistent when used in components,"## Summary
I have a store that looks like this:
```
export const useSlurmStateStore = create(
    persist(
        set => ({
            values: [""mixed"", ""drain"", ""drained"", ""down""],
            setValues: (newValues) => set({ values: newValues })
        }),
        {
            name: 'slurm-state',
            storage: createJSONStorage(() => localStorage)
        }
    )
)
```
It is used in a MUI-based component like this:
```
export default function CamieFilterSlurmState() {

  const [values, setValues] = useSlurmStateStore((state) => [state.values, state.setValues])

  const handleChange = (event, newFormats) => {
    setValues(newFormats);
  };

  return (
    <ToggleButtonGroup
      color=""primary""
      value={values}
      onChange={handleChange}
    >
      <ToggleButton value=""idle"">Idle</ToggleButton>
      <ToggleButton value=""mixed"">Mixed</ToggleButton>
      <ToggleButton value=""drain"">Drain</ToggleButton>
      <ToggleButton value=""drained"">Drained</ToggleButton>
      <ToggleButton value=""down"">Down</ToggleButton>
    </ToggleButtonGroup>
  )
}
```
The value is also accessed on a page like this:
```
const valuesSlurmState = useSlurmStateStore((state) => state.values)
```
When I reload the page, the values on the page are loaded from localStorage, while the values in the component are loaded from the default values defined in the store. Everything else works as expected.

Is this zustand's fault? Am I doing something wrong?",,
1529845087,1535,[Design bug / type issue][Middleware/persist] Overstrict type for persist serialization,"## Background
The current `persist` middleware type for serialization output to the cache solution is `string`. This matches the output type of `JSON.stringify()`, which is the default serialization function.

While this makes sense as a default type, there is no strict implementation reason for `persist` to serialize to / deserialize from a `string` type. In fact, recasting the persist middleware in Typescript to use a different serialization intermediate type works just fine.... but recasting like this is extremely messy

```ts
interface ICustomPersistOptions<State, CacheState, ISerializedState>
    extends Omit<PersistOptions<State, CacheState>, ""getStorage"" | ""serialize"" | ""deserialize""> {
    getStorage?: () => IStateStorage<ISerializedState>;
    serialize?: (state: IStorageValue<CacheState>) => ISerializedState;
    deserialize?: (serializedState: ISerializedState) => IStorageValue<CacheState>;
}

type CustomPersist = <
    State,
    CacheState,
    ISerializedState,
    Mps extends [StoreMutatorIdentifier, unknown][] = [],
    Mcs extends [StoreMutatorIdentifier, unknown][] = [],
    U = State
>(
    makeStore: StateCreator<State, [...Mps, [""zustand/persist"", unknown]], Mcs>,
    options?: ICustomPersistOptions<State, CacheState, ISerializedState>
) => StateCreator<State, Mps, [[""zustand/persist"", U], ...Mcs]>;

const persistMiddleware = persist as CustomPersist;
```

## Problem Statement
While the `string` type is sufficient for basic cache solutions, it's not flexible enough for all use-cases, and I think it's inappropriate for the library to artificially enforce this limited type (""artificial"", as there is no type limitation in zustand's implementation for persist serialization). This also seems to break from Zustand's general unopinionated philosophy/vibe. After all, Zustand is a store solution, not a caching solution!

A good example is the popular [`localForage` cache library](https://github.com/localForage/localForage) using IndexedDB as its cache middleware. With this setup, it's possible to cache modern ES6 types like `Maps` and `Sets` (at least from the perspective of a cached store author).

Unfortunately, there is no easy/clean way to pass these modern types along to the cache layer via a serialized `string` type that zustand requires.

## Proposed Solution
I propose two possible solutions:

1. Retype the serialized intermediate type from `string` to something more generic (with `string` as the default type,  matching the output of `JSON.stringify`). This generic type will also need to be part of the contract for `getStorage`. Looking at the internal implementation, this should be fairly straightforward / a small change.

2. Add an option to skip simply serialization, since another way to view this issue is that the cache library has its own, more robust/advanced serialization strategy, and we want to defer to that. This is still requires a type change to `getStorage`.

## Link to reproduction
Not a runtime issue

## Check List

Please do not ask questions in issues.

- [x] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue.
    -  **N/A** (not a question)
    
Please fill this template if you're filling an issue regarding TypeScript.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
    -  **N/A** (not a runtime bug)
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1529781727,1534,zustand/middleware persist option to set `initializeWithValue`,"## The problem

With frameworks that do hydration like Next.js, we have the following flow:

1. The server renders `/my-page` where there is no persisted store (localStorage), therefore the default values are used and renders the page with them.
2. Then the client renders the HTML, but since the persisted store is sync, the values are available on the first render, which could be different from the default values, the ones that the server used to render (THIS IS THE ISSUE).
3. We get hydration error

## Proposal

It would be beneficial to include an option to set if the persisted store should be initiated with values (sync) or not (async).

```tsx
create<StoreState>()(
  persist(
    (...a) => ({
      ...myStore(...a)
    }),
    {
      name: 'MY-STORE',
      initializeWithValue: false // default to true?
    }
  )
)
```

This should make the storage async by default, meaning on the first render the persisted values will be `undefined`, matching what was rendered on the server and therefore, potentially avoiding the Rehydration error. Thoughts? 
",,
1527909990,1528,default import for shallow is not working since 4.3.0,"## Summary

Since 4.3.0 `import shallow from 'zustand/shallow'` is not working anymore. 

## Link to reproduction

https://codesandbox.io/s/admiring-feather-0r46z8?file=/src/index.ts

",,
1527902358,1527,Calling state setter function  in onRehydrateStorage listener is not working when onRehydrateStorage and partialize exists,"## Summary
When using persist middleware, if both `onRehydrateStorage` callback and `partialize` exist in the Persist options,
Setting state by calling store function inside the onRehydrateStorage listener  failed to set and update the state of the store 

The demo demonstrates the problem,
even when the `setHasHydrated` and `onRehydrateStorage` are being called 
the screen still stuck in loading  because the store is value is not updated

this happens only in v4.3.X

v.4.2.0 has no such problem

## Link to reproduction
[https://codesandbox.io/s/zustand-4-3-x-bug-srmtzq?file=/src/App.js](https://codesandbox.io/s/zustand-4-3-x-bug-srmtzq?file=/src/App.js)
Please download it and run it locally because CodePen Demo can't access localStorage directly

## Check List

[ tick ] Please do not ask questions in issues.

- [ ] I've already opened a [discussion](https://github.com/pmndrs/zustand/discussions) before opening this issue.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1517248751,1505,Mocking state broken in 4.2.0 (with AsyncStorage in React Native),"## Summary
Hello and thank you for a great state library!

When upgrading to 4.2.0 and using persist, the suggested [mock approach](https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.mdx) throws error `TypeError: Cannot read properties of undefined (reading 'getItem')`

Suggested mock code that breaks:
```typescript
// when creating a store, we get its initial state, create a reset function and add it in the set
const create =
  () =>
  <S>(createState: StateCreator<S>) => {
    const store = actualCreate<S>(createState); // <-- breaks here
    const initialState = store.getState();
    storeResetFns.add(() => store.setState(initialState, true));
    return store;
  };
```
Our persist setup:
```typescript
import create from 'zustand';
import {createJSONStorage, persist} from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
...
const useAppState = create<State & Actions>()(
  persist(
    set => ({
      ...initialState,
      setIsColdStarted: isColdStarted => set({isColdStarted}),
      setSettings: settings =>
        set(state => ({settings: {...state.settings, ...settings}})),
      reset: () => set(initialState),
    }),
    {
      name: 'appState',
      storage: createJSONStorage(() => AsyncStorage), // <-- instead of deprecated getStorage: () => AsyncStorage
      partialize: ({settings}) => ({
        settings,
      }),
    },
  ),
);
```

",,
1508793281,1494,"Typescript Error when using Immer with custom ""Reset Multiple Stores"" function","## Summary

I'm using the `create` function defined in [this guide for resetting all stores](https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md). When I wrap a store with immer, I get a typescript error.

## Link to reproduction

The following sandbox is forked from the advanced example in the 'reset-state' guide.

https://codesandbox.io/s/zustand-with-immer-reset-all-stores-tme1b4

The typescript error is:

```
Argument of type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to parameter of type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon> | StoreApi<StateSalmon & ActionsSalmon>'.
  Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon>'.
    Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
      Types of property '$$storeMutators' are incompatible.
        Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
          Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
            Source has 1 element(s) but target allows only 0.ts(2345)
```

## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1363560202,"It's because we don't follow ""in particular that `create` is to be used as `create<T>()(...)`"".

Should we remove the old example from the docs?
cc @Cuppachino @dbritto-dev"
1508793281,1494,"Typescript Error when using Immer with custom ""Reset Multiple Stores"" function","## Summary

I'm using the `create` function defined in [this guide for resetting all stores](https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md). When I wrap a store with immer, I get a typescript error.

## Link to reproduction

The following sandbox is forked from the advanced example in the 'reset-state' guide.

https://codesandbox.io/s/zustand-with-immer-reset-all-stores-tme1b4

The typescript error is:

```
Argument of type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to parameter of type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon> | StoreApi<StateSalmon & ActionsSalmon>'.
  Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon>'.
    Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
      Types of property '$$storeMutators' are incompatible.
        Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
          Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
            Source has 1 element(s) but target allows only 0.ts(2345)
```

## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1363561586,Where should the additional `()` be applied in this case? 
1508793281,1494,"Typescript Error when using Immer with custom ""Reset Multiple Stores"" function","## Summary

I'm using the `create` function defined in [this guide for resetting all stores](https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md). When I wrap a store with immer, I get a typescript error.

## Link to reproduction

The following sandbox is forked from the advanced example in the 'reset-state' guide.

https://codesandbox.io/s/zustand-with-immer-reset-all-stores-tme1b4

The typescript error is:

```
Argument of type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to parameter of type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon> | StoreApi<StateSalmon & ActionsSalmon>'.
  Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon>'.
    Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
      Types of property '$$storeMutators' are incompatible.
        Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
          Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
            Source has 1 element(s) but target allows only 0.ts(2345)
```

## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1363566502,"https://tsplay.dev/mZQBaN should be a workaround. I haven't tried if it really works.

Anyone, please open a PR to fix the doc. Thanks."
1508793281,1494,"Typescript Error when using Immer with custom ""Reset Multiple Stores"" function","## Summary

I'm using the `create` function defined in [this guide for resetting all stores](https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md). When I wrap a store with immer, I get a typescript error.

## Link to reproduction

The following sandbox is forked from the advanced example in the 'reset-state' guide.

https://codesandbox.io/s/zustand-with-immer-reset-all-stores-tme1b4

The typescript error is:

```
Argument of type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to parameter of type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon> | StoreApi<StateSalmon & ActionsSalmon>'.
  Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon>'.
    Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
      Types of property '$$storeMutators' are incompatible.
        Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
          Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
            Source has 1 element(s) but target allows only 0.ts(2345)
```

## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1363579459,"Hey peeps  what about this approach ? -> https://codesandbox.io/s/zustand-with-immer-reset-all-stores-forked-ouowtt?file=/src/App.tsx

CC: @dai-shi @KevinMusgrave "
1508793281,1494,"Typescript Error when using Immer with custom ""Reset Multiple Stores"" function","## Summary

I'm using the `create` function defined in [this guide for resetting all stores](https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md). When I wrap a store with immer, I get a typescript error.

## Link to reproduction

The following sandbox is forked from the advanced example in the 'reset-state' guide.

https://codesandbox.io/s/zustand-with-immer-reset-all-stores-tme1b4

The typescript error is:

```
Argument of type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to parameter of type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon> | StoreApi<StateSalmon & ActionsSalmon>'.
  Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon>'.
    Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
      Types of property '$$storeMutators' are incompatible.
        Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
          Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
            Source has 1 element(s) but target allows only 0.ts(2345)
```

## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1363601770,"Hey peeps here's the other way to achieve the same -> https://codesandbox.io/s/zustand-with-immer-reset-all-stores-forked-nyet3f?file=/src/App.tsx

Note: similar to the example that we have on integrations -> https://codesandbox.io/s/zustand-updating-draft-states-basic-demo-zkp22g (ref: https://github.com/pmndrs/zustand/blob/main/docs/integrations/immer-middleware.md)"
1508793281,1494,"Typescript Error when using Immer with custom ""Reset Multiple Stores"" function","## Summary

I'm using the `create` function defined in [this guide for resetting all stores](https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md). When I wrap a store with immer, I get a typescript error.

## Link to reproduction

The following sandbox is forked from the advanced example in the 'reset-state' guide.

https://codesandbox.io/s/zustand-with-immer-reset-all-stores-tme1b4

The typescript error is:

```
Argument of type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to parameter of type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon> | StoreApi<StateSalmon & ActionsSalmon>'.
  Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon>'.
    Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
      Types of property '$$storeMutators' are incompatible.
        Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
          Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
            Source has 1 element(s) but target allows only 0.ts(2345)
```

## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1363603616,I can add an example for that and also update the previous ones to use the new typing approach so we can keep consistency between docs and examples
1508793281,1494,"Typescript Error when using Immer with custom ""Reset Multiple Stores"" function","## Summary

I'm using the `create` function defined in [this guide for resetting all stores](https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md). When I wrap a store with immer, I get a typescript error.

## Link to reproduction

The following sandbox is forked from the advanced example in the 'reset-state' guide.

https://codesandbox.io/s/zustand-with-immer-reset-all-stores-tme1b4

The typescript error is:

```
Argument of type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to parameter of type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon> | StoreApi<StateSalmon & ActionsSalmon>'.
  Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon>'.
    Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
      Types of property '$$storeMutators' are incompatible.
        Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
          Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
            Source has 1 element(s) but target allows only 0.ts(2345)
```

## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1363611362,"Yeah, that looks good too. Thanks! Please go ahead."
1508793281,1494,"Typescript Error when using Immer with custom ""Reset Multiple Stores"" function","## Summary

I'm using the `create` function defined in [this guide for resetting all stores](https://github.com/pmndrs/zustand/blob/main/docs/guides/how-to-reset-state.md). When I wrap a store with immer, I get a typescript error.

## Link to reproduction

The following sandbox is forked from the advanced example in the 'reset-state' guide.

https://codesandbox.io/s/zustand-with-immer-reset-all-stores-tme1b4

The typescript error is:

```
Argument of type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to parameter of type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon> | StoreApi<StateSalmon & ActionsSalmon>'.
  Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type 'StateCreator<StateSalmon & ActionsSalmon, [], [], StateSalmon & ActionsSalmon>'.
    Type 'StateCreator<StateSalmon & ActionsSalmon, [], [[""zustand/immer"", never]], StateSalmon & ActionsSalmon>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
      Types of property '$$storeMutators' are incompatible.
        Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
          Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
            Source has 1 element(s) but target allows only 0.ts(2345)
```

## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [x] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1364037281,"Thank you, it works"
1507612376,1493,Could not resolve immer,"## Summary

I followed the docs for the use of immer but I'm getting this error:

`optional-peer-dep:__vite-optional-peer-dep:immer:zustand:1 Uncaught Error: Could not resolve ""immer"" imported by ""zustand"". Is it installed?
    at optional-peer-dep:__vite-optional-peer-dep:immer:zustand:1:7`

My store:

```
import create from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { ChatSessionStore } from '../typings';

const useChatSessionStore = create(
  immer<ChatSessionStore>((set) => ({
    chatSession: null,
  }))
);

export default useChatSessionStore;
```

## Link to reproduction

## Check List

NodeJS: v16.17
Zustand: 4.1.5

- [x] I understand this is not a question.
",1362770534,"can you install immer?
https://github.com/pmndrs/zustand/blob/4a99653967bd0ada4ed1a4bd77dc64eefdaf98ff/docs/integrations/immer-middleware.md#installation"
1507612376,1493,Could not resolve immer,"## Summary

I followed the docs for the use of immer but I'm getting this error:

`optional-peer-dep:__vite-optional-peer-dep:immer:zustand:1 Uncaught Error: Could not resolve ""immer"" imported by ""zustand"". Is it installed?
    at optional-peer-dep:__vite-optional-peer-dep:immer:zustand:1:7`

My store:

```
import create from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { ChatSessionStore } from '../typings';

const useChatSessionStore = create(
  immer<ChatSessionStore>((set) => ({
    chatSession: null,
  }))
);

export default useChatSessionStore;
```

## Link to reproduction

## Check List

NodeJS: v16.17
Zustand: 4.1.5

- [x] I understand this is not a question.
",1362793871,"> can you install immer? https://github.com/pmndrs/zustand/blob/4a99653967bd0ada4ed1a4bd77dc64eefdaf98ff/docs/integrations/immer-middleware.md#installation

Done:

immer: 9.0.16

But I am still getting the same error."
1507612376,1493,Could not resolve immer,"## Summary

I followed the docs for the use of immer but I'm getting this error:

`optional-peer-dep:__vite-optional-peer-dep:immer:zustand:1 Uncaught Error: Could not resolve ""immer"" imported by ""zustand"". Is it installed?
    at optional-peer-dep:__vite-optional-peer-dep:immer:zustand:1:7`

My store:

```
import create from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { ChatSessionStore } from '../typings';

const useChatSessionStore = create(
  immer<ChatSessionStore>((set) => ({
    chatSession: null,
  }))
);

export default useChatSessionStore;
```

## Link to reproduction

## Check List

NodeJS: v16.17
Zustand: 4.1.5

- [x] I understand this is not a question.
",1362799547,"> can you install immer? https://github.com/pmndrs/zustand/blob/4a99653967bd0ada4ed1a4bd77dc64eefdaf98ff/docs/integrations/immer-middleware.md#installation

Disregard my first reply. It works now I have to restart my VSCode.


"
1507612376,1493,Could not resolve immer,"## Summary

I followed the docs for the use of immer but I'm getting this error:

`optional-peer-dep:__vite-optional-peer-dep:immer:zustand:1 Uncaught Error: Could not resolve ""immer"" imported by ""zustand"". Is it installed?
    at optional-peer-dep:__vite-optional-peer-dep:immer:zustand:1:7`

My store:

```
import create from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { ChatSessionStore } from '../typings';

const useChatSessionStore = create(
  immer<ChatSessionStore>((set) => ({
    chatSession: null,
  }))
);

export default useChatSessionStore;
```

## Link to reproduction

## Check List

NodeJS: v16.17
Zustand: 4.1.5

- [x] I understand this is not a question.
",1362803878,🎉 
1502475016,1489,devtools order in documentation is wrong,"## Summary
In https://docs.pmnd.rs/zustand/guides/typescript  
It said 

> we recommend using devtools middleware as last as possible. For example, when you use it with immer as a middleware, it should be immer(devtools(...)) and not devtools(immer(...)).

So I wonder if e.g. `devtools(immer(persist(...)))`should be the correct one.

## Link to reproduction
In https://docs.pmnd.rs/zustand/guides/typescript
",1357630357,"I think ""last"" means inner most?
Can @devanshj confirm?"
1502475016,1489,devtools order in documentation is wrong,"## Summary
In https://docs.pmnd.rs/zustand/guides/typescript  
It said 

> we recommend using devtools middleware as last as possible. For example, when you use it with immer as a middleware, it should be immer(devtools(...)) and not devtools(immer(...)).

So I wonder if e.g. `devtools(immer(persist(...)))`should be the correct one.

## Link to reproduction
In https://docs.pmnd.rs/zustand/guides/typescript
",1357675137,"The docs are correct. Here ""last"" means ""last to mutate the store"". There's also an example given precisely because the word ""last"" can be ambiguous here. "
1502475016,1489,devtools order in documentation is wrong,"## Summary
In https://docs.pmnd.rs/zustand/guides/typescript  
It said 

> we recommend using devtools middleware as last as possible. For example, when you use it with immer as a middleware, it should be immer(devtools(...)) and not devtools(immer(...)).

So I wonder if e.g. `devtools(immer(persist(...)))`should be the correct one.

## Link to reproduction
In https://docs.pmnd.rs/zustand/guides/typescript
",1358909596,So last means outer most?
1502475016,1489,devtools order in documentation is wrong,"## Summary
In https://docs.pmnd.rs/zustand/guides/typescript  
It said 

> we recommend using devtools middleware as last as possible. For example, when you use it with immer as a middleware, it should be immer(devtools(...)) and not devtools(immer(...)).

So I wonder if e.g. `devtools(immer(persist(...)))`should be the correct one.

## Link to reproduction
In https://docs.pmnd.rs/zustand/guides/typescript
",1358945119,"No, the docs are correct. Especially the example. Closing."
1502475016,1489,devtools order in documentation is wrong,"## Summary
In https://docs.pmnd.rs/zustand/guides/typescript  
It said 

> we recommend using devtools middleware as last as possible. For example, when you use it with immer as a middleware, it should be immer(devtools(...)) and not devtools(immer(...)).

So I wonder if e.g. `devtools(immer(persist(...)))`should be the correct one.

## Link to reproduction
In https://docs.pmnd.rs/zustand/guides/typescript
",2038119823,"@devanshj @dai-shi I've got the same confusion. The docs says 

> we recommend using devtools middleware as last as possible

And says this is the correct implementation

>  immer(devtools(...))

Which makes me wonder what is the definition of last. It's written last, but runs first. It's a bit confusing, but if you read 

> Hence using devtools at the end makes sure that no middlewares mutate setState before it

you can figure out what the author means. 

And a few lines before you have the example

>  devtools(persist(f, { name: 'bearStore' }))

Which is written first, but runs last. So the other way around

Maybe a simple example. What runs last?

> const first = () => console.log('first');
const second = () => console.log('second');
first(second());"
1502475016,1489,devtools order in documentation is wrong,"## Summary
In https://docs.pmnd.rs/zustand/guides/typescript  
It said 

> we recommend using devtools middleware as last as possible. For example, when you use it with immer as a middleware, it should be immer(devtools(...)) and not devtools(immer(...)).

So I wonder if e.g. `devtools(immer(persist(...)))`should be the correct one.

## Link to reproduction
In https://docs.pmnd.rs/zustand/guides/typescript
",2038487932,"We had a similar discussion lately on Discord.
There seems to be some inconsistencies.
Let's make `middlewareTests.test.tsx` the source of truth, and update docs. (If some patterns are missing updating `middlewareTests.test.tsx` is also welcome.)
Would you like to open a PR?"
1498263313,1483,Zustand persist with AsyncStorage,"## Summary
When i use zustand persist on react native, i found the nested **actions** can  not be persisted.

I use **useCommonActions** , **actions** are undefined.




## Link to reproduction
``` 
import create from ""zustand"";
import { persist } from ""zustand/middleware"";
import AsyncStorage from ""@react-native-async-storage/async-storage"";

export const useCommonStore = create(
  persist(
    (set, get) => ({
      token: ""1"",
      isIntro: false,
      phone: ""56782345"",
      avatar: """",
      galleryPermission: false,
      profile: {
        UserName: """",
        FirstName: """",
        SecondName: """",
        Description: """",
      },
      actions: {
        setToken: (token) => set((state) => ({ token: token })),
        setPhone: (newPhone) => set(() => ({ phone: newPhone })),
        setAvatar: (newAvater) => set(() => ({ avatar: newAvater })),
        setProfile: (newProfile) => set(() => ({ profile: newProfile })),
        setIsIntro: (isIntro) => set(() => ({ isIntro: isIntro })),
        setGalleryPermission: (newPermission) =>
          set(() => ({ galleryPermission: newPermission })),
      },
    }),
    { name: ""common-storage"", getStorage: () => AsyncStorage }
  )
);

export const useCommonActions = () => useCommonStore((state) => state.actions);
```

",1352941034,Duplicate of #1481.
1498000272,1482,Updating state does not trigger a component rerender,"## Summary
Zustand doesnt update component after a state change

```ts
import create from ""zustand"";
import { devtools } from ""zustand/middleware"";
import { MerchantsExtended } from ""@/web/clients/libs/types"";

export interface MerchantStoreType {
  merchants: MerchantsExtended[];
  setMerchantData: (merchantData: MerchantsExtended) => void;
}

export const useMerchantStore = create<MerchantStoreType>()(
  devtools(
    (set) => ({
      merchants: [],
      setMerchantData: (merchantData) => set((state) => {

          const currentMerchantIndex = state.merchants
          .findIndex((merchant) => merchant.id === merchantData.id);
          
          if (currentMerchantIndex >= 0) {
            state.merchants[currentMerchantIndex] = merchantData;
          } else {
            state.merchants.push(merchantData);
          }

          return state;
        })
    }),
    {
      name: ""merchantStore"",
    }
  )
);
```
",1352736532,Found that it doesnt update only arrays
1498000272,1482,Updating state does not trigger a component rerender,"## Summary
Zustand doesnt update component after a state change

```ts
import create from ""zustand"";
import { devtools } from ""zustand/middleware"";
import { MerchantsExtended } from ""@/web/clients/libs/types"";

export interface MerchantStoreType {
  merchants: MerchantsExtended[];
  setMerchantData: (merchantData: MerchantsExtended) => void;
}

export const useMerchantStore = create<MerchantStoreType>()(
  devtools(
    (set) => ({
      merchants: [],
      setMerchantData: (merchantData) => set((state) => {

          const currentMerchantIndex = state.merchants
          .findIndex((merchant) => merchant.id === merchantData.id);
          
          if (currentMerchantIndex >= 0) {
            state.merchants[currentMerchantIndex] = merchantData;
          } else {
            state.merchants.push(merchantData);
          }

          return state;
        })
    }),
    {
      name: ""merchantStore"",
    }
  )
);
```
",1352751914,Fixed it by using the `just-clone` package to clone the state first before mutating
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1344944734,"Thanks for reporting!

Do you have any guess what causes the issue?
Do any previous versions work?"
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1344987979,"Hey, all previous versions work. I dug a little deeper and found that the problem no longer exists in the latest version when scope hoisting in parcel is disabled (`--no-scope-hoist`). Also, here is a more detailed screenshot of the error:

![screenshot](https://user-images.githubusercontent.com/20912141/206824735-5c54f3cf-8e70-412c-a8fc-d04f11c787ae.png)"
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1344990345,"Can you please modify the last line to this and see how it goes?
```js
if (exports.default) { Object.assign(exports.default, exports); module.exports = exports.default; }
```"
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1344992795,"Okay, manually edited the bundled file and this seems to fix the error.

Edit: Or even directly editing the source file from zustand with the above changes removes the error from production bundles."
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1345186674,@barelyhuman Do you have other ideas?
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1345257221,"i could do a empty assign check similar to the above solution but then that's just boiler code I expect bundlers to add.

Let me play around with rollup a bit, i should be able to get a cleaner solution"
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1345288590,"@dai-shi 

After hacking around, I think if we slowly let people used named imports instead that would be a good solution in the long run. 

for now , if I change the `index.ts` to export both `create` and a default like it already does, we can provide a solution to #559 and also can mark the `default` export as deprecated to make it easier for people, since I don't think waiting for each tool to break for an import would be a nice idea? Let me know what you think

```js
export * from './vanilla'
export * from './react'
export { default as createStore } from './vanilla'
import create from './react'
export { create }

/**
 * @deprecated
 */
export default create
```"
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1345420621,"@barelyhuman 

We could add a named export and deprecate the default export for v5, but not sure what @drcmda would think.

What's the issue with the hack? In the long run, I believe tools migrate to native ESM, so this issue will be less likely to happen.

Can you also check what I do in proxy-memoize? Does it help in our case?
https://github.com/dai-shi/proxy-memoize/blob/05c5b873c65d079d953ef9f08833702e29fd2978/package.json#L21"
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1345579281,"The `node` field from what I've read and understood is only read by webpack, could be worth a try since the source of most issues we've had seem to be from webpack users.

No direct issue with using a hack, it's just that we are running in circles with the export thing. We've got enough configuration to compile 10 libraries in the codebase which means more moving parts and harder to control what's going on, plus with the name and direct `module.exports` we are actually fighting against the other tooling since most of them agree on only having named exports. 

Hence, the recommendation to do the slow removal of the default export. I understand the aesthetic value of 
```js
import create from ""zustand""
```
so I'd like to make it work in most cases, going throught older React bundling techniques where both the import styled worked.
```js
const React  = require(""react"");
//and
import React from 'react'
```

Even when there were almost 6-7 other named exports on the library. 
In theory it's just 
```js
React = react 
React.Children = Children 

exports = React
exports.default = React 
exports.Children = Children
```

But I'd like to go through it a little more before I implement it here"
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1346112121,I just want to confirm that I have the same issue with 4.1.5 release. 4.1.4 is ok.
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1397718071,I am still having this issue with `parcel@2.8.3` and `zustand@4.3.2`
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1397759032,Do you mean the reproduction in OP is failing with 4.3.2? It should have fixed before.
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1399256870,"Hey, I also encountered a new bug in my production build after updating to 4.3.2.

To test this I updated my reproduction to zustand@4.3.2 and to use named exports (https://github.com/nicobohne/zustand-parcel-reproduction/tree/update/4.3.2). I can confirm that there is a new error.

This time the error is as follows:
```
Uncaught TypeError: (0 , i.create) is not a function
    at app.js:3:22
```

I also tested zustand@4.3.1. No error occurs in this version. So I guess this error is related to #1531?

Should I open a new issue for this error?"
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1399260322,"> I also tested zustand@4.3.1. No error occurs in this version. So I guess this error is related to https://github.com/pmndrs/zustand/pull/1531?

Oh, really... Yeah, please open a new issue."
1487391794,1475,Parcel production builds can't bundle the latest version,"## Summary
The latest version of Zustand is not compatible with [Parcel's](https://github.com/parcel-bundler/parcel) builds. The following error is thrown when the bundled code is run:

```
index.js:41 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.assign (<anonymous>)
    at index.js:41:42
````

## Link to reproduction
https://github.com/nicobohne/zustand-parcel-reproduction

## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1399269040,"Done: #1563 

P.S.: Thx for this fantastic library"
1486252653,1473,Should shallow equality compare the order between two Sets?,"Hi ~ thanks to your great works ! My question is the title you see
https://github.com/pmndrs/zustand/blob/0736a1c8bb54f5af3a5abc9ac043cf3abfc83004/src/shallow.ts#L25-L33
Here init the store
```typescript
const useBearStore = create((set) => ({
  bears: new Set(),
  updateBears: () => set((state) => ({
      bears: new Set(shuffle(...state.bears)) 
  })),
}))
```

And then get bears. It seems like bears would not update after the Set of bears being shuffled.
```typescript
import shallow from 'zustand/shallow'

const { bears } = useBearStore(
  (state) => ({ bears: state.bears }),
  shallow
)
```",1343984351,"https://en.wikipedia.org/wiki/Set_(abstract_data_type)
A set shouldn't depend on the order.
If you care the order, please consider using an array."
1481895123,1470,Zustand store in React context with Suspense causes server-client mismatch,"## Summary

A combination of suspense, client context and zustand causes a server-client mismatch error. If suspense is removed, the behaviour is as expected.

The app structure overview:
```
<ContextProvider>: client component
- <Suspense>
-- <NavigationProvider>: server component
--- <Navigation>: client component
- <PageComponents>: client component
```

My guess as to what is happening:
1. On the server,  `<Navigation>` renders with theme `system`
2. On the client, `<PageComponents>` renders first and in `useEffect` updates theme to `dark`
3. Then, after a delay in `<Suspense>`, `<NavigationProvider>` renders `<Navigation>`, which receives theme `dark`
4. Mismatch error

## Link to reproduction

https://stackblitz.com/edit/nextjs-ydmeqq?file=app%2Flayout.js


## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

",1344326747,"Page https://beta.reactjs.org/apis/react/useSyncExternalStore has a note, saying that:


> Make sure that getServerSnapshot returns the same exact data on the initial client render as it returned on the server. For example, if getServerSnapshot returned some prepopulated store content on the server, you need to transfer this content to the client. One common way to do this is to emit a <script> tag that sets a global like window.MY_STORE_DATA during server rendering, and then read from that global on the client in getServerSnapshot


In `useStore`, the value for `getServerSnapshot` always falls back to `getState`:
```const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getState,
    selector,
    equalityFn
  )
```
and `getState` on the first render in the example returns a value for `theme` that is not the the value rendered on the server. 

A solution seems to be that zustand must serialise the server store state into a JS object, emit it in a <script> tag and read from it with api.getServerState."
1470082584,1456,Export internal types such as ExtractState,"## Summary
Currently, when consuming the new v4 context-based API it can become verbose and in order to facilitate the creation of a context-based store in my current project I do need to re-use a few types and provide more type safety at the application level. 
Not exposing the internal types could be international but for library authors or anyone that's actually consuming and enhancing local code, it can become challenging and have to perform a manual copy.

My request would simply be exposing those types because at some point they are handy to quickly override such as:
```typescript
const myStore = create(middleware1(...))
````
The following Channing can produce something like
````typescript
UseBoundStore<Write<StoreApi<State>, StoreSubscribeWithSelector<State>>>
````

It would be good if we could gather those types or have some sort of alias and simply use those and they are helpful when it comes to creating local store refs


## Link to reproduction
Attempting to import types like `ExtractType`, `StoreSubscribeWithSelector`, or `Write` will result in an error


## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [X] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1332929652,"Exporting `ExtractState` may make sense. We can do that.
What's your use case?

---

`Write` and `WithSomething` are internal types and people should never use it. If we export them, people would just misuse them.

It feels like the zustand typing is just very hard to understand for many developers, and we fail to educate the usage very well.

So, If I understand your case correctly, it should be something like this.
https://tsplay.dev/wRz5Yw
```ts
import create, { UseBoundStore, Mutate, StoreApi } from ""zustand"";
import { subscribeWithSelector } from ""zustand/middleware"";

type MyState = {
  count: number;
  inc: () => void;
};

type UseMyStore = UseBoundStore<
  Mutate<StoreApi<MyState>, [[""zustand/subscribeWithSelector"", never]]>
>;

const useMyStore: UseMyStore = create<MyState>()(
  subscribeWithSelector((set) => ({
    count: 0,
    inc: () => set((state) => ({ count: state.count + 1 })),
  }))
);
```
Does it look something you were trying?

See also #930 discussion."
1470082584,1456,Export internal types such as ExtractState,"## Summary
Currently, when consuming the new v4 context-based API it can become verbose and in order to facilitate the creation of a context-based store in my current project I do need to re-use a few types and provide more type safety at the application level. 
Not exposing the internal types could be international but for library authors or anyone that's actually consuming and enhancing local code, it can become challenging and have to perform a manual copy.

My request would simply be exposing those types because at some point they are handy to quickly override such as:
```typescript
const myStore = create(middleware1(...))
````
The following Channing can produce something like
````typescript
UseBoundStore<Write<StoreApi<State>, StoreSubscribeWithSelector<State>>>
````

It would be good if we could gather those types or have some sort of alias and simply use those and they are helpful when it comes to creating local store refs


## Link to reproduction
Attempting to import types like `ExtractType`, `StoreSubscribeWithSelector`, or `Write` will result in an error


## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [X] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1333634692,"@dai-shi Thanks for getting back to me so fast. For `Write` and other internal types, you're right i probably don't need them and the following example helps, it allows us to build a re-usable type with `subscribeWithSelector` which fixes one problem. 
The other problem might occur with the function overloading types that we don't have access to which i ended up having a manual copy.

## What might be the use for the overloading types?
Let's consider the following:
```typescript
const MyComponent = () => {
    const api = useContext(ZustandStoreContext)
    const data = useStore(api)
    const selectedData = useStore(api,state => state.whatever)
}
```
It ends up being how we consume the context but if you want to build a re-usable pattern you'll need to abstract a few steps such as providing the API if you already have it
```typescript
type UseStoreFunc<T, ReturnedData> = {
  (): ExtractState<T>;
  (selector: (state: ExtractState<StoreApi<T>>) => ReturnedData, equalityFn?: (a: ReturnedData, b: ReturnedData) => boolean): ReturnedData
}

type Params<S, R> = Parameters<UseStoreFunc<S, R>>
export const createZustandContext = <State,>() => {
  const { Provider } = createContext<Store<State>>({} as Store<State>)
  let storeApi: Store<State>

  const useStoreProxy = <ReturnValue = State>(...params: Params<State, ReturnValue>) => {
    return useStore(storeApi, params?.[0] ?? ((state: State) => state as State) as any, params?.[1])
  }

  const useStoreApi = () => {
    return storeApi
  }

  const initializeStore = (initializer: StateCreator<State>) => {
    storeApi = create(initializer)
    return storeApi
  };

  return {
    initializeStore,
    Provider,
    useStore: useStoreProxy,
    useStoreApi
  };
};
```

The challenge here was to be able to already provide the API so that the consumer would continue using the API the same way as a global store (trying to avoid the boilerplate)
Let me know if there's anything else i can provide but essentially the use case here is mostly introducing a generic helper function that could alleviate the boilerplate when dealing with context-based stores"
1470082584,1456,Export internal types such as ExtractState,"## Summary
Currently, when consuming the new v4 context-based API it can become verbose and in order to facilitate the creation of a context-based store in my current project I do need to re-use a few types and provide more type safety at the application level. 
Not exposing the internal types could be international but for library authors or anyone that's actually consuming and enhancing local code, it can become challenging and have to perform a manual copy.

My request would simply be exposing those types because at some point they are handy to quickly override such as:
```typescript
const myStore = create(middleware1(...))
````
The following Channing can produce something like
````typescript
UseBoundStore<Write<StoreApi<State>, StoreSubscribeWithSelector<State>>>
````

It would be good if we could gather those types or have some sort of alias and simply use those and they are helpful when it comes to creating local store refs


## Link to reproduction
Attempting to import types like `ExtractType`, `StoreSubscribeWithSelector`, or `Write` will result in an error


## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [X] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1333671594,"Yeah, function overloading is a difficult one. I don't think exporting types helps it anyway. I also think it's a rare case anyways. (And, there should be easier workarounds for TS beginners to avoid function overloading.)

Here's what I've got: https://tsplay.dev/mbK0dW"
1470082584,1456,Export internal types such as ExtractState,"## Summary
Currently, when consuming the new v4 context-based API it can become verbose and in order to facilitate the creation of a context-based store in my current project I do need to re-use a few types and provide more type safety at the application level. 
Not exposing the internal types could be international but for library authors or anyone that's actually consuming and enhancing local code, it can become challenging and have to perform a manual copy.

My request would simply be exposing those types because at some point they are handy to quickly override such as:
```typescript
const myStore = create(middleware1(...))
````
The following Channing can produce something like
````typescript
UseBoundStore<Write<StoreApi<State>, StoreSubscribeWithSelector<State>>>
````

It would be good if we could gather those types or have some sort of alias and simply use those and they are helpful when it comes to creating local store refs


## Link to reproduction
Attempting to import types like `ExtractType`, `StoreSubscribeWithSelector`, or `Write` will result in an error


## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [X] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1333674361,"@dai-shi I wanted to have the most type of safety so that once we upgrade (if there is any breaking change) to easily catch those but I think your solution can probably alleviate and temporarily solve the problem that I'm facing.
Thanks for the responses! Feel free to close if there's no action item out of this request"
1470082584,1456,Export internal types such as ExtractState,"## Summary
Currently, when consuming the new v4 context-based API it can become verbose and in order to facilitate the creation of a context-based store in my current project I do need to re-use a few types and provide more type safety at the application level. 
Not exposing the internal types could be international but for library authors or anyone that's actually consuming and enhancing local code, it can become challenging and have to perform a manual copy.

My request would simply be exposing those types because at some point they are handy to quickly override such as:
```typescript
const myStore = create(middleware1(...))
````
The following Channing can produce something like
````typescript
UseBoundStore<Write<StoreApi<State>, StoreSubscribeWithSelector<State>>>
````

It would be good if we could gather those types or have some sort of alias and simply use those and they are helpful when it comes to creating local store refs


## Link to reproduction
Attempting to import types like `ExtractType`, `StoreSubscribeWithSelector`, or `Write` will result in an error


## Check List

Please do not ask questions in issues.

- [X] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [X] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",1333683223,"> Exporting ExtractState may make sense. 

For most cases, people would know their state without extracting.

Closing this. Thanks for sharing the use cases."
1468200877,1452,Export `WithImmer` type,"## Summary

The VSCode editor reports that the inferred type is not portable and advises adding a type annotation. Typescript CLI (v4.8.4) doesn't report this as error.

The inferred type is:

```ts
UseBoundStore<WithImmer<StoreApi<AppState>>>
```

The `AppState` type is my custom type. I can import `UseBoundStore` and `StoreApi` from zustand, but `WithImmer` type is not exported from the immer middleware.

Could you export the `WithImmer` type as well?

## Link to reproduction

<img width=""1208"" alt=""vscode-message"" src=""https://user-images.githubusercontent.com/5012724/204561357-a4f8735d-0764-47e4-8de5-5252707d6cab.png"">

## Check List

Please do not ask questions in issues.

- [x] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [x] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1450245883,1430,Suggestion: drop uncurried support of `create`,"I've lost count of how many people have missed the extra parenthesis in `create()(...)` (and the wrong usage ie `create(...)` doesn't even get caught because it's allowed). I don't see how supporting the `create(...)` usage adds any value, it's just creating trouble for many people (including me). I know I've suggested this before but I want to make the suggestion official hence opening an issue.",1316400902,There's also an option to support it in runtime but not include it in types (ie .d.ts won't include the uncurried overload).
1450245883,1430,Suggestion: drop uncurried support of `create`,"I've lost count of how many people have missed the extra parenthesis in `create()(...)` (and the wrong usage ie `create(...)` doesn't even get caught because it's allowed). I don't see how supporting the `create(...)` usage adds any value, it's just creating trouble for many people (including me). I know I've suggested this before but I want to make the suggestion official hence opening an issue.",1373626898,"> Maybe i'm misunderstanding but is this the two types of syntaxes we're discussing?

Yeah, in summary:
- In TypeScript, the curried one is _required_ if you use middleware (not all of them, but with store mutation, but hard to know which).
- The curried one works for all cases, both in JavaScript and TypeScript
- In JavaScript, the uncurried one works for all cases."
1450245883,1430,Suggestion: drop uncurried support of `create`,"I've lost count of how many people have missed the extra parenthesis in `create()(...)` (and the wrong usage ie `create(...)` doesn't even get caught because it's allowed). I don't see how supporting the `create(...)` usage adds any value, it's just creating trouble for many people (including me). I know I've suggested this before but I want to make the suggestion official hence opening an issue.",1375786812,"We use TS, and have used the uncurried version almost exclusively, and have not had any problems, I guess because we aren't using middleware that requires it. We tend to use type inference on factory function return types for different slices, with good results."
1448521747,1427,Zustand produces SyntaxError in Chrome<66 (optional catch binding),"## SyntaxError in older browsers due to optional catch binding not transpiled

Zustand codebase utilizes ""optional catch binding"" JS feature (eg. here: https://github.com/pmndrs/zustand/blob/main/src/middleware/devtools.ts#L163) which is [ECMAScript Stage 4 proposal](https://github.com/tc39/proposal-optional-catch-binding) and is not supported in Chrome versions less than 66: https://caniuse.com/?search=optional%20catch%20binding

Probably due to wrong babel configuration, `try {} catch {}` syntax is not correctly transpiled to `try {} catch (e) {}`. This should be done automatically by [@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env#modules) which contains [@babel/plugin-proposal-optional-catch-binding](https://babeljs.io/docs/en/babel-plugin-proposal-optional-catch-binding), but is not: https://unpkg.com/browse/zustand@4.1.4/esm/middleware.js

Wrong syntax produces ""SyntaxError"" in browsers like Chrome 65:

> Uncaught SyntaxError: Unexpected token {

![syntax](https://user-images.githubusercontent.com/777087/201734146-ea5b750e-e466-4ecf-9415-653506d962e5.png)

![image](https://user-images.githubusercontent.com/777087/201735327-500c3ce0-e292-4e70-b738-a5fc45c5b3bd.png)


",1314559909,"Nice catch. Thanks for reporting.
Seems like you are using esm, not cjs.
cjs target is old browser, but esm target is modern.
I don't think it's easy to change the config only for this.

That said, it's the only one place we use optional catch binding (and I was a bit anxious), so let's change the source code.
Would you like to open a PR?"
1443241843,1416,Demo website is flickering on my machine ,"## Summary

Demo website is flickering on my machine 

## Link to reproduction



## Check List

Please do not ask questions in issues.

- [x ] I understand this is not a question.

Please fill this template if you're filling an issue regarding TypeScript.

- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.
",,
1436398566,1408,Type error with middleware + slice pattern,"Hello,

Tanks for providing us this library. I have some trouble using _slice pattern_, _middleware_ and _TypeScript_ together. Here's my code:

```ts
export const useStore = create<AuthStore & TransactionStore>()(
  devtools(
    (...args) => ({
      ...createAuthSlice(...args),
      ...createTransactionSlice(...args),
    }),
    { enabled: process.env.NODE_ENV === ""development"" }
  )
)
```

And got this incomprehensible typescript error.

```
Argument of type '[[""zustand/devtools"", never]]' is not assignable to parameter of type '[]'.
  Source has 1 element(s) but target allows only 0.
```

I also have typing problems when trying to use custom middleware

```ts
export const useStore = create<AuthStore & TransactionStore>()(
  devtools(
    withLog((...args) => ({
      ...createAuthSlice(...args),
      ...createTransactionSlice(...args),
    })),
    { enabled: process.env.NODE_ENV === ""development"" }
  )
)

export withLog = (config) => (set, get, api) => config(
    (...args) => {
      console.log(args)
    },
    get,
    api
  )
```

```
Parameter 'config' implicitly has an 'any' type.
Parameter 'set' implicitly has an 'any' type.
Parameter 'get' implicitly has an 'any' type.
Parameter 'api' implicitly has an 'any' type.
Rest parameter 'args' implicitly has an 'any[]' type.
```

I'm clueless on how to solve it, can you help ?

Note: in both case the code is working fine, it's just a problem of typing (got the devtools working).",,
1435070164,1407,Middleware that does not mutate the store cannot be composed with middleware that does (not),"Hi, I'm working on updating [zustand-middleware-yjs](/joebobmiles/zustand-middleware-yjs) to the latest version of Zustand. One of my tests is to verify composing middleware still works, and TypeScript is giving the following type error when I compose the Yjs middleware with the Immer middleware:

```
Argument of type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to parameter of type 'StateCreator<Store, [], [], Store>'.
  Type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
    Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
        Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
          Source has 1 element(s) but target allows only 0.
```

From the docs I know there are two ways to type a middleware: the 'no mutation' style and the 'with mutation' style. The yjs middleware does not mutate the store, so I've opted for the former when choosing the types:

```ts
type Yjs = <
  T extends unknown,
  InMutators extends [StoreMutatorIdentifier, unknown][] = [],
  OutMutators extends [StoreMutatorIdentifier, unknown][] = []
>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, InMutators, OutMutators>,
) => StateCreator<T, InMutators, OutMutators>;

type YjsImpl = <T extends unknown>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, [], []>,
) => StateCreator<T, [], []>;
```

However, I also notice that while the Immer middleware technically _doesn't_ mutate the store, it still uses the later 'with mutation' style of typing. The two styles are incompatible according to TypeScript, but as far as I've seen, the documentation doesn't warn you from trying to compose middleware that use the different styles.

So are the two styles supposed to be compatible and is this a bug? Or are they incompatible and middleware intended to be composed together should always default to the 'with mutation' style of typing, and it's not documented?",1302809922,@devanshj Could you help on this?
1435070164,1407,Middleware that does not mutate the store cannot be composed with middleware that does (not),"Hi, I'm working on updating [zustand-middleware-yjs](/joebobmiles/zustand-middleware-yjs) to the latest version of Zustand. One of my tests is to verify composing middleware still works, and TypeScript is giving the following type error when I compose the Yjs middleware with the Immer middleware:

```
Argument of type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to parameter of type 'StateCreator<Store, [], [], Store>'.
  Type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
    Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
        Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
          Source has 1 element(s) but target allows only 0.
```

From the docs I know there are two ways to type a middleware: the 'no mutation' style and the 'with mutation' style. The yjs middleware does not mutate the store, so I've opted for the former when choosing the types:

```ts
type Yjs = <
  T extends unknown,
  InMutators extends [StoreMutatorIdentifier, unknown][] = [],
  OutMutators extends [StoreMutatorIdentifier, unknown][] = []
>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, InMutators, OutMutators>,
) => StateCreator<T, InMutators, OutMutators>;

type YjsImpl = <T extends unknown>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, [], []>,
) => StateCreator<T, [], []>;
```

However, I also notice that while the Immer middleware technically _doesn't_ mutate the store, it still uses the later 'with mutation' style of typing. The two styles are incompatible according to TypeScript, but as far as I've seen, the documentation doesn't warn you from trying to compose middleware that use the different styles.

So are the two styles supposed to be compatible and is this a bug? Or are they incompatible and middleware intended to be composed together should always default to the 'with mutation' style of typing, and it's not documented?",1302818313,"Middlewares that change the store type and the middlewares that don't change the store type are compatible with each other.

I'll require a minimal reproduction of the error you're seeing to help you out, you can use the typescript playground (tip: you can use `declare const yjs: YourType` instead of writing the full implementation there, or you can even import `yjs` if it's already published with the type that produces the error), or a codesandbox, or if none of that works then a git repository.

Also `immer` middleware does change the store type, `setState` in particular, you can check the source.

So to be clear, this is most probably not a bug but incorrect usage in the userland, I could be wrong, but I can comment concretely only after seeing a reproduction of the error."
1435070164,1407,Middleware that does not mutate the store cannot be composed with middleware that does (not),"Hi, I'm working on updating [zustand-middleware-yjs](/joebobmiles/zustand-middleware-yjs) to the latest version of Zustand. One of my tests is to verify composing middleware still works, and TypeScript is giving the following type error when I compose the Yjs middleware with the Immer middleware:

```
Argument of type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to parameter of type 'StateCreator<Store, [], [], Store>'.
  Type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
    Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
        Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
          Source has 1 element(s) but target allows only 0.
```

From the docs I know there are two ways to type a middleware: the 'no mutation' style and the 'with mutation' style. The yjs middleware does not mutate the store, so I've opted for the former when choosing the types:

```ts
type Yjs = <
  T extends unknown,
  InMutators extends [StoreMutatorIdentifier, unknown][] = [],
  OutMutators extends [StoreMutatorIdentifier, unknown][] = []
>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, InMutators, OutMutators>,
) => StateCreator<T, InMutators, OutMutators>;

type YjsImpl = <T extends unknown>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, [], []>,
) => StateCreator<T, [], []>;
```

However, I also notice that while the Immer middleware technically _doesn't_ mutate the store, it still uses the later 'with mutation' style of typing. The two styles are incompatible according to TypeScript, but as far as I've seen, the documentation doesn't warn you from trying to compose middleware that use the different styles.

So are the two styles supposed to be compatible and is this a bug? Or are they incompatible and middleware intended to be composed together should always default to the 'with mutation' style of typing, and it's not documented?",1303652126,Here's a reproduction in [TypeScript Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAYygUwIY2QGjgbzgZRnWQGEV1ptDpkBZAVyJmgEkATZAOxmADNhkUOAF84vKBBBwARAC96AZyKc20gNwAoUJFi44oEIJFiJUuYuVsA9CGBs2AG2QB3VCisHB6reGjwAVHCoCnAAmiaSMgCeAFYK3howUWDIYXFwALxwADwacHAAKnDIAB4YKiH0nADWnBDOnJh5cCycDEzQIaXlbCEA2tQo7RRQ7Fw8-ILYVbX1nAC6ffOZcEtN+QDyjMPMUF1lXL2rg3SMI2PcfAJQ0zV1DYvLWUsaAHwAFM1sEAgAXGEAOgAIj91nBOKhDP8lFBgJwAOZgpBoXb-QjEMgo6DZArYVo7TrYLYwAl7V5NACUmVeBCYpHIuxxeLaZ12CiJ21ZnVemg0Vn8iWSqVCcRY4AcKxxxQOFTgM3unA+Xx+-1CwNBzQhULgMLhiOayJGaLpmJGTNW82wS3JGipGRp6IwpsZuItVvmPI0-isGg0HAQDjcqQQEE4SjgsQUqrivKSKVpNBWOANECqMH+nHoIAARlNmnDkYZuP93naaQA3CB2JrCXmGjDZE5K-KRz75fKcFyAkEIUtg-LSCSSaT9-QgQxQNvt-LvBTIGBluDvZPT6chtP-AAMo+nBZQRfTS7LzVX7bnMHes7px9Pp+XMnX3Gk0LpAMf8AA1HAAIzYYQUikdxECkTzgED8hAilNCAA)
1435070164,1407,Middleware that does not mutate the store cannot be composed with middleware that does (not),"Hi, I'm working on updating [zustand-middleware-yjs](/joebobmiles/zustand-middleware-yjs) to the latest version of Zustand. One of my tests is to verify composing middleware still works, and TypeScript is giving the following type error when I compose the Yjs middleware with the Immer middleware:

```
Argument of type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to parameter of type 'StateCreator<Store, [], [], Store>'.
  Type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
    Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
        Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
          Source has 1 element(s) but target allows only 0.
```

From the docs I know there are two ways to type a middleware: the 'no mutation' style and the 'with mutation' style. The yjs middleware does not mutate the store, so I've opted for the former when choosing the types:

```ts
type Yjs = <
  T extends unknown,
  InMutators extends [StoreMutatorIdentifier, unknown][] = [],
  OutMutators extends [StoreMutatorIdentifier, unknown][] = []
>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, InMutators, OutMutators>,
) => StateCreator<T, InMutators, OutMutators>;

type YjsImpl = <T extends unknown>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, [], []>,
) => StateCreator<T, [], []>;
```

However, I also notice that while the Immer middleware technically _doesn't_ mutate the store, it still uses the later 'with mutation' style of typing. The two styles are incompatible according to TypeScript, but as far as I've seen, the documentation doesn't warn you from trying to compose middleware that use the different styles.

So are the two styles supposed to be compatible and is this a bug? Or are they incompatible and middleware intended to be composed together should always default to the 'with mutation' style of typing, and it's not documented?",1304376832,"You're missing the extra `()` after `create` as shown in the typescript docs, [it works fine with it](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAYygUwIY2QGjgbzgZRnWQGEV1ptDpkBZAVyJmgEkATZAOxmADNhkUOAF84vKBBBwARAC96AZyKc20gNwAoUJFi44oEIJFiJUuYuVsA9CGBs2AG2QB3VCisHB6reGjwAVHCoCnAAmiaSMgCeAFYK3howUWDIYXFwALxwADwacHAAKnDIAB4YKiH0nADWnBDOnJh5cCycDEzQIaXlbCEA2tQo7RRQ7Fw8-ILYVbX1nAC6ffOZcEtN+QDyjMPMUF1lXL2rg3SMI2PcfAJQ0zV1DYvLWUsaAHwAFM1sEAgAXGEAOgAIj91nBOKhDP8lFBgJwAOZgpBoXb-QjEMgo6DZArYVo7TrYLYwAl7V5NACUmVeBCYpHIuxxeLaZ12CiJ21ZnVemg0Vn8iWSqVCcRY4AcKxxxQOFTgM3unA+Xx+-1CwNBzQhULgMLhiOayJGaLpmJGTNW82wS3JGipGRp6IwpsZuItVvmPI0-isGg0HAQDjcqQQEE4SjgsQUqrivKSKVpNBWOANECqMH+nHoIAARlNmnDkYZuP93naaQA3CB2JrCXmGjDZE4fCmffKR1v5cEuQEghClsH5aQSSTSAf6ECGKAdztwd4KZAwMuz5MzmchtP-AAMY5nBZQRfTs7LzVXnfnMHec7px9Pp-eeGk6+40mhdIBT-gAGo4ABGbDCCkKR3EQKRPOBQPyUCKU0IA).

---

@dai-shi I'd suggest adding an issue template that looks something like this...

Please fill this template if you're filling an issue regarding TypeScript, if not then remove it
- [ ] I've added a link to a [typescript playground](https://www.typescriptlang.org/play) or [codesandbox](https://codesandbox.io) with a minimal reproduction. Or some other way of reproduction if these two don't suffice.
- [ ] I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that `create` is to be used as `create<T>()(...)` and not `create<T>(...)`.

I think we've come across many people falling for these mistakes so it makes sense to prompt them before they open an issue.

Again only a suggestion, please do what you see right.

I've also opened #1410, I think the instructions are already clear but it doesn't hurt to highlight more given so many people miss it.

Also I'd suggest you to consider dropping the `create(...)` support, I don't see how it adds any value, it just creates trouble. In fact even JavaScript users should use the TypeScript extra parenthesis version so that the intellisense is better (as vscode does type analysis on JavaScript files too as all JavaScript is valid TypeScript.)
"
1435070164,1407,Middleware that does not mutate the store cannot be composed with middleware that does (not),"Hi, I'm working on updating [zustand-middleware-yjs](/joebobmiles/zustand-middleware-yjs) to the latest version of Zustand. One of my tests is to verify composing middleware still works, and TypeScript is giving the following type error when I compose the Yjs middleware with the Immer middleware:

```
Argument of type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to parameter of type 'StateCreator<Store, [], [], Store>'.
  Type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
    Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
        Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
          Source has 1 element(s) but target allows only 0.
```

From the docs I know there are two ways to type a middleware: the 'no mutation' style and the 'with mutation' style. The yjs middleware does not mutate the store, so I've opted for the former when choosing the types:

```ts
type Yjs = <
  T extends unknown,
  InMutators extends [StoreMutatorIdentifier, unknown][] = [],
  OutMutators extends [StoreMutatorIdentifier, unknown][] = []
>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, InMutators, OutMutators>,
) => StateCreator<T, InMutators, OutMutators>;

type YjsImpl = <T extends unknown>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, [], []>,
) => StateCreator<T, [], []>;
```

However, I also notice that while the Immer middleware technically _doesn't_ mutate the store, it still uses the later 'with mutation' style of typing. The two styles are incompatible according to TypeScript, but as far as I've seen, the documentation doesn't warn you from trying to compose middleware that use the different styles.

So are the two styles supposed to be compatible and is this a bug? Or are they incompatible and middleware intended to be composed together should always default to the 'with mutation' style of typing, and it's not documented?",1304382960,"> I've read the [typescript guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md), in particular that create is to be used as create<T>()(...) and not create<T>(...).

I guess that's what I get for not paging through change notes and jumping from 3.5 to 4. It is devilishly easy to gloss over that initial parenthesis or even mistake it for a typo if you don't read that introductory paragraph.

Thanks for the help!"
1435070164,1407,Middleware that does not mutate the store cannot be composed with middleware that does (not),"Hi, I'm working on updating [zustand-middleware-yjs](/joebobmiles/zustand-middleware-yjs) to the latest version of Zustand. One of my tests is to verify composing middleware still works, and TypeScript is giving the following type error when I compose the Yjs middleware with the Immer middleware:

```
Argument of type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to parameter of type 'StateCreator<Store, [], [], Store>'.
  Type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
    Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
        Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
          Source has 1 element(s) but target allows only 0.
```

From the docs I know there are two ways to type a middleware: the 'no mutation' style and the 'with mutation' style. The yjs middleware does not mutate the store, so I've opted for the former when choosing the types:

```ts
type Yjs = <
  T extends unknown,
  InMutators extends [StoreMutatorIdentifier, unknown][] = [],
  OutMutators extends [StoreMutatorIdentifier, unknown][] = []
>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, InMutators, OutMutators>,
) => StateCreator<T, InMutators, OutMutators>;

type YjsImpl = <T extends unknown>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, [], []>,
) => StateCreator<T, [], []>;
```

However, I also notice that while the Immer middleware technically _doesn't_ mutate the store, it still uses the later 'with mutation' style of typing. The two styles are incompatible according to TypeScript, but as far as I've seen, the documentation doesn't warn you from trying to compose middleware that use the different styles.

So are the two styles supposed to be compatible and is this a bug? Or are they incompatible and middleware intended to be composed together should always default to the 'with mutation' style of typing, and it's not documented?",1304383585,"Yes I understand, it's a bit unintuitive without the docs... Hence my suggestion has always been that we only have one way of writing it ie with extra parenthesis, in that case users won't need docs (as you'll have to call `create` with no parameters first or else it won't type-check).

And no problems!"
1435070164,1407,Middleware that does not mutate the store cannot be composed with middleware that does (not),"Hi, I'm working on updating [zustand-middleware-yjs](/joebobmiles/zustand-middleware-yjs) to the latest version of Zustand. One of my tests is to verify composing middleware still works, and TypeScript is giving the following type error when I compose the Yjs middleware with the Immer middleware:

```
Argument of type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to parameter of type 'StateCreator<Store, [], [], Store>'.
  Type 'StateCreator<Store, [], [[""zustand/immer"", never]], Store>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
    Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
        Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
          Source has 1 element(s) but target allows only 0.
```

From the docs I know there are two ways to type a middleware: the 'no mutation' style and the 'with mutation' style. The yjs middleware does not mutate the store, so I've opted for the former when choosing the types:

```ts
type Yjs = <
  T extends unknown,
  InMutators extends [StoreMutatorIdentifier, unknown][] = [],
  OutMutators extends [StoreMutatorIdentifier, unknown][] = []
>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, InMutators, OutMutators>,
) => StateCreator<T, InMutators, OutMutators>;

type YjsImpl = <T extends unknown>(
  doc: Y.Doc,
  name: string,
  creator: StateCreator<T, [], []>,
) => StateCreator<T, [], []>;
```

However, I also notice that while the Immer middleware technically _doesn't_ mutate the store, it still uses the later 'with mutation' style of typing. The two styles are incompatible according to TypeScript, but as far as I've seen, the documentation doesn't warn you from trying to compose middleware that use the different styles.

So are the two styles supposed to be compatible and is this a bug? Or are they incompatible and middleware intended to be composed together should always default to the 'with mutation' style of typing, and it's not documented?",1304393047,"> @dai-shi I'd suggest adding an issue template that looks something like this...

Yeah, let's do that."
1429034822,1400,Rerenders MUI DataGrid when updating the selection model,"I'm trying to use Zustand with MUI DataGrid, so I set up a store that has the table data state and the selection model state. When I update the selection model, which is just an array of row ids returned from the table, it's causing a re-render of the entire table. If I set up a local selection model state with `useState`, the issue is gone. Any ideas why?

```js
import create from ""zustand"";

export const useCustomersStore = create((set) => {
  return {
    customerList: [],
    selectedCustomersList: [],
    setCustomerList: (customerList) => {
      set({ customerList });
    },
    setSelectedCustomersList: (ids) => {
      set({ selectedCustomersList: ids });
    },
  };
});

```",,
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1298938975,"Does anyone like me think this might have something to do with the [""Dual Package Hazard""](https://nodejs.org/api/packages.html#:~:text=The%20reason%20that,to%2Dtroubleshoot%20bugs.) caused by multiple instances of a same dependency?

> The reason that state is an issue is because both the CommonJS and ES module versions of the package might get used within an application; for example, the user's application code could `import` the ES module version while a dependency `require`s the CommonJS version. If that were to occur, two copies of the package would be loaded in memory and therefore two separate states would be present. This would likely cause hard-to-troubleshoot bugs."
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1299336578,"Zustand library itself shouldn't suffer from Dual Package Hazard, because it doesn't have module state. (On the other hand, Jotai and Valtio have module state, so they can suffer.)"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1299541035,"@dai-shi yeah you're right it is not caused by zustand library itself. I did some test and I saw this error is triggered when `useDebugValue` is called on the server side. This simple patch will make the code work. Not sure about the proper way to fix this though:

```diff
diff --git a/node_modules/zustand/esm/index.mjs b/node_modules/zustand/esm/index.mjs
index 2c76b55..73ad140 100644
--- a/node_modules/zustand/esm/index.mjs
+++ b/node_modules/zustand/esm/index.mjs
@@ -13,7 +13,9 @@ function useStore(api, selector = api.getState, equalityFn) {
     selector,
     equalityFn
   );
-  useDebugValue(slice);
+  if (typeof window !== ""undefined"") {
+    useDebugValue(slice);
+  }
   return slice;
 }
 const createImpl = (createState) => {
```"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1299560774,"Ah, maybe because React doesn't provide ESM.
Can you try this?
```js
// ./node_modules/zustand/esm/index.mjs
import React from 'react'

// ...
  React.useDebugValue(slice)
```"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1299565271,"> Ah, maybe because React doesn't provide ESM. Can you try this?
> 
> ```js
> // ./node_modules/zustand/esm/index.mjs
> import React from 'react'
> 
> // ...
>   React.useDebugValue(slice)
> ```

nope, this won't work, same error."
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1299639850,"These two issues might be relevant? (but neither solves this problem)
https://github.com/vercel/next.js/issues/41929
https://github.com/react-bootstrap/react-bootstrap/issues/6475
and this doc:
https://beta.nextjs.org/docs/rendering/server-and-client-components"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1299657960,I start thinking that this issue may be a misuse of the nextjs 13 `appDir` feature? If I follow the [docs](https://beta.nextjs.org/docs/upgrade-guide#migrating-from-pages-to-app) to setup/migrate the app to nextjs 13. Everything just works: https://stackblitz.com/edit/nextjs-od7fky?file=app/Button.jsx Maybe we shouldn't keep the `appDir` `true` while using the `pages` dir?
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1302166307,https://github.com/pmndrs/jotai/issues/1529#issuecomment-1302156604
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1302168609,Same issue without appDir is enabled
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1309432987,Hi everyone! Just want to note that we're looking into this on the nextjs team.
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1311553041,@jescalan Good news! Anywhere we can track progress of the investigation?
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1312230518,"No, it's generally in our company slack. We will have something out for this soon though, it's an active priority. The core issue is the ESM thing mentioned above, which is also causing bugs with a number of other things."
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1312587483,@jescalan any suggestions on state management tools similar to Zustand in the mean time?
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1315195190,"We also facing a issue when we want to load the store into a file which is located at /app/contact.tsx (It gives an error like: `
Unhandled Runtime Error
Error: useRef is not a function
`)

contact.tsx
```
import useBearStore from '../../stores/cart'

function HomePage() {
  const { bears } = useBearStore();
  return (
    <main>
      Contact
      { bears }
    </main>
  )
}

export default HomePage;
```"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1315217334,"> We also facing a issue when we want to load the store into a file which is located at /app/contact.tsx (It gives an error like: `Unhandled Runtime Error Error: useRef is not a function`)
> 
> contact.tsx
> 
> ```
> import useBearStore from '../../stores/cart'
> 
> function HomePage() {
>   const { bears } = useBearStore();
>   return (
>     <main>
>       Contact
>       { bears }
>     </main>
>   )
> }
> 
> export default HomePage;
> ```

@nhatimme Have you tried adding `'use client';` at the very first line.  [Reference in this link](https://beta.nextjs.org/docs/rendering/server-and-client-components#convention)"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1315247726,@adriannecris Thanks. So it is impossible to use it as Server Side component?
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1319430847,"Yeah, it's never going to be possible to use zustand in a server component, as state is not supported by server components in general. It works quite well in app directory right now as long as you are using client components. Actually I think it may be working fine with the latest version of nextjs, [I just made a reproduction repo here](https://github.com/jescalan/zustand-next13-testing) and everything is working quite nicely. This includes an example of it working both in pages and app directory.

Let me know if I missed anything or if anyone has a reproduction with the latest version - hopefully this can be closed out!

Edit: confirmed that updating to `13.0.3` [in the original stackblitz](https://stackblitz.com/edit/nextjs-sqjkod?file=package.json) fixes the issue"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1319953597,@jescalan: Perfect.
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1338656728,"still having this issue im 13.0.6 now
"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1345436594,"can use it just fine after add ""use client"""
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1416239334,"> @adriannecris Thanks. So it is impossible to use it as Server Side component?

you may be able to use useBearStore.setState(...) / useBearStore.getState().myVal in the server side without an issue."
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1416241075,all client based hook should be used after adding 'use client' on top of the file. But Next13 does not give a good error message where is missing. That is really tough since I have to find it manually.
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1450636002,"> can use it just fine after add ""use client""

@vlausargs Which files are you labelling 'use client'? I have tried adding it to all files that import anything from zustand and I'm still seeing the error appearing:
```
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
```"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1454993341,"> > can use it just fine after add ""use client""
> 
> @vlausargs Which files are you labelling 'use client'? I have tried adding it to all files that import anything from zustand and I'm still seeing the error appearing:
> 
> ```
> Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
> 1. You might have mismatching versions of React and the renderer (such as React DOM)
> 2. You might be breaking the Rules of Hooks
> 3. You might have more than one copy of React in the same app
> See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
> TypeError: Cannot read properties of null (reading 'useDebugValue')
> ```
it could be because of a lot of reason and next 13 sometimes gives not even relative error.  worst part is it ia hard to tell where is the origin of the error.. you might want to move all page and app path to somewhere else not in the app directory to narrow down where is the origin of the issue.
but some of cases you may check to figure out where is it coming from, tty below.. not 100% sure though. 
make sure if you wrap the component that uses ""use client"" as a separated component to use it in the server component. you may be using ""use client"" in the page.jsx file. async component cannot be used with client component. 
you may call hook after returning content.
you shouldnt use hook in the server or async component.

"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1552057105,"We encountered this error when using Next.js 13.4 with a custom server, even though we were not using the new app dir. I believe the problem is explained here: https://github.com/vercel/next.js/issues/49355#issuecomment-1537536063

We've fixed this for now by specifying our Next.js version as `~13.3.4`"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1558578090,"It seems like this issue is fixed with `next@13.4.3` for custom server (my use case). This issue is tracked in Next.js https://github.com/vercel/next.js/issues/49355, it is not related to just zustand. I think this issue should be closed."
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1646554830,"it is working fine when I tried it you can see it below example:
https://codesandbox.io/p/sandbox/cocky-mcclintock-38j52j?file=%2Fapp%2Fpage.tsx%3A13%2C28"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1657212696,I think this issue should be closed.
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1657229294,"Zustand has been working fine in my nextjs project with app dir, so I'm closing this issue now. "
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1705328752,"still getting same error, on `pages` directory.
Using following version of next and zustand:

```
    ""next"": ""13.4.19"",
    ""zustand"": ""^4.4.1""
```"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1707962889,Issue seems to appear again with next `13.4.19`
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1717723782,"> still getting same error, on `pages` directory. Using following version of next and zustand:
> 
> ```
>     ""next"": ""13.4.19"",
>     ""zustand"": ""^4.4.1""
> ```

Did you try deleting `.next` folder?"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1783619389,"It started reproducing again in Next v14, pages dir in the Docker. App dir is fine.

I've tried `ppr: true` won't help
![image](https://github.com/pmndrs/zustand/assets/11524061/798536a3-8b0c-4d33-9e54-a9a2def46a9e)

Zustand version is 4.4.4"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1783638385,"Please try #2154 
https://ci.codesandbox.io/status/pmndrs/zustand/pr/2154
☝️ Find ""Local Install Instructions"""
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1783750166,it was fast! Thanks!
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1805016906,"Issue not fixed yet it seems. I face the issue with ` ""next"": ""13.4.19"", ""zustand"": ""^4.4.1""` and page dir."
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1805259149,@JanRuettinger update Zustand to the latest version 
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1867178694,"This issue appears again on `""next"": ""14.0.3"", ""zustand"": ""^4.4.7""`"
1426362542,1395,Zustand breaks with NextJS 13 when enabling appDir (Cannot read properties of null (reading 'useDebugValue')),"I created a minimal reproduction here: 
https://stackblitz.com/edit/nextjs-egfcaj?file=package.json

It throws the following error: 
```bash
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
TypeError: Cannot read properties of null (reading 'useDebugValue')
    at Module.useDebugValue (/home/projects/nextjs-egfcaj/node_modules/react/cjs/react.development.js:1659:23)
    at useStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:37:10)
    at useBoundStore (file:///home/projects/nextjs-egfcaj/node_modules/zustand/esm/index.mjs:42:51)
    at __WEBPACK_DEFAULT_EXPORT__ (webpack-internal:///./pages/index.js:20:19)
```

If you remove the ""appDir: true"" line from next.config.js, the counter works as expected. The weirdest thing is that the project doesn't even use the app dir, just enabling the flag is enough for the error to happen.
After a bit of debugging in my project, comparing the useDebugValue that is imported by zustand and the one I imported in my component, they are not equal. Seems like the multiple react copies error, although there is only one react version installed.

I also tried zustand version 3, it throws a similar error, but with the useReducer hook instead of useDebugValue.
I also tried the version from here: https://github.com/pmndrs/zustand/issues/1392 but it didn't help.

Relevant NextJS discussion: https://github.com/vercel/next.js/discussions/41236",1908781270,"Issue is here again on `""next"": ""14.1.0"", ""zustand"": ""^4.5.0""`"
1424843902,1392,"Zustand/middleware - devtools - NextJS 13 w/ Turbopack Error: ""Cannot use 'import.meta' outside a module""","With the announcement at NextJS Conf, I was eager to try out the speeds of [Turbopack](https://nextjs.org/blog/next-13#introducing-turbopack-alpha). I installed and setup the most basic state for Zustand and was presented with the follow error that's specific to  `'zustand/middleware'` `devtools` integration:

```
\\?\..\.next\server\pages\renderer\home\chunks\node_modules_zustand_8c2e96.js:430
            extensionConnector = (enabled != null ? enabled : (import.meta.env && import.meta.env.MODE) !== ""production"") && window.__REDUX_DEVTOOLS_EXTENSION__;
                                                                      ^^^^

SyntaxError: Cannot use 'import.meta' outside a module
    at Object.compileFunction (node:vm:352:18)
    at wrapSafe (node:internal/modules/cjs/loader:1033:15)
    at Module._compile (node:internal/modules/cjs/loader:1069:27)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Module.require (node:internal/modules/cjs/loader:1005:19)
    at require (node:internal/modules/cjs/helpers:102:18)
    at Object.<anonymous> (\\?\D:\Developer\home-x\.next\server\pages\renderer\home\index.js:4:1)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
```

It's worth noting that the error only occurs using the ""Turbopack"" command `next dev --turbo`.",1292893386,"Thanks for reporting!
Hm, it uses cjs/loader, but picks ""esm"".
I wonder if they use ""module"" condition or ""import"" condition, but maybe we shouldn't use `import.meta` for ""module"" condition.
"
1424843902,1392,"Zustand/middleware - devtools - NextJS 13 w/ Turbopack Error: ""Cannot use 'import.meta' outside a module""","With the announcement at NextJS Conf, I was eager to try out the speeds of [Turbopack](https://nextjs.org/blog/next-13#introducing-turbopack-alpha). I installed and setup the most basic state for Zustand and was presented with the follow error that's specific to  `'zustand/middleware'` `devtools` integration:

```
\\?\..\.next\server\pages\renderer\home\chunks\node_modules_zustand_8c2e96.js:430
            extensionConnector = (enabled != null ? enabled : (import.meta.env && import.meta.env.MODE) !== ""production"") && window.__REDUX_DEVTOOLS_EXTENSION__;
                                                                      ^^^^

SyntaxError: Cannot use 'import.meta' outside a module
    at Object.compileFunction (node:vm:352:18)
    at wrapSafe (node:internal/modules/cjs/loader:1033:15)
    at Module._compile (node:internal/modules/cjs/loader:1069:27)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Module.require (node:internal/modules/cjs/loader:1005:19)
    at require (node:internal/modules/cjs/helpers:102:18)
    at Object.<anonymous> (\\?\D:\Developer\home-x\.next\server\pages\renderer\home\index.js:4:1)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
```

It's worth noting that the error only occurs using the ""Turbopack"" command `next dev --turbo`.",1292899748,"Can you try this?
https://ci.codesandbox.io/status/pmndrs/zustand/pr/1393
See ""Local Install Instruction"" ☝️ 
"
1424843902,1392,"Zustand/middleware - devtools - NextJS 13 w/ Turbopack Error: ""Cannot use 'import.meta' outside a module""","With the announcement at NextJS Conf, I was eager to try out the speeds of [Turbopack](https://nextjs.org/blog/next-13#introducing-turbopack-alpha). I installed and setup the most basic state for Zustand and was presented with the follow error that's specific to  `'zustand/middleware'` `devtools` integration:

```
\\?\..\.next\server\pages\renderer\home\chunks\node_modules_zustand_8c2e96.js:430
            extensionConnector = (enabled != null ? enabled : (import.meta.env && import.meta.env.MODE) !== ""production"") && window.__REDUX_DEVTOOLS_EXTENSION__;
                                                                      ^^^^

SyntaxError: Cannot use 'import.meta' outside a module
    at Object.compileFunction (node:vm:352:18)
    at wrapSafe (node:internal/modules/cjs/loader:1033:15)
    at Module._compile (node:internal/modules/cjs/loader:1069:27)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Module.require (node:internal/modules/cjs/loader:1005:19)
    at require (node:internal/modules/cjs/helpers:102:18)
    at Object.<anonymous> (\\?\D:\Developer\home-x\.next\server\pages\renderer\home\index.js:4:1)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
```

It's worth noting that the error only occurs using the ""Turbopack"" command `next dev --turbo`.",1293591764,"Tested with and without Turbopack, works great! Thanks for fix!"
1424843902,1392,"Zustand/middleware - devtools - NextJS 13 w/ Turbopack Error: ""Cannot use 'import.meta' outside a module""","With the announcement at NextJS Conf, I was eager to try out the speeds of [Turbopack](https://nextjs.org/blog/next-13#introducing-turbopack-alpha). I installed and setup the most basic state for Zustand and was presented with the follow error that's specific to  `'zustand/middleware'` `devtools` integration:

```
\\?\..\.next\server\pages\renderer\home\chunks\node_modules_zustand_8c2e96.js:430
            extensionConnector = (enabled != null ? enabled : (import.meta.env && import.meta.env.MODE) !== ""production"") && window.__REDUX_DEVTOOLS_EXTENSION__;
                                                                      ^^^^

SyntaxError: Cannot use 'import.meta' outside a module
    at Object.compileFunction (node:vm:352:18)
    at wrapSafe (node:internal/modules/cjs/loader:1033:15)
    at Module._compile (node:internal/modules/cjs/loader:1069:27)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Module.require (node:internal/modules/cjs/loader:1005:19)
    at require (node:internal/modules/cjs/helpers:102:18)
    at Object.<anonymous> (\\?\D:\Developer\home-x\.next\server\pages\renderer\home\index.js:4:1)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
```

It's worth noting that the error only occurs using the ""Turbopack"" command `next dev --turbo`.",1510427647,"> Thanks for reporting! Hm, it uses cjs/loader, but picks ""esm"". I wonder if they use ""module"" condition or ""import"" condition, but maybe we shouldn't use `import.meta` for ""module"" condition.

get the same error on [rspack](https://github.com/web-infra-dev/rspack)

<img width=""610"" alt=""image"" src=""https://user-images.githubusercontent.com/6551888/232327130-eec9a93e-9be1-4bfc-aa78-07b518b6db37.png"">
"
1424843902,1392,"Zustand/middleware - devtools - NextJS 13 w/ Turbopack Error: ""Cannot use 'import.meta' outside a module""","With the announcement at NextJS Conf, I was eager to try out the speeds of [Turbopack](https://nextjs.org/blog/next-13#introducing-turbopack-alpha). I installed and setup the most basic state for Zustand and was presented with the follow error that's specific to  `'zustand/middleware'` `devtools` integration:

```
\\?\..\.next\server\pages\renderer\home\chunks\node_modules_zustand_8c2e96.js:430
            extensionConnector = (enabled != null ? enabled : (import.meta.env && import.meta.env.MODE) !== ""production"") && window.__REDUX_DEVTOOLS_EXTENSION__;
                                                                      ^^^^

SyntaxError: Cannot use 'import.meta' outside a module
    at Object.compileFunction (node:vm:352:18)
    at wrapSafe (node:internal/modules/cjs/loader:1033:15)
    at Module._compile (node:internal/modules/cjs/loader:1069:27)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Module.require (node:internal/modules/cjs/loader:1005:19)
    at require (node:internal/modules/cjs/helpers:102:18)
    at Object.<anonymous> (\\?\D:\Developer\home-x\.next\server\pages\renderer\home\index.js:4:1)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
```

It's worth noting that the error only occurs using the ""Turbopack"" command `next dev --turbo`.",1510548984,"It happens when when a bundler picks ""import"" condition, but it doesn't let browsers to load as ESM.

In Jotai, we discuss about possible migration paths until all bundlers support ESM fully.

FYI,
> maybe we shouldn't use import.meta for ""module"" condition.

We no longer use `import.meta` for ""module""."
1424843902,1392,"Zustand/middleware - devtools - NextJS 13 w/ Turbopack Error: ""Cannot use 'import.meta' outside a module""","With the announcement at NextJS Conf, I was eager to try out the speeds of [Turbopack](https://nextjs.org/blog/next-13#introducing-turbopack-alpha). I installed and setup the most basic state for Zustand and was presented with the follow error that's specific to  `'zustand/middleware'` `devtools` integration:

```
\\?\..\.next\server\pages\renderer\home\chunks\node_modules_zustand_8c2e96.js:430
            extensionConnector = (enabled != null ? enabled : (import.meta.env && import.meta.env.MODE) !== ""production"") && window.__REDUX_DEVTOOLS_EXTENSION__;
                                                                      ^^^^

SyntaxError: Cannot use 'import.meta' outside a module
    at Object.compileFunction (node:vm:352:18)
    at wrapSafe (node:internal/modules/cjs/loader:1033:15)
    at Module._compile (node:internal/modules/cjs/loader:1069:27)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Module.require (node:internal/modules/cjs/loader:1005:19)
    at require (node:internal/modules/cjs/helpers:102:18)
    at Object.<anonymous> (\\?\D:\Developer\home-x\.next\server\pages\renderer\home\index.js:4:1)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
```

It's worth noting that the error only occurs using the ""Turbopack"" command `next dev --turbo`.",1511629627,"> It happens when when a bundler picks ""import"" condition, but it doesn't let browsers to load as ESM.
> 
> In Jotai, we discuss about possible migration paths until all bundlers support ESM fully.
> 
> FYI,
> 
> > maybe we shouldn't use import.meta for ""module"" condition.
> 
> We no longer use `import.meta` for ""module"".

I'm using the latest zustand, still getting this error. Is there some kind of webpack configuration to bypass this issue?"
1424843902,1392,"Zustand/middleware - devtools - NextJS 13 w/ Turbopack Error: ""Cannot use 'import.meta' outside a module""","With the announcement at NextJS Conf, I was eager to try out the speeds of [Turbopack](https://nextjs.org/blog/next-13#introducing-turbopack-alpha). I installed and setup the most basic state for Zustand and was presented with the follow error that's specific to  `'zustand/middleware'` `devtools` integration:

```
\\?\..\.next\server\pages\renderer\home\chunks\node_modules_zustand_8c2e96.js:430
            extensionConnector = (enabled != null ? enabled : (import.meta.env && import.meta.env.MODE) !== ""production"") && window.__REDUX_DEVTOOLS_EXTENSION__;
                                                                      ^^^^

SyntaxError: Cannot use 'import.meta' outside a module
    at Object.compileFunction (node:vm:352:18)
    at wrapSafe (node:internal/modules/cjs/loader:1033:15)
    at Module._compile (node:internal/modules/cjs/loader:1069:27)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Module.require (node:internal/modules/cjs/loader:1005:19)
    at require (node:internal/modules/cjs/helpers:102:18)
    at Object.<anonymous> (\\?\D:\Developer\home-x\.next\server\pages\renderer\home\index.js:4:1)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
```

It's worth noting that the error only occurs using the ""Turbopack"" command `next dev --turbo`.",1512331804,"check these:
- https://webpack.js.org/guides/package-exports/
- https://webpack.js.org/configuration/resolve/#resolveconditionnames

```js
module.exports = {
  //...
  resolve: {
    conditionNames: ['module'],
  },
};
```"
1423733024,1389,The example for createSelectors no longer works in zustand 4.1.3,"As seen here: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md and in the linked [codesandbox](https://codesandbox.io/s/zustand-auto-generate-selectors-forked-7wzsuz?file=/src/selectors.ts).  

Just set zustand to the latest version (4.1.3 as of this moment) and you'll see the type errors",1291771646,maybe examples like this should be part of the test suite somehow. I'm not sure how that would work though.
1423733024,1389,The example for createSelectors no longer works in zustand 4.1.3,"As seen here: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md and in the linked [codesandbox](https://codesandbox.io/s/zustand-auto-generate-selectors-forked-7wzsuz?file=/src/selectors.ts).  

Just set zustand to the latest version (4.1.3 as of this moment) and you'll see the type errors",1291862597,"Thanks for reporting. Looks like this is because the change in v4.1.0 #1144 and #1199.
From the library perspective, it's an intentional change.
Let's update the example. 
How's this: https://codesandbox.io/s/zustand-auto-generate-selectors-forked-y1zfso?file=/src/selectors.ts"
1423733024,1389,The example for createSelectors no longer works in zustand 4.1.3,"As seen here: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md and in the linked [codesandbox](https://codesandbox.io/s/zustand-auto-generate-selectors-forked-7wzsuz?file=/src/selectors.ts).  

Just set zustand to the latest version (4.1.3 as of this moment) and you'll see the type errors",1292132250,"works for me. my only suggestion is to explicitly type `s` in `(store.use as any)[k] = () => store((s) => s[k as keyof typeof s]);` 

Otherwise, it's nice. thanks :)"
1423733024,1389,The example for createSelectors no longer works in zustand 4.1.3,"As seen here: https://github.com/pmndrs/zustand/blob/main/docs/guides/auto-generating-selectors.md and in the linked [codesandbox](https://codesandbox.io/s/zustand-auto-generate-selectors-forked-7wzsuz?file=/src/selectors.ts).  

Just set zustand to the latest version (4.1.3 as of this moment) and you'll see the type errors",1292198484,You are welcome to open a PR. I'll also let the doc/website team know and see if someone can take it.
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1288243991,"Thanks for reporting.

Can anyone elaborate this issue? How can we declare types for mjs entrypoints?

(It looks the same if you import `create` from `zustand`. https://stackblitz.com/edit/node-mcrpwh?file=src%2Findex.ts )"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1289942729,"I think I find the reason why zustand does not work properly as an esm import.

While I was searching for related problems, I bumped into this solved issue: https://github.com/hayes/pothos/issues/597, which was also an esm module resolution problem. The author finally got his package fixed after several pushes and I noticed [one of his comments](https://github.com/hayes/pothos/issues/597#issuecomment-1263441108):

> thanks, I think I see what's going in. Looks like some imports in the esm definintions are not working correctly because they are importing directories rather than explicitly asking for `dir/index.js`

and

> ... Needed to transform all the imports to include the full file path...

So I first checked his [`package.json`](https://cdn.jsdelivr.net/npm/@pothos/core@3.22.8/package.json):
```json
  ""main"": ""./lib/index.js"",
  ""types"": ""./dts/index.d.ts"",
  ""module"": ""./esm/index.js"",
  ""exports"": {
    ""import"": {
      ""default"": ""./esm/index.js""
    },
    ""require"": {
      ""types"": ""./dts/index.d.ts"",
      ""default"": ""./lib/index.js""
    }
  },
```

And according to this configuration, typescript will use [`./dts/index.d.ts`](https://cdn.jsdelivr.net/npm/@pothos/core@3.22.8/dts/index.d.ts) when this module is resolved as a cjs module and will use [`./esm/index.d.ts`](https://cdn.jsdelivr.net/npm/@pothos/core@3.22.8/esm/index.d.ts) when it is resolved as an es module. By comparing these two typedef files, we can find that **the `.js` extension** is needed in all the `export` or `import` statements in an esm typedef file:
<details>
  <summary>diff ./esm/index.d.ts ./dts/index.d.ts</summary>

  ```diff
  @@ -1,11 +1,11 @@
  -import './types/global';
  -import SchemaBuilderClass from './builder';
  -import type { FieldKind, NormalizeSchemeBuilderOptions, SchemaTypes } from './types';
  -export * from './plugins';
  -export * from './types';
  -export * from './utils';
  +import './types/global/index.js';
  +import SchemaBuilderClass from './builder.js';
  +import type { FieldKind, NormalizeSchemeBuilderOptions, SchemaTypes } from './types/index.js';
  +export * from './plugins/index.js';
  +export * from './types/index.js';
  +export * from './utils/index.js';
   declare const SchemaBuilder: {
  -    new <Types extends Partial<PothosSchemaTypes.UserSchemaTypes> = {}>(options: import(""./types"").RemoveNeverKeys<PothosSchemaTypes.SchemaBuilderOptions<PothosSchemaTypes.ExtendDefaultTypes<Types>>>): PothosSchemaTypes.SchemaBuilder<PothosSchemaTypes.ExtendDefaultTypes<Types>>;
  +    new <Types extends Partial<PothosSchemaTypes.UserSchemaTypes> = {}>(options: import(""./types/index.js"").RemoveNeverKeys<PothosSchemaTypes.SchemaBuilderOptions<PothosSchemaTypes.ExtendDefaultTypes<Types>>>): PothosSchemaTypes.SchemaBuilder<PothosSchemaTypes.ExtendDefaultTypes<Types>>;
       registerPlugin: typeof SchemaBuilderClass.registerPlugin;
       allowPluginReRegistration: boolean;
   };
  @@ -23,10 +23,10 @@ export declare type ObjectFieldBuilder<Types extends SchemaTypes, ParentShape> =
   export declare const ObjectFieldBuilder: new <Types extends SchemaTypes, ParentShape>(name: string, builder: SchemaBuilderClass<Types>) => PothosSchemaTypes.ObjectFieldBuilder<Types, ParentShape>;
   export declare type InterfaceFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.InterfaceFieldBuilder<Types, ParentShape>;
   export declare const InterfaceFieldBuilder: new <Types extends SchemaTypes, ParentShape>(name: string, builder: SchemaBuilderClass<Types>) => PothosSchemaTypes.InterfaceFieldBuilder<Types, ParentShape>;
  -export declare type InputFieldBuilder<Types extends SchemaTypes, Kind extends 'Arg' | 'InputObject' = 'Arg' | 'InputObject'> = PothosSchemaTypes.InputFieldBuilder<Types, Kind>;
  +export declare type InputFieldBuilder<Types extends SchemaTypes, Kind extends ""Arg"" | ""InputObject"" = ""Arg"" | ""InputObject""> = PothosSchemaTypes.InputFieldBuilder<Types, Kind>;
   export declare const InputFieldBuilder: new <Types extends SchemaTypes, Kind extends ""InputObject"" | ""Arg"" = ""InputObject"" | ""Arg"">(builder: SchemaBuilderClass<Types>, kind: Kind, typename: string) => PothosSchemaTypes.InputFieldBuilder<Types, Kind>;
   export declare type BaseTypeRef = PothosSchemaTypes.BaseTypeRef;
  -export declare const BaseTypeRef: new (kind: 'Enum' | 'InputObject' | 'Interface' | 'Object' | 'Scalar' | 'Union', name: string) => PothosSchemaTypes.BaseTypeRef;
  +export declare const BaseTypeRef: new (kind: ""Enum"" | ""InputObject"" | ""Interface"" | ""Object"" | ""Scalar"" | ""Union"", name: string) => PothosSchemaTypes.BaseTypeRef;
   export declare type EnumRef<T, P = T> = PothosSchemaTypes.EnumRef<T, P>;
   export declare const EnumRef: new <T, P = T>(name: string) => PothosSchemaTypes.EnumRef<T, P>;
   export declare type InputObjectRef<T> = PothosSchemaTypes.InputObjectRef<T>;
  @@ -39,13 +39,13 @@ export declare type ScalarRef<T, U, P = T> = PothosSchemaTypes.ScalarRef<T, U, P
   export declare const ScalarRef: new <T, U, P = T>(name: string) => PothosSchemaTypes.ScalarRef<T, U, P>;
   export declare type UnionRef<T, P = T> = PothosSchemaTypes.UnionRef<T, P>;
   export declare const UnionRef: new <T, P = T>(name: string) => PothosSchemaTypes.UnionRef<T, P>;
  -export { default as BuildCache } from './build-cache';
  -export { default as BuiltinScalarRef } from './refs/builtin-scalar';
  -export { default as FieldRef } from './refs/field';
  -export { default as InputTypeRef } from './refs/input';
  -export { default as InputFieldRef } from './refs/input-field';
  -export { ImplementableInputObjectRef } from './refs/input-object';
  -export { ImplementableInterfaceRef } from './refs/interface';
  -export { ImplementableObjectRef } from './refs/object';
  -export { default as OutputTypeRef } from './refs/output';
  -//# sourceMappingURL=index.d.ts.map
  \ No newline at end of file
  +export { default as BuildCache } from './build-cache.js';
  +export { default as BuiltinScalarRef } from './refs/builtin-scalar.js';
  +export { default as FieldRef } from './refs/field.js';
  +export { default as InputTypeRef } from './refs/input.js';
  +export { default as InputFieldRef } from './refs/input-field.js';
  +export { ImplementableInputObjectRef } from './refs/input-object.js';
  +export { ImplementableInterfaceRef } from './refs/interface.js';
  +export { ImplementableObjectRef } from './refs/object.js';
  +export { default as OutputTypeRef } from './refs/output.js';
  +//# sourceMappingURL=index.d.ts.map
  ```
</details>

And the reason is that typescript doesn't mutate any `import` or `export` statements when it compiles user's source code to generate typedefs. Therefore, if a package using typescript is not of type `module` while planning to support esm build and allowing other esm typescript projects to import it, the package will have to also include typedefs specifically for esm imports.

And that's why this problem occurs in zustand because it only generated cjs typedefs, i.e. no "".js"" extensions in the export or import statements:

**[index.d.ts](https://cdn.jsdelivr.net/npm/zustand@4.1.3/index.d.ts), this affects `zustand`:**
```d.ts
export * from './vanilla';
export * from './react';
export { default as createStore } from './vanilla';
export { default } from './react';
```

**[middleware/devtools.d.ts](https://cdn.jsdelivr.net/npm/zustand@4.1.3/middleware/devtools.d.ts), this and other middleware typedefs affect `zustand/vanilla`:**
```d.ts
import type { StateCreator, StoreApi, StoreMutatorIdentifier } from '../vanilla';

declare module '../vanilla' {
    interface StoreMutators<S, A> {
        'zustand/devtools': WithDevtools<S>;
    }
}
```

I am not familiar with the bundle/build scripts in generating or transforming these files, but I hope the above provided info can help you or other contributors locate the problem and fix it. ❤️ "
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1289973579,"@Sec-ant Thanks! Good investigation.
One thing I'm not sure is our `vanilla.d.ts` file doesn't have any imports from other files. So, why do you still have the issue with `import create from 'zustand/vanilla'`?"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1289981297,"> One thing I'm not sure is our `vanilla.d.ts` file doesn't have any imports from other files. So, why do you still have the issue with `import create from 'zustand/vanilla'`?

I think it is caused by the extended declarations in the middleware type files:

```d.ts
declare module '../vanilla' {
    interface StoreMutators<S, A> {
        'zustand/devtools': WithDevtools<S>;
    }
}
```

But I'm not sure, because I didn't import any middleware in my example. Maybe typescript will  analyze all the type files even if they are not imported?"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1289993183,"@Sec-ant If you have a chance, can you try hand-patch the d.ts files in your local folder (or use `patch-package`) and see if adding `.js` resolves the issue??"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1290164758,"@dai-shi OK, I made a simple test, and it seems that the .js extension is not the only problem, and hand patching them will not fix it (at least not for vanilla). It seems to be another totally different problem. I still do not fully understand whether it is a Typescript bug or not, but I'll show what I've got so far:

1. I cloned the zustand repo as `zustand-patch` locally
2. I ran the following commands to build:
    ```bash
    cd zustand-patch
    yarn
    yarn run build
    ```
3. Under the same path where `zustand-patch` is located, I used `yarn init` in another empty dir called `zustand-esm-test`
4. I used the following comands to install `zustand-patch` and `typescript` as dependencies
    ```bash
    yarn add zustand@link:../zustand-patch/dist
    yarn add -D typescript
    ```
5. In `zustand-esm-test`, the `package.json`, `tsconfig.json` and `src/index.ts` are respectively:
    <details>
      <summary>package.json</summary>
    
      ```json
      {
        ""name"": ""zustand-esm-test"",
        ""version"": ""1.0.0"",
        ""main"": ""index.js"",
        ""license"": ""MIT"",
        ""type"": ""module"",
        ""exports"": {
          ""types"": ""./dist/index.d.ts"",
          ""import"": ""./dist/index.js"",
          ""node"": ""./dist/index.js"",
          ""default"": ""./dist/index.js""
        },
        ""scripts"": {
          ""build"": ""yarn cache clean && tsc"",
          ""trace"": ""yarn cache clean && tsc --traceResolution --noEmit | grep vanilla"",
          ""test"": ""node ./dist/index.js""
        },
        ""dependencies"": {
          ""zustand"": ""link:../zustand-patch/dist""
        },
        ""devDependencies"": {
          ""typescript"": ""^4.8.4""
        }
      }
      ```
    </details>
    <details>
      <summary>tsconfig.json</summary>
    
      ```json
      {
        ""compilerOptions"": {
          ""outDir"": ""dist"",
          ""target"": ""ESNext"",
          ""module"": ""NodeNext"",
          ""moduleResolution"": ""NodeNext"",
          ""declaration"": true,
          ""declarationDir"": ""dist""
        },
        ""include"": [""src/**/*""]
      }
      ```
    </details>
    <details>
    <summary>src/index.ts</summary>
    
    ```ts
    import create from ""zustand/vanilla"";
    export const store = create(() => ({ foo: ""bar"" }));
    ```
    </details>

8. If I run `yarn run trace` in `zustand-esm-test` without modifying any files in the `zustand-patch`, the error occurs, and the output is:
    <details>
      <summary>output</summary>
      
      ```output
      success Cleared cache.
      ======== Resolving module 'zustand/vanilla' from '/home/secant/zustand-esm-test/src/index.ts'. ========
      Loading module 'zustand/vanilla' from 'node_modules' folder, target file type 'TypeScript'.
      File '/home/secant/zustand-esm-test/node_modules/zustand/vanilla.d.ts' exist - use it as a name resolution result.
      Resolving real path for '/home/secant/zustand-esm-test/node_modules/zustand/vanilla.d.ts', result '/home/secant/zustand-patch/dist/vanilla.d.ts'.
      ======== Module name 'zustand/vanilla' was successfully resolved to '/home/secant/zustand-patch/dist/vanilla.d.ts' with Package ID 'zustand/vanilla.d.ts@4.1.3'. ========
        Type 'typeof import(""/home/secant/zustand-patch/dist/vanilla"")' has no call signatures.
      Done in 3.11s.
      ```
    </details>

10. If I delete `./vanilla.d.ts` under `zustand-patch/dist/`, and in `zustand-esm-test` run `yarn run trace`, TSC can only find the `.mjs` file but no types (even under the `esm` directory, because TSC is looking for `vanilla.d.mts` not `vanilla.d.ts`), however this will build successfully (which is expected actually because no type is found):
    <details>
      <summary>output</summary>
    
      ```output
      success Cleared cache.
      ======== Resolving module 'zustand/vanilla' from '/home/secant/zustand-esm-test/src/index.ts'. ========
      Loading module 'zustand/vanilla' from 'node_modules' folder, target file type 'TypeScript'.
      File '/home/secant/zustand-esm-test/node_modules/zustand/vanilla.d.ts' does not exist.
      File name '/home/secant/zustand-esm-test/node_modules/zustand/esm/vanilla.mjs' has a '.mjs' extension - stripping it.
      File '/home/secant/zustand-esm-test/node_modules/zustand/esm/vanilla.mts' does not exist.
      File '/home/secant/zustand-esm-test/node_modules/zustand/esm/vanilla.d.mts' does not exist.
      File name '/home/secant/zustand-esm-test/node_modules/zustand/vanilla.js' has a '.js' extension - stripping it.
      File '/home/secant/zustand-esm-test/node_modules/zustand/vanilla.ts' does not exist.
      File '/home/secant/zustand-esm-test/node_modules/zustand/vanilla.tsx' does not exist.
      File '/home/secant/zustand-esm-test/node_modules/zustand/vanilla.d.ts' does not exist.
      Export specifier './vanilla' does not exist in package.json scope at path '/home/secant/zustand-esm-test/node_modules/zustand'.
      Loading module 'zustand/vanilla' from 'node_modules' folder, target file type 'JavaScript'.
      File name '/home/secant/zustand-esm-test/node_modules/zustand/esm/vanilla.mjs' has a '.mjs' extension - stripping it.
      File '/home/secant/zustand-esm-test/node_modules/zustand/esm/vanilla.mjs' exist - use it as a name resolution result.
      Resolving real path for '/home/secant/zustand-esm-test/node_modules/zustand/esm/vanilla.mjs', result '/home/secant/zustand-patch/dist/esm/vanilla.mjs'.
      ======== Module name 'zustand/vanilla' was successfully resolved to '/home/secant/zustand-patch/dist/esm/vanilla.mjs' with Package ID 'zustand/esm/vanilla.mjs@4.1.3'. ========
      Done in 3.01s.
      ```
    </details>

11. From above we can see that TSC respects the `exports` field in the `package.json`. But it seems that something is wrong with the type file, so I revert all the modifications and change the content in `./vanilla.d.ts` and run `yarn run trace` again. Well, again failed. I also tried remove all the middlewares but the error remained:
    <details>
      <summary>modified ./vanilla.d.ts</summary>
      
      ```d.ts
      declare const createStore: () => void
      export default createStore
      ```
    </details>
    <details>
      <summary>output</summary>
      
      ```output
      success Cleared cache.
      ======== Resolving module 'zustand/vanilla' from '/home/secant/zustand-esm-test/src/index.ts'. ========
      Loading module 'zustand/vanilla' from 'node_modules' folder, target file type 'TypeScript'.
      File '/home/secant/zustand-esm-test/node_modules/zustand/vanilla.d.ts' exist - use it as a name resolution result.
      Resolving real path for '/home/secant/zustand-esm-test/node_modules/zustand/vanilla.d.ts', result '/home/secant/zustand-patch/dist/vanilla.d.ts'.
      ======== Module name 'zustand/vanilla' was successfully resolved to '/home/secant/zustand-patch/dist/vanilla.d.ts' with Package ID 'zustand/vanilla.d.ts@4.1.3'. ========
        Type 'typeof import(""/home/secant/zustand-patch/dist/vanilla"")' has no call signatures.
      Done in 2.92s.
      ```
    </details>

13. And then I tried copy the `./vanilla.d.ts` and `./esm/vanilla.js` files into `zustand-esm-test/src`, and use `import create from ""./vanilla.js"";` to import and everything works just fine:
    <details>
      <summary>src/index.ts</summary>
      
      ```ts
      import create from ""./vanilla.js"";
      export const store = create(() => ({ foo: ""bar"" }));
      ```
    </details>

    <details>
      <summary>output</summary>
      
      ```output
      success Cleared cache.
      ======== Resolving module './vanilla.js' from '/home/secant/zustand-esm-test/src/index.ts'. ========
      Loading module as file / folder, candidate module location '/home/secant/zustand-esm-test/src/vanilla.js', target file type 'TypeScript'.
      File name '/home/secant/zustand-esm-test/src/vanilla.js' has a '.js' extension - stripping it.
      File '/home/secant/zustand-esm-test/src/vanilla.ts' does not exist.
      File '/home/secant/zustand-esm-test/src/vanilla.tsx' does not exist.
      File '/home/secant/zustand-esm-test/src/vanilla.d.ts' exist - use it as a name resolution result.
      ======== Module name './vanilla.js' was successfully resolved to '/home/secant/zustand-esm-test/src/vanilla.d.ts'. ========
      Done in 2.90s
      ```
    </details>

14. At this point, it seems that there is nothing wrong with types either. I'm starting to doubt that there's something buggy in typescript. 😮‍💨 "
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1290296210,"I have some promising findings:

If I change the `package.json > exports > ./vanilla > types` field from `""./vanilla.d.ts""` to `""./esm/vanilla.d.mts""` like this:

```json
""./vanilla"": {
  ""types"": ""./esm/vanilla.d.mts"",
  ""module"": ""./esm/vanilla.js"",
  ""import"": ""./esm/vanilla.mjs"",
  ""default"": ""./vanilla.js""
},
```

and add a new file: `dist/esm/vanilla.d.mts` whose content is copied from `dist/esm/vanilla.d.ts` (We can safely copy the content because no `import` or `export` is used in `vanilla`, so there's no `.js` extension issues, but of course in order for other exported subpaths to work, we'll have to consider this difference). We can finally get a successful output:

```output
success Cleared cache.
======== Resolving module 'zustand/vanilla' from '/home/secant/zustand-esm-test/src/index.ts'. ========
Loading module 'zustand/vanilla' from 'node_modules' folder, target file type 'TypeScript'.
File '/home/secant/zustand-esm-test/node_modules/zustand/esm/vanilla.d.mts' exist - use it as a name resolution result.
Resolving real path for '/home/secant/zustand-esm-test/node_modules/zustand/esm/vanilla.d.mts', result '/home/secant/zustand-patch/dist/esm/vanilla.d.mts'.
======== Module name 'zustand/vanilla' was successfully resolved to '/home/secant/zustand-patch/dist/esm/vanilla.d.mts' with Package ID 'zustand/esm/vanilla.d.mts@4.1.3'. ========
Done in 1.82s
```

As I understand it, the `.d.mts` extension is telling TSC to regard this type file as a type file of a package imported as an esmodule rather than a commonjs module, or otherwise because we don't have `type: ""module""` field in the `package.json`, TSC seems cannot decide which type of module we are expecting."
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1290307085,"Just about package.json:
Does this work?
```json
""./vanilla"": {
  ""types"": ""./vanilla.d.ts"",
  ""module"": ""./esm/vanilla.js"",
  ""import"": {
    ""types"": ""./esm/vanilla.d.mts"", // trying to apply this only for ""import""
    ""default"": ""./esm/vanilla.mjs"",
  },
  ""default"": ""./vanilla.js""
},
```"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1290316687,"> Just about package.json: Does this work?
> 
> ```json
> ""./vanilla"": {
>   ""types"": ""./vanilla.d.ts"",
>   ""module"": ""./esm/vanilla.js"",
>   ""import"": {
>     ""types"": ""./esm/vanilla.d.mts"", // trying to apply this only for ""import""
>     ""default"": ""./esm/vanilla.mjs"",
>   },
>   ""default"": ""./vanilla.js""
> },
> ```

Unfortunately no, TSC will use `./vanilla.d.ts` as the resolution result, but if you change the order like this, it will work:

```json
""./vanilla"": {
  ""import"": {
    ""types"": ""./esm/vanilla.d.mts"",
    ""default"": ""./esm/vanilla.mjs""
  },
  ""types"": ""./vanilla.d.ts"",
  ""module"": ""./esm/vanilla.js"",
  ""default"": ""./vanilla.js""
},
```"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1290335413,"I think there might be a better way to handle this, we can add a `package.json` file with `type: ""module""` in the `esm` folder, just like what [@pothos/core](https://cdn.jsdelivr.net/npm/@pothos/core@3.22.8/esm/package.json) did, and do not use `types` field in the beginning, but let TSC find the types automatically.

a `package.json` in esm folder
```json
{
  ""type"": ""module""
}
```

and something like this in the toplevel `package.json`:

```json
""./vanilla"": {
  ""module"": ""./esm/vanilla.js"",
  ""import"": ""./esm/vanilla.js"",
  ""default"": ""./vanilla.js""
}
```

will work.

We can also use the `.mjs` extension but then we'll have to generate a `.d.mts` type file along with it."
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1290351032,"> a `package.json` in esm folder
> 
> ```json
> {
>   ""type"": ""module""
> }
> ```

We did that once in some project, and there was a problem at that time. So, I would like to avoid it if the ""changing the order"" hack works."
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1290372040,"> We did that once in some project, and there was a problem at that time. So, I would like to avoid it if the ""changing the order"" hack works.

Ok, I'm fine with this approach. But if that's the case, I'm concerned that adding "".js"" extensions may also break some of the packages."
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1291221586,"> I'm concerned that adding "".js"" extensions may also break some of the packages.

Is it ☝️  about adding .js in *.d.mts files?

---

So, in summary, what we need to do is:
1. modify `package.json` so that ""import"" condition picks `esm/*.d.mts`.
2. rename `esm/*d.ts` to `esm/*.d.mts`.
3. add `.js` extension for import/export statements in `esm/*.d.mts`.

Sounds okay?"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1291484854,"> Is it ☝️ about adding .js in *.d.mts files?

Yes, I'm not sure whether this will break other runtime or bundlers. Specifically, what concerns me is [this](https://github.com/microsoft/TypeScript/issues/50152#:~:text=These%20bundlers%20use,the%20user%20experience.).

> So, in summary, what we need to do is:
> 
> 1. modify `package.json` so that ""import"" condition picks `esm/*.d.mts`.
> 2. rename `esm/*d.ts` to `esm/*.d.mts`.
> 3. add `.js` extension for import/export statements in `esm/*.d.mts`.
> 
> Sounds okay?

Basically yes. But 3 can be tricky if the transformation is applied on cjs type emits after build. And in our case, I think the extension should be `.mjs` rather than `.js`. I also tried to create and hand patch all the `*.d.mts` files (adding extensions), but the monorepo structure and somewhat a little complicated type declarations seemed to keep me hitting the walls. I'll leave these to you guys, but I'd be glad to do some testing if you need 😄"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1291690039,"@Sec-ant Can you try #1387?

I'm a little skeptical about the mjs extension.

```js
//  dist/esm/index.d.mts 
export * from './vanilla.mjs';
export * from './react.mjs'; // We don't have such a file!!!
export { default as createStore } from './vanilla.mjs';
export { default } from './react.mjs';
```"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1291751507,"![image](https://user-images.githubusercontent.com/10386119/197985734-eb49dd72-2b7f-4804-b9fc-d9db39d2469f.png)
I think we should take those extended declarations into consideration too?

```d.mts
declare module '../vanilla.mjs' { // <= not '../vanilla'
    interface StoreMutators<S, A> {
        'zustand/redux': WithRedux<S, A>;
    }
}
```

After I hand patched them, there were no more resolution errors, and I can get rid of `default-import` now and build successfully :)

My current project is not using react, so I need to look further into that.

And one more thing, do we need to keep the `.js` files in the `esm` folder? Are they kept for other tools that do not recognize `.mjs` files? If so, will renaming `.d.ts` to `.d.mts` break those tools?"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1291810549,"> I think we should take those extended declarations into consideration too?

Good point.

> After I hand patched them, there were no more resolution errors, and I can get rid of `default-import` now and build successfully :)

That's great to hear.

> My current project is not using react, so I need to look further into that.

Can you quickly check if any of middleware (except for immer) works for you? It's the same as `react.mjs`.

> And one more thing, do we need to keep the `.js` files in the `esm` folder? Are they kept for other tools that do not recognize `.mjs` files?

Yes, for ""module"" condition.

> If so, will renaming `.d.ts` to `.d.mts` break those tools?

Ah, now I get it. Yeah, it's safer to keep them."
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1291821554,"> Can you quickly check if any of middleware (except for immer) works for you? It's the same as `react.mjs`.

Already did that, I use `subscribeWithSelector` in my project and it works fine after all the extensions being added.

I also made a simple test on react, and I didn't find any problems:

👇 This piece of code will build just fine (with a `NodeNext` module resolution config):
```tsx
import React from ""react"";
import create from ""zustand"";
import { subscribeWithSelector } from ""zustand/middleware"";

interface BearState {
  bears: number;
}

interface BearControls {
  increasePopulation: () => void;
}

const useBearStore = create<BearState & BearControls>()(
  subscribeWithSelector((set) => ({
    bears: 0,
    increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
  }))
);

export function BearCounter() {
  const bears = useBearStore((state) => state.bears);
  return <h1>{bears} around here ...</h1>;
}

export function Controls() {
  const increasePopulation = useBearStore((state) => state.increasePopulation);
  return <button onClick={increasePopulation}>one up</button>;
}
```"
1419900262,1381,"TSC throws an error when compiling with ""moduleResolution"": ""NodeNext""","When I want to import the default `create` function from `zustand/vanilla` while setting `NodeNext` for both `module` and `moduleResolution` in `tsconfig.json`, TSC will throw an error: `error TS2349: This expression is not callable.`

I mentioned this issue in https://github.com/microsoft/TypeScript/issues/50058#issuecomment-1288155712. However, according to the reply, this is a zustand problem:

> `@zustand/vanilla` has incorrect types, again, it only declares types for a cjs entrypoint for everything, and that is the result of that mismatch.

Kindly request a fix on this problem, thanks!

In the meantime, I use [`default-import`](https://www.npmjs.com/package/default-import) as a temporary patch.

### this doesn't work
```ts
import create from ""zustand/vanilla"";
export const store = create(() => ({ foo: ""bar"" }));
```

### this works
```ts
import zustand from ""zustand/vanilla"";
import { defaultImport } from ""default-import"";
const create = defaultImport(zustand);
export const store = create(() => ({ foo: ""bar"" }));
```

A minimal repo to reproduce this problem: https://stackblitz.com/edit/node-vj368k?file=src/index.ts",1291846100,Sounds great!
1419207783,1377,NextJS + Zustand localStorage persist middleware causing hydration errors,"I am unable to persist a few states like the theme, layout etc in my Nextjs app using Zustand with the persist middleware. I'm using localStorage as the storage option. After refreshing the window, it causes a content mismatch error:

`Error: Hydration failed because the initial UI does not match what was rendered on the server.`

If this already is a known issue, how would I go about using the persist middleware whilst avoiding this? 

Thanks",1288316873,"With zustand v3, we use a custom storage engine and make get localStorage an async method. 

Haven't tried this workaround yet with v4, but it works with v3, and the latest next and react versions. 

See this comment: https://github.com/pmndrs/zustand/issues/1145#issuecomment-1202871214"
1418279968,1374,subscribeWithSelector doesn't fire or notify only on state changes that's passed to subscribe,"Hey folks,

I like Zustand a lot and would actually need to use it in between React and VanillaJS, however I'm running into problems. Am I using it incorrectly or is something not working correctly?

I'm referencing to this part of the documentation:

[Reading/writing state and reacting to changes outside of components](https://docs.pmnd.rs/zustand/recipes/recipes#reading/writing-state-and-reacting-to-changes-outside-of-components)

[I've also created a codesandbox to illustrate the problem:](https://codesandbox.io/s/npm-playground-forked-kkpxbc?file=/src/index.js)

It's very basic:
```javascript
import create from ""zustand"";
import { subscribeWithSelector } from ""zustand/middleware"";
const useStoreWithSelector = create(
  subscribeWithSelector(() => ({ paw: true, snout: true, fur: true }))
);

useStoreWithSelector.subscribe(console.log, (state) => state.paw);

useStoreWithSelector.setState({ paw: false });
useStoreWithSelector.setState({ fur: false });
```

What I'm expecting to happen is that only the changes to state.paw are going to be logged to the console, so basically two logs. One initial and one after it's set to false.

What's actually happening is that I get three logs because I'm getting the state logged when fur changes, too.

In your docs it's a similar example:
> // Listening to selected changes, in this case when ""paw"" changes
> const unsub2 = useStore.subscribe(console.log, state => state.paw)

Here's a console screenshot:
<img width=""326"" alt=""image"" src=""https://user-images.githubusercontent.com/15145968/197197669-94824649-e732-4e5c-8e24-f64952e6349b.png"">

However, that example also fails. And what's also failing in your docs is copying the whole segment and running it in a sandbox because of the use of shallow variable and not importing create first. I get that this second point is a bit nitpicky maybe but it would be neat to copy a block of code without running into errors first.",,
1412360201,1368,zustand 4.1.2 create() initializer type problems with store mutators,"I have a function that extracts out the initializer for a store to a function so that I can create many variants of a particular store, in this case various cache stores.

I was previously working with zustand 4.1.1 and the only type errors that I had were the getter and setter possibly being undefined, so I could suppress them using assertions.

After updating to zustand 4.1.2, there are now new type errors that prevent building, and I cannot for the life of me figure out what's going on with them.

I made a [minimal CodeSandbox demo of the problem available here](https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-zer3y6?file=/src/App.tsx).

A possibly notable observation is that without the `M` parameter, the type of `set` is reported to be `(partial: Cache<K, V> | Partial<Cache<K, V>> | ((state: Cache<K, V>) => Cache<K, V> | Partial<Cache<K, V>>), replace?: boolean | undefined) => void`.

With the `M` parameter, it instead becomes `Get<Mutate<StoreApi<Cache<K, V>>, M>, ""setState"", undefined>`.

The closest I've gotten to figuring out a possible cause is that the `Get` type might not be inferring that the `""setState""` and `""getState""` fields should (I think) be guaranteed to be present, but that's really just grasping at straws.",1281627403,"Interesting. I can't reproduce the error in typescript playground: https://tsplay.dev/mbQv4N

(how can we change the typescript version in codesandbox?)"
1412360201,1368,zustand 4.1.2 create() initializer type problems with store mutators,"I have a function that extracts out the initializer for a store to a function so that I can create many variants of a particular store, in this case various cache stores.

I was previously working with zustand 4.1.1 and the only type errors that I had were the getter and setter possibly being undefined, so I could suppress them using assertions.

After updating to zustand 4.1.2, there are now new type errors that prevent building, and I cannot for the life of me figure out what's going on with them.

I made a [minimal CodeSandbox demo of the problem available here](https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-zer3y6?file=/src/App.tsx).

A possibly notable observation is that without the `M` parameter, the type of `set` is reported to be `(partial: Cache<K, V> | Partial<Cache<K, V>> | ((state: Cache<K, V>) => Cache<K, V> | Partial<Cache<K, V>>), replace?: boolean | undefined) => void`.

With the `M` parameter, it instead becomes `Get<Mutate<StoreApi<Cache<K, V>>, M>, ""setState"", undefined>`.

The closest I've gotten to figuring out a possible cause is that the `Get` type might not be inferring that the `""setState""` and `""getState""` fields should (I think) be guaranteed to be present, but that's really just grasping at straws.",1281641563,"I edited the `package.json` file to use 4.8.4 as the TypeScript version, so if you want to use some other version you can change that value."
1412360201,1368,zustand 4.1.2 create() initializer type problems with store mutators,"I have a function that extracts out the initializer for a store to a function so that I can create many variants of a particular store, in this case various cache stores.

I was previously working with zustand 4.1.1 and the only type errors that I had were the getter and setter possibly being undefined, so I could suppress them using assertions.

After updating to zustand 4.1.2, there are now new type errors that prevent building, and I cannot for the life of me figure out what's going on with them.

I made a [minimal CodeSandbox demo of the problem available here](https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-zer3y6?file=/src/App.tsx).

A possibly notable observation is that without the `M` parameter, the type of `set` is reported to be `(partial: Cache<K, V> | Partial<Cache<K, V>> | ((state: Cache<K, V>) => Cache<K, V> | Partial<Cache<K, V>>), replace?: boolean | undefined) => void`.

With the `M` parameter, it instead becomes `Get<Mutate<StoreApi<Cache<K, V>>, M>, ""setState"", undefined>`.

The closest I've gotten to figuring out a possible cause is that the `Get` type might not be inferring that the `""setState""` and `""getState""` fields should (I think) be guaranteed to be present, but that's really just grasping at straws.",1284482219,"Long post ahead, if you're looking for just a fix, the codesandbox with the fix is linked at the very end.

This behavior is kinda correct, let me first build a minimal repro...

```ts
import create, { StateCreator, StoreMutatorIdentifier } from ""zustand""
import { persist } from ""zustand/middleware""

interface State
  { count: number
  , increment: () => void
  }

const foo: <M extends [StoreMutatorIdentifier, unknown][]>() => StateCreator<State, M> =
  () => (set, get) => ({
    count: 0,
    increment: () => {
      // @ts-expect-error
      set({ count: get().count + 1 })
    }
  })

create<State>()(persist(foo()))
```

Here it is wrong to expect `get` to be `StoreApi<State>[""getState""]` and `set` to be `StoreApi<State>[""setState""]`... Why? Because they can be anything, `M` will decide what they'll be, it's possible they are `42` for if `M` is `[[""troll"", never]]`...

```ts
import create, { StoreApi, Mutate, StateCreator, StoreMutatorIdentifier } from ""zustand""
import { persist } from ""zustand/middleware""

declare module 'zustand' {
  interface StoreMutators<S, A> {
    troll: Omit<S, ""getState"" | ""setState""> & { getState: 42, setState: 42 }
  }
}

export const troll = ((f: any) => (_: any, __: any, store: any) => {
  store.getState = 42
  store.setState = 42
  return f(store.getState, store.setState, store)
}) as unknown as
  < T extends State
  , Mps extends [StoreMutatorIdentifier, unknown][] = []
  , Mcs extends [StoreMutatorIdentifier, unknown][] = []
  >
    (f: StateCreator<T, [...Mps, ['troll', never]], Mcs>) =>
      StateCreator<T, Mps, [['troll', never], ...Mcs]>

interface State
  { count: number
  , increment: () => void
  }

const foo: <M extends [StoreMutatorIdentifier, unknown][]>() => StateCreator<State, M> =
  () => (set, get) => ({
    count: 0,
    increment: () => {
      set({ count: get().count + 1 })
    }
  })

create<State>()(persist(troll(foo())))
```

Surely we don't want this code to compile, and it doesn't. So the previous code also doesn't compile because of the same reason... What `foo` is claiming in it's type is false, it's saying I can work with any mutators `M`, well if that is true then why do you make assumptions about `M` in your implementation that it'll not contain `[""troll"", never]`? So the correct type of `foo` is this...

```ts
import create, { StateCreator } from ""zustand""
import { persist } from ""zustand/middleware""

interface State
  { count: number
  , increment: () => void
  }

const foo: () => StateCreator<State, []> =
  () => (set, get) => ({
    count: 0,
    increment: () => {
      set({ count: get().count + 1 })
    }
  })

create<State>()(persist(foo()))
//                      ~~~~~
// Type '[[""zustand/persist"", unknown]]' is not assignable to type '[]'
```

Now `foo` is honest, it accepts that it can't implement the state creator for all store types, it can implement the state creator as long as the store type is a subset of `StoreApi<State>`, but now we have this new type error.

This is were we've hit the limitation of how we encode mutations...

```ts
import { StoreMutatorIdentifier, StoreApi, Mutate } from ""zustand""

let test0: StateCreatorActual<State, [[""zustand/persist"", unknown]]> =
  {} as StateCreatorActual<State, []>
// compiles

let test1: StateCreatorWithPhantom<State, [[""zustand/persist"", unknown]]> =
  {} as StateCreatorWithPhantom<State, []>
// doesn't compile
// Types of parameters '$$storeMutations' and '$$storeMutations' are incompatible.
//   Type '[[""zustand/persist"", unknown]]' is not assignable to type '[]'.

type StateCreatorActual<
  T,
  Mis extends [StoreMutatorIdentifier, unknown][] = [],
  Mos extends [StoreMutatorIdentifier, unknown][] = [],
  U = T
> =
  & (
      ( setState: Get<Mutate<StoreApi<T>, Mis>, ""setState"", undefined>
      , getState: Get<Mutate<StoreApi<T>, Mis>, ""getState"", undefined>
      , store: Mutate<StoreApi<T>, Mis>
      // , $$storeMutations: Mis
      ) => U
    )
  & { $$storeMutators?: Mos }

// same as `StateCreator` from zustand
type StateCreatorWithPhantom<
  T,
  Mis extends [StoreMutatorIdentifier, unknown][] = [],
  Mos extends [StoreMutatorIdentifier, unknown][] = [],
  U = T
> =
  & (
      ( setState: Get<Mutate<StoreApi<T>, Mis>, ""setState"", undefined>
      , getState: Get<Mutate<StoreApi<T>, Mis>, ""getState"", undefined>
      , store: Mutate<StoreApi<T>, Mis>
      , $$storeMutations: Mis
      ) => U
    )
  & { $$storeMutators?: Mos }

type Get<T, K, F> =
  K extends keyof T ? T[K] : F

interface State
  { count: number
  , increment: () => void
  }
```

So we can see that `StateCreator<State, []>` actually is a subtype of `StateCreator<State, [[""zustand/persist"", unknown]]>` but because of our phantom `$$storeMutations` it no longer is a subtype that hence our code does not compile.

I'll see if I can remove that phantom parameter and improve the subtyping relation, but for now you'd have to make an assertion...

```ts
import create, { StateCreator } from ""zustand""
import { persist } from ""zustand/middleware""

interface State
  { count: number
  , increment: () => void
  }

const foo: () => StateCreator<State, []> =
  () => (set, get) => ({
    count: 0,
    increment: () => {
      set({ count: get().count + 1 })
    }
  })

create<State>()(persist(foo() as unknown as StateCreator<State, [[""zustand/persist"", unknown]]>))
```

Or if you want to be a bit fancy then...

```ts
const assertMutators =
  <Mis extends [StoreMutatorIdentifier, unknown][]>() =>
    <T, Mos extends [StoreMutatorIdentifier, unknown][]>(f: StateCreator<T, any, Mos>) =>
      f as unknown as StateCreator<T, Mis, Mos>

// ...

let x = create<State>()(persist(assertMutators<[[""zustand/persist"", unknown]]>()(foo())))
```

Also keep in mind that `[""troll, never]` was an extreme example, it could also have been more realistic for example a mutator that mutates the store in a way that `foo` which assumes the mutators to be `[]` breaks. If we want unsoundness to be caught then the types should not lie. Ie if we are truthful in `foo`'s type and use `[]`, then when `foo()` is used with `troll` it will be caught but if we're not truthful in `foo`'s type and use a generic `M`, then it won't be caught...

```ts
import create, { StoreApi, Mutate, StateCreator, StoreMutatorIdentifier } from ""zustand""
import { persist } from ""zustand/middleware""

declare module 'zustand' {
  interface StoreMutators<S, A> {
    troll: Omit<S, ""getState"" | ""setState""> & { getState: 42, setState: 42 }
  }
}

export const troll = ((f: any) => (_: any, __: any, store: any) => {
  store.getState = 42
  store.setState = 42
  return f(store.getState, store.setState, store)
}) as unknown as
  < T extends State
  , Mps extends [StoreMutatorIdentifier, unknown][] = []
  , Mcs extends [StoreMutatorIdentifier, unknown][] = []
  >
    (f: StateCreator<T, [...Mps, ['troll', never]], Mcs>) =>
      StateCreator<T, Mps, [['troll', never], ...Mcs]>

interface State
  { count: number
  , increment: () => void
  }

const fooTruthful: () => StateCreator<State, []> =
  () => (set, get) => ({
    count: 0,
    increment: () => {
      set({ count: get().count + 1 })
    }
  })


const fooLying: <M extends [StoreMutatorIdentifier, unknown][]>() => StateCreator<State, M> =
  () => (set, get) => ({
    count: 0,
    increment: () => {
      // @ts-ignore
      set({ count: get().count + 1 })
    }
  })

create<State>()(persist(troll(fooLying())))
// compiles

create<State>()(persist(troll(fooTruthful())))
//                            ~~~~~~~~~~~~~
// does not compile
// Types of parameters 'setState' and 'setState' are incompatible.
//   Type 'number' is not assignable to type '(partial: State | Partial<State> | ((state: State) => State | Partial<State>), replace?: boolean | undefined) => void'
```

Now ofc if one doesn't want to aim for such soundness and wishes to make using `foo` more convenient ie without requiring a type assertion at the caller then they can indeed lie in the type and make an assertion in the implementation, that's also not a big deal I guess...

```ts
const foo = <M extends [StoreMutatorIdentifier, unknown][]>() => {
  let f: StateCreator<State, []> = (set, get) => ({
    count: 0,
    increment: () => {
      set({ count: get().count + 1 })
    }
  })
  return f as unknown as StateCreator<State, M>
}

create<State>()(persist(foo())) // compiles
create<State>()(troll(foo())) // also compiles
```

So if there's an gaurantee outside the type system that you will always use middlewares in your codebase that never mutate the store in a way it's no longer a subtype of the vanilla store, then sure you can use the generic `M extends [StoreMutatorIdentifier, unknown][]>` because now there's an implicit gaurantee that `Mutate<StoreApi<unknown>, M>` will always be a subtype of `Mutate<StoreApi<unknown>, []>`. This is indeed true for all middlewares zustand exports, but it's not true for middlewares in general, they can do whatever they want.

Now another the problem is that the types of `get`, `set` and even `store` in `foo` that has the generic `M` are not correct... Both in `4.1.1` and in `4.1.2`... They are more weird in `4.1.2`, not sure why but it's not important as the types are wrong anyway... all three parameters should be `unknown`. Because they are literally unknown, `M` can be anything it could even make the whole store 
`42` not just `getState` or `setState`... xD

```ts
declare module 'zustand' {
  interface StoreMutators<S, A> {
    troll: 42
  }
}
```

(Also, technically the current types are correct, ie they are ""generic"" which is indeed like `unknown` but they later get resolved it to something concrete which we don't want).

So I'll open a PR to fix this, instead of `unknown` get could make an empty interface that acts like unknown but has some documentation...

```ts
/**
 * You're writing an implementation that works with all mutators,
 * in most cases this is not possible hence you've stumble upon
 * this unknown type. See #1368 issue for more.
 * Most likely you want to make them concrete to set a minimum
 * contraint.
 */
interface UnknownBecauseOfGenericMutators {}
```

And now in `foo`, `get`, `set` and `store` would become of type `UnknownBecauseOfGenericMutators`. I'm not sure if this is a breaking change or not, but this is indeed the correct change, we can discuss whether we want to have this or not in the PR.

Another option is if zustand declares that it's types assume that the all store mutators mutate the store in a way that they remain a subtype of the vanilla store, then in that case if we come across a generic `M` instead of making the parameters `unknown`, we can make them of the vanilla store as that's the minimum gaurantee. But note that here invovles a bit of lie, the type system is not aware of this implicit constriant on mutators, but still not a big deal and doable. And we probably can't make the contraint explicit in the type system.

And note that usually all middlewares would have to mutate to preserve the subtype with `StoreApi<unknown>` or else the store won't work with things like [`useStore`](https://github.com/pmndrs/zustand/blob/d27ea948843b2c955ce2be530e5e963dff8958de/src/react.ts#L23-L31) etc.

So let me know @dai-shi, what you prefer out of these two options...
1. No implicit contraints, store mutators can mutate store anyhow, make all parameters of `StateCreator<unknown, [StoreMutatorIdentifier, unknown][]>` as `UnknownBecauseOfGenericMutators`.
2. Implicict contraints, store mutators can only mutate the store in a way it remains a subtype of `StoreApi<unknown>`, make parameters of `StateCreator<unknown, [StoreMutatorIdentifier, unknown][]>` same as `StoreCreator<unknown, []>`.

So to summarize...
- The type of `foo` is not correct (given zustand does not have any restrictions on mutators as of today). The implementation assumes that `get` and `set` would be a subtype of the vanilla store, so this must be reflected in the type.
- The type errors when typing `foo` with a generic `M` are not helpful, we'll either make them better if we go with option 1 or you'll no longer see those errors if we go with option 2.
- `StateCreator` type has a limitation because `StateCreator<unknown, []>` is not a subtype of `StateCreator<unknown, [[""zustand/persist"", unknown]]` but when in fact it should be a subtype. I'll probably open a PR to experiment a fix I had in mind if we go with option 1. But it won't be required at least in this case if we go with option 2.

The two ways to solve the OP issue....
- Make `getTestCacheInitializer` not use generic `M` and make an type assertion at the call... https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-solution-1-xw11yh?file=/src/App.tsx
- Make `getTestCacheInitializer` use generic `M` and make an type assertion in it's implementation... https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-solution-2-3qkjdk?file=/src/App.tsx

The solution that requires no type assertion doesn't exist today."
1412360201,1368,zustand 4.1.2 create() initializer type problems with store mutators,"I have a function that extracts out the initializer for a store to a function so that I can create many variants of a particular store, in this case various cache stores.

I was previously working with zustand 4.1.1 and the only type errors that I had were the getter and setter possibly being undefined, so I could suppress them using assertions.

After updating to zustand 4.1.2, there are now new type errors that prevent building, and I cannot for the life of me figure out what's going on with them.

I made a [minimal CodeSandbox demo of the problem available here](https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-zer3y6?file=/src/App.tsx).

A possibly notable observation is that without the `M` parameter, the type of `set` is reported to be `(partial: Cache<K, V> | Partial<Cache<K, V>> | ((state: Cache<K, V>) => Cache<K, V> | Partial<Cache<K, V>>), replace?: boolean | undefined) => void`.

With the `M` parameter, it instead becomes `Get<Mutate<StoreApi<Cache<K, V>>, M>, ""setState"", undefined>`.

The closest I've gotten to figuring out a possible cause is that the `Get` type might not be inferring that the `""setState""` and `""getState""` fields should (I think) be guaranteed to be present, but that's really just grasping at straws.",1284615840,"The depth of type system intricacies here is far beyond my knowledge so I can't weigh in on the matter of what should be done about it, but thank you for the workarounds in the meantime!"
1412360201,1368,zustand 4.1.2 create() initializer type problems with store mutators,"I have a function that extracts out the initializer for a store to a function so that I can create many variants of a particular store, in this case various cache stores.

I was previously working with zustand 4.1.1 and the only type errors that I had were the getter and setter possibly being undefined, so I could suppress them using assertions.

After updating to zustand 4.1.2, there are now new type errors that prevent building, and I cannot for the life of me figure out what's going on with them.

I made a [minimal CodeSandbox demo of the problem available here](https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-zer3y6?file=/src/App.tsx).

A possibly notable observation is that without the `M` parameter, the type of `set` is reported to be `(partial: Cache<K, V> | Partial<Cache<K, V>> | ((state: Cache<K, V>) => Cache<K, V> | Partial<Cache<K, V>>), replace?: boolean | undefined) => void`.

With the `M` parameter, it instead becomes `Get<Mutate<StoreApi<Cache<K, V>>, M>, ""setState"", undefined>`.

The closest I've gotten to figuring out a possible cause is that the `Get` type might not be inferring that the `""setState""` and `""getState""` fields should (I think) be guaranteed to be present, but that's really just grasping at straws.",1294883148,"Hi, don't know if related but searches redirected me here

Is it possible to wrap a `vanilla` `create<T>()` store inside a default `create<T>()(persist())` using typescript?

I'm trying to access the store from inside and outside react components but the `persist` middleware does not accept a vanilla store"
1412360201,1368,zustand 4.1.2 create() initializer type problems with store mutators,"I have a function that extracts out the initializer for a store to a function so that I can create many variants of a particular store, in this case various cache stores.

I was previously working with zustand 4.1.1 and the only type errors that I had were the getter and setter possibly being undefined, so I could suppress them using assertions.

After updating to zustand 4.1.2, there are now new type errors that prevent building, and I cannot for the life of me figure out what's going on with them.

I made a [minimal CodeSandbox demo of the problem available here](https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-zer3y6?file=/src/App.tsx).

A possibly notable observation is that without the `M` parameter, the type of `set` is reported to be `(partial: Cache<K, V> | Partial<Cache<K, V>> | ((state: Cache<K, V>) => Cache<K, V> | Partial<Cache<K, V>>), replace?: boolean | undefined) => void`.

With the `M` parameter, it instead becomes `Get<Mutate<StoreApi<Cache<K, V>>, M>, ""setState"", undefined>`.

The closest I've gotten to figuring out a possible cause is that the `Get` type might not be inferring that the `""setState""` and `""getState""` fields should (I think) be guaranteed to be present, but that's really just grasping at straws.",1294893508,"Trying this pattern to have both vanilla and the react hook

```js
import createVanilla from 'zustand/vanilla'
import create from 'zustand'

const vanillaStore = createVanilla(() => ({ ... }))
const { getState, setState, subscribe, destroy } = store

const useBoundStore = create(vanillaStore)
```
(example taken from the readme)

Ideally this implementation would make the react code DRY

but I can't add `persist` to wrap my `vanillaStore`"
1412360201,1368,zustand 4.1.2 create() initializer type problems with store mutators,"I have a function that extracts out the initializer for a store to a function so that I can create many variants of a particular store, in this case various cache stores.

I was previously working with zustand 4.1.1 and the only type errors that I had were the getter and setter possibly being undefined, so I could suppress them using assertions.

After updating to zustand 4.1.2, there are now new type errors that prevent building, and I cannot for the life of me figure out what's going on with them.

I made a [minimal CodeSandbox demo of the problem available here](https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-zer3y6?file=/src/App.tsx).

A possibly notable observation is that without the `M` parameter, the type of `set` is reported to be `(partial: Cache<K, V> | Partial<Cache<K, V>> | ((state: Cache<K, V>) => Cache<K, V> | Partial<Cache<K, V>>), replace?: boolean | undefined) => void`.

With the `M` parameter, it instead becomes `Get<Mutate<StoreApi<Cache<K, V>>, M>, ""setState"", undefined>`.

The closest I've gotten to figuring out a possible cause is that the `Get` type might not be inferring that the `""setState""` and `""getState""` fields should (I think) be guaranteed to be present, but that's really just grasping at straws.",1294903101,"You need to use `persist` for vanilla store.

btw, I'm planning to deprecate `create(vanillaStore)` usage in the future. Because unlike v3, it's easy to do in userland with v4 api.

```js
import createStore from 'zustand/vanilla'
import { useStore } from 'zustand'
import { persist } from 'zustand/middleware'

const store = createStore(persist(() => ({ ... })))
const { getState, setState, subscribe, destroy } = store

const useBoundStore = (selector) => useStore(store, selector)
```"
1412360201,1368,zustand 4.1.2 create() initializer type problems with store mutators,"I have a function that extracts out the initializer for a store to a function so that I can create many variants of a particular store, in this case various cache stores.

I was previously working with zustand 4.1.1 and the only type errors that I had were the getter and setter possibly being undefined, so I could suppress them using assertions.

After updating to zustand 4.1.2, there are now new type errors that prevent building, and I cannot for the life of me figure out what's going on with them.

I made a [minimal CodeSandbox demo of the problem available here](https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-zer3y6?file=/src/App.tsx).

A possibly notable observation is that without the `M` parameter, the type of `set` is reported to be `(partial: Cache<K, V> | Partial<Cache<K, V>> | ((state: Cache<K, V>) => Cache<K, V> | Partial<Cache<K, V>>), replace?: boolean | undefined) => void`.

With the `M` parameter, it instead becomes `Get<Mutate<StoreApi<Cache<K, V>>, M>, ""setState"", undefined>`.

The closest I've gotten to figuring out a possible cause is that the `Get` type might not be inferring that the `""setState""` and `""getState""` fields should (I think) be guaranteed to be present, but that's really just grasping at straws.",1294921538,"That solves it!
but what about typings in the code you provided?

```ts
export const vanillaStore = createVanilla(
  persist<MyStore>((set, get) => ({
    // ...
  }))
)

export const useBoundStore = selector => useStore<MyStore>(vanillaStore, selector)
//                           ^^^^^^^^ selector has implicit any here
```"
1412360201,1368,zustand 4.1.2 create() initializer type problems with store mutators,"I have a function that extracts out the initializer for a store to a function so that I can create many variants of a particular store, in this case various cache stores.

I was previously working with zustand 4.1.1 and the only type errors that I had were the getter and setter possibly being undefined, so I could suppress them using assertions.

After updating to zustand 4.1.2, there are now new type errors that prevent building, and I cannot for the life of me figure out what's going on with them.

I made a [minimal CodeSandbox demo of the problem available here](https://codesandbox.io/s/zustand-create-initializer-with-storemutator-problem-zer3y6?file=/src/App.tsx).

A possibly notable observation is that without the `M` parameter, the type of `set` is reported to be `(partial: Cache<K, V> | Partial<Cache<K, V>> | ((state: Cache<K, V>) => Cache<K, V> | Partial<Cache<K, V>>), replace?: boolean | undefined) => void`.

With the `M` parameter, it instead becomes `Get<Mutate<StoreApi<Cache<K, V>>, M>, ""setState"", undefined>`.

The closest I've gotten to figuring out a possible cause is that the `Get` type might not be inferring that the `""setState""` and `""getState""` fields should (I think) be guaranteed to be present, but that's really just grasping at straws.",1294940271,"You want create()() for TS:
```ts
export const vanillaStore = createVanilla<MyStore>()(
  persist((set, get) => ({
    // ...
  }))
)

export const useBoundStore = <T>(selector: (state: MyStore) => T) => useStore(vanillaStore, selector)
```"
1406968501,1360,Zustand v4 immer middleware is not compatible with Typescript,"```typescript
create<{ b: boolean}>(immer((set)  => ({ b: false })))

// error TS2345: Argument of type error ,,,
```

The `immer` is imported from `zustand/middleware/immer`
",1276902426,"This is not an issue if you follow
https://docs.pmnd.rs/zustand/integrations/updating-draft-states

and be sure to not have your `create` call with the type, bad DON'T do this ... `create<State>(immer<State>((set) ....` just call `create`."
1406968501,1360,Zustand v4 immer middleware is not compatible with Typescript,"```typescript
create<{ b: boolean}>(immer((set)  => ({ b: false })))

// error TS2345: Argument of type error ,,,
```

The `immer` is imported from `zustand/middleware/immer`
",1276904022,"Closing this, it is not a bug."
1398160354,1345,Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js',"Hello, I'm using zustand together with the immer middleware according to the code below:

```typescript
import zustand from 'zustand'
import { immer } from 'zustand/middleware/immer'

type CounterStore = {
  counter: number
  increment(): void
  decrement(): void
}

export const counterStore = zustand(immer<CounterStore>((set) => ({
  counter: 0,
  increment(){ set(state => state.counter++) },
  decrement(){ set(state => state.counter--) }
})))
```

But when I try to run tests using jest I get this error:

```shell
 FAIL  tests/pages/index.spec.tsx
  ● Test suite failed to run

    Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js'

    Require stack:
      node_modules/zustand/middleware/immer.js
      src/store/counterStore.ts
      src/store/index.ts
      src/pages/index.tsx

    However, Jest was able to find:
        './immer.d.ts'
        './immer.js'

    You might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js', 'mjs', 'cjs', 'jsx', 'ts', 'tsx', 'json', 'node'].

    See https://jestjs.io/docs/configuration#modulefileextensions-arraystring
```

Jest is using the default ""moduleFileExtensions"" configuration as you can see in the error and the file having the ""js"" extension should be exported without any problem.

Has anyone caught this error?",1268761244,"Looking at the middleware code I saw that it imports the immer, and I thought it was not necessary to install it and that it was already internally in zustand because of the middleware. To solve the problem just install the immer"
1398160354,1345,Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js',"Hello, I'm using zustand together with the immer middleware according to the code below:

```typescript
import zustand from 'zustand'
import { immer } from 'zustand/middleware/immer'

type CounterStore = {
  counter: number
  increment(): void
  decrement(): void
}

export const counterStore = zustand(immer<CounterStore>((set) => ({
  counter: 0,
  increment(){ set(state => state.counter++) },
  decrement(){ set(state => state.counter--) }
})))
```

But when I try to run tests using jest I get this error:

```shell
 FAIL  tests/pages/index.spec.tsx
  ● Test suite failed to run

    Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js'

    Require stack:
      node_modules/zustand/middleware/immer.js
      src/store/counterStore.ts
      src/store/index.ts
      src/pages/index.tsx

    However, Jest was able to find:
        './immer.d.ts'
        './immer.js'

    You might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js', 'mjs', 'cjs', 'jsx', 'ts', 'tsx', 'json', 'node'].

    See https://jestjs.io/docs/configuration#modulefileextensions-arraystring
```

Jest is using the default ""moduleFileExtensions"" configuration as you can see in the error and the file having the ""js"" extension should be exported without any problem.

Has anyone caught this error?",1268773184,"@leandroluk even I faced this issue before and installing `immer` explicitly in my project did do the job. 

@dai-shi can this be solved by moving `immer` from the devDeps to first level deps in the library's `package.json`?
This would be helpful since the people using zustand need not explicitly install immer in their projects to use the immer middleware from zustand since immer would come installed with zustand out of the box. "
1398160354,1345,Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js',"Hello, I'm using zustand together with the immer middleware according to the code below:

```typescript
import zustand from 'zustand'
import { immer } from 'zustand/middleware/immer'

type CounterStore = {
  counter: number
  increment(): void
  decrement(): void
}

export const counterStore = zustand(immer<CounterStore>((set) => ({
  counter: 0,
  increment(){ set(state => state.counter++) },
  decrement(){ set(state => state.counter--) }
})))
```

But when I try to run tests using jest I get this error:

```shell
 FAIL  tests/pages/index.spec.tsx
  ● Test suite failed to run

    Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js'

    Require stack:
      node_modules/zustand/middleware/immer.js
      src/store/counterStore.ts
      src/store/index.ts
      src/pages/index.tsx

    However, Jest was able to find:
        './immer.d.ts'
        './immer.js'

    You might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js', 'mjs', 'cjs', 'jsx', 'ts', 'tsx', 'json', 'node'].

    See https://jestjs.io/docs/configuration#modulefileextensions-arraystring
```

Jest is using the default ""moduleFileExtensions"" configuration as you can see in the error and the file having the ""js"" extension should be exported without any problem.

Has anyone caught this error?",1269242770,"Using `immer` is optional. Maybe quite a few people use it, but from the library perspective, it's not necessary. See also: https://github.com/pmndrs/zustand/blob/94dec53d9a0d061dd950d325ffe84d6fa1feb0ee/docs/guides/updating-state.md#deeply-nested-object

(fwiw, I personally wouldn't use immer with zustand.)"
1398160354,1345,Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js',"Hello, I'm using zustand together with the immer middleware according to the code below:

```typescript
import zustand from 'zustand'
import { immer } from 'zustand/middleware/immer'

type CounterStore = {
  counter: number
  increment(): void
  decrement(): void
}

export const counterStore = zustand(immer<CounterStore>((set) => ({
  counter: 0,
  increment(){ set(state => state.counter++) },
  decrement(){ set(state => state.counter--) }
})))
```

But when I try to run tests using jest I get this error:

```shell
 FAIL  tests/pages/index.spec.tsx
  ● Test suite failed to run

    Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js'

    Require stack:
      node_modules/zustand/middleware/immer.js
      src/store/counterStore.ts
      src/store/index.ts
      src/pages/index.tsx

    However, Jest was able to find:
        './immer.d.ts'
        './immer.js'

    You might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js', 'mjs', 'cjs', 'jsx', 'ts', 'tsx', 'json', 'node'].

    See https://jestjs.io/docs/configuration#modulefileextensions-arraystring
```

Jest is using the default ""moduleFileExtensions"" configuration as you can see in the error and the file having the ""js"" extension should be exported without any problem.

Has anyone caught this error?",1269243106,"I think it's a doc issue. We don't yet have docs about `immer` middleware?
"
1398160354,1345,Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js',"Hello, I'm using zustand together with the immer middleware according to the code below:

```typescript
import zustand from 'zustand'
import { immer } from 'zustand/middleware/immer'

type CounterStore = {
  counter: number
  increment(): void
  decrement(): void
}

export const counterStore = zustand(immer<CounterStore>((set) => ({
  counter: 0,
  increment(){ set(state => state.counter++) },
  decrement(){ set(state => state.counter--) }
})))
```

But when I try to run tests using jest I get this error:

```shell
 FAIL  tests/pages/index.spec.tsx
  ● Test suite failed to run

    Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js'

    Require stack:
      node_modules/zustand/middleware/immer.js
      src/store/counterStore.ts
      src/store/index.ts
      src/pages/index.tsx

    However, Jest was able to find:
        './immer.d.ts'
        './immer.js'

    You might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js', 'mjs', 'cjs', 'jsx', 'ts', 'tsx', 'json', 'node'].

    See https://jestjs.io/docs/configuration#modulefileextensions-arraystring
```

Jest is using the default ""moduleFileExtensions"" configuration as you can see in the error and the file having the ""js"" extension should be exported without any problem.

Has anyone caught this error?",1269307404,"We do have docs on the `immer` middleware.
https://github.com/pmndrs/zustand/blob/main/docs/integrations/updating-draft-states.md

I think we need to add a section in the doc where we ask the user to install `immer`, if they want to use `immer` with `zustand`."
1398160354,1345,Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js',"Hello, I'm using zustand together with the immer middleware according to the code below:

```typescript
import zustand from 'zustand'
import { immer } from 'zustand/middleware/immer'

type CounterStore = {
  counter: number
  increment(): void
  decrement(): void
}

export const counterStore = zustand(immer<CounterStore>((set) => ({
  counter: 0,
  increment(){ set(state => state.counter++) },
  decrement(){ set(state => state.counter--) }
})))
```

But when I try to run tests using jest I get this error:

```shell
 FAIL  tests/pages/index.spec.tsx
  ● Test suite failed to run

    Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js'

    Require stack:
      node_modules/zustand/middleware/immer.js
      src/store/counterStore.ts
      src/store/index.ts
      src/pages/index.tsx

    However, Jest was able to find:
        './immer.d.ts'
        './immer.js'

    You might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js', 'mjs', 'cjs', 'jsx', 'ts', 'tsx', 'json', 'node'].

    See https://jestjs.io/docs/configuration#modulefileextensions-arraystring
```

Jest is using the default ""moduleFileExtensions"" configuration as you can see in the error and the file having the ""js"" extension should be exported without any problem.

Has anyone caught this error?",1269308914,"Ah, we do. Good. Yes, please open a PR."
1398160354,1345,Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js',"Hello, I'm using zustand together with the immer middleware according to the code below:

```typescript
import zustand from 'zustand'
import { immer } from 'zustand/middleware/immer'

type CounterStore = {
  counter: number
  increment(): void
  decrement(): void
}

export const counterStore = zustand(immer<CounterStore>((set) => ({
  counter: 0,
  increment(){ set(state => state.counter++) },
  decrement(){ set(state => state.counter--) }
})))
```

But when I try to run tests using jest I get this error:

```shell
 FAIL  tests/pages/index.spec.tsx
  ● Test suite failed to run

    Cannot find module 'immer' from 'node_modules/zustand/middleware/immer.js'

    Require stack:
      node_modules/zustand/middleware/immer.js
      src/store/counterStore.ts
      src/store/index.ts
      src/pages/index.tsx

    However, Jest was able to find:
        './immer.d.ts'
        './immer.js'

    You might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js', 'mjs', 'cjs', 'jsx', 'ts', 'tsx', 'json', 'node'].

    See https://jestjs.io/docs/configuration#modulefileextensions-arraystring
```

Jest is using the default ""moduleFileExtensions"" configuration as you can see in the error and the file having the ""js"" extension should be exported without any problem.

Has anyone caught this error?",1696848809,"Sometimes just bundler/packer don't support mjs, as immer start using it.

For example, in React native you need to do this as described in https://github.com/expo/expo/issues/23180#issuecomment-1612970642:

```sh
npx expo customize metro.config.js
```

```js
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require('expo/metro-config');

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);
const {
  resolver: { sourceExts },
  resolver,
} = config;

module.exports = {
  ...config,
  resolver: {
    ...resolver,
    sourceExts: [...sourceExts, 'mjs'],
  },
};
```"
1388625583,1321,Can create function accept a class?,"Hey!

From my observations, it seems like a `create` function can easily accept a function-constructing-a-class argument. Maybe can pass a class directly, have not really tried, more a theoretical question at 5AM... So:

```js
import create from 'zustand';

class BearStore {
  constructor(set) {
    this.set = set;
  }

  bears = 0;

  increasePopulation: () => this.set(this.increasePopulation)

  _increasePopulation: (state) => ({ bears: state.bears + 1 }))

  removeAllBears: () => this.set({ bears: 0 })
}

const useBearStore = create((set) => new BearStore(set))
```

**Looking at this monster, you might think: Why to accept classes?**

Well, if we assume store functions could need modification in the future, that would work really well. As we could extend them easily.

**Composition is possible...**

Yeah, we could try composition too, but the boilerplate + a ton of set calls, will it be worth it? Like really, we want to expose each setter for extension or interception...

For context: the apps we build are not single-use. We build a base for hundreds other websites (ecom specifically). Developers build on-top of main codebase, without modifying the source code. There are direct overrides + extensions and plugin approach (intercepting any function).

So given I need extensibility, can I use Zustand with class as creator? There are quite few optimisations possible, we can always bind set to selected functions, and more... Will this break performance? Any consequences of doing this?",,
1385030055,1313,[Documentation] Link Issue for TS - `create` without curried workaround,"
The sidebar on the [TypeScript page](https://docs.pmnd.rs/zustand/guides/typescript) leads to https://docs.pmnd.rs/zustand/guides/typescript#create-without-curried-workaround

When clicked on, it goes nowhere. However, if you go to 
https://docs.pmnd.rs/zustand/guides/typescript#undefined-without-curried-workaround it links to the proper section. 

This probably has something to do with the ""`"" tags around ""create"" in the header. 


![image](https://user-images.githubusercontent.com/33907581/192146524-d88c13ee-3ece-45f9-9160-32deb41a4272.png)
",,
1382144603,1306,"""This expression is not callable"" with NodeNext module resolution","When trying to import zustand with ```import create from zustand``` while using NodeNext moduleResolution inside tsconfig i get the ts error: ""This expression is not callable"".

Minimal reproduction:

- create new vite react-ts project
- set moduleResolution to NodeNext
- import create from zustand",,
1374009292,1295,Mocking zustand gives error that actual zustand import is not a function ,"Hello, I'm trying to mock zustand module, but I got an error that originalModule is not a function. Here is my mock
```javascript
jest.mock(""zustand"", () => {
  const originalModule = jest.requireActual(""zustand"");
  const create = (createState) => {
    const store = originalModule((set) => {
      const state = createState(set);
      return {
        ...state,
        count: 5,
      };
    });
    return store;
  };
  return { __esModule: true, default: create };
});
```
",,
1368945377,1287,"Missing ""./react"" export in ""zustand"" package","Currently when I try to use any sort of Zustand state, even from the docs, I get an error saying `Missing ""./react"" export in ""zustand"" package`. I am using Vite and TypeScript.

```
const bears = useBearStore((state) => state.bears);

  useEffect(() => {
    console.log(bears);
  }, []);
```

Here is my vite.config.ts

```
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import * as path from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: [{ find: '@', replacement: path.resolve(__dirname, 'src') }],
  },
});
``",,
1368576000,1278,React 18 strict mode changes behaviour. Updating my store via a useEffect does not rer-ender components.,"### Versions:
NextJS: ""^12.3.0""
React: ""^18.2.0""
Zustand: ""^4.1.1""

### Bug
When my page loads, it gets a ""post"" from my app and prefills some fields, like so:

```
  prefillFromExistingListing: (listing: ListingObject) => {
    set({
      title: listing?.title,
      description: listing?.description,
      buyNow: listing?.buyNow,
      bestOffer: listing?.bestOffer,
      trade: listing?.trade,
      category: listing?.category,
      price: listing?.price.toFixed(2),
      shippingPrice: listing?.shipping?.base.toString(),
      quantity: Object.values(listing?.lineItems)[0].quantity.toString(),
      additionalShipping: Object.values(
        listing?.lineItems
      )[0].additionalShipping.toString(),
      condition: listing?.condition,
      collectibleId:
        Object.values(listing?.lineItems)[0]?.collectibleDetails
          ?.collectibleId ?? null,
    });
  },
```

This all happens in my `EditListing` component:

```
import useCreateSingleItemListing, {
  CREATE_LISTING_UPLOAD_STATUS,
} from ""@components/CreateListing/useCreateSingleItemListing"";
import CreateSingleListingForm from ""@components/CreateListing/CreateSingleListingForm/CreateSingleListingForm"";
import { CREATE_EDIT_LISTING_MODE, LISTING_TYPE } from ""@interfaces/interfaces"";
import axios from ""axios"";
import React, { useCallback, useEffect } from ""react"";
import { getListing } from ""@services/firebase/client/listing-client-services"";
import useSWR from ""swr"";
import shallow from ""zustand/shallow"";

export default function EditListing({ listingId }) {
  const {
    setMode,
    setExistingListingData,
    setPhotos,
    prefillFromExistingListing,
    setListingId,
    setPhotosChanged,
    setUploadProgress,
    setUploadStatus,
  } = useCreateSingleItemListing(
    (state) => ({
      setMode: state.setMode,
      setExistingListingData: state.setExistingListingData,
      setPhotos: state.setPhotos,
      prefillFromExistingListing: state.prefillFromExistingListing,
      setListingId: state.setListingId,
      setPhotosChanged: state.setPhotosChanged,
      setUploadProgress: state.setUploadProgress,
      setUploadStatus: state.setUploadStatus,
    }),
    shallow
  );
  const { data } = useSWR(listingId, getListing);

  const initEditListing = useCallback(async () => {
    if (!data) return;
    setMode(CREATE_EDIT_LISTING_MODE.EDIT);
    setExistingListingData(data.listing);
    setListingId(listingId);
    prefillFromExistingListing(data.listing);
    let photoArray: Array<File> = [];
    await Promise.all(
      data.listing?.listingPhotos?.map(async (photo) => {
        try {
          const response = await axios({
            url: photo.url,
            method: ""GET"",
            responseType: ""blob"",
          });
          if (response?.data) {
            photoArray[photo.index] = response.data;
          }
        } catch (e) {
          console.log(`Error getting photo:`, photo.url);
          photoArray[photo.index] = null;
        }
      })
    );
    photoArray = photoArray.filter((file) => file !== null);
    setPhotos(photoArray);
    setPhotosChanged(false);
  }, [
    data,
    listingId,
    prefillFromExistingListing,
    setExistingListingData,
    setListingId,
    setMode,
    setPhotos,
    setPhotosChanged,
  ]);

  useEffect(() => {
    if (data?.listing) {
      initEditListing();
    }
    return () => {
      setExistingListingData(null);
      setUploadProgress(0);
      setUploadStatus(CREATE_LISTING_UPLOAD_STATUS.IDLE);
    };
  }, [
    data?.listing,
    initEditListing,
    setExistingListingData,
    setUploadProgress,
    setUploadStatus,
  ]);

  if (!data) return null;

  return (
    <main className=""flex min-h-screen flex-col items-center justify-center py-2 px-8 xl:px-0"">
      {data?.listing?.type === LISTING_TYPE.SINGLE && (
        <CreateSingleListingForm />
      )}
    </main>
  );
}
```

These fields e.g. `title` are then used in their respective components, e.g. `ListingTitle.tsx`:
```
import useCreateSingleItemListing from ""@components/CreateListing/useCreateSingleItemListing"";
import InputText from ""@components/UI/Input/InputText"";
import React, { useEffect } from ""react"";
import shallow from ""zustand/shallow"";

export default function ListingTitle({ className = """" }) {
  const { title, setTitle } = useCreateSingleItemListing(
    (state) => ({
      title: state.title,
      setTitle: state.setTitle,
    }),
    shallow
  );

  return (
    <InputText
      className={className}
      id=""title""
      label=""Title""
      tabIndex={1}
      onChange={(e) => {
        setTitle(e.target.value);
      }}
      inputClassName=""col-span-4 md:col-span-2""
      value={title}
      minLength={10}
      maxLength={100}
      tip=""Titles must be between 10 and 100 characters.""
    />
  );
}
```

### Screenshots

On page load, my app looks like this:

<img width=""1440"" alt=""Screenshot 2022-09-10 at 11 05 16"" src=""https://user-images.githubusercontent.com/25225528/189478653-0a790859-a9d6-472c-89e6-89259dd23326.png"">

Whereas it should look like this:
<img width=""1440"" alt=""Screenshot 2022-09-10 at 11 06 02"" src=""https://user-images.githubusercontent.com/25225528/189478672-8e664de7-71d5-48c3-84eb-c6fa7fd6bd03.png"">

### Workarounds

To fix the problem, I either need to:

1. Disable strict mode in React 18
or
2. Use React 17

### Conclusion

I understand that React 18 has some new behaviour regarding useEffects. However I can see the component has mounted, un-mounted and then mounted again. So I am confused as to why it's not triggering a re-render and populating the inputs.",,
1364379624,1268,Setting nested state from catch with using the Hermes cause Unhandled Promise Rejection,"Code example

```
import React, { useEffect } from 'react';
import create from 'zustand';

const useStore = create(() => ({
    someData: {
        fetch: () => {},
        fetching: 'initial'
    }
}))

export const useZustandTest = () => {
    useEffect(() => {
        (async () => {
            try {
                throw new Error('error')
            } catch (error) {
                // useStore.setState((s) => ({ someData: {...s.someData, fetching: error} }))          // this works
                useStore.setState(({someData}) => ({ someData: {...someData, fetching: error} }))       // this causes the error
            }
        })()
    }, [])
};
```

In console error appears and new state not sets
Possible Unhandled Promise Rejection (id: 0):
ReferenceError: Property 'error' doesn't exist

",,
1361911965,1263,[BUG] Zustand produce a ts error when using combine with persist,"[Example](https://codesandbox.io/s/blissful-sea-p146jz?file=/store.ts)
It's working in v 3.6.8 but not anymore in the latest version which is 4.1.1. and all the types are unknown. ",,
1359220883,1253,Document for Slices Pattern,"From https://github.com/pmndrs/zustand/pull/1177#issuecomment-1209592975

> I think the problem is that the readme (and some other docs too) link to the typescript document for slices pattern...
> > You may wonder how to organize your code for better maintenance: [Splitting the store into separate slices](https://github.com/pmndrs/zustand/blob/main/docs/typescript.md#slices-pattern)
> 
> Instead there should be a seperate document for slices pattern (just like there used to be a wiki) or a section in readme.

Currently there are a couple of links in some documents that link to the TypeScript guide for slices pattern. Which isn't great because the TypeScript guide only documents the TypeScript instructions and code for slices pattern, it does not introduce or explain slices pattern itself, nor it should, there should be a seperate document for that.

Opening just for tracking purpose, in case someone is interested in working on this.

",,
1355128188,1242,Typescript issue when trying to combine multiple middlewares in v4.1.1,"I tried to follow the docs from here: https://docs.pmnd.rs/zustand/guides/typescript#using-middlewares

but when I try to combine multiple middlewares like:

````ts
import create from 'zustand'
import { devtools, persist } from 'zustand/middleware'

const myMiddlewares = (f) => devtools(persist(f))
````

I'm getting:

````ts
Argument of type 'StateCreator<unknown, [], [[""zustand/persist"", unknown]], unknown>' is not assignable to parameter of type 'StateCreator<unknown, [[""zustand/devtools"", never]], [[""zustand/persist"", unknown]], unknown>'.
  Type 'StateCreator<unknown, [], [[""zustand/persist"", unknown]], unknown>' is not assignable to type '(setState: <A extends string | { type: unknown; }>(partial: unknown, replace?: boolean | undefined, action?: A | undefined) => void, getState: () => unknown, store: WithDevtools<StoreApi<unknown>>, $$storeMutations: [...]) => unknown'.
    Types of parameters '$$storeMutations' and '$$storeMutations' are incompatible.
      Type '[[""zustand/devtools"", never]]' is not assignable to type '[]'.
````

Is there any workaround for this?
",,
1353070054,1232,[Help needed]  TS issues when creating a store factory.,"

Hi, I'm trying to create a small helper to generate a store with `immer, subscribeWithSelector, devtools` middlewares. I'm not sure if I got the types right as I'm getting `error TS2349: This expression is not callable.
  Type 'never' has no call signatures.` everywhere I'm invoking `set` or `get`.

`Zustand 4.1.1`
```ts
export const createStoreWithSubscribe = <T>(
  config: StateCreator<T, [['zustand/subscribeWithSelector', T], ['zustand/immer', T], ['zustand/devtools', T]], []>,
  options: Parameters<typeof devtools>[1]
): StoreReturnType<T> => create<T>()(subscribeWithSelector(immer(devTools(config, options))))
```

I also tried to explicitly specify the return type:
```ts
type StoreReturnType<T> = UseBoundStore<
  Mutate<
    StoreApi<T>,
    [['zustand/subscribeWithSelector', never], ['zustand/immer', never], ['zustand/devtools', never], ...[]]
  >
>;

export const createStoreWithSubscribe = <T>(
  config: StateCreator<T, [['zustand/subscribeWithSelector', T], ['zustand/immer', T], ['zustand/devtools', T]], []>,
  options: Parameters<typeof devtools>[1]
): StoreReturnType<T> => create<T>()(subscribeWithSelector(immer(devTools(config, options)))) as StoreReturnType<T>;
```
That didn't really help.

Previously, prior to v4.0 this was my implementation that used a custom immer middleware, that worked fine.

```ts
export const createStoreWithPersistAndSubscribe = <T extends State>(
  config: StateCreator<
    T,
    (partial: ((draft: Draft<T>) => void) | T | Partial<T>, replace?: boolean, type?: string) => void,
    GetState<T>,
    Mutate<StoreApi<T>, [['zustand/subscribeWithSelector', never]]> &
      Mutate<StoreApi<T>, [['zustand/persist', Partial<T>]]> &
      Mutate<StoreApi<T>, [['zustand/devtools', never]]> &
      StoreApi<T>
  >,
  persistOptions: PersistOptions<T>,
  options: Parameters<typeof devtools>[1]
) => create(devTools(subscribeWithSelector(persist(withImmer(config), persistOptions)), options));
```

I'd appreciate anyone's help! Thanks.",,
1352080378,1228,setState outside of component doesn't update,"Zustand: 4.0.0
Next: 12.2.5
React: 18.2.0

My store is set inside store.js as all the other Zustand stores:

```
const retryStore = create(set => ({
    retry_n: 0,
    setGRetry: (retry_n) => set(state => ({
        ...state,
        retry_n,
    })),
}));
export { retryStore };
```

inside my @/utils/get.js file I try to update the number by 1, using setState as:


```
const retry_n = retryStore.getState().retry_n
    const xxx = xxxStore.getState().xxx
    const xxxx = xxxxStore.getState().xxxx

    var j=0;
    const maxretry = 20;

    const myFetch = async () => {
        try {
            let url = `...`

            while(j < maxretry){

                console.log('while try n:',j)     // 1,2,3... ecc
                console.log('get.js retry_n:',retry_n)  // always 0
                
                if (isItRetry){            // TRUE
                    retryStore.setState({ retry_n: retry_n + 1})
                    console.log('playThis retry_n now:',retry_n)    // always 0
                }else{
                    ...
                }

                if (a != b){ ... return }

                j++
            }
            etc...
```


shouldn't this increment by 1 each loop? why is always 0? I use other stores the same way in the same file and all work but this one.

(are there any known conflicts with next-pwa ? using vers. 5.5.4)",,
1348993611,1220,[documentation update] Individual page audit,"Core conversation here: https://github.com/pmndrs/zustand/discussions/1033

For each of the pages on the new documentation site, audit each page for clear, concise explanations, checking code snippets are correct, and conveys the correct information. 

Blocked by https://github.com/pmndrs/zustand/issues/1215

Current list of pages, may change based on 1215 (above)

 - [ ] 3rd party libraries
 - [ ] auto generating selectors
 - [ ] event handler in pre react 18
 - [ ] flux inspired practice
 - [ ] immutable state and merging
 - [ ] Update immutable state and merging
 - [ ] introduction
 - [ ] maps and sets usage
 - [ ] persisting store data
 - [ ] practice with no store actions
 - [ ] recipes
 - [ ] testing
 - [ ] typescript
 - [ ] updating nested state object values
 - [ ] v4 migration
 - [ ] zustand v3 create context",,
1348983594,1215,[documentation update] Add top level structure to new docs site,"Core conversation here: https://github.com/pmndrs/zustand/discussions/1033

The new document site is currently with the following top level categories: ""Introduction, Recipes, etc""
This issue is to introduce a similar structure is Jotai, which is quite clear to a newcomer. 

The structure will be (and can be iterated on in the future):

    - Getting Started
    - Basics
        - Concepts: Some of the content from first section of readme.md
        - Comparison: Similar to Jotai, and some content from the Zustand introduction section
        - Examples: Similar to Jotai ""Showcase"". Personally I prefer ""example"", to me, ""showcase"" sounds like production sites using Zustand. Thoughts?
    - Guides
        - Updating nested state object values (from current Zustand docs)
        - Immutable state and merging (from current Zustand docs)
        - Recommended practices (from current Zustand docs - ""Flux inspired practice"")
        - Auto Generating Selectors (from current Zustand docs)
        - Practice with no store actions (from current Zustand docs)
        - TypeScript (from current Zustand docs)
        - Testing (from current Zustand docs)
    - Recipes
        - Split recipes into individual guides (so approx 10 pages here)
    - Integrations (I don't know if this is broad enough for the below, let me know)
        - 3rd party libraries (from current Zustand docs)
        - Persist middleware (from current Zustand docs)
        - Devtools (from current Zustand readme.md)
    - Previous versions
        - V3 reateContext from zustand/context (from current Zustand docs)
    - Migrations
        - V4 migrations (from current Zustand docs)


This can be done in parallel to the work @dbritto-dev is working on in https://github.com/pmndrs/zustand/issues/1008
",,
1346171657,1210,(middlware/persist): Limitations are not documented,"Based on #618 and #652 there are limitations to what can be stored. Aside from the actual reasons for this limitation, users should be made aware of this. If this can be done using the typesystem for TypeScript users, that'd be great (I'm used to Java). If not, please add a big fat warning so that users don't run into issues. Without proper documentation, there's no way to know if the code you're going to write is going to work. Trial-and-error isn't a viably alternative for me, YMMV.

From #618:

> By default, persist serializes the state using JSON.stringify.
Unfortunately JSON doesn't fit very well with Sets and Maps.

To me that sounds like a bug, not a documentation issue. If JSON doesn't do what you need it to do, don't use JSON (or fix it).",,
1345931655,1209,Immer middleware not exported,"```ts
export * from './middleware/redux';
export * from './middleware/devtools';
export * from './middleware/subscribeWithSelector';
export * from './middleware/combine';
export * from './middleware/persist';
```
These are the middlewares being exported and that do show up when trying to import them. Immer is not here, making it impossible to import. 
When doing:
```ts
import { immer } from 'zustand/middleware/immer'
```
I get the following error: 
```
Loading module from “http://localhost:5173/node_modules/.vite/deps/zustand_middleware_immer.js?v=df421ac0” was blocked because of a disallowed MIME type (“”)
```",,
1344855663,1205,Typescript devtools named store typing issue,"Typescript gives the following error for named devtool stores, for example from the docs `devtools(store, {name: ""MyStore""})`

```
Argument of type '{ name: string; }' is not assignable to parameter of type 'DevtoolsOptions'
```

Looks like the types from @redux-devtools/extension are not being pulled in due to it being a dev dependency, adding @redux-devtools/extension as an additional dependency to my project solves the issue.

Example:
https://stackblitz.com/edit/react-ts-ktahyv?file=store.ts

Using zustand version 4.1.0",,
1338950513,1192,How to properly reset state before using navigate,"Hey guys, 

first of all thanks for the great work, I really like zustand and I'm probably just doing something wrong but I have to ask how to properly reset the store state into the initial state before we leave the page. I'm doing that currently in useEffect unmounting but it seems like the store is set to initial state after the next page is actually initialized. I've prepared a [simple demo](https://codesandbox.io/s/zustand-navigate-wk5t8s?file=/src/page.jsx).

The issue can be spotted in the console when you navigate from landing.jsx to page.jsx, so I'm getting some data at landing page and setting the isSuccess and message values in the store and resetting them in useEffect unmount.  After navigating to page.jsx, you can see in console.log that the resetting will run after the page.jsx is rendered. 

So my question is, am I doing something wrong or it is normal scenario. Thank you very much.

*store.js*
```
import create from ""zustand"";

const useStore = create((set, get) => ({
  items: [],
  isError: false,
  isSuccess: false,
  isLoading: false,
  message: """",
  reset: () => {
    set({
      items: [],
      isError: false,
      isSuccess: false,
      isLoading: false,
      message: """"
    });
  },
  getItems: () => {
    // lets say we fetch items from api here
    const fetchedItems = [
      { id: 1, title: ""item"" },
      { id: 2, title: ""item2"" }
    ];
    set({
      items: fetchedItems,
      isError: false,
      isSuccess: true,
      isLoading: false,
      message: ""Successfully get items list""
    });
  }
}));

export default useStore;
```

*landing.jsx*
```
import { useEffect } from ""react"";
import { Link } from ""react-router-dom"";
import useStore from ""./store"";
import shallow from ""zustand/shallow"";

function LandingPage() {
  const { items, getItems, reset } = useStore(
    (state) => ({
      items: state.items,
      getItems: state.getItems,
      reset: state.reset
    }),
    shallow
  );

  useEffect(() => {
    getItems();
  }, []);

  useEffect(() => {
    return () => {
      reset();
    };
  }, []);

  return (
    <div>
      <p>LandingPage</p>
      <p>{JSON.stringify(items)}</p>
      <Link to=""/page"">Go to another page</Link>
    </div>
  );
}
export default LandingPage;
```

*page.jsx*
```
import { Link } from ""react-router-dom"";
import { useEffect } from ""react"";
import useStore from ""./store"";

function Page() {
  const isSuccess = useStore((state) => state.isSuccess);
  const message = useStore((state) => state.message);

  useEffect(() => {
    console.log(""useeffect"", isSuccess, message);
  }, [isSuccess]);

  return (
    <>
      <p>Another page</p>
      <Link to=""/"">Go back</Link>
    </>
  );
}
export default Page;
```",,
1336306074,1190,Zustand 4 can't use store outside react,"Hi! following the advise here https://github.com/pmndrs/zustand#using-zustand-without-react I'm trying to use my zustand appContextStore outside react (in a helper.js file)

My deps are:
    ""react"": ""18.0.0"",
    ""react-native"": ""0.69.4"",
    ""zustand"": ""^4.0.0"",

This is my appContextStore,js:
```
import create from 'zustand';

const appContextStore = create((set) => ({
  clientURL: '',
  setClientURL: (clientURL) => set({ clientURL }),
  firstLoad: true,
  setFirstLoad: (firstLoad) => set({ firstLoad }),
}));

export default appContextStore;
```

Then, this is my helper.js file:
```
import create from 'zustand'
import appContextStore from '../stores/appContextStore';

const useBoundAppContextStore = create(appContextStore); <-- this creates an error
```

This is the error generated, it seems that something about react is still needed...
```
ExceptionsManager.js:149 Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.
ExceptionsManager.js:149 TypeError: Cannot read properties of null (reading 'useRef')

```
",,
1333957132,1182,Redux middleware types are not exported,"I caught the ts error 4023 ⬇️
![image](https://user-images.githubusercontent.com/50517848/183837275-4f758dd7-0b4a-4f20-bcf9-36de5ea071a4.png)
Because the redux middleware types are not exported.
![image](https://user-images.githubusercontent.com/50517848/183792268-868f61b7-3362-4e7b-bcad-d74ac61c88a6.png)
I have seen one similar issue #1100, so could you please fix these type error?
",,
1331461559,1178,zustand v4 + Preact produces intermittent failures,"Now that this issue with Preact identified in #1137 (https://github.com/preactjs/preact/issues/3632) has been fixed and [Preact 10.10.1](https://github.com/preactjs/preact/releases/tag/10.10.1) has been released I was hoping to update to Zustand v4 but I've come across another issue.

Specifically, the definition of `useSyncExternalStore` in Preact is:

```js
export function useSyncExternalStore(subscribe, getSnapshot) {
  const [state, setState] = useState(getSnapshot);

  useEffect(() => {
    return subscribe(() => {
      setState(() => getSnapshot());
    });
  }, [subscribe, getSnapshot]);

  return state;
}
```

The trouble is with this definition is that it relies on `useEffect`. This can cause the `subscribe` function to be run too late.

For example, on the initial render, `useSyncExternalStore` and hence `useStore` returns the result of `getSnapshot` immediately. However, if the store is updated before effects are run, the `subscribe()` callback will not yet have been run and components relying on `useStore` will not be re-rendered since they are not yet registered as listeners of the store.

Due to this, our playwright tests running using the `webkit` project experienced very frequent failures after attempting to update to Zustand v4. The `chrome` and `firefox` tests appear to pass. (WebKit typically tries to reduce reflows on page load so this result is somewhat understandable.)

If I change Preact to use `useLayoutEffect`, the tests pass.

I'm not sure what the expected behavior for `useSyncExternalStore` is, so I'm not sure if this is a Preact bug or not. Presumably it is? If so, I'm happy to file it.

In the interim, I wonder if there is a convenient way to have Zustand to force the shimmed version of `useSyncExternalStore` to be used?",,
1331265045,1175,Slice pattern got an error after add middleware (Typescript) ,"## Spec: 
- Zustand v4
- Nextjs 12.1.6
-  Typescript 4.6.4

## What I did: 
I have created a ""slice pattern"" for my store and added devtools middleware on them

## What I got: 
I got an error when trying to add ""mutators reference"". See image below
<img width=""1040"" alt=""image"" src=""https://user-images.githubusercontent.com/18025983/183331042-5d7bbc3e-af53-4723-9555-f8246ddc92dd.png"">

## What I expect: 
It should be no error on it, I have followed the doc but still got error. Link to doc: https://github.com/pmndrs/zustand/blob/main/docs/typescript.md#middlewares-and-their-mutators-reference
<img width=""1045"" alt=""image"" src=""https://user-images.githubusercontent.com/18025983/183331226-c7bacb72-fb7b-4063-9375-50b291b2cff6.png"">

Did I miss something? 

Thank you!


",,
1331155256,1173,support default value using `getServerState`,"I see there's a field called `getServerState`, but I don't see any usage of this API

https://github.com/pmndrs/zustand/blob/49dcec03ee9cd20a338b4e5a8219ef60ad944f7a/src/react.ts#L38

If we support like this, that will help SSR on `next.js`
```ts
import { ssr } 'zustand/middleware'
const defaultValue = { ... }
create(
  ssr(set => ({ ... }), () => {...defaultValue})
)
```

Upstream: #1145",,
1330062108,1170,"Upgrading to v4, attempting to remove zustand/context","Hello! I'm attempting to upgrade to v4, and in the process of that I'd like to get rid of my usage of `zustand/context`.

Am running into an interesting issue when initializing my store with slices. I'm on the latest version of NextJS (v12.2.4), but I also experienced this on v12.1.0.

If I initialize the state from my slice within the store creation method, everything will work as intended:

```typescript
interface ModalSlice {
  open: boolean;
}

type StoreState = ModalSlice; // Eventually there will be more slices!

const useStore = create<StoreState>()((...a) => ({
  open: false
}))
```

However, if I start to break the state into slices:

```typescript
// store/index.ts
import { ModalSlice, createModalSlice } from ""./store/modal-slice"";

type StoreState = ModalSlice; // Eventually there will be more slices!

const useStore = create<StoreState>()((...a) => ({
  ...createModalSlice(...a)
}))

// store/modal-slice/index.ts

export const createModalSlice: StateCreator<
  StoreState,
  [],
  [],
  ModalSlice
> = _ => ({
  open: false,
});
```

I'll run into an odd error about webpack imports:

```TypeError: _modal_slice__WEBPACK_IMPORTED_MODULE_0__.createModalSlice is undefined```

<img width=""954"" alt=""Screen Shot 2022-08-05 at 11 07 18 AM"" src=""https://user-images.githubusercontent.com/9866928/183106533-e6077389-94d7-49cc-ab45-87251b96af86.png"">

Any thoughts on how to alleviate this issue? I would like the ability to split into slices. I have attempted enabling/disabling `esmExternals` in my `next.config.js` but it seems it does not make a difference.",,
1328532490,1168,TypeError: vanillaExports is not a function    ,"Problem
- I'm using zustand v4 in a library (eth-hooks, written in typescript).   
- When i used this package in a vite app that (uses rollup to build and serve)

i get this error 
```
TypeError: vanillaExports is not a function
    at createImpl (index.js:20:51)
    at chunk-64K5LCRV.js:1:10870
```

zustand is part of the dependencies of this app.  if i don't have zustand as part of the dependencies i get 
```
TypeError: zustandExports is not a function
```



Any others thoughts on how to approach this issue?  i'm using tsup (esbuild) to build my library and vite to build the app. Should i make zustand a peer dependency in my library?",,
1328373363,1167,IOS Chrome can not set a string and returns nothing,"Hi, I am using zustand V3 with react V18 and typescript, the problem is on IOS platforms using chrome and google 
the code that set an access token is not working

here is my code


`
if (typeof data === ""string"") {
            setLoading(false);
            setAccess(data);
            setIsLogIn(true);
            navigate(""profile"");
          } else {
            alert(""Wallet address and telegram Id is used before"");
            window.location.reload();
          }
`
in the above code I am trying to send an request to the server to get the access token and want to save that token to the `access` state and use it everywhere 

also should mention that I am storing the token to the cookies as well

`store.ts`

`
import create from ""zustand"";

interface USER {
  access: string;
  setAccess: (access: string) => void;
  setIsLogIn: (data: boolean) => void;
  isLoggedIn: boolean;
  onLogin: boolean;
  setOnLogin: (data: boolean) => void;
  ref: string | null;
  setRef: (ref: string) => void;
}

export const useLogin = create<USER>((set) => ({
  access: """",
  isLoggedIn: false,
  onLogin: true,
  ref: null,

  setRef: (ref) => set((state) => ({ ...state, ref })),
  setAccess: (token) => set((state) => ({ ...state, access: token })),
  setIsLogIn: (data) => set((state) => ({ ...state, isLoggedIn: data })),

  setOnLogin: (data) => set((state) => ({ ...state, onLogin: data })),
}));
`

the code above is ok when using any other platforms such as macOS and android and even safari in IOS
but not saving the `access` on IOS search engines such as firefox chrome and google

",,
1321939194,1156,set function expects 3-4 parameters when used with devtools middleware (typescript),"**Expected**
When using `create` function with the devtools middleware i expect the store `set` function to work in the same way as it does without the middleware and produce no compilation error.

**Actual**

When using `create` function with the devtools middleware typescript emits a compilation error as it expects 3-4 params for the `set` function which is unexpected for me.

**Example to reproduce**

```javascript
import create from ""zustand"";
import { devtools } from ""zustand/middleware"";
import { immer } from ""zustand/middleware/immer"";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const works = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}));

const alsoWorks = create<BearState>()(
    immer((set) => ({
        bears: 0,
        increase: (by) => set((state) => ({ bears: state.bears + by })),
    }))
);


// Compilation Error at the call of ""set((state) ..."": TS2554: Expected 3-4 arguments, but got 1.
const doesntWork = create<BearState>()(
  devtools((set) => ({
    bears: 0,
    increase: (by) => set((state) => ({ bears: state.bears + by })),
  }))
);
```

**Versions**

typescript: 4.1.3
zustand: 4.0.0",,
1321229673,1151,Copy state array,"When I set the state in setCatsTop it sets the state of the useTopCategories store as well.
How can I prevent that ? 
Is there a spesial way to copy the state of the store ?

-------------------------------------------------------------------------------------------

import {useTopCategories,} from ""@/hooks/DynamickProps""

const CategoryPanel = () => {
  const categoriesTop = useTopCategories(state => state.categoriesTop)
  
  const [catsTop, setCatsTop] = useState(...[categoriesTop])

  const changeTopCatPublished = (i) => {
    let tempArray = catsTop
    const x = Number(tempArray[i].cPublished)
    tempArray[i].cPublished = x === 1 ? 0 : 1
    setCatsTop([...tempArray])      
  }

return (
{catsTop.map((cat,i) => (
    <>
    <p>{cat.cName}</p>
    <Box
        as=""button""
        background={cat.cPublished === 0 ? butBgColor:butBgColorSel}
        borderColor={cat.cPublished === 0 ? butBorderColor:butBorderColorSel}
        color={butTextColor}
        borderWidth=""1px""
        borderLeftStyle=""solid""
        padding=""0px"" 
        width=""50%"" 
        height=""32px""
        textAlign=""center""
        outline=""none""
        cursor= ""pointer""
        _hover={{
        borderWidth:""1px"",
        borderStyle:""solid"",
        borderColor:butBorderColorSel
        }}
        onClick={e => changeTopCatPublished(i)} 
        >
        <span className=""ButtonLabel"" style={cat.cPublished === 0 ? {color:butTextColor}:{color:butTextColorSel}}>Publisert</span>
    </Box>
    </>
))}
)

}",,
1319580186,1145,Persist middleware and SSR/SSG,"Hello 👋

I would like to know how, in your NextJS or any SSR/SSG project, did you use the persist middleware.

I have this issue on my project where the state persisted in the localstorage is retrieved before NextJS hydration. This means, the SSR/SSG render differs from the first client-side render, which causes the React tree to be out of sync.

My solution for this problem is to defer zustand hydration using a new option on the persist middleware. [Here is my custom persist middleware.](https://github.com/kinoadr/zustand/commit/d9f62ed58fa11cbc7a55e30354e6c58ac090cf71)

I resolve the given promise when I know the first client-side render is done. This triggers the persisted state to hydrate.

What do you think ?
",,
1317735543,1137,useStore + selectors that return functions with Preact,"I tried updating to v4 on a Preact project today but I'm hitting issues with a selector that returns a function while using `useStore`. It appears that Preact is deciding to execute said function.

I've debugged this using Preact but I suspect it could apply to React too.

Following is my debugging which is probably a bit verbose but hopefully helps somewhat.

In Preact, `useState` is defined as:

```js
export function useState(initialState) {
  currentHook = 1;
  return useReducer(invokeOrReturn, initialState);
}
```

where `useReducer` is:

```js
export function useReducer(reducer, initialState, init) {
  const hookState = getHookState(currentIndex++, 2);
  hookState._reducer = reducer;
  if (!hookState._component) {
    hookState._value = [
      !init ? invokeOrReturn(undefined, initialState) : init(initialState),

      (action) => {
        const nextValue = hookState._reducer(hookState._value[0], action);
        if (hookState._value[0] !== nextValue) {
          hookState._value = [nextValue, hookState._value[1]];
          hookState._component.setState({});
        }
      },
    ];

    hookState._component = currentComponent;
  }

  return hookState._value;
}
```

and `invokeOrReturn` is:

```js
function invokeOrReturn(arg, f) {
  return typeof f == 'function' ? f(arg) : f;
}
```

As a result, when you call the `setState` callback, you effectively call the `dispatch` callback from the reducer, i.e.

```js
(action) => {
  const nextValue = hookState._reducer(hookState._value[0], action);
  if (hookState._value[0] !== nextValue) {
    hookState._value = [nextValue, hookState._value[1]];
    hookState._component.setState({});
  }
};
```

Now, `_reducer` here is `invokeOrReturn` so if the state (`action`) you pass in is a function, it will be executed with the current state (`hookState._value[0]`) as the argument.

So far, so good. This matches React's definition of `setState` so hopefully nothing Preact-specific this far.

When we use the new `useStore` function from v4 we get a call to `useSyncExternalStoreWithSelector` which uses the shim from the `use-sync-external-store` package but it ultimately ends up calling into Preact's version of `useSyncExternalStore` which is defined as follows:

```js
export function useSyncExternalStore(subscribe, getSnapshot) {
  const [state, setState] = useState(getSnapshot);

  // TODO: in suspense for data we could have a discrepancy here because Preact won't re-init the ""useState""
  // when this unsuspends which could lead to stale state as the subscription is torn down.

  useEffect(() => {
    return subscribe(() => {
      setState(getSnapshot());
    });
  }, [subscribe, getSnapshot]);

  return state;
}
```

Notice the use of `useState` here.

Now, in zustand I have a store defined using the following function.

```js
export const createEditStore = () =>
  createStore<Immutable<EditState>>((set) => ({
    cardState: { kind: 'init' },
    dispatch: (event: EditEvent) => {
      set(
        produce((state: EditState) => {
          state.cardState = reduce({
            event,
            state: state.cardState,
            dispatch: state.dispatch,
          });
      );
    },
  }));
```

This allows fetching the `dispatch` function off the state in order to mutate it with actions that run through a separate reducer.

Accordingly there is a selector for that:

```js
export const getDispatch = (state: EditState) => state.dispatch;
```

which we can use as follows:

```js
const editStore = React.useContext(EditStoreContext);
const dispatch = useStore(editStore, getDispatch);
```

In the definition of `dispatch`, the call to `set` (`setState`) ends up triggering all listeners on the store--all of which are defined using `useSyncExternalStore` so presumably they are the places I'm using `useStore`.

They go to run the call to `setState(getSnapshot())` in Preact's definition of `useSyncExternalStore` which in turn runs `useReducer` passing in the result of the selector, which, in this case, is a function.

Preact sees a function being passed to `setState` and proceeds to execute it.

I've sunk an hour or two into this so far so I'll take a break for now, but let me know if you need minimal test case in order to reproduce it and I'll try to make time in the next few days for it.",,
1317559160,1134,v4 Partialize TS Issues,"Hi. Thank you for this great package. 

I am using v4 RC 4 and am having TS issues when using the persist middleware with the partialize method. 

I've attached a [code sandbox](https://codesandbox.io/s/heuristic-rain-swytsd?fontsize=14&hidenavigation=1&theme=dark) with a reproductino of the issue. If you comment line 25, the types are fine. What's the recommended way of using partialize with Typescript in v4?

Here is the same [code working with zustand v3.7.2](https://codesandbox.io/s/mystifying-cartwright-8m61rw?file=/src/App.tsx).

Thank you!",,
1316137422,1128,Multi Zustands - Seems like you have not used zustand provider as an ancestor.,"Hi! 

I'm using React Three Fiber( with Drei), ReactFlow and [Plate](https://plate-api.udecode.io/) (all of which use Zustand internally), in  React App that uses Redux for state management. 

I'm getting this error 

```
context.js:32 Uncaught Error: Seems like you have not used zustand provider as an ancestor.
    at useStoreApi (context.js:32:1)
    at slicedToArray.js:7:1
```

I've got no idea where this is coming from! 

On I think pages that are using the Plate text editor, which is within a drei HTML component where the Redux state is passed in 

```
             const ContextBridge = useContextBridge(ReactReduxContext);
            ....
          <ContextBridge>
            <Wrapper ref={ref} readOnly={!editing} id={'text-editor'} className=""box"">
              <TextEditor
                textId={entity.textId}
                readOnly={!editing}
                parentId={entity.id}
                parentType={EntityTypes.ACTION_ENTITY}
              />
            </Wrapper>
          </ContextBridge>
```

This error has only recently started turning up, I assume on of the libraries has updated how they manage content. 

If I comment this out, I still get the error - but on pages where this text component isn't present I never see this error. 

Any idea how to get rid of it? ",,
1316076749,1127,Broken `PersistOptions['partialize']`,"I just bumped from `rc-1` to `rc-4` and found out that now the `partialize` func in the `persist` middleware is not returning a `Partial<State>` anymore. The only workaround i found right now is to cast the entire options object to `PersistOptions<State, Partial<State>>` and then cast it again to `any`.

Is this intended? Maybe I'm using the `partialize` func in the wrong way.. Shouldn't it be used to filter keys that have to bes stored?

An example impl below:

```ts
interface State {
	pageTitle?: string
	sidebarOpen: boolean
}

/* simplified (without setters) too keep it short */
const useLayoutState = create(
	persist<State>(
		set => ({
			sidebarOpen: true,
		}),
		{
			name: 'layout-state',
			partialize: ({ sidebarOpen }) => ({
				sidebarOpen,
			}),
		} as PersistOptions<State, Partial<State>> as any
	)
);
```",,
1310883798,1118,Store is not callable,"A follow up to #1113 I'm using the commit based package mentioned there.

@dai-shi I'm getting an error where the hook created by createStore isn't callable.  It doesn't seem to be a function when i try to use it in a react funtion.

```
This expression is not callable.
  Type 'Write<WithDevtools<StoreApi<IEthersAppStore>>, StorePersist<IEthersAppStore, IEthersAppStore>>' has no call signatures.ts(2349)
```

```
import { createStore } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

import { IBlockNumberState } from '~~/context/EthersAppState';

interface IEthersAppStore {
  blockNumberStore: IBlockNumberState;
}

type TSetStoreFunc =
  | IEthersAppStore
  | Partial<IEthersAppStore>
  | ((state: IEthersAppStore) => IEthersAppStore | Partial<IEthersAppStore>);

const setBlockNumber = (chainId: number, blocknumber: number): TSetStoreFunc => {
  return (state): IEthersAppStore => {
    state.blockNumberStore[chainId] = blocknumber;
    return state;
  };
};
export const useEthersAppStore = createStore<IEthersAppStore>()(
  devtools(
    persist((set) => ({
      blockNumberStore: {},
      setBlockNumber: (blocknumber: number, chainId: number): void => set(setBlockNumber(chainId, blocknumber)),
    }))
  )
);


export const useBlockNumberContext = (): number => {
  const store = useEthersAppStore();
  // if (blockNumber == null) {
  //  console.log('blockNumber context is null');
  // }
  // invariant(blockNumber != null, 'useBlockNumberContext needs to be used under BlockNumberContext');
  return blockNumber ?? 0;
};

```",,
1310000090,1115,setState failing after rc1 to rc2 update,"I'm using `store.setState` in some Cypress tests to set up my store externally. This is my code:
```js
import set from 'lodash/set';
import {useUserStore} from 'user/store';

const onOrgSwitch = () => {
    const {activeOrg} = useUserStore.getState();
    
    useUserStore.setState(set(activeOrg, 'planType', 'PACE'));
};
```
in rc2 it no longer works and the state is not updated and my tests fail. This is a snippet from a test file obviously but I can confirm this is the portion that is no longer working across multiple tests that do basically the same thing. Downgrading to rc1 fixes the issue and all the tests pass.",,
1309491088,1113,Typescript store error,"I'm getting the following error from the below code.  I'm copying the typescript example for my purpose.  I'm unsure as to why i'm getting this typescript error.  

```
Exported variable 'useEthersAppStore' has or is using name 'StorePersist' from external module 
""/Documents/dev/open-source/ethereum/scaffold-eth/eth-hooks/node_modules/zustand/middleware/persist"" 
but cannot be named.ts(4023)
```

```
import { createStore } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

import { IBlockNumberState } from '~~/context/ethers-app/BlockNumberContext';

interface IEthersAppStore {
  blockNumberStore: IBlockNumberState;
}

export const useEthersAppStore = createStore<IEthersAppStore>()(
  devtools(
    persist((set) => ({
      blockNumberStore: {},
      setBlockNumber: (blocknumber: number, chainId: number): void =>
        set((state): IEthersAppStore => {
          state.blockNumberStore[chainId] = blocknumber;
          return state;
        }),
    }))
  )
);

```",,
1309316276,1112,Uncaught TypeError: Cannot set properties of undefined (setting 'setState'),"**Error**
```
Uncaught TypeError: Cannot set properties of undefined (setting 'setState')
    at zustand_middleware.js?v=56051a9a:60:16
    at App (App.jsx:11:17)
    at renderWithHooks (react-dom_client.js?v=56051a9a:11608:26)
    at mountIndeterminateComponent (react-dom_client.js?v=56051a9a:14296:21)
    at beginWork (react-dom_client.js?v=56051a9a:15228:22)
    at HTMLUnknownElement.callCallback2 (react-dom_client.js?v=56051a9a:3451:22)
    at Object.invokeGuardedCallbackDev (react-dom_client.js?v=56051a9a:3476:24)
    at invokeGuardedCallback (react-dom_client.js?v=56051a9a:3510:39)
    at beginWork$1 (react-dom_client.js?v=56051a9a:19032:15)
    at performUnitOfWork (react-dom_client.js?v=56051a9a:18465:20)
```
**My App.js**
```
import { useEffect } from ""react"";
import { BrowserRouter as Router, Route, Routes } from ""react-router-dom"";

import Login from ""./pages/Login"";
import Home from ""./pages/Home"";
import Transactions from ""./pages/Transactions"";

import useConnectStore from ""./store/useConnectStore"";

const App = () => {
  const check = useConnectStore((state) => state.checkIfConnected); //This is where the error is coming from
  useEffect(() => {
    check();
  }, []);

  return (
    <Router>
      <Routes>
        <Route path=""/"" element={<Home />} />
        <Route path=""/login"" element={<Login />} />
      </Routes>
    </Router>
  );
};

export default App;

```

**My useConnectStore**
```
import create from ""zustand"";
import { persist, devtools } from ""zustand/middleware"";

const connectStore = (set) => ({
  connectedAccount: """",
  connectedAccountBalance: """",
  checkIfConnected: async () => {
    try {
        set((state) => ({
          connectedAccount: """",
          connectedAccountBalance: """",
      } else {
        console.log(""No accounts found"");
      }
    } catch (error) {
      console.log(error);
    }
  },
  connectW: async () => {
    try {
      set((state) => ({
        connectedAccount: """",
        connectedAccountBalance: """",
      }));
    } catch (error) {
      console.log(error);
    }
  },
});

const useConnectStore = devtools(
  persist(create(connectStore), {
    name: ""connectStore"",
  })
);

export default useConnectStore;

```

Please what's the issue, is it from me or from zustand",,
1309192708,1111,Cannot clear storage after updating to 3.7.2,"Hi,

After updating to version 3.7.2, the clearStorage function doesn't seem to work correctly anymore. It looks like PR #894 broke it for us.  When resetting the first change in https://github.com/pmndrs/zustand/pull/894/files, it works again. We have the following code:

```
export function StoreProvider(props: { children: ReactNode }) {
  const { children } = props;

  const hasHydrated = useStore(state => state._hasHydrated);

  // Clear persisted storage when new app install
  const initializeApp = async () => {
    const appInstalled = await AsyncStorageService.getItem(APP_INSTALLED_KEY);

    if (!appInstalled) {
      useStore.persist.clearStorage();
      useStore.persist.rehydrate();
    }
  };

  useEffect(() => {
    initializeApp();
  }, []);

  return hasHydrated ? <Provider createStore={() => useStore}>{children}</Provider> : null;
}
```

It's a provider that wil check if the app was installed. If opening the app, and the appInstalled state Is not true, it would clear the storage because we don't want the persisted storage to still be here when you deleted the application.

Sander",,
1308254416,1103,Missing exports on middleware,"Following the documentation and creating a very simple store with a handful of middleware I've found that it's not possible to generate a declaration file from the returned type due to missing exports in some of the middleware interfaces
https://codesandbox.io/s/zustand-4-0-0-rc-2-declaration-ndix3z?file=/src/index.ts

```ts
// ...
export const store = create(
  subscribeWithSelector(devtools(redux(reducer, defaultState)))
);
```

With the following TS Config:
```json
{
  ""compilerOptions"": {
    ""declaration"": true
  }
}
```


<details>
<summary>Full TS error</summary>

```
const store: WithRedux<WithDevtools<Write<StoreApi<Write<{
    count: number;
}, ReduxState<Actions>>>, StoreSubscribeWithSelector<Write<{
    count: number;
}, ReduxState<Actions>>>>>, Actions>
Exported variable 'store' has or is using name 'ReduxState' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'ReduxState' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'StoreSubscribeWithSelector' from external module ""/sandbox/node_modules/zustand/middleware/subscribeWithSelector"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'ReduxState' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'ReduxState' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'ReduxState' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'ReduxState' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'ReduxState' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'Action' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'Action' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'StoreRedux' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
Exported variable 'store' has or is using name 'StoreRedux' from external module ""/sandbox/node_modules/zustand/middleware/redux"" but cannot be named.ts(4023)
```
</details>

Simple fix would be to export the interfaces that are used in the resolved types, so typescript can pull them out to:
```
import('zustand/middleware').SomeInterface
```
When exporting a declaration file. ~Happy to open a PR if that's the case~ (PR #1104)

Edit: took an example from the [TypeScript Guide](https://github.com/pmndrs/zustand/blob/main/docs/typescript.md) highlighting the issue: https://codesandbox.io/s/zustand-4-0-0-rc-2-declaration-from-docs-uq2yv1",,
1307867678,1100,Store factory typings,"So I'm trying to create a store factory which will essentially adds just one helper method to the initial state object:

```
import create, { type State } from ""zustand"";
import { combine, persist } from ""zustand/middleware"";

export const createPreferencesStore = <TState extends State>(initialState: TState, storageKey = ""preferences"") =>
  create(
    persist(
      combine(initialState, (setState) => ({
        setPreference: <TKey extends keyof TState>(key: TKey, value: TState[TKey]) => {
          setState({ [key]: value } as unknown as Partial<TState>);
        },
      })),
      { name: storageKey }
    )
  );
```

Before the last update everything worked fine, but now I have an error: _""TS4023: Exported variable 'createPreferencesStore' has or is using name 'StorePersist' from external module "".../node_modules/zustand/middleware/persist"" but cannot be named.""_ I understand that you have removed the StorePersist type from the exports? Is there any way to type the factory? I also think that the ""as unknown as Partial<TState>"" is not the correct way to type the function.",,
1307531987,1098,Example for unit testing zustand+immer?,"I'm using `zustand@4`, plus `zustand/middleware/immer` (thanks!).

My actions typically look like this:

```tsx
const { getState, setState } = useUserStore

export const fetchUser = async () => {
  try {
    setState(state => { state.user.meta = loadingMeta('loading') })

    const data = await myAPIClient.get<User>({ relativeUrl: '/v1/user' })

    setState(state => {
      state.user = { data, meta: loadingMeta('loaded') }
    })
  } catch (error: any) {
    setState(state => { state.user.meta = loadingMeta('error', error) })
  }
}
```

I'm wondering if anyone has suggestions about how to unit test such an action, given that `setState` is called with a _function_ that directly mutates the input.

The only sort of pattern I've been able to come up with so far, looks like this (pseudo code):

```tsx
describe('fetchUser', () => {
  it('calls setState with the correct payload', async () => {
    await userStoreActions.fetchUser()

    const [[call]] = (useUserStore.setState as jest.Mock).mock.calls
    const state = {
      user: {
        data: null,
      },
    }

    call(state)

    expect(state.user.data.id).toBe('test-user-id')
  })
})
```

This feels very imperfect, as it basically requires manual testing of the mutation ourselves.

Would be very grateful to hear any suggestions!",,
1306851468,1091,IndexedDB not persisted,"Hi! I'm having a hard time setting up IndexedDB with idb-keyval and zustand. First of all, I'm using Expo to develop a custom RN app using expo development builds.

I can use zustand without any issue to setup fishes state and **addFish** to add plus one fish each time it's called, but the persisted storage that I want to use with IndexedDB doesn't seem to get persisted at all, because, after reload or reboot of the app, the storage gets value 0 on the **fishes** key. 

**My deps are**
```
    ""idb-keyval"": ""^6.2.0"",
    ""zustand"": ""^3.7.2""
```

**usePersistAppContextStore.tsx**
```
import create from 'zustand';
import { persist, StateStorage } from 'zustand/middleware';
import { get, set, del } from 'idb-keyval';

const zustandStorage: StateStorage = {
  getItem: async (name: string): Promise<string | null> => {
    return (await get(name)) || null;
  },
  setItem: async (name: string, value: string): Promise<void> => {
    await set(name, value);
  },
  removeItem: async (name: string): Promise<void> => {
    await del(name);
  },
};

const usePersistAppContextStore = create(
  persist(
    (set, get) => ({
      fishes: 0,
      addFish: () => set({ fishes: get().fishes + 1 }),
      clearFish: () => set({ fishes: 0 }),
    }),
    {
      name: 'app-storage',
      getStorage: () => zustandStorage,
    },
  ),
);

export default usePersistAppContextStore;
```

**App.tsx**
```
...
...
import usePersistAppContextStore from './app/stores/usePersistAppContextStore';

export default function App() {
  const { fishes, addFish } = usePersistAppContextStore(({ fishes, addFish }) => ({
    fishes,
    addFish,
  }));

  console.log('Stored fishes:', fishes);
  addFish();
  console.log('Added one fish, equals to ', fishes, ' fishes');
...
...
```

The code above add fishes but after restart of reboot app, the counter starts at 0 again.",,
1300459012,1076,v4: Typescript type missing,"I follow the new Typescipt doc and use the curring to make the type work. But it is still show any.
Bellow is the code.
```
import create from ""zustand"";

import createAStore, { IExample1Store } from ""./store1"";
import createBStore, { IExample2Store } from './store2'

export type MyState = IExample1Store & IExample2Store;

const useStore = create<MyState>()((set, get) => ({
  ...createAStore(set, get),
  ...createBStore(set, get)
}));

export default useStore;
```
```
import { GetState, SetState } from ""zustand"";
import produce from 'immer'
import useAsync from '@/utils/useAsync'
import { mockFetch } from '@/api/example/mockFetch';
import { MyState } from ""./index"";

export interface IExample1Store {
  dataA: any
  getDataAAction: () => void
}

type StoreFunction = (set: SetState<MyState>, get: GetState<MyState>) => IExample1Store

const createAStore: StoreFunction = (set, get) => ({
  dataA: '',
  getDataAAction: async () => {
    const [result, error] = await useAsync(mockFetch(1))
    if (error) {
      return
    }
    set(produce(state => { state.dataA = result.data }))
  }
});

export default createAStore;
```
```
import { GetState, SetState } from ""zustand"";
import produce from 'immer'
import useAsync from '@/utils/useAsync'
import { mockFetch } from '@/api/example/mockFetch';
import { MyState } from ""./index"";

export interface IExample2Store {
  dataB: any
  getDataBAction: () => void
}

type StoreFunction = (set: SetState<MyState>, get: GetState<MyState>) => IExample2Store

const createBStore: StoreFunction = (set, get) => ({
  dataB: '',
  getDataBAction: async () => {
    const [result, error] = await useAsync(mockFetch(2))
    if (error) {
      return
    }
    set(produce(state => { state.dataB = result.data }))
  }
});

export default createBStore;
```

useStore and the state both show any type.
sad",,
1298810139,1065,zustand typescript issue,close,,
1294766139,1060,create<T>()() misunderstanding,"According to the Typescript.md:
The difference when using TypeScript is instead of writing create(...), you have to write create<T>()(...) where T would be type of the state so as to annotate it.

First, I don't understand what the ()() is doing, it seems to be related to currying (something I don't ever use) (sorry my ignorance) , secondly it seems to work fine without that. Must we change our create calls to have the ()() ?


Also, it would be better to use type only imports in zustand/context to separate the types from the functions like this:


//context.ts
```

import {
  createContext as reactCreateContext,
  createElement,
  useContext,
  useMemo,
  useRef,
  type ReactNode,
} from 'react';
import {
  useStore,
  type EqualityChecker,
  type State,
  type StateSelector,
  type StoreApi,
} from 'zustand';",,
1294731239,1059,Trying to migrate to v4 but hitting issue with mocking,"I was using the __mocks__/zustand.ts that contained the boilerplate from the doc, but now I get 
 TypeError: store.getState is not a function

```
import { act } from 'react-dom/test-utils';
import actualCreate from 'zustand';

// a variable to hold reset functions for all stores declared in the app
const storeResetFns = new Set();

// when creating a store, we get its initial state, create a reset function and add it in the set
const create = createState => {
  const store = actualCreate(createState);
  const initialState = store().getState();
  storeResetFns.add(() => store.setState(initialState, true));

  return store;
};

// Reset all stores after each test run
afterEach(() => {
  act(() => storeResetFns.forEach(resetFn => resetFn()));
});

export default create;",,
1293704028,1054,only one argument is being passed if multiple variables are imported as destructured object,"  const {stateVariable1, stateVariable2, updateVariable1} = myStore(store => ({
        stateVariable1: store.stateVariable1 ,
        stateVariable2: store.stateVariable2,
        updateVariable1: store.updateVariable1,
    }))

updateVariable1(arg1, arg2)

the problem is that if I import variables to my component this way the function inside the store 
will only read 1st argument and ignore the second one. 

is it intended behavior or a bug?

",,
1293393813,1053,Persist Partialize not working with TypeScript,"I've been having trouble getting Zustand's _persist partialize_ middleware, to work with TypeScript. I'm not sure what type to provide and where.

Thanks in advance!

Here is the TS error I am currently getting.
```
Argument of type 'StateCreator<Store, [], [[""zustand/persist"", { siteId: string; }]], Store>' 
is not assignable to parameter of type' StateCreator<Store, [], [[""zustand/persist"", Store]], Store>'.

Type 'StateCreator<Store, [], [[""zustand/persist"", { siteId: string; }]], Store>' 
is not assignable to type '{ $$storeMutators?: [[""zustand/persist"", Store]]; }'.

Types of property '$$storeMutators' are incompatible.

Type '[[""zustand/persist"", { siteId: string; }]]' is not assignable to type '[[""zustand/persist"", Store]]'.

Type '[""zustand/persist"", { siteId: string; }]' is not assignable to type '[""zustand/persist"", Store]'.

Type at position 1 in source is not compatible with type at position 1 in target.

Type '{ siteId: string; }' is missing the following properties from type 'Store': tooltip, setTooltip, email, setEmail, and 5 more.
```
Here is my store in a codesandbox:
https://codesandbox.io/s/flamboyant-sun-mwhr13?file=/store.ts",,
1293338210,1052,Immer middleware in 4.0.0-rc.1 produces typescript error,"I'm using zustand `4.0.0-rc.1` with `react 17` and immerjs. I tried using the immer middleware as shown in the readme (not a custom method like in [the documentation](https://docs.pmnd.rs/zustand/recipes#sick-of-reducers-and-changing-nested-state?-use-immer!), but really the exported immer middleware from `zustand/middleware/immer`.

In a simple store like this:

```typescript
type MyState = Immutable<{
  myId: string;
  setMyId: (id: string) => void;
}>;

const myStore = create<MyState>(
  immer((set) => ({
    myId: '',
    setMyId: (id) =>
      set((state) => {
        state.myId = id;
      }),
  }))
);
```

the following typescript error is shown: 

```
Argument of type 'StateCreator<{ readonly myId: string; readonly setMyId: (id: string) => void; }, [], [[""zustand/immer"", never]], { readonly myId: string; readonly setMyId: (id: string) => void; }>' is not assignable to parameter of type 'StateCreator<{ readonly myId: string; readonly setMyId: (id: string) => void; }, [], [], { readonly myId: string; readonly setMyId: (id: string) => void; }>'.
  Type 'StateCreator<{ readonly myId: string; readonly setMyId: (id: string) => void; }, [], [[""zustand/immer"", never]], { readonly myId: string; readonly setMyId: (id: string) => void; }>' is not assignable to type '{ $$storeMutators?: []; }'.
    Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
        Source has 1 element(s) but target allows only 0.(2345)
```

However, the middleware works as intended when I 
- remove the `MyState` typing from the create method or
- move the typing to the immer middleware, so 

```typescript
const myStore = create(
  immer<MyState>((set) => ({
    myId: '',
    setMyId: (id) =>
      set((state) => {
        state.myId = id;
      }),
  }))
);
```

Is this intended, or should the store be typed like in my first code snippet? This is at least what I would expect.

Here a reproduction repo: https://stackblitz.com/edit/react-ts-gblznc?file=store.ts

Also, two small things:
- Version [4.0.0-rc.1](https://www.npmjs.com/package/zustand/v/4.0.0-rc.1) seems to be marked as a **stable** version, so is installed by default via NPM. That seems very odd.
- I would love to see an example on how to create some utility functions around the store, for example a default `createStoreWithMiddleware` method that always uses the same middleware and is still typed. I was not able to create such a method using the immer middleware as I always ran into typing issues.

Let me know if you need amy more details, thank you!",,
1291849108,1047,typed action return type ignored only inside zustand,"Recreating the same action + type outside of zustand, typescript catches the error. I'm not quite sure why it is happening and was able to reproduce it in a sandbox.

Sandbox: https://codesandbox.io/s/weathered-silence-esui4g?file=/src/App.tsx",,
1286762834,1040,can we cache our async await task in zustand?,,,
1286504565,1038,Zombie children when using React 16?,"Forgive me if the ""zombie children"" term is not correct, but from what I understand this is what I figured out while researching about the issue.
It seems that zustand's selectors are executing in incorrect order after a specific scenario.

Imagine the following application:

```
App
 |-- View1
      |-- Viewer
      |-- Editor
 |-- View2
```

- There is a ternary in `App` which renders either `View1` or `View2`
- There is a ternary in `View1` which looks up a zustand store and decides which component (`Viewer` or `Editor`) to render
- The `Viewer` contains a button which updates zustand store so that we can transit to `Editor`
- The `Editor` contains a controlled input where its value is stored in zustand. The `Editor` component has a ""submit"" button which erases that value, thus making the transition to `Viewer`
 
 Code sandbox link: https://codesandbox.io/s/sharp-pike-zdomm2

Perform the following steps:
1. Click on button ""Show view 1"":
2. Click on button ""EDIT""
3. Click on button ""Show view 2"":
4. Click on button ""Show view 1"":
5. Type anything on the field and hit ""SUBMIT"" button

Actual behaviour: Receiving type error.
Expected behaviour: switch back to View component without any error.

Notes: 
1) Issue is not reproducible when omitting steps 3 and 4
2) Issue is not reproducible when using React 18

I suspect that when returning back to View1 useStore's selectors are not placed in the correct order, but how can we correct this ?",,
1285044200,1037,Basic example from docs not working,"Hey y'all,

New to Zustand here. I'm trying out the docs, and created [a basic example](https://codesandbox.io/s/confident-stitch-l2fkgp?file=/pages/index.js) in Code Sandbox to showcase my issue. My sandbox is in NextJS - but the same error happens in a standard React app.

Here is what the basic example looks like: 

```javascript
import create from ""zustand"";

export default function IndexPage() {
  const useStore = create((set) => ({
    bears: 0,
    increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
    removeAllBears: () => set({ bears: 0 })
  }));

  const bears = useStore((state) => state.bears);
  const increasePopulation = useStore((state) => state.increasePopulation);

  return (
    <div>
      <h1>{bears}</h1>
      <button onClick={increasePopulation}>increase population</button>
    </div>
  );
}

```

However, calling `increasePopulation` doesn't increase the values of bears. Is there something I'm missing from the documentation/an error that I'm making?",,
1284632933,1034,setTimeout,"I want disappering alert boxes, so in storefile I defined 

 ```
alerts    : [],
  addAlert  : (text)=>{
    set(            s=>({alerts:[...s.alerts, text]}) ); 
    setTimeout( () => set(s=>{
      s.alerts.shift();
      console.log(""timing outing is  "", s.alerts)
      return {alerts:s.alerts} 
      }), 2000 );} ,
```


and to render those 

```
import userInfo from ""../libs/user""
export default ()=>{
  let alerts = userInfo(s=>s.alerts)
  console.log(alerts)
  return  <div className=""alertPlace"" >
    {alerts.map(a=> <div className=""alert alert-error shadow-lg"">
                        <div>
                            <span>{a}</span>
                        </div>
                    </div>
    )}
            </div>
}

```


When I ""addAlert"" ui updates latest state, timeout works and removes items but doesnt effect ui, may be I disconnect function ""set""?",,
1278395570,1024,why can't I merge my slices into named indeices in an object,"```jsx
const createBearSlice: StoreSlice<IBearSlice, IFishSlice> = (set, get) => ({
  eatFish: () =>
    set((prev) => ({ fishes: prev.fishes > 1 ? prev.fishes - 1 : 0 })),
});
const createRootSlice = (set: SetState<any>, get: GetState<any>) => ({
  bears: createBearSlice(set, get),
  fishes: createFishSlice(set, get),
});
```
when I fire `eatFish` function is doesn't fire and gives me the following error `TypeError: eatFishis not a function` 

when I go back to the example in the docs 
```jsx

const createRootSlice = (set: SetState<any>, get: GetState<any>) => ({
  ...createBearSlice(set, get),
  ...createFishSlice(set, get),
});
```
it does work fine,
is there a solution other than writing my action in the very top level of my store or making my global state data look like a train wreck
",,
1275150044,1017,[question] How to type provided value in api through middleware (typescript),"Hello, I try to provide an helpers function to all my stores trough a middleware. 

But I can not find the way to **type the api object**.

Here is a codesandbox to highlight my issue: https://codesandbox.io/s/zustand-middleware-typescript-provide-method-60bz2v?file=/src/zustand-demo.ts

Here is my custom ""createStore"" who use my middleware

```ts
// zustand-helper.ts
export const createStore = <StoreType extends {}>(
  fn: StateCreator<StoreType>
) => {
  const customMiddleware: Middleware<StoreType> = config => (set, get, api) => {
    const test = () => {
      console.log(""THIS IS A TEST"")
    }
    return config(set, get, { ...api, test }, [])
  }
  return create(customMiddleware(fn))
}
```
Here I got a type error on test in config return:
![image](https://user-images.githubusercontent.com/18116930/174324834-e94041c9-b0ab-4294-a59c-ae436bb984a8.png)

And this how I use my store

```ts
// zustand-demo.ts
import { createStore } from ""./zustand-helper""
type DemoStore = {
  test: string
  setTest: (test: string) => void
}
export const useDemoStore = createStore<DemoStore>((set, get, api) => ({
  test: """",
  setTest(value: string) {
    api.test()
    set({ test: value })
  }
}))
```
![image](https://user-images.githubusercontent.com/18116930/174325103-70949acc-b686-4636-8ff0-fbbab4683792.png)


",,
1273387563,1013,TS issue with the set function when using devtools (with older TS versions),"Hey there zustand team

I'm having a problem when using zustand with devtools in my next.js project.

When running the store locally, everything works fine and I'm seeing devtools. Awesome.

But, when building my app for production with nx/next.js, it throws the following error:

```bash
Type error: Expected 3-4 arguments, but got 1.

  62 |       damageLocation: TDamageLocation
  63 |     ) => {
> 64 |       set({ damageType, damageLocation, view: 'station' });
     |       ^
  65 |     },
  66 |     updateStation: (station: IStationState) => {
  67 |       set({ station, view: 'timeSlot' });
```

### What have I do so far:
1. Tried to follow this https://github.com/pmndrs/zustand/discussions/976 and looked at the `tests/middlewareTypes.test.tsx` and `tests/devtools.test.tsx` examples but not successful.
2. Tried to type the store like in the example above: `create<InitialState, [[""zustand/devtools"", InitialState]]>`
3. Tried changing the set function called on line 64 (example above) but then I get the same error on a different function

Using the following core dependencies:

- next: 12.1.0,
- nx: 13.9.5,
- react: 17.0.2,
- zustand: ^4.0.0-rc.1

Let me know if you need more details or if this makes no sense.",,
1271729275,1010,Type breaks inside of action when changing function arity.,"This issue is really hard for me to pinpoint exactly, as it seems to be caused by multiple things. This example might not seem to make sense, as I stripped away everything that didn't seem to cause the issue.

The following code types data as any, even though fetcher returns data as a string.

```ts
const fetcher = async (id: string, email: string, password: string) => ({
  data: id,
})

const useStore = create<{
  action: (id: string, email: string, password: string) => Promise<any>
}>(() => ({
  action: async (id, email, password) => {
    const { data } = await fetcher(id, email, password)

    return data // not returning data fixes the issue.
  },
}))
```

This one types data correctly as a string:

```ts
const fetcher = async (id: string) => ({
  data: id,
})

const useStore = create<{
  action: (id: string) => Promise<any>
}>(() => ({
  action: async id => {
    const { data } = await fetcher(id)

    return data // works even when returning data now
  },
}))

```

Typing the action function outside zustand seems to result in the expected result in both cases. I really hope someone can help me with this as I am at a loss.

Zustand version: 4.0.0
Typescript: 4.4.2",,
1268678040,1002,"Issue with Bitbucket Pipelines with Next.js 12, Zustand, and Cypress","Currently, I am using Next.js 12.0.1, Zustand 3.7.5, and Cypress for end-to-end testing. Everything works fine locally. However, when I try the same thing to do in Bitbucket pipelines, it seems that it is an issue related to #665, #962 or https://github.com/vercel/next.js/issues/30750

I've tried several things like using other node images or disabling `esmExternals` in the next config.

I get the following error:
```
$ cypress run --config video=false
$ next dev
ready - started server on 0.0.0.0:3000, url: http://localhost:3000/
info  - Loaded env from /opt/atlassian/pipelines/agent/build/.env.development
[STARTED] Task without title.
(node:72) ExperimentalWarning: The ESM module loader is experimental.
wait  - compiling...
event - compiled client and server successfully in 5.9s (341 modules)
[305:0612/191621.252637:ERROR:cert_verify_proc_builtin.cc(681)] CertVerifyProcBuiltin for [redirector.gvt1.com](http://redirector.gvt1.com/) failed:
----- Certificate i=0 (OU=Cypress Proxy Server Certificate,O=Cypress Proxy CA,L=Internet,ST=Internet,C=Internet,[CN=redirector.gvt1.com](http://cn%3Dredirector.gvt1.com/)) -----
ERROR: No matching issuer found
Attention: Next.js now collects completely anonymous telemetry regarding usage.
This information is used to shape Next.js' roadmap and prioritize features.
You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:
https://nextjs.org/telemetry
[305:0612/191621.940217:ERROR:cert_verify_proc_builtin.cc(681)] CertVerifyProcBuiltin for [r2---sn-p5qddn76.gvt1.com](http://r2---sn-p5qddn76.gvt1.com/) failed:
----- Certificate i=0 (OU=Cypress Proxy Server Certificate,O=Cypress Proxy CA,L=Internet,ST=Internet,C=Internet,[CN=r2---sn-p5qddn76.gvt1.com](http://cn%3Dr2---sn-p5qddn76.gvt1.com/)) -----
ERROR: No matching issuer found
Browserslist: caniuse-lite is outdated. Please run:
npx browserslist@latest --update-db
Why you should do it regularly:
https://github.com/browserslist/browserslist#browsers-data-updating
  Authentication
    anonymous user
wait  - compiling /auth (client and server)...
wait  - compiling...
event - compiled client and server successfully in 6.4s (1945 modules)
wait  - compiling /_error (client and server)...
wait  - compiling...
event - compiled client and server successfully in 1090 ms (1946 modules)
file:///opt/atlassian/pipelines/agent/build/node_modules/zustand/esm/index.mjs:1
import { useReducer, useRef, useDebugValue, useEffect, useLayoutEffect } from 'react';
                     ^^^^^^
SyntaxError: The requested module 'react' is expected to be of type CommonJS, which does not support named exports. CommonJS modules can be imported by importing the default export.
For example:
import pkg from 'react';
const { useReducer, useRef, useDebugValue, useEffect, useLayoutEffect } = pkg;
    at ModuleJob._instantiate (internal/modules/esm/module_job.js:97:21)
    at async ModuleJob.run (internal/modules/esm/module_job.js:136:20)
    at async Loader.import (internal/modules/esm/loader.js:179:24)
file:///opt/atlassian/pipelines/agent/build/node_modules/zustand/esm/index.mjs:1
```

In addition, I do not really get why node complains that ESM module loader is experimental because I am on node version >16.
Is the new Next.js compiler working fine with Zustand?",,
1268605708,1001,TypeScript error when using redux middleware,"Hey lovely zustand community,

I've read the documentation about using the redux middleware and how to use TypeScript with zustand. However I'm having trouble combining the two. Here is my minimal example to reproduce my problem:

```TypeScript
import create from ""zustand"";
import { redux } from ""zustand/middleware"";

export const actionTypes = {
  INCREMENT_MOVE_COUNTER: ""INCREMENT_MOVE_COUNTER"",
  INCREMENT_PAIR_COUNTER: ""INCREMENT_PAIR_COUNTER"",
};

interface StoreType {
  moveCounter: number;
  pairCounter: number;
}

const initialState: StoreType = {
  moveCounter: 0,
  pairCounter: 0,
};

const reducer = (state, action) => {
  switch (action.type) {
    case actionTypes.INCREMENT_MOVE_COUNTER: {
      return { ...state, moveCounter: state.moveCounter + 1 };
    }
    case actionTypes.INCREMENT_PAIR_COUNTER: {
      return { ...state, pairCounter: state.pairCounter + 1 };
    }
  }
};

export const useStore = create<StoreType>()(redux(reducer, initialState));
```

This will give me a very long TypeScript error on the last line, that I can't figure out how to interpret.

```
Argument of type 'StateCreator<Write<any, ReduxState<any>>, [], [[""zustand/redux"", any]], Write<any, ReduxState<any>>>' is not assignable to parameter of type 'StateCreator<StoreType, [], [[""zustand/redux"", any]], StoreType>'.
  Type 'StateCreator<Write<any, ReduxState<any>>, [], [[""zustand/redux"", any]], Write<any, ReduxState<any>>>' is not assignable to type '(setState: (partial: StoreType | Partial<StoreType> | ((state: StoreType) => StoreType | Partial<StoreType>), replace?: boolean) => void, getState: GetState<...>, store: StoreApi<...>, $$storeMutations: []) => StoreType'.
```

Any hints how I might be able to solve this?",,
1263903392,998,createContext creates wrong typescript for useStoreApi().subscribe,"When using createContext and wanting to subscribe to changes i can use the old style (listener, selector, equalityFn) but i will end up with a deprecated warning. 

If i change it to the new `subscribeWithSelector` it will work fine, but the typescript will show an error as it still wants the old format to be used (listener, selector, equalityFn) instead of the new (selector, listener, equalityFn)

![error](https://user-images.githubusercontent.com/5678318/172486803-f1dc8d0c-7120-4db4-9205-7472e198b099.png)

```ts
import create from 'zustand'
import createContext from 'zustand/context'
import { subscribeWithSelector } from 'zustand/middleware'
import { useEffect } from 'react'

type TestStoreState = {
  readonly bears: number
  increase: (by: number) => void
}

const { Provider, useStoreApi } = createContext<TestStoreState>()

const createStore = () =>
  create(
    subscribeWithSelector<TestStoreState>((set) => ({
      bears: 0,
      increase: (by) => set((state) => ({ bears: state.bears + by }))
    }))
  )

const App = () => (
  <Provider createStore={createStore}>
    <Test />
  </Provider>
)

const Test: React.FC = () => {
  const storeApi = useStoreApi()

  useEffect(
    () =>
      storeApi.subscribe(
        (state) => state.bears,
        (bears) => {
          console.log(bears)
        }
      ),
    [storeApi]
  )

  return null
}
```
",,
1261122350,994,How to compose middleware with TypeScript,"in version 3 i could do something like this:

```ts
type CounterStore = {
  count: 0;
  increase(): void;
};

let store: StateCreator<
  CounterStore,
  SetState<CounterStore>,
  GetState<CounterStore>,
  StoreApiWithPersist<CounterStore> & StoreApiWithDevtools<CounterStore>
> = (set, get) => ({
  count: 0,
  increase: () => set(() => ({ count: get().count + 1 })),
});

store = devtools(store, 'counter');
store = persist(store, {
  name: 'store/counter',
  version: 1,
});

export const useCounter = create(store);
```


in my opinion, this is very readable. However, in version 4 with the new types i cannot get the store types properly anymore.


```ts
import create, { StateCreator } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

type CountStore = {
  count: number;
  increase(): void;
};

let store: StateCreator<CountStore, [], [['zustand/persist', CountStore], ['zustand/devtools', CountStore]]> = (
  set,
  get,
) => ({
  count: 0,
  increase: () => set(() => ({ count: get().count + 1 })),
});

// ts error here
store = persist(store, { name: 'store/counter', version: 1 });
// ts error here
store = devtools(store, { name: 'counter' });

// here is everything fine and ts infers middleware properly
export const useCount = create(store);
```
it keeps compaining about the type of the store does not meet the middleware types.

`Argument of type 'StateCreator<CountStore, [], [[""zustand/persist"", CountStore], [""zustand/devtools"", CountStore]], CountStore>' is not assignable to parameter of type 'StateCreator<CountStore, [[""zustand/persist"", unknown]], [[""zustand/persist"", CountStore], [""zustand/devtools"", CountStore]], CountStore>'.`

Anyone know how to properly type this? any help is welcome. thank you!",,
1261024975,993,State updated outside the component does NOT re renders the component that is using the changed state,"I am working on an application where we have a user (talent) card from where we can send a chat request to the user and the method that we call to do so, is inside a `chatStore`.

From that method inside chat store we are updating the `talentStore` state by subscribing to the store as follows (**we are using immer**):

```js
// chatStore.ts
// ...
 sendChatRequest: async (userId: string, content: string) => {
        if (!userId || !content) return alert(""Payload cannot be empty"");
        set((state) => {
          state.loading = true;
        });
        try {
          const response = await ChatApi.sendChatRequest(userId, content);
          if (response[0]) {
            // subscribe to the store
            const unsubscribe1 = useTalentStore.subscribe((state) => {
              console.log(state, ""subscribed talent state"");
            });
            useTalentStore.setState((state) => {
              state.talents = [...state.talents].map((talent) => {
                if (talent.owner === userId && response[0]?.data?.chatRoomId) {
                  talent.chatRoom = [
                    {
                      _id: response[0]?.data?.chatRoomId,
                    },
                  ];
                }
                return talent;
              });
            });
            // unsubscribe listeners
            unsubscribe1();
            // destroy the store to remove all listeners
            useTalentStore.destroy();
            return;
          }
          return alert(""Error"");
        } catch (error) {
          console.log(error);
        } finally {
          set((state) => {
            state.loading = false;
          });
        }
      },
```

The **issue is** when m updating the `talentStore` state the component that is using that state does not get rerendered and for some odd reasons it gets rerendered only on the first request. if i do another request without reloading the page the component does not get rerendered. The state is getting updated though _(I tried console loggin it and the roomId is getting set in the state but component is not getting rerendered)_.

```js
// TalentPage.tsx

const { talents, loading, setTalents, totalPages } = useTalents(); // useTalents is a hook providing the store states

// ...

<div className=""mt-8 flex flex-col gap-4"">
        {loading
          ? [...Array(12)].map((_, i) => {
              return <TalentCardSkeleton key={i} />;
            })
          : [...talents].map(({ ...talent }, i) => {
              return (
                <TalentCard
                  talent={talent}
                  key={talent.id}
                  id={`${Math.random() * 1000000}`}
                />
              );
            })}
  </div>
// ...
```
The above code is where m using the `talentStore` `talents` state variable.",,
1260140267,990,Auto type inference for store,"Not really an issue, just a suggestion.

I found a way to let typescript to infer store type. It just needs some hacking, but it's quite short and also works better than `combine` middleware.

Here's the demo (also [codesandbox](https://codesandbox.io/s/amazing-shirley-dcpmb8?file=/src/index.ts)):

```ts
// small helper
const getParams = <T extends { setState; getState }>(args) =>
  [...args] as [T[""setState""], T[""getState""], T];

// 1. function style
const useStore = create(function () {
  const [set, get, api] = getParams<typeof useStore>(arguments);

  return {
    id: 123,
    name: ""test"",

    setId() {
      set({ id: 1 });
    },

    setName() {
      set({ name: ""abc"" });
    },

    setBoth() {
      get().setId();
      get().setName();
    }
  };
});

// 2. arrow function style
const useStore2 = create((...args: any[]) => {
  const [set, get, api] = getParams<typeof useStore2>(args);

  return {
    id: 123,
    name: ""test"",

    setId() {
      set({ id: 1 });
    },

    setName() {
      set({ name: ""abc"" });
    },

    setBoth() {
      get().setId();
      get().setName();
    }
  };
});

```

So, the idea is to omit `set, get, api` parameters from function to break circular type dependency. It lets typescript to infer store type by return value only.

And if you have `""target"": ""es5""` in your tsconfig.json, then it's even simpler:

```ts
import create, { GetState } from 'zustand'

create((set, get: GetState<typeof _self>) => {
  const _self = {
    name: ""test"",

    test() {
      set({ name: ""abc"" });
    },
  };

  return _self;
});
```

Unfortunately, it doesn't work with any other targets, only with `es5`.",,
1258616817,987,"Error: Missing getServerSnapshot, which is required for server-rendered content. ","It seems this error happens whenever I try to use any hooks in Next.js. I saw this error referenced earlier in the issues but it said it was fixed in`4.0.0-beta.3`, I am using `4.0.0-rc.1` which I believe is a later update. Regardless, switching to `4.0.0-beta.3` still causes the same issue.
#886 

This is my first time trying Zustand, so perhaps I've set it up wrong.

Store.jsx: 
```
import create from 'zustand'

const useStore = create((set) => ({
    particles: 0,
    increaseParticles: () => set((state) => ({particles: state.particles +1})),
    removeAllParticles: () => set((state) => ({particles: 0})),
}))
```
Particles.jsx:
```
import React from ""react"";
import { HStack, Heading, Box, Badge, Center } from ""@chakra-ui/react"";
import { useStore } from ""zustand"";

export default function Particles() {

    // State
    const particles = useStore((state) => state.particles);

    // Responsiveness
    const responsiveTypography = {
        base: ""sm"",
        md: ""md"",
        lg: ""lg""
    }
  return (
		<Center>
			<Heading size={responsiveTypography} >
				{particles} Particles
				<Badge colorScheme=""green"" size=""lg"">
					0/s
				</Badge>
			</Heading>
		</Center>
	)
};
```
![zustand_error](https://user-images.githubusercontent.com/29440338/171723270-a81688a6-5427-4ba2-9673-4f6968ee9dbe.png)


",,
1254498749,982,@testing-library/react-hooks not working with Zustand to update state,"I'm developing a lib for React/React Native where I export a hook to be used in the application, this hook is working correctly in a React/React Native application, I tested the lib locally.

Initially I used Context API, but it's a complex hook and I started having problems using the Context API, so I rewrote that hook using Zustand and it worked perfectly for what I needed, but the unit tests I had before working 100% with Context API, do not work in Zustand.

I'm using `@testing-library/react-hooks` to do the tests, but if I update some state and expect the result of that state to be the value I updated, it doesn't work.

`package.json`

```json
""jest"": {
  ""bail"": true,
  ""clearMocks"": true,
  ""collectCoverage"": true,
  ""collectCoverageFrom"": [
    ""<rootDir>/src/hooks/**/*.tsx"",
    ""<rootDir>/src/utils/*.ts""
  ],
  ""coverageDirectory"": ""coverage"",
  ""coverageProvider"": ""v8"",
  ""coverageReporters"": [
    ""text"",
    ""lcov""
  ],
  ""transform"": {
    "".(ts|tsx)"": ""ts-jest""
  },
  ""testRegex"": ""(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$"",
  ""moduleFileExtensions"": [
    ""ts"",
    ""tsx"",
    ""js""
  ],
  ""modulePathIgnorePatterns"": [
    ""<rootDir>/dist/""
  ]
},
""peerDependencies"": {
  ""react"": "">= 17.0.2"",
  ""react-dom"": "">= 17.0.2""
},
""devDependencies"": {
  ""@testing-library/react-hooks"": ""^8.0.0"",
  ""@types/jest"": ""^27.5.1"",
  ""@types/react"": ""^18.0.9"",
  ""@types/react-dom"": ""^18.0.4"",
  ""jest"": ""^28.0.3"",
  ""jest-environment-jsdom"": ""^28.1.0"",
  ""react"": ""^17.0.2"",
  ""react-dom"": ""^17.0.2"",
  ""react-test-renderer"": ""^18.1.0"",
  ""ts-jest"": ""^28.0.2"",
  ""typescript"": ""^4.6.4""
},
```

`useExample`

```ts
export const useExample = create(set => ({
  value: 0,
  add: (newValue: number) => set({ value: newValue }),
}))
```

`useExemple.spec.ts`

In this test where I was supposed to get 10, I get 0.

```ts
import { renderHook, act } from '@testing-library/react-hooks/server';

test('example', () => {
  const { result } = renderHook(() => useExemple());

  act(() => result.current.add(10));

  expect(result.current.value).toBe(10);
});
```

```ts
● useExemple tests › example

    expect(received).toBe(expected) // Object.is equality

    Expected: 10
    Received: 0

      15 |     act(() => result.current.add(10));
      16 |
    > 17 |     expect(result.current.value).toBe(10);
         |                                  ^
      18 |   });
      19 |
```

<br />

**obs**: I'm using `@testing-library/react-hooks/server` because for some reason if I use `@testing-library/react-hooks` it gives me the following error:

```ts
● useExample tests › example

    TypeError: (0 , _reactTestRenderer.act) is not a function

      11 | describe('useExample tests', () => {
      12 |   it('example', () => {
    > 13 |     const { result } = renderHook(() => useExample());
         |                                  ^
      14 |
      15 |     act(() => result.current.add(10));
      16 |

      at render (node_modules/@testing-library/react-hooks/lib/native/pure.js:73:34)
      at renderHook (node_modules/@testing-library/react-hooks/lib/core/index.js:114:5)
      at Object.<anonymous> (src/hooks/useExample/index.spec.tsx:13:34)
```

This error did not happen before with tests working in the Context API.

I really enjoyed working with Zustand, I managed to rewrite the hook very quickly, but the tests are important that they work, if anyone can help I would appreciate it.",,
1253974970,980,Support Action Name in Typescript SetState,"It came to our attention that the SetStateType action name is not defined in `zustand/src/vanilla.d.ts`.
Even though it's written in the [documentation](https://github.com/pmndrs/zustand#logging-actions) 

Suggestion to add the definition of the actionName to the type",,
1252720042,977,persist doesn't let me use a typed store,"example: https://codesandbox.io/s/focused-currying-lsdqeu?file=/src/App.tsx:443-619

when trying to type a store with persist I get an error:


```
Argument of type 'StateCreator<{ fishes: number; addAFist: (value: number) => void; }, [], [[""zustand/persist"", Partial<{ fishes: number; addAFist: (value: number) => void; }>]], { fishes: number; addAFist: (value: number) => void; }>' is not assignable to parameter of type 'StateCreator<{ fishes: number; addAFist: (value: number) => void; }, [], [], { fishes: number; addAFist: (value: number) => void; }>'.
  Type 'StateCreator<{ fishes: number; addAFist: (value: number) => void; }, [], [[""zustand/persist"", Partial<{ fishes: number; addAFist: (value: number) => void; }>]], { fishes: number; addAFist: (value: number) => void; }>' is not assignable to type '{ $$storeMutators?: [] | undefined; }'.
    Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/persist"", Partial<{ fishes: number; addAFist: (value: number) => void; }>]] | undefined' is not assignable to type '[] | undefined'.
        Type '[[""zustand/persist"", Partial<{ fishes: number; addAFist: (value: number) => void; }>]]' is not assignable to type '[]'.
          Source has 1 element(s) but target allows only 0.ts(2345)
```

example code:

```
import create from 'zustand';
import { persist } from 'zustand/middleware';

const useStore = create<{fishes:number, addAFist: (value: number) => void}>(
  persist(
    (set, get) => ({
      fishes: 0,
      addAFish: () => set({ fishes: get().fishes + 1 }),
    }),
    {
      name: 'food-storage', // unique name
      getStorage: () => sessionStorage, // (optional) by default, 'localStorage' is used
    }
  )
);
```
",,
1251784186,975,Error when using inside React Native (Android) / Works fine with React Native web.,"I'm using the latest version when I try use Zustand with React Native (Android) on [Expo](https://expo.dev/) or [Bare React Native](https://reactnative.dev/).

I get this Error **TypeError: Object is not a function (near '...(0, _zustand.default)...')**
Again this only happen on Android but when I open the same app on **Web** it runs without errors.

`import create from ""zustand"";`
`const useStore = create((set) => ({`
`  bears: 0,`
`}));`

`export default function App() {`
`const bears = useStore(state => state.bears)`
`  return (...)`
`}`
",,
1244323894,970,State does not update ,"Hello,
First of all, thank you so much for this wonderful library! It looks really promising and awesome. 
I have been trying to get the state to update but for some reason, none of the examples from docs are working. I am on latest react version 18+ and my application uses Vite for bundling. I am using TailwindCSS v3+. 
I tried the very simple example from https://zustand-demo.pmnd.rs/ which just updates a counter by 1 onclick of the button but it didn't work. The state remains the same which is the initial one. Here is my code:

```
import { useState } from 'react';
import create from 'zustand';

function App() {
  // const [count, setCount] = useState(0);
  const useStore = create((set) => ({
    count: 1,
    inc: () => set((state) => ({ count: state.count + 1 })),
  }));
  const inc = useStore((state) => state.inc);

  const count = useStore((state) => state.count);

  return (
    <div className=""App"">
      <header className=""App-header"">
        <p>Hello Vite + React!</p>
        <p>
          <button type=""button"" onClick={inc}>
            count is: {count}
          </button>
        </p>
        <p>
          Edit <code>App.jsx</code> and save to test HMR updates.
        </p>
        <p>
          <a
            className=""App-link""
            href=""https://reactjs.org""
            target=""_blank""
            rel=""noopener noreferrer""
          >
            Learn React
          </a>
          {' | '}
          <a
            className=""App-link""
            href=""https://vitejs.dev/guide/features.html""
            target=""_blank""
            rel=""noopener noreferrer""
          >
            Vite Docs
          </a>
        </p>
      </header>
    </div>
  );
}

export default App;
```

Here is the stackblitz URL: https://stackblitz.com/edit/vitejs-vite-fkyr2s?file=src/App.jsx
I am missing something very basic. Any help would be really appreciated. Thanks!",,
1240563434,964,`createSelectors` types do not work with new typescript interfaces,"**Current Create Selectors** from the wiki

```ts
import create, { StateCreator, State, StoreApi, UseStore } from 'zustand'

interface Selectors<StoreType> {
  use: {
    [key in keyof StoreType]: () => StoreType[key]
  }
}

function createSelectors<StoreType extends State>(
  store: UseStore<StoreType>,
) {
  ;(store as any).use = {}

  Object.keys(store.getState()).forEach(key => {
    const selector = (state: StoreType) => state[key as keyof StoreType]
    ;(store as any).use[key] = () => store(selector)
  })

  return store as UseStore<StoreType> & Selectors<StoreType>
}
```

**My attempt to rewrite**

My attempt doesn't preserve the store type. Any help rewriting this correctly would be appreciated!

```ts
import { State, StoreApi, UseBoundStore } from ""zustand"";

interface Selectors<StoreType> {
  use: {
    [key in keyof StoreType]: () => StoreType[key];
  };
}

export function createSelectors<StoreType extends State>(
  store: UseBoundStore<StoreApi<StoreType>>
) {
  (store as any).use = {};

  Object.keys(store.getState()).forEach((key) => {
    const selector = (state: StoreType) => state[key as keyof StoreType];
    (store as any).use[key] = () => store(selector);
  });

  return store as UseBoundStore<StoreApi<StoreType>> & Selectors<StoreType>;
}

```",,
1239383975,962, The requested module 'react' is expected to be of type CommonJS (NEXT JS / Node 18),"Using Zustand(typescript) W/ Next JS and when im grabbing global state, i get this error

SyntaxError: The requested module 'react' is expected to be of type CommonJS, which does not support named exports. CommonJS modules can be imported by importing the default export.
For example:
import pkg from 'react';
const { useDebugValue } = pkg;

Call Stack
<unknown>
node_modules/zustand/esm/index.mjs (4)
ModuleJob._instantiate
internal/modules/esm/module_job.js (97:21)
async ModuleJob.run
internal/modules/esm/module_job.js (136:20)
async Loader.import
internal/modules/esm/loader.js (179:24)",,
1236483850,958,Typescript conflict when using vanilla create,"I have a non-react file with helper methods that will need to access and set global state 

An example
``` typescript
import create from 'zustand/vanilla'

type User = {
    username: string
    id: number
}

interface GlobalStoreType {
    authError: string | null
    setAuthError: (err: string) => void
    user: User | null
    setUser: (user: User | null) => void
}

const store = create<GlobalStoreType>((set) => ({
    authError: null,
    setAuthError: (authError: string | null) => set(() => ({ authError })),
    user: null,
    setUser: (user: User | null) => set(() => ({ user })),
}))

export default store

```

I need to access the store in a non react file


```const { authError, setAuthError, user, setUser } = store```

gives off the a typescript error of 

`const setUser: any
Property 'setUser' does not exist on type 'StoreApi<GlobalStoreType>'`

setUser is just one of the four errors 

",,
1228762377,952,Type safety regression for set() in 4.0.0-rc.0+,"Hi, just started using this library. I noticed that within a `set()` function, I can set a variable to `undefined` even though `undefined` isn't supposed to be allowed. This can lead to bugs at runtime.

```ts
interface BearState {
  bears: number;
  breakBears: () => void;
}

const useStore = create<BearState>()((set) => ({
  bears: 0,
  breakBears: () => set({ bears: undefined }) // This should be illegal
}));
```

Demo: https://codesandbox.io/s/friendly-snowflake-n3c64k?file=/src/App.tsx

It seems like #317 is closely related, so this problem has been fixed in the past, but has now resurfaced. If I downgrade the library to v4.0.0-beta.3 or lower, then Typescript correctly warns me about the illegal type.",,
1227493643,950,Typescript issue while using subscribeWithSelector in 4.0.0-rc1,"This is my code snippet
```

const createRootSlice = (set: SetState<any>, get: GetState<any>) => ({
  ...createConfigSlice(set, get),
  ...createDeviceSlice(set, get),
  ...createCartSlice(set, get),
  ...createRouteSlice(set, get),
  ...createCollectionsSlice(set, get),
  ...createProductsSlice(set, get),
  ...createAddressSlice(set, get),
  ...createSearchSlice(set, get),
  ...createConfigEditorSlice(set, get),
})

type AppSlice = ConfigSlice &
  DeviceSlice &
  CartSlice &
  RouteSlice &
  CollectionSlice &
  ProductSlice &
  AddressSlice &
  SearchSlice &
  ConfigEditorSlice
  
export const useAppStore = create<AppSlice>(
  subscribeWithSelector(createRootSlice)
)
```
And this is the issue I am gettting
`Type '[[""zustand/subscribeWithSelector"", never]] | undefined' is not assignable to type '[] | undefined'.`",,
1218371929,939,`devtools` middleware throwing a type error for passed slice,"I am trying to create a themeSlice and passing it inside `devtools` middleware but getting compilation error. 

```ts
// themeSlice.ts

import { StateCreator } from ""zustand"";

export interface ThemeState {
  isDarkMode: boolean;
  toggleTheme: () => void;
}

export const themeSlice: StateCreator<ThemeState> = (set) => ({
  isDarkMode: true,
  toggleTheme: (): void => {
    set((state) => ({ isDarkMode: !state.isDarkMode }));
  },
});
```

Getting error in the following code
```ts
// index.ts (themeStore)

import create, { GetState, SetState, StoreApi } from ""zustand"";
import { devtools } from ""zustand/middleware"";
import { themeSlice, ThemeState } from ""./themeSlice"";

interface ThemeStore extends ThemeState {}

export const useThemeStore = create<ThemeStore>(
  // error here
  devtools((set, get, api) => ({
    ...themeSlice(
      set as unknown as SetState<ThemeState>,
      get as GetState<ThemeState>,
      api as unknown as StoreApi<ThemeState>,
    ),
  })),
);

```

ERROR:
```
Argument of type 'StateCreator<ThemeStore, [], [[""zustand/devtools"", never]], ThemeStore>' is not assignable to parameter of type 'StateCreator<ThemeStore, [], [], ThemeStore>'.
```",,
1215021550,936,What is the appropriate pattern to split the store in modules?,"First of all: congratulations to the core team for developing such an amazing tool. It was about time to have a tool to match Redux! :heart:

I understand that most frontend **store ** approaches/patterns relies on a ""single source of truth"". Therefore, the premise would be creating a single store and merge all the different parts (state and methods) in a single object when instantiating `zustand` store, like this:

```ts
import create from 'zustand';
import { IModuleA, stateModuleA, actionsModuleA } from 'moduleA';
import { IModuleB, stateModuleB, actionsModuleB } from 'moduleA';
import { IModuleC, stateModuleC, actionsModuleC } from 'moduleA';

export const useStore = create<IModuleA & IModuleB & IModuleC>((set, get) => ({
  ...stateModuleA,
  ...actionsModuleA(set, get),
   ...stateModuleB,
  ...actionsModuleB(set, get),
   ...stateModuleC,
  ...actionsModuleC(set, get),
}));
```

This pattern, however, exposes the state/methods to undesired collisions/overrides. But the most annoying thing is the ""single-level"" properties where the store is set on, so each state/action must be more descriptive like `{ createReport: () => {}, createFile^() => {}, createFoo: () => {}, ... }`. 

As a workaround to this, I wonder if the pattern of **creating multiple stores** is acceptable in `zustand` world, like this:

```ts
import create from 'zustand';
import { IModuleA, stateModuleA, actionsModuleA } from 'moduleA';
import { IModuleB, stateModuleB, actionsModuleB } from 'moduleA';
import { IModuleC, stateModuleC, actionsModuleC } from 'moduleA';

export const useA= create<IModuleA>((set, get) => ({
  ...stateModuleA,
  ...actionsModuleA(set, get),
}));

export const useB= create<IModuleB>((set, get) => ({
  ...stateModuleB,
  ...actionsModuleB(set, get),
}));

export const useC= create<IModuleC>((set, get) => ({
  ...stateModuleC,
  ...actionsModuleC(set, get),
}));
```

Wrapping up: what is the best pattern to create a multiple-modules-like store with this library?",,
1214717992,935,TypeScript 4.0.0 migration confusion.  ,"This is not a bug.  I just want to leave a trail of breadcrumbs for future travelers like myself that fail to thoroughly read the TypeScript [release notes](https://github.com/pmndrs/zustand/blob/main/docs/typescript.md).

If you are seeing this compiler error after upgrading to Zustand 4.0.0:

```
...
Types of property '$$storeMutators' are incompatible.
      Type '[[""zustand/immer"", never]] | undefined' is not assignable to type '[] | undefined'.
        Type '[[""zustand/immer"", never]]' is not assignable to type '[]'.
          Source has 1 element(s) but target allows only 0.ts
```

You need an extra set of parenthesis after your `create<T>(...)` call.  From the [release notes](https://github.com/pmndrs/zustand/blob/main/docs/typescript.md):

> When using TypeScript you just have to make a tiny change that instead of writing create(...) you'll have to write create<T>()(...) where T would be type of the state so as to annotate it.",,
1214687617,934,zustand stops working after HMR (hot module reload),"I am trying some zustand in a react redux webpack app
I use zustand to help put up a ""do you really want to delete a record"" modal (after pressing a delete button)
If the app has just been refreshed then it seems to work - the modal appears
If I then make a minor code change to trigger HMR then the modal stops appearing
if I surround the store with persist then it works even after HMR. (interestingly the key in localstorage is undefined)

But I believe that persist should not be necessary. I am pretty sure that HMR is disturbing Zustand in some way. Any ideas? 

I got the code from https://dev.to/uguremirmustafa/material-ui-reusable-confirmation-dialog-in-react-2jnl

```
import React, { useCallback, useState } from 'react'
// material ui
import {
  Typography,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  IconButton,
  makeStyles,
} from '@material-ui/core'
import { Close } from '@material-ui/icons'
import create from 'zustand'
import { persist } from 'zustand/middleware'

const useMyConfirmDialogStore = create(
  persist((set) => ({
    message: '',
    message2: '',
    onSubmit: undefined,
    close: () => set({ onSubmit: undefined }),
  }))
)

export const confirmDialog = (message, message2, onSubmit) => {
  console.log(""confirmDialog "" + onSubmit)

  useMyConfirmDialogStore.setState({
    message: message,
    message2: message2,
    onSubmit: onSubmit,
  })
}

const useStyles = makeStyles((theme) => {
  return {
    actions: {
      padding: theme.spacing(2),
    },
  }
})

const MyConfirmDialog = () => {
  const c = useStyles()
  const { message, message2, onSubmit, close } = useMyConfirmDialogStore()

  return (
    <Dialog open={Boolean(onSubmit)} onClose={close} maxWidth=""sm"" fullWidth>
      <Box display=""flex"" justifyContent=""space-between"" alignItems=""center"">
        <DialogTitle>{message}</DialogTitle>
        <IconButton onClick={close}>
          <Close />
        </IconButton>
      </Box>
      <DialogContent>
        <Typography severity=""error"">{message2}</Typography>
      </DialogContent>
      <DialogActions className={c.actions}>
        <Button color=""primary"" variant=""contained"" onClick={close}>
          Cancel
        </Button>
        <Button
          // ref={callbackRef}
          color=""secondary""
          variant=""contained""
          onClick={() => {
            if (onSubmit) {
              onSubmit()
            }
            close()
          }}
        >
          Confirm
        </Button>
      </DialogActions>
    </Dialog>
  )
}

export default MyConfirmDialog
```


",,
1213731264,930,Using subscribeWithSelector and immer middleware,"I am using v4.0 (TS 4.5.5) and trying the standard immer middleware and subscribeWithSelector:

```typescript
export const store = create<
  Store
>()(subscribeWithSelector(immer((set, get) => createRootSlice(set, get))));
```
but I got this error: 

`TS4023: Exported variable 'store' has or is using name 'StoreSubscribeWithSelector' from external module ""zustand/middleware/subscribeWithSelector"" but cannot be named.`

Am I doing something wrong, or it is a problem with Zustand v4?

",,
1210424322,924,How to avoid the behind sliceStore cover the front sliceStore?,"I follow the Beast Practices and split the store into seperate slices. Here is my code.

    // A.ts
    import { GetState, SetState } from ""zustand"";
    import { MyState } from ""./index"";
    
    export interface ISliceAStore {
      A: string
      C: number
    }
    
    type StoreFunction = (set: SetState<MyState>, get: GetState<MyState>) => ISliceAStore
    
    const createUserInfo: StoreFunction = (set, get) => ({
      A: 'A',
      C: 1
    });
    
    export default createUserInfo;
    

    // B.ts
    import { GetState, SetState } from ""zustand"";
    import { MyState } from ""./index"";
    
    export interface ISliceBStore {
      B: string
      C: number
    }
    
    type StoreFunction = (set: SetState<MyState>, get: GetState<MyState>) => ISliceBStore
    
    const createUserInfo: StoreFunction = (set, get) => ({
      B: 'B',
      C: 999
    });
    
    export default createUserInfo;
    

    // index.ts
    import create from ""zustand"";
    
    import createSliceAStore, { ISliceAStore } from ""./A"";
    import createSliceBStore, { ISliceBStore } from './B'
    
    export type MyState = ISliceAStore & ISliceBStore;
    
    const useStore = create<MyState>((set, get) => ({
      ...createSliceAStore(set, get),
      ...createSliceBStore(set, get)
    }));
    
    export default useStore;
    

The problem is that the C will be 999. The SliceBStore will cover the SliceAStore.

I want to ask how to avoid this like namespace?

Like [Pinia](https://pinia.vuejs.org/introduction.html#basic-example)

    const useCounterStore = defineStore('counter', {
      state: () => ({ count: 0 }),
      getters: {
        double: (state) => state.count * 2,
      },
      actions: {
        increment() {
          this.count++
        }
      }
    })",,
1207244791,919,createContext Typescript example broken?,"If I copy and paste the `createContext` Typescript example into a new file, I get several errors. I'm using 4.0.0-rc0. Here's the example for reference, annotated with the errors I get from typescript. What is the recommended way to use the `createContext` pattern now?

```tsx
import create from ""zustand"";
import createContext from ""zustand/context"";

type BearState = {
  bears: number
  increase: () => void
}

const { Provider, useStore } = createContext<BearState>();
// Type 'BearState' does not satisfy the constraint 'StoreApi<object>'.
//   Type 'BearState' is missing the following properties from type 'StoreApi<object>': setState, getState, subscribe, destroy ts(2344)

export default function App({ initialBears }: { initialBears: number }) {
  return (
    <Provider
      createStore={() =>
        create((set) => ({
          bears: initialBears,
          increase: () => set((state) => ({ bears: state.bears + 1 })),
        }))
        // Type 'UseBoundStore<StoreApi<object>>' is missing the following properties from type 'BearState': bears, increase ts(2739)
      }
    >
      <Button />
    </Provider>
  )
}
```

Also, FWIW, I get the following errors on zustand@3.7.2. If I add an annotation to create like `create<BearState>(set => ...` then everything works.
```tsx
    <Provider
      createStore={() =>
        create(set => ({
          bears: initialBears,
          increase: () => set(state => ({ bears: state.bears + 1 })),
          // for `set`: Object is of type 'unknown'. ts(2571)
          // Parameter 'state' implicitly has an 'any' type. ts(7006)
        }))
      }
    >
      <div />
    </Provider>
```


",,
1205548516,910,Noob-question: Typescript + Splitted Store + Middleware,"Hello :)

THANK you soo much for Zustand! I love it!
Using it whereever I can :)
Now I would love to go Typescript.
Basic example for Typescript + Splitted Store + Middleware.

Goal:
![image](https://user-images.githubusercontent.com/28861537/163571708-a0854b4b-8024-4e8f-9ef8-f7948ec9c658.png)

I added 2 approaches for the `useStore`.
With each Im failing at some point:

```ts
// storeBears.tsx
import produce from 'immer'

export const storeBears = { 
  animals: { 
    bears: 1
  }
}

export const storeBearsActions = (set:any) => ({ 
  increase: (by: number):void => set(produce((state:any) => { state.animals.bears =  state.animals.bears + by }), false, ""bears/increase""),
})
```

```ts
// storeUI.tsx

export const storeUI = { 
  darkMode: false,
}

export const storeUIActions = (set:any) => ({
  setDarkMode: (dark: boolean):void => set((state:any) => ({ darkMode: dark }), false, ""ui/darkmode""),    
})
```

Approach 1:
```ts
// useStore.ts

import create from 'zustand';
import { devtools } from 'zustand/middleware';
import { combine } from 'zustand/middleware';
import { storeBears, storeBearsActions, } from './storeBears';
import { storeUI, storeUIActions } from './storeUI';

export const useStore = create(
  devtools(
    combine(
      {
        ...storeBears,
        ...storeUI
      },
      storeUIActions
      // >>>>cannot add storeBearsAction here<<<<
    )
  )
);
```

Approach 2:
```ts
// useStore.ts

import create from 'zustand';
import { devtools } from 'zustand/middleware';
import { combine } from 'zustand/middleware';
import { storeBears, storeBearsActions, } from './storeBears';
import { storeUI, storeUIActions } from './storeUI';

// >>>>cannot add middlewares here<<<<
export const useStore = create(((set) => ({  
  ...storeBearsActions(set),
  ...storeBears,
  
  ...storeUIActions(set),
  ...storeUI,
})))
```",,
1199673292,905,"Zustand testing throws an error ""TypeError: store.getState is not a function""","In the documentation it states that adding this in JEST would enable testing for ZUSTAND state.


```
const create = createState => {
  const store = actualCreate(createState);
  const initialState = store.getState();
  storeResetFns.add(() => store.setState(initialState, true));
  return store;
};
```

But it seems to throw an error ""TypeError: store.getState is not a function""

I am using typescript not sure if this causes some issues. Also, it is not well documented on how to use this test in jest. Just want to have values on my states so that they can be used on my componentes during rendering of test components.",,
1198791752,902,Feature Request: Update persist middleware so setItem is only called when data being persisted has changed,"**Background**
Since the `partialize` function has been added to the `persist` middleware, we've been able to customize the data that is passed to the `setItem` function within `getStorage`. This also gives us the ability to remove certain properties that are within a Zustand store so they're not persisted.

In practice, it appears that `setItem` will be called for every single state update, even if the piece of state being updated isn't being persisted.

**Demo**
Please see this very contrived example of a store that contains a user property. This could be some form of authentication information that we don't want to persist, so we exclude using the `partialize` function. However, every time the value of `name` changes, the `setItem` function will be called, even though the data is exactly the same each time
https://codesandbox.io/s/long-resonance-46hry8

**Request**
Ideally this `setItem` function would only be called when the data that is being persisted has actually changed.

**Why**
If we're using persist to store to localStorage, then it probably doesn't matter. However, as soon as we introduce some sort of async storage, perhaps an online database through a cloud function, extra calls to the database that don't actually update anything could have cost implications in the app's hosting environment. As the app scales to many users, there could be many more calls to update the database that aren't necessary, and therefore the costs for the app hosting could skyrocket.

**How**
`setItem` is called with a `value` that is simply a string. We could store the previous value in memory and do a simple comparison to see if the data has changed, only triggering `setItem` when that data has changed.
I'm also open to any other ideas, this is just the most simple that I thought would fit in with Zustand's lightweight approach.

**Alternative**
If we don't want to implement this into Zustand core, I think it would be really beneficial to at least give a mechanism, either through new middleware or a new function within `persist`, to be able to handle such comparison ourselves",,
1197767639,899,Unable to view store in redux devtools,"Hi!

I seem to have a problem linking the redux dev tools with zustand.

My setup is as follows:
```
import { devtools } from 'zustand/middleware';

export type State = {
  // State
  requests: Map<string, boolean>;

  // Actions
  storeRequest: (key: string) => void;
};

export const useStore = create<State>(
  devtools(
    (set): State => ({
      // State
      requests: new Map<string, boolean>(),

      // Actions
      storeRequest: (key: string) =>
        set(
          produce<State>(state => {
            state.requests.set(key, true);
          }),
        ),
    }),
  ),
);
```

![image](https://user-images.githubusercontent.com/2957868/162521261-83f655ec-9e55-4668-ac0d-dbdc470b8732.png)


When I augment state with `storeRequest` the state is not updated in redux devtools.
But is set internally in the store.

Is there something that I'm missing or is this broken in the latest release? (I'm using `3.7.2`)",,
1186679609,886,"Error: Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.","With React 18, this error occurs when using a useStore hook:

```ts
// useDarkMode.ts
import create from 'zustand'
import { persist } from 'zustand/middleware'

type darkModeState = {
  /**
   * State of user settings
   */
  isDarkMode: boolean
  toggleDarkMode: () => void
}

export const useDarkMode = create<darkModeState>(
  persist(
    (set) => ({
      isDarkMode: false,
      toggleDarkMode: () =>
        set(({ isDarkMode }) => ({
          isDarkMode: !isDarkMode
        }))
    }),
    { name: 'useDarkMode' }
  )
)
```

```tsx
// app.tsx

import { useMemo } from 'react'
import { cssStringFromTheme } from '../css/cssStringFromTheme'
import { useDarkMode } from '../hooks/useDarkMode'
import { darkTheme } from '../themes/darkTheme'
import { lightTheme } from '../themes/lightTheme'
import { Box } from './Box'

export const ThemeSwitch = () => {
  const isDarkMode = useDarkMode((s) => s.isDarkMode)
  const toggleDarkMode = useDarkMode((s) => s.toggleDarkMode)

  const themeObject = useMemo(() => {
    if (isDarkMode) return darkTheme
    else return lightTheme
  }, [isDarkMode])

  return (
    <style global jsx>
      {`
        :root {
          ${cssStringFromTheme(themeObject)}
        }

        @media (prefers-color-scheme: dark) {
          :root {
            ${cssStringFromTheme(isDarkMode ? darkTheme : themeObject)}
          }
        }
      `}
    </style>
  )
}
```

this error occurs:

![image](https://user-images.githubusercontent.com/35937217/160880323-02b33c95-eb0e-4adb-a7e7-7e2d3bb8c8f4.png)

This is using zustand@4.0.0-beta.2, react@18 and next@12.1",,
1179583668,882,Using a persisted store with createContext and TypeScript,"Hi all,

We're using the store persistence in conjunction with a context to provide the store to all parts of the application. Since the persist callback modifies the returned useStore hook we are having trouble getting TypeScript to recognize the persist property of the hook.

We tried modifying the create type itself to match the middleware tests as indicated in the code comment(https://github.com/pmndrs/zustand/blob/main/src/middleware/persist.ts#L91):

```
const useStore = create<
        IStore,
        SetState<IStore>,
        GetState<IStore>,
        Mutate<StoreApi<IStore>, [['zustand/persist', Partial<IStore>]]>
    >(
```

However this didn't solve our root issue because we are accessing useStore from a context. Looking at the createContext function I'm not sure how to pass in the correct types so useStore has the persist property. How do you intend to use both persist and createContext with TypeScript? https://github.com/pmndrs/zustand/blob/main/src/context.ts#L15
https://github.com/pmndrs/zustand/blob/main/src/context.ts#L60

I can provide a PR with proposed changes if that is preferred.

",,
1178051741,881,api methods aren't modified by middleware if they are called in a non-reactive way from prototype,"Hello,

I am trying to use zustand with immer using the ""immer middleware"" from this example: [middlewareTypes.test.tsx](https://github.com/pmndrs/zustand/blob/HEAD/tests/middlewareTypes.test.tsx).

First of all, I realized that this example does not modify the **api.setState** method the same way, as it modifies the **set** method.
I am not sure if this was intentional, if yes, some comment in the example would be really great. 
Anyway, I modified also the **api.setState** and this is my code:
```typescript

type ImmerSetState<T extends State> = (partial: ((draft: Draft<T>) => void) | T, replace?: boolean) => void

export const immerMiddleware =
  <
    T extends State,
    CustomSetState extends SetState<T>,
    CustomGetState extends GetState<T>,
    CustomStoreApi extends StoreApi<T>
  >(
    config: StateCreator<T, ImmerSetState<T>, GetState<T>, CustomStoreApi>
  ): StateCreator<T, CustomSetState, CustomGetState, CustomStoreApi> =>
  (set, get, api) =>
    config(
      (partial, replace) => {
        console.log('set')
        const nextState = typeof partial === 'function' ? produce(partial as (state: Draft<T>) => T) : (partial as T)
        return set(nextState, replace)
      },
      get,
      {
        ...api,
        setState: (partial, replace) => {
          console.log('setState')
          const nextState = typeof partial === 'function' ? produce(partial as (state: Draft<T>) => T) : (partial as T)
          return api.setState(nextState, replace)
        },
      }
    )
```

As you can see, the only difference is that:

1.  I created a custom ImmerSetState type because I think that it is a little bit more readable.
2.  I copied the ""immer set"" function and used it for the **api.setState** method
(the only difference in that function is, that at the end I call `api.setState(nextState, replace)` instead of `set(nextState, replace)` )
3.  I added some console logs to these functions so I am 100 % sure, when do I call my modified functions and when do I call the prototype versions of these functions.

And this is the function that creates my store:
```typescript
import create, { State } from 'zustand'
import { Draft } from 'immer'
import { immerMiddleware } from './middleware'

type ImmerStore<T> = T & {
  // TS doesn't like the ImmerSetState here, so I had to remove the T option from partial
  set: (partial: (draft: Draft<T>) => void, replace?: boolean) => void
}

export const createStore = <T extends State>(args: T) =>
  create<ImmerStore<T>>(immerMiddleware((set, get, api) => ({ ...args, set, api })))
```

And this is the useStore hook:
```typescript
import { createStore } from './utils'

export interface CounterState {
  count: number
}

export interface StoreState {
  red: CounterState
  green: CounterState
  blue: CounterState
}

export const useStore = createStore<StoreState>({
  red: { count: 0 },
  green: { count: 0 },
  blue: { count: 0 },
})
```

And here is my usecase for the Red counter:
```typescript
import React, { FC, useCallback } from 'react'
import { useStore } from 'store'
import { Counter } from '../Counter'

export const RedCounter: FC = () => {
  const count = useStore((state) => state.red.count)
  const set = useStore((state) => state.set)
  const setState = useStore((state) => state.api.setState)

  const incrementSet = useCallback(
    () =>
      set((state) => {
        state.red.count += 1
      }),
    [set]
  )
  const incrementSetState = useCallback(
    () =>
      setState((state) => {
        state.red.count += 1
      }),
    [setState]
  )
  const incrementNonReactiveSetState = useCallback(
    () =>
      useStore.setState((state) => {
        state.red.count += 1
      }),
    []
  )

  return (
    // Counter is just 3 buttons + displayed count
    <Counter
      count={count}
      incrementSet={incrementSet}
      incrementSetState={incrementSetState}
      incrementNonReactiveSetState={incrementNonReactiveSetState}
    />
  )
}
```


Now when I call:

-  incrementSet: there is a ""set"" in a console log
- incrementSetState: there is a ""setState"" in a console log
- incrementNonReactiveSetState: there nothing in a console log (if I called previous functions before this one, there is an error: `index.tsx:27 Uncaught TypeError: Cannot assign to read only property 'count' of object '#<Object>'`

Which brings me to _probably_ another issue, state is protected from mutable changes only after first set call, because the produce function was used. So if someone is combining how they modify the state  (with|without immerSet) sometimes the state is protected from the mutable changes and sometimes it isn't.


**TLDR. My question is, if there is some way how to apply middleware modifications for the non-reactive methods of the useStore hook?**

",,
1175611640,879,valtio-like render optimization for zustand,"Hey there,

I'm a huge fan of both zustand and valtio, I think the DX is awesome.
The feature I love the most in valtio is its render optimization via proxy, but the fact that the state is deeply proxied may be a problem for my use case as I often use plain object comparison (`Object.is` or `===`) in my applications...

Using a different selector in each component is kinda heavy to use, so I created a `useZustand` hook (a kind of ""zustio"" mix?), taking a vanilla zustand store as parameter.

I'm not sure this hook fully cover the common issues zustand fixed, (zombie child problem, react concurrency, context loss). I used to create React apps with class based components and just starting to use hooks, so I'm not confident enough with their edge cases to create a PR... but I think some users might find this approach interesting.

So, I removed the whole ""slice"" code from the zustand hook, but maybe I was a bit too heavy on the ""delete line"" command?

```typescript
import { useEffect, useLayoutEffect, useReducer, useRef } from ""react"";
import { State, StoreApi } from ""zustand"";

// For server-side rendering: https://github.com/pmndrs/zustand/pull/34
// Deno support: https://github.com/pmndrs/zustand/issues/347
const isSSR =
    typeof window === ""undefined"" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);

const STATE_GETTER_PROPERTY = ""_$zustandGetState"";

const useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect;

type Frozen<T> = T extends (...args: any[]) => any
    ? T
    : T extends Promise<infer V>
    ? Frozen<V>
    : { readonly [K in keyof T]: Frozen<T[K]> };

export const useZustand = <T extends State>(api: StoreApi<T>) => {
    const [, forceUpdate] = useReducer((c) => c + 1, 0);

    const state = api.getState();
    const stateRef = useRef(state);

    const accessed: Set<keyof T> = new Set();

    const proxyState = (state: T) => {
        const proxied = new Proxy(state, {
            get: function (t, p) {
                accessed.add(p as keyof T);
                return t[p as keyof T];
            },
        });
        return proxied;
    };

    // Replace get state so properties accessed via getState()
    // are tracked... even in state actions
    if (!api.getState.hasOwnProperty(STATE_GETTER_PROPERTY)) {
        const getOriginalState = api.getState;
        const getStateProxy = () => proxyState(getOriginalState.apply(api));

        // Create hidden property to identify if getState() is already returning a proxy
        Object.defineProperty(getStateProxy, STATE_GETTER_PROPERTY, {
            configurable: false,
            enumerable: false,
            value: getOriginalState,
        });
        api.getState = getStateProxy;
    }

    const stateBeforeSubscriptionRef = useRef(state);
    useIsomorphicLayoutEffect(() => {
        const listener = () => {
            const nextState = api.getState();
            let isNewSlice = false;

            for (const k of accessed) {
                if (!Object.is(nextState[k], stateRef.current[k])) {
                    // At least one of used props has changed
                    isNewSlice = true;
                    break;
                }
            }

            if (isNewSlice) {
                stateRef.current = nextState;
                forceUpdate();
            }
        };
        const unsubscribe = api.subscribe(listener);
        if (api.getState() !== stateBeforeSubscriptionRef.current) {
            listener(); // state has changed before subscription
        }
        return unsubscribe;
    }, []);

    return api.getState() as Frozen<T>;
};
```

Usage is

```typescript
import create from ""zustand/vanilla"";

const zu = create(() => ({
    prop1: 2,
    prop2: ""hey !"",
    updateProp1: (v: number) => {
        zu.setState({ prop1: v });
    },
    updateProp2: (v: string) => {
        zu.setState({ prop2: v });
    },
    getProp2: () => zu.getState().prop2,
}));

export const TestComponent = () => {
    const zus = useZustand(zu);

    return (
        <div>
            <span>Prop2: {zus.getProp2()}</span>
            <button
                onClick={() => {
                    // Won't trigger re-render as 'prop1' is not used
                    zus.updateProp1(10);
                }}
            >
                Change prop1
            </button>
            <button
                onClick={() => {
                    // Will trigger re-render as getProp2() is using getState().prop2
                    zus.updateProp2(zus.getProp2() + ""!"");
                }}
            >
                Change prop2
            </button>
        </div>
    );
};

export const TestComponentWithSpread = () => {
    const { prop1, updateProp1, updateProp2 } = useZustand(zu);

    return (
        <div>
            <span>{prop1}</span>
            <button
                onClick={() => {
                    // Will trigger re-render as 'prop1' used by
                    // { prop1, updateProp1, updateProp2 } = useExtendedZustand(zu);
                    updateProp1(10);
                }}
            >
                PROP1
            </button>
            <button
                onClick={() => {
                    // Will not trigger re-render as prop2 isn't used
                    updateProp2(""bye!"");
                }}
            >
                PROP2
            </button>
        </div>
    );
};
```

I would be glad to see this in zustand, and happy to help implementing it with an experienced hook coder. And also, if I could have feedback on what could be wrong with my implementation, if I'm missing something... or maybe tell me why this approach is not a good idea?

Big up to the `pmndrs` collective",,
1174412600,875,Docs show deprecated syntax for using subscribe with selector in TypeScript,Looks like `StoreApiWithSubscribeWithSelector` was deprecated but the docs still show its usage,,
1173864056,874,Zustand DevTools log in production code,"My understanding is that the devtools only load in development and when `NODE_ENV === 'production'` they are not included. That being said, I'm looking at my output JS and I'm seeing the `console.warn` still showing in there even though its around a `__DEV__` condition, which I assume is looking at `NODE_ENV === 'development'` from what I can gather looking through the source. Why would this log still be showing (`[zustand devtools middleware] Please install/enable Redux devtools extension`)? Here is a snipped of my production code where you can see the log(s) are still present:

```js
u=void 0===t?{name:void 0,anonymousActionType:void 0}:""string""==typeof t?{name:t}:t;let s;try{s=window.__REDUX_DEVTOOLS_EXTENSION__||window.top.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!s)return""undefined""!=typeof window&&console.warn(""[zustand devtools middleware] Please install/enable Redux devtools extension""),e(n,r,i);let c=Object.create(s.connect(u)),l=!1;Object.defineProperty(i,""devtools"",{get:()=>(l||(console.warn(""[zustand devtools middleware] `devtools` property on the store is deprecated it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly""),l=!0),c),set:e=>{l||(console.warn(""[zustand devtools middleware] `api.devtools` is deprecated, it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly""),l=!0),c=e}});
```

This is my hook:
```js
export const useUserStore = create(
    devtools(set => ({
        ...storeStuff
    }))
);
```",,
1172456763,873,Error with v4 Context and React-Three/Fiber canvas,"Hi all,

I have a component that defines a context according to the example shown here (using v4):

_SceneContext.jsx_
```jsx
import React from 'react';
import {createContext, useContext} from 'react';
import { useDefaultSceneStore } from './defaultStore';
import { useStore } from 'zustand'

const SceneContext = createContext();

export const useSceneStore = (selector, equalityFn) => {
    const store = useContext(SceneContext);
    return useStore(store, selector, equalityFn)
}

export const SceneProvider = ({store, children}) => {
    return (
        <SceneContext.Provider value={store ? store : useDefaultSceneStore}>
            {children}
        </SceneContext.Provider>
    )
}
```

The goal is to accept a store in the actual component that can be overridden by the user of the component, in case they have their own store they want to use. This works great generally, but I have encountered an issue when combining this with `react-three/fiber`, since I am using that as well. What happens is that when nesting the store directly within the provider itself, there are no errors, but wrapping anything that uses the store within the Canvas causes errors. Here is the simplest version.

_Scene.jsx_

```jsx
import React, { Suspense } from 'react';
import { Canvas } from ""@react-three/fiber"";
import { SceneProvider, useSceneStore } from ""./SceneContext"";

const TestContent = () => {
  const tfs = useSceneStore(state=>Object.keys(state.tfs));
  console.log(tfs)
  return null
}

export default function Scene({ store, ...otherProps }) {

  return (
    <SceneProvider store={store}>
        {/* Placing the test content here is fine, which makes sense */}
        <TestContent />
        <Canvas>
          {/* Placing the test content here causes error */}
          <TestContent />
          <Suspense>
            {/* Placing the test content here also causes error */}
            <TestContent />
          </Suspense>
        </Canvas>
    </SceneProvider>
  )
}
```

The error I get is as follows:

```
Uncaught TypeError: Cannot read properties of undefined (reading 'subscribe')
    at useStore (index.js:27:1)
    at useSceneStore (SceneContext.jsx:10:1)
    at TestContent (Scene.jsx:56:1)
```

Am I doing something incorrectly or is there a limitation/bug here I am unaware of? Any help would be appreciated!

Thanks!",,
1170873858,872,Wrong types on onRehydrateStorage ,"Hi all

It seems like there is some inconsistent in the Typescript types on the persist function.

The `state` in the `onRehydrateStorage` does not know that the `reference` is optional from the create function, so i can't check for it.
<img width=""492"" alt=""image"" src=""https://user-images.githubusercontent.com/4134473/158576494-e971a76d-2366-494c-b094-a6e7a3ea0ad5.png"">


```js
import create from 'zustand';
import { persist } from 'zustand/middleware';

const useBasketStore = create<BasketStore>(
    persist(
        (set) => ({
            setReference: (reference) => set({ reference }),
        }),
        {
            name: 'basket',
            onRehydrateStorage: () => async (state, error) => {
                console.log('hydration starts', state);

                if (error || !state) {
                    console.log('an error happened during hydration', error);
                } else if (state.reference) {
                    const { basketReference } = await createBasket();
                    state.setReference(basketReference);
                }
            },
        }
    )
);

type BasketStore = {
    reference?: string;
    setReference: (reference: string) => void;
};
```


Seems like a bug, or is there a way to set the state in the create function to avoid this issue?",,
1160484701,853,Can an async store method call another async store method?,"```
create((get, set) => {
  a: async() => {},
  b: async() => {
    // here I want to call await a() - how do I do it correctly?
  }
})
```",,
1159546823,848,unable to unsubscribe from `subscribeWithSelector` on `fireImmediately`,"I have a case where I need to subscribe to the store and wait until a condition is met. Following the example in the docs, it would be something like this:

```js
const useStore = create(
  subscribeWithSelector(() => ({ paw: true, snout: true, fur: true }))
);

const unsub = useStore.subscribe(
  state => state.paw,
  hasPaw => {
      if (hasPaw) {
        unsub() // unsub is undefined on first call
      } else {
        // ... do something else
      }
  },
  { fireImmediately: true }
);
```

The problem is that the first call triggered by `fireImmediately` happens before the subscription is set up, and so `unsub` is `undefined`

Looking at the code, when the first call happens [the subscription is indeed not set up yet](https://github.com/pmndrs/zustand/blob/main/src/middleware/subscribeWithSelector.ts#L88)

Is this expected behaviour? If it is, then I can add a PR to warn of this in the docs. If not, I don't mind working on this but I only started using zustand this week so I may need guidance on what would be the prefered approach",,
1155441586,837,Expose zustand/context for use in Class components,"Zustand/context is a great for what I need. I need to use the Context in a Class component as well as functional. Can you just export the value from React.CreateContext() ?

https://github.com/pmndrs/zustand/blob/main/src/context.ts",,
1154054558,834,Use store inside a custom hook,"Hello,

Frequently, I bump into the need of using zustand stores lazily, after some configs are fetched and ready to use. And also I need them instance based. So I thought, I can extract the creation of the store into a custom hook.

But typing seems to be problematic. I can't just give `UseBoundStore<Store>` as hook's type and move on. Typescript complains about signature's incompatibility with `useStore()` usage. I couldn't find how to overcome it.


```ts
type Store = {};

const stores = new Map<string, UseBoundStore<Store>>();

const getCollectionStore = (collectionId: string) => {
  const store = stores.get(collectionId);
  
  if (store) { return store; }
  
  const newStore = create<Store>({ ... });
  
  stores.set(collectionId, newStore);
  
  return newStore;
}


const useCollectionStore: UseBoundStore<Store> = (selector, equalityFn) => {
  const route = useRoute();
  const collectionId = route.params.collectionId;
  
  const storeRef = React.useRef(getCollectionCreationStore(collectionId));
  Object.assign(useCollectionCreationStore, storeRef.current);
  
  React.useLayoutEffect(() => {
    storeRef.current = getCollectionCreationStore(collectionId);
    Object.assign(useCollectionCreationStore, storeRef.current);
  }, [collectionId]);
  
  return storeRef.current(selector, equalityFn);
}
```

```bash
Type '<U>(selector: StateSelector<Store, U>, equalityFn: EqualityChecker<U> | undefined) => any' is not assignable to type '{ (): Store; <U>(selector: StateSelector<Store, U>, equalityFn?: EqualityChecker<U> | undefined): U; }'.
```

Returning slice as any doesn't work either: `storeRef.current(selector, equalityFn) as any`. I think it is because of the `(): T` signature; this one works:

```ts
type UseBoundStoreAlt<T> = <U>(
  selector: StateSelector<T, U>,
  equalityFn?: EqualityChecker<U>
) => U & StoreApi<T>;


const useCollectionStore: UseBoundStoreAlt<Store> = (selector, equalityFn) => {
  ...

  return storeRef.current(selector, equalityFn) as any;
}
```

Any thoughts on this?

Thanks.",,
1149682242,830,Example in persist is broken,"### What is the issue

The line `useStore.setState({ _hasHydrated: true })` does not actually update the state: https://github.com/pmndrs/zustand/wiki/Persisting-the-store's-data#how-can-i-check-if-my-store-has-been-hydrated

```javascript
const useStore = create(
  persist(
    (set, get) => ({
      // ...
      _hasHydrated: false
    }),
    {
      // ...
      onRehydrateStorage: () => () => {
        useStore.setState({ _hasHydrated: true }) // THIS DOES NOT CHANGE THE STATE
      }
    }
  )
);

export default function App() {
  const hasHydrated = useStore(state => state._hasHydrated);

  if (!hasHydrated) {
    return <p>Loading...</p>
  }

  return (
    // ...
  );
}
```

However, if we update the state through a setter, then it works
```javascript
const useStore = create(
  persist(
    (set, get) => ({
      // ...
      setHydrate: (val) =>
        set((state) => {
          state._hasHydrated = val;
      }),
      _hasHydrated: false
    }),
    {
      // ...
      onRehydrateStorage: () => (state) => {
        state.setHydrate(true) // THIS WORKS
      }
    }
  )
);
```

### Reproducible Example
https://codesandbox.io/s/dry-breeze-rpfk4p?file=/src/App.js:420-513

Is this an expected behavior? Or I can probably take a look and fix it.
",,
1146563694,820,Accessing previous state when updating state,"Hi,

This is not really an issue but I did not know where can I ask this information so I put it here.
Can I, and if so how, access previous state when updating state ?
What I mean is that for example with basic React useState i can write

```
const [test, setTest] = useState ({first: true, second: true});
setTest (prev => {return {...prev, second: false }});
```
here I can access previous state and update only 'second' property;
with zustand can I do the same somehow ?
for example in zustand store i have

```
interface View {
    current: string,
    next: boolean
}

interface AppState {
    view: View;
    setView: (view: View) => void;
}

export const useStore = create<AppState>((set: SetState<AppState>, get: GetState<AppState>) => ({   
    view: {current: 'landing', next: false},
    setView: (view: View) => {set ({view: view})},
}));

```

and then I consume store and try to update in component

```
const setView = useStore(state => state.setView);
setView( prev => ...prev) // THIS HERE!! How can I access previous state ? for example to only update next property while using current from previous state.

```
",,
1145021588,816,Error while building: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory,"Hi 
I'm getting error while build. It's like `zustand` store which I made is using too much memory or anything lie that.

Error getting after `yarn build`
```shell
Creating an optimized production build...

<--- Last few GCs --->

[11987:0x5d13be0]    77824 ms: Scavenge 2038.0 (2079.2) -> 2036.3 (2079.5) MB, 5.2 / 0.0 ms  (average mu = 0.171, current mu = 0.143) allocation failure 
[11987:0x5d13be0]    77832 ms: Scavenge 2038.4 (2079.7) -> 2036.8 (2080.2) MB, 5.3 / 0.0 ms  (average mu = 0.171, current mu = 0.143) allocation failure 
[11987:0x5d13be0]    77841 ms: Scavenge 2038.9 (2080.2) -> 2037.3 (2084.7) MB, 5.3 / 0.0 ms  (average mu = 0.171, current mu = 0.143) allocation failure 


<--- JS stacktrace --->

FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory
 1: 0xafd010 node::Abort() [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
 2: 0xa141fb node::FatalError(char const*, char const*) [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
 3: 0xce746e v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
 4: 0xce77e7 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
 5: 0xeb5c85  [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
 6: 0xeb6766  [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
 7: 0xec471e  [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
 8: 0xec5140 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
 9: 0xec7f25 v8::internal::Heap::HandleGCRequest() [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
10: 0xe56557 v8::internal::StackGuard::HandleInterrupts() [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
11: 0x11fdf35 v8::internal::Runtime_StackGuard(int, unsigned long*, v8::internal::Isolate*) [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
12: 0x15e7fb9  [/home/minam/.nvm/versions/node/v16.10.0/bin/node]
```

Store component I made
```javascript
import create from ""zustand"";

const useDataStore = create((set) => ({
  data: [],
  isLoaded: true,
  requestError: """",
  setData: (newData) => set(() => ({ data: newData })),
  setIsLoaded: (boolean) => set(() => ({ isLoaded: boolean })),
  setRequestError: (error) => set(() => ({ requestError: error })),
}));

export default useDataStore;
```

then using it in form part to set data like
```javascript
import useDataStore from ""../../store"";
// other code
const updataData = useDataStore((state) => state.setData);
const setIsLoaded = useDataStore((state) => state.setIsLoaded);
const setRequestError = useDataStore((state) => state.setRequestError);

async function handleSubmit(e) {
    e.preventDefault();

    const entries = new FormData(e.target).entries(); // geting all form inputs value 
    fetch(""/api/get-all-data?"" + new URLSearchParams(entries))
      .then((res) => res.json())
      .then(
        (result) => {
          setIsLoaded(true); // setting loading 
          updataData(result.data); // setting data
        },
        (error) => {
          setIsLoaded(true);
          setRequestError(error); // setting error
          console.log(error);
        }
      );
}
```
and using using it in other component like 
```javascript
import useDataStore from ""../../store"";
// other code
const items = useDataStore((state) => state.data);
const isLoaded = useDataStore((state) => state.isLoaded);
const requestError = useDataStore((state) => state.requestError);

```

Package info: (default create-react-react)
```json
""dependencies"": {
    ""@auth0/auth0-react"": ""^1.8.0"",
    ""@testing-library/jest-dom"": ""^5.14.1"",
    ""@testing-library/react"": ""^12.0.0"",
    ""@testing-library/user-event"": ""^13.2.1"",
    ""react"": ""^17.0.2"",
    ""react-dom"": ""^17.0.2"",
    ""react-map-gl"": ""^7.0.6"",
    ""react-router-dom"": ""^6.2.1"",
    ""react-scripts"": ""5.0.0"",
    ""web-vitals"": ""^2.1.0"",
    ""zustand"": ""^3.7.0""
}
```
",,
1142858253,815,Using zustand/context without a Provider,"Native React contexts allow you to use the `useContext` hook without having a provider wrapped around the component. There are some use-cases where such behavior is desirable, for example, those described [here](https://github.com/facebook/react/issues/17912#issuecomment-578518909).

This behavior is different from the zustand Context implementation, as using the `useStore` hook without a provider will throw an error due to [this](https://github.com/pmndrs/zustand/blob/main/src/context.ts#L67-L69) assertion.

Due to this, even though we have zustand in our project and we would like to leverage it, in some cases using a native context is cleaner than a zustand one. What do you think about extending this functionality a little bit to also export the `ZustandContext` itself [here](https://github.com/pmndrs/zustand/blob/main/src/context.ts#L101-L105) to enable usage of native `useContext` with it? Or perhaps not throwing the error in the current implementation but that would modify the current logic.",,
1141231216,812,useCallback selector loses type inference in version 3.7.0,"Just updated from 3.6.9 to 3.7.0 and I'm facing typescript errors in my project because useCallback loses type inference.
Here is an example: https://codesandbox.io/s/tender-scott-9902ek?file=/src/App.tsx
hover `valid` and `invalid` variables.

You can change zustand version to 3.6.9 sandbox to see it working.",,
1124389653,780,'devtools' is deprecated.,"Following the library README I saw how to use devtools to debug my application. I have implemented the devtools just like the guide says but from VSC it tells me that the devtools method is deprecated, is there a new way to use the devtools? Can I have some information about it? Thank you.
Below you will find my code.


```import create from ""zustand"";
import { devtools } from ""zustand/middleware"";
export const useStore = create(
  devtools((set: any) => ({
    address: ""Connect Wallet"", // case: Install wallet, Connect Wallet, Address
    setAddress: (newAddress) => set((state) => ({ address: newAddress })),
    removeAddress: () => set({ address: null }),
    chain: null,
    setChain: (chain) => set((state) => ({ chain })),
    removeChain: () => set({ chain: null }),
  }))
);

package.json :
""dependencies "": {
    ""next"": ""12.0.8"",
    ""react"": ""17.0.2"",
    ""react-dom"": ""17.0.2"",
    ""zustand"": ""^ 3.6.9""
  } 

```
<img width=""544"" alt=""Immagine 2022-02-04 172922"" src=""https://user-images.githubusercontent.com/61518840/152565927-3cc5c7d3-ea54-485c-a95a-b82c346f6911.png"">
",,
1124332158,779,"zustand/context ""Seems like you have not used zustand provider as an ancestor"" error","As I have multiple instances of the same component at the same page. So I am trying to implement zustand/context to be able to have separate states for each instance.  This is my store file :

```
import create from 'zustand'
import createContext from 'zustand/context'

import { getNoteBlock } from '../../../../helpers/Blocks/noteBlock'

const { Provider, useStore } = createContext()

const createStore = () =>
	create((set) => ({
		notes: [],
		title: '',
		blockId: null,
		blockSettings: {},
		isLoading: true,
		isSaving: false,
		getBlockData: async (blockId) => {
			const blockData = await getNoteBlock(blockId)
			set({ notes: blockData.notes, title: blockData.title, blockId: blockId, blockSettings: blockData.blockSettings, isLoading: false })
		},
	}))

export { Provider, useStore, createStore }
```

And this is how I use : 

```
import react from 'react'
import { useEffect } from 'react'

import GetBlockData from './GetBlockData'
import { Provider, useStore, createStore } from './BlockStore/BlockStore'

const NoteBlock = ({ blockId }) => {
	const getBlockData = useStore((state) => state.getBlockData)
	const isLoading = useStore((state) => state.isLoading)

	useEffect(() => {
		getBlockData(blockId)
	}, [])

	return (
		<Provider createStore={createStore}>
			<react.Fragment>
				{!isLoading && <GetBlockData />}
				{isLoading && <div>Loading...</div>}
			</react.Fragment>
		</Provider>
	)
}

export default NoteBlock
```

Unfortunately, I am getting this error:

`Error: Seems like you have not used zustand provider as an ancestor.`

I have checked and compared the docs for zustand/context, but still can't figure out the issue. 
Thank you for your input in advance !
",,
1123918944,776,Confusion,"Hi there,

I have a small issue that I can't understand, wondering if someone can point me in the right direction

Please see the snippet below


Could someone please explain why **console.log(""The user is"", user)** is returning null ?

as loadUserFromAsyncStorage() - is using await 

Shouldn't the console.log return a user object instead of null ?

Thank you so much if someone can clear this up


---

    const { user, loadUserFromAsyncStorage} = userState();



    useEffect(() => {

        loadUserAndPrepareMessaging()

    }, [])


---

    async function loadUserAndPrepareMessaging() {

        try {

            await loadUserFromAsyncStorage()
            **console.log(""The user is"", user)**  -- this returns null
            await requestUserPermission()

        } catch (error) {

            console.log(""Error loading user from storage"", error.message)

        } finally {
            setLoading(false)
        }

    }

----

export const userState = create((set, get) => ({

    user: null,
 

    loadUserFromAsyncStorage: async () => {

        if (!get().user)

            try {
                let storedUser = JSON.parse(await AsyncStorage.getItem(API.asyncStorageKey))

                console.log(""The stored user is"", storedUser)

                //we don't care about the data which is returned, we just want to ensure that the jwt token is still valid

                await axios.get(`${API.server}/users/me`, {

                    headers: {
                        Authorization:
                            `Bearer ${storedUser.jwt}`,
                    }

                })

                set({ user: storedUser })

            } catch (e) {
                console.log(""Could not load user data from active storage either because he does not exist or the jwt token is invalid"", e.message)
            }
    },

----


",,
1123799728,775,Unable to subcribe to the transient state.,"```
const Home = () => {
  const focusRef = useRef(useStore.getState().isSearchBarFocussed);
  useEffect(
    () => useStore.subscribe((state) => (focusRef.current = state.isSearchBarFocussed)),
    []
  );

  console.log(focusRef.current);
  const { isLoading, data } = useQuery('home', getData);
  let cleanedHomeData: CleanedHomeData[] = [];
  const homeData = data?.data as HomeData;

  if (!isLoading && data) {
    cleanedHomeData = objToSortedArr(homeData);
  }
  if (isLoading) {
    return <Loading />;
  }

  if (homeData && homeData.status === 'error') {
    return <Error />;
  }

  return (
    <React.Fragment>
      <FlatList
        data={Object.keys(cleanedHomeData)}
        renderItem={({ index }) => {
          return (
            <Main index={index}>
              {index === 0 ? <SearchBar /> : <></>}
              <MbText>{focusRef.current.toString()}</MbText>
              <MbRadioRenderer item={cleanedHomeData[index] as CleanedHomeDataEntity0} />
            </Main>
          );
        }}
        keyExtractor={() => {
          return (
            new Date().getTime().toString() +
            Math.floor(Math.random() * Math.floor(new Date().getTime())).toString()
          );
        }}
        maxToRenderPerBatch={Math.ceil(Dimensions.get('screen').height / 140)}
        initialNumToRender={Math.ceil(Dimensions.get('screen').height / 140)}
        showsVerticalScrollIndicator={false}
      />
    </React.Fragment>
  );
};

export default Home;
```

I am updating the focus state from the SearchBar component. it works fine if. i use the normal way of getting the state.
Please tell me if i am doing wrong.

Project: React Native 0.67",,
1118385698,766,Proper arguments are not printed when using log middleware + Persist middleware not persisting functions,"I have set up log/immer middleware like the documentation. However, when I trigger a function from the store, the arguments on the log are not properly printed. I get something like ""ƒ (n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}"" 
get() part looks good on my end though.

Please let me know if I missed anything!
Thanks in advance!

```
import produce from 'immer';
import create, { SetState } from 'zustand';
import createContext from 'zustand/context';

const log = config => (set, get, api) =>
  config(
    (args) => {
      console.log(
        'payload: ',
        args,
      );
      console.log(
        'New State: ',
        get(),
      );
      set(args);
    },
    get,
    api,
  );

const immer = config => (set, get, api) =>
  config(
    (partial, replace) => {
      const nextState = typeof partial === 'function' ? produce(partial) : partial;
      return set(nextState, replace);
    },
    get,
    api,
  );
  
  const { Provider, useStore } = createContext();
  
  const createStore = () =>
    create(
      log(
        immer((set)=> {
          return {
            store: ...,
            props: ...,
            actions: {
              fetchRequest: () => {
                set(state => {
                  state.store.network.status = LOADING;
                });
              },
              },
            },
          };
        }),
      ),
    );
    
    <Provider createStore={createStore}>{children}</Provider>
```",,
1113869295,760,[TypeScript] subscribe shows as deprecated even when using middleware...,"I am using `zustand/vanilla` and with the 3.6.0 changes my subscribe function is showing depricated even after importing the middleware:

```
export const trackStore = create<TrackState>(
  subscribeWithSelector((set, get) => ({
    tracks: [],
    actions: {
      setVisibleTracks: (trackIds: number[]) => {
        console.log('trackIds:', trackIds)
        set(
          produce((draft: TrackState) => {
            draft.tracks = trackIds
          }),
        )
      },
    },
  })),
)
```

Is Zustand moving into only supporting React or is this a temporary problem?",,
1104075555,755,Can't use devtools with Typed store,"hey guys and thanks for all the effort you are putting on this amazing project,

my issue is simple, i want to use typescript & devtools on stores
![Screenshot 2022-01-14 215913](https://user-images.githubusercontent.com/92998703/149577392-9a01ed74-4b5f-4ce3-9080-0eecf7862adc.png)

currently i'm using the commented line, but i'd like to have the first line working. any help please?
",,
1099562226,748,Inconsistent typing between zustand and zustand/vanilla,"If we pass the `StoreApi` created with `zustand/vanilla` as an argument to the `create` method from `zustand`, the typing is incorrectly inferred.

### `zustand`

```tsx
import create from ""zustand"";

const useStore = create(
  combine(
    {
      bears: 0,
    },
    (set) => ({
      increase: (by: number) => set((state) => ({ bears: state.bears + by })),
    })
  )
);

useStore((state) => state.bears); // ✅ number
```

### `zustand/vanilla` + `zustand`

```tsx
import create from ""zustand"";
import createVanilla from ""zustand/vanilla"";

const vanillaStore = createVanilla(
  combine(
    {
      bears: 0,
    },
    (set) => ({
      increase: (by: number) => set((state) => ({ bears: state.bears + by })),
    })
  )
);

const useVanillaStore = create(vanillaStore);

useVanillaStore((state) => state.bears); // ❎ Property 'bears' does not exist on type 'object'
```

The expected type is `number`.

---

Tested on `v3.6.9`. It was working properly on `v3.4.1`.",,
1097209702,741,does returning get() to chain commands come with a performance impact?,"I'm trying to build a store that lets me chain calls together

Something like:

```jsx
const useMyStore((state) => state.showOrHide)
showOrHide().removeMultiple([""id1"", ""id2""]).add(""id3"")
```

technically, in the store every function would just return get()

```jsx
showOrHide: (element) => {
  // if the element is already open, close it
  if (get().isOpen(element)) {
    get().remove(element)
    // else just show it
  } else {
    get().add(element as Draft<T>)
  }
  return get()
}
```

However, not sure if that is incredibly imperformant",,
1092975816,736,How to get ReturnType from store?,"With the following code:

```ts
import create from ""zustand"";
import { combine } from ""zustand/middleware"";

const useStore = create(
  combine({ bears: 0 }, (set) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by }))
  }))
);

type Type = ReturnType<typeof useStore>;
```

`Type` will be typed as  `unknown`. Is this fixable somehow?",,
1091859890,734,"not sure how I can ""setState""","In the store I have 
```
interface GridState {
   columnsState: ColumnState[];
 }
export const useGridStore = create<GridState>(persist(
    (set, get) => ({
        columnsState: []
    }),
    {
        name: ""status-grid-storage"", // name of item in the storage (must be unique)
        getStorage: () => localStorage, // (optional) by default the 'localStorage' is used
    }
))
```

then in the component setter I have:
```
useGridStore.setState({ columnsState: localColumnsState });
```
Does it really populate `state.columnsState` with the value of localColumnsState ?

Should I create a method in the store to populate the property? How would I do it with a parameter?

Thank you.
",,
1088014389,726,How can I test the store hook?,"Basically, I'm trying to to do the following:
- To be able to mount the store
- To call a method 
- To check if the state has been updated correctly.

So I came up with the following code:

// The test
```
import actualCreate, { GetState, SetState } from ""zustand"";
import {
  act,
  Renderer,
  renderHook,
  RenderHookResult,
} from ""@testing-library/react-hooks"";

import { groceryStore } from ""."";
import { GroceryListStoreMethods, GroceryListStoreProperties } from ""../types"";

type GroceryListStore = GroceryListStoreProperties & GroceryListStoreMethods;

type ResetFunction = () => void;

type CreateState = (
  set: SetState<GroceryListStore>,
  get: GetState<GroceryListStore>,
  api: any
) => GroceryListStore;

const storeResetFns = new Set<ResetFunction>();

const create = (createState: CreateState) => {
  const store = actualCreate<GroceryListStore>(createState);
  const initialState = store.getState();
  storeResetFns.add(() => store.setState(initialState, true));
  return store;
};

let store: RenderHookResult<
  unknown,
  GroceryListStore,
  Renderer<unknown>
> | null;

beforeEach(() => {
  const useGroceryListStore = create(groceryStore);
  store = renderHook(() => useGroceryListStore());
});

test(""Should return true to a isEmpty() check"", () => {
  act(() => {
    const result = store?.result.current.isEmpty();
    expect(result).toBe(true);
  });
});

test(""Should add a grocery item to the list"", (resolve) => {
  act(() => {
    const theStore = store?.result.current;
    theStore?.addGrocery(""Bananas"", 3);

    store?.waitForValueToChange(() => {
      try {
        expect(theStore?.groceries.length).toBe(1);
        resolve();
      } catch (e) {
        resolve(e);
      }
    });
  });
});

afterEach(() => {
  act(() => storeResetFns.forEach((resetFn) => resetFn()));
  store = null;
});
```

// The Store
```
import { combine } from ""zustand/middleware"";
import { createId } from ""@/services/utils"";

import { GroceryListStoreProperties, GroceryListStoreMethods } from ""../types"";

const groceryStore = combine<
  GroceryListStoreProperties,
  GroceryListStoreMethods
>(
  {
    groceries: {},
    selectedGroceries: [],
    lastAddedGrocery: """",
  },
  (set, get) => ({
    addGrocery(name, amount = 1) {
      const id = createId();

      set((state) => {
        return {
          groceries: {
            ...state.groceries,
            ...{ [id]: { id, name, amount } },
          },
        };
      });
    },

    removeGroceries(ids) {
      set((state) => {
        state.selectedGroceries = [];

        if (!ids) {
          state.groceries = {};
        } else {
          ids.forEach((groceryId) => {
            delete state.groceries[groceryId];
          });
        }

        return {
          selectedGroceries: [],
          groceries: state.groceries,
        };
      });
    },

    updateGrocery(id, props) {
      set((state) => {
        state.groceries[id] = {
          ...state.groceries[id],
          ...props,
        };
        return { ...state };
      });
    },

    getTotalAmount() {
      return Object.values(get().groceries).reduce(
        (acc, curr) => acc + curr.amount,
        0
      );
    },

    getGroceriesList() {
      return Object.values(get().groceries);
    },

    setSelectedGroceries({ checked, id }) {
      set((state) => {
        state.selectedGroceries = checked
          ? [...state.selectedGroceries, id]
          : state.selectedGroceries.filter((value) => value != id);

        return { ...state };
      });
    },

    isEmpty() {
      return Object.keys(get().groceries).length === 0;
    },
  })
);

export default groceryStore;
export { groceryStore };

```

The second test (""Should add a grocery item to the list"") result is always ""0"".
Any help would be great!
",,
1087279527,721,A swapped in store will not update reactively,"I'm trying to use `zustand` for a project where a user can specify a `zustand`-backed provider. If the user switches their provider, any changes to the new providers store are not picked up by react. This is because any uses of the `zustand` hook `useStore` will not be updated to listen to the new provider, because the listener is set up once, with no deps.

As a contrived (untested) example:
```
<MyComponent storeBackedProvider={mock} />
```

```
function MyComponent({storeBackedProvider}) {
  const useStore = create(storeBackedProvider.store)
  const value = useStore()

  return <span>{value}</span>
}
```

In this case, if the `mock` is swapped out, `MyComponent` will no longer be reactive to `value`.

---

I propose depending on `api` when registering listeners to fix this.",999983109,"@zzmp I'm very sorry. I didn't correctly understand what this is about, went ahead to #722, and thought it's fine.

But, this is not something we want to allow. It's like conditionally invoking hooks, which is basically violating the rule of hooks. We shouldn't dynamically create a hook in a component. It just happen to work because the useStore hook has the same implementation, but in general it's not guaranteed, and it looks like a bad practice.

zustand v3 has a workaround with `zustand/context` which make sure the store is created just once.

In your use case, what's easy is to remount the component:
```jsx
<MyComponent key={unique_string_for_mock} storeBackedProvider={mock} />
```

I agree this is a non-trivial limitation and zustand v4 with #550 will provide a new API for this use case. So, please be patient.

My big apologies again for your work in #722 with my wrong understanding."
1085740926,719,Question: Why do hooks useRef instead of useState,"I've noticed for a [few](https://github.com/ctrlplusb/easy-peasy/blob/5c4c0e8e0a708e0c218f82d0a89aa679d1f44dcb/src/hooks.js#L79) state libraries, [including zustand](https://github.com/pmndrs/zustand/blob/c319075d8c152b59054de78ca6051e3d22b7c62f/src/react.ts#L138), use `useRef`, diff the previous value and then forceRender(), instead of leaving this to `useState` which does all this for free. Why is that?

My guess it's something to do with isomorphic layouts?",998711317,"basically, it's to support inline (non-memoized) selectors (and to avoid re-subscribing when selectors change).

with #550, we no longer have explicit useRef."
1085740926,719,Question: Why do hooks useRef instead of useState,"I've noticed for a [few](https://github.com/ctrlplusb/easy-peasy/blob/5c4c0e8e0a708e0c218f82d0a89aa679d1f44dcb/src/hooks.js#L79) state libraries, [including zustand](https://github.com/pmndrs/zustand/blob/c319075d8c152b59054de78ca6051e3d22b7c62f/src/react.ts#L138), use `useRef`, diff the previous value and then forceRender(), instead of leaving this to `useState` which does all this for free. Why is that?

My guess it's something to do with isomorphic layouts?",998718035,"Thanks for your prompt response.

But can't you support non-memoized selectors and avoid re-subscribing like so:

```js
function useStore(selector) {
  const ref = useRef({ selector }).current;
  ref.selector = selector;
  const [state, setState] = useState(selector(value));
  useEffect(() => subscribe(x => setState(ref.selector(x))), []);
  return useMemo(() => [state, set], [state]);
}
```

* Selector always stays up to date
* Don't resubscribe every time the selector changes"
1085740926,719,Question: Why do hooks useRef instead of useState,"I've noticed for a [few](https://github.com/ctrlplusb/easy-peasy/blob/5c4c0e8e0a708e0c218f82d0a89aa679d1f44dcb/src/hooks.js#L79) state libraries, [including zustand](https://github.com/pmndrs/zustand/blob/c319075d8c152b59054de78ca6051e3d22b7c62f/src/react.ts#L138), use `useRef`, diff the previous value and then forceRender(), instead of leaving this to `useState` which does all this for free. Why is that?

My guess it's something to do with isomorphic layouts?",998720071,"no, you want to support changing the selector. `useStore(state => state[props.key])`

> Selector always stays up to date

this doesn't work, if state is not changed, but only props.key changes."
1085740926,719,Question: Why do hooks useRef instead of useState,"I've noticed for a [few](https://github.com/ctrlplusb/easy-peasy/blob/5c4c0e8e0a708e0c218f82d0a89aa679d1f44dcb/src/hooks.js#L79) state libraries, [including zustand](https://github.com/pmndrs/zustand/blob/c319075d8c152b59054de78ca6051e3d22b7c62f/src/react.ts#L138), use `useRef`, diff the previous value and then forceRender(), instead of leaving this to `useState` which does all this for free. Why is that?

My guess it's something to do with isomorphic layouts?",998722566,"Ah gotcha! The resulting state will be stale until the underlying state itself changes.

"
1077393051,710,Proposal: Encoding store mutations type-level,"Middlewares in zustand can and do mutate the store, which makes it impossible to type them with without some workaround, this proposal tries to encode mutations type-level to make zustand almost 100% type-safe and still extensible.

I'll walk you through how this came to be, because I think it makes one understand how it works and why certain elements of it are necessary.

PR #662 already implements this proposal so you can try it out if you want. And [here](https://tsplay.dev/NlxjeN)'s the final playground to try things out.

## Index

This is less of a ""table of content"" and more of an ""index"", meaning the whole thing is single-read and there are no independent ""sections"" per se, they are made as such to aid the reader to track their progress because this document is rather too long to be a single-read.

- Independent mutations
  - Forwarding mutations up the tree
  - Forwarding mutations down the tree
  - Ordered writes
  - Subtractive mutations
- Dependent mutations
  - Higher kinded mutations
  - Higher kinded mutators
- Zustand-adapted version
- To-dos
  - Caveats
  - Others
- Action point

## Independent mutations

Consider this scenario (I'll be making the api simpler only for the explanation, there are no api changes required)...

```js
const withA = (a, f) => store => {
  store.a = a,
  return f(store);
}

const withB = (b, f) => store => {
  store.b = b,
  return f(store);
}

let storeOut = create(
  withB(""b"",
    withA(""a"",
      storeIn =>
        ({ count: 0 })
    )
  )
)
```

Here both `storeOut` and `storeIn` should be of type `Store<unknown> & { a: string } & { b: string }` (we don't care about inferring the state `{ count: number }` for now)

So how would we approach this? First let's take a simpler version

```js
const withA = (a, f) => store => {
  store.a = a,
  return f(store);
}

let storeOut = create(
  withA(""a"",
    storeIn =>
      ({ count: 0 })
  ),
)
```

One could begin with something like...

```ts
// https://tsplay.dev/w6XJ6m

declare const create:
  <T, M>
    ( initializer:
        & ((store: Store<T>) => T)
        & { __mutation?: M }
    ) =>
    Store<T> & M

type Store<T> =
  { get: () => T
  , set: (t: T) => void
  }
  
declare const withA: 
  <A, T>
    ( a: A
    , initializer:
        (store: Store<T> & { a: A }) => T
    ) =>
      & ((store: Store<T>) => T)
      & { __mutation?: { a: A } }


let storeOut = create(
  withA(""a"",
    storeIn =>
      ({ count: 0 })
  ),
)
```

And it works. `storeOut` and `storeIn` are `Store<unknown> & { a: string }`. But why does it work? Intuitively you could think that had the store been immutable the middlewares would have returned the mutation isn't it? That's what we're doing here, the middlewares not only return the initializer but also the mutation to the store.

### Forwarding mutations up the tree

Okay now let's see if it works for a more complex example...

```ts
// https://tsplay.dev/mbGe3W

declare const create:
  <T, M>
    ( initializer:
        & ((store: Store<T>) => T)
        & { __mutation?: M }
    ) =>
      Store<T> & M

type Store<T> =
  { get: () => T
  , set: (t: T) => void
  }
  
declare const withA: 
  <A, T>
    ( a: A
    , initializer:
        (store: Store<T> & { a: A }) => T
    ) =>
      & ((store: Store<T>) => T)
      & { __mutation?: { a: A } }

declare const withB: 
  <B, T>
    ( b: B
    , initializer:
        (store: Store<T> & { b: B }) => T
    ) =>
      & ((store: Store<T>) => T)
      & { __mutation?: { b: B } }


let storeOut = create(
  withB(""b"",
    withA(""a"",
      storeIn =>
        ({ count: 0 })
    )
  )
)
```

Hmm, it doesn't work. `storeOut` is `Store<unknown> & { b: string }` and `storeIn` is `Store<unknown> & { a: string }`. Why is that? Because were aren't accommodating the fact that the ""child"" of `withB` ie `withA` itself comes with its mutation so we need to carry forward mutations up the tree. Let's do that[^1]...

```diff
  // https://tsplay.dev/mpvdzw

  declare const withA: 
    < A
    , T
+   , M extends {}
    >
      ( a: A
      , initializer:
          & ((store: Store<T> & { a: A }) => T)
+         & { __mutation?: M }
      ) =>
        & ((store: Store<T>) => T)
        & { __mutation?:
+            & M
             & { a: A }
          }
```

So when the child itself has a mutation `M` (ie when the initializer has `{ mutation?: M }`) we carry it forward as `{ __mutation?: M & { a: A } }` instead of just `{ __mutation?: { a: A } }`.

Also the `extends {}` constraint on `M` is so that it doesn't get fixated to `undefined` because of the `?` in `{ __mutation?: M }`.

### Forwarding mutations down the tree

Okay so now the mutation is forwarded upstream and `storeOut` is `Store<unknown> & { a: string } & { b: string }`. But `storeIn` is still `Store<unknown> & { a: string }`. That's because we have only forwarded mutations upstream, we also need to forward the mutations downstream. Let's see how we can do that...

```diff
  // https://tsplay.dev/m3aLqw

  declare const withA: 
    < A
    , T
    , Mc extends {}
+   , Mp extends {}
    >
      ( a: A
      , initializer:
          & ((store:
              & Store<T>
+             & Mp
              & { a: A }
            ) => T)
          & { __mutation?: Mc }
      ) =>
        & ((store:
            & Store<T>
+           & Mp
          ) => T)
        & { __mutation?: Mc & { a: A } }
```

But it doesn't compile. Why so? Let me first show you a minimal equivalent of the above...

```ts
// https://tsplay.dev/wR9kXW

declare const create:
  <T>(initializer: (store: Store<T>) => T) => Store<T>

type Store<T> =
  { get: () => T
  , set: (t: T) => void
  }
  
declare const identityMiddleware: 
  <T, S extends Store<T>>
    (initializer: (store: S) => T) =>
      (store: S) => T

let storeOut = create(
  identityMiddleware(
    storeIn =>
      ({ count: 0 })
  )
)
```

Now what's happening here? Why does it not compile? The problem is TypeScript can't contextually infer `S`, it eagerly resolves it to `Store<unknown>`. And why does it do that? Well it'll take me rather too long to develop what I know intuitively so [this comment](https://github.com/microsoft/TypeScript/issues/44999#issuecomment-883531098) is the best I can offer right now.

Long story short it doesn't work, we need a workaround. Which looks something like this...

```diff
  // https://tsplay.dev/wX2ALm

  declare const withA: 
    < A
    , T
    , Mc extends {}
    , Mp extends {}
    >
      ( a: A
      , initializer:
          & ( ( store:
                & Store<T>
                & Mp
                & { a: A }
+             , __mutation: UnionToIntersection<Mp | { a: A }>
              ) => T
            )
          & { __mutation?: Mc }
      ) =>
        & ( ( store:
              & Store<T>
-             & Mp
+           , __mutation: Mp
            ) => T
          )
        & { __mutation?: Mc & { a: A } }

+ type UnionToIntersection<U> =
+   (U extends unknown ? (u: U) => void : never) extends (i: infer I) => void
+     ? I
+     : never
```

So instead of passing the mutation from parent as `(store: Store<T> & Pm) =>` we're doing `(store: Store<T>, __mutation: Pm) =>` which in spirit is the same thing. And instead of `Pm & { a: A }` we trick the compiler by doing `UnionToIntersection<Pm | { a: A }>` which is effectively resolves to the same thing.

Why does all this works? Well, I kinda vaguely know it in my ""feels"" but it's going to take me a lot of experimentation to come up with a good enough theory, so let's just skip that xD

So now finally `storeOut` and `storeIn` both are `Store<unknown> & { a: string } & { b: string }`

### Ordered writes

What if we have a scenario like this...

```js
const withA = (a, f) => store => {
  store.a = a;
  return f(store)
}

let storeOut = create(
  withA(1,
    withA(""a"",
      storeIn =>
        ({ count: 0 })
    )
  )
)
```

Here with our existing approach `storeOut` and `storeIn` would be `Store<unknown> & { a: number } & { a: string }` when it should have been `Store<unknown> & { a: string }`. That means we need to ""write"" instead of just intersecting and order of mutations matters too. Let's see how we can do that...

```diff
  // https://tsplay.dev/NnXdvW

  declare const withA: 
    < A
    , T
-   , Mc extends {}
+   , Mcs extends {}[] = []
-   , Mp extends {}
+   , Mps extends {}[] = []
    >
      ( a: A
      , initializer:
-         & ( ( store: Store<T> & Mp & { a: A }
+         & ( ( store: Mutate<Store<T>, [...Mps, { a: A }]>
-             , __mutation: UnionToIntersection<Mp | { a: A }>
+             , __mutations: [...Mp, { a: A }]
              ) => T
            )
-         & { __mutation?: Mp }
+         & { __mutations?: Mps }
      ) =>
        & ( ( store: Store<T>
-           , __mutation: Mp
+           , __mutations: Mps
            ) => T
          )
-       & { __mutation?: { a: A } & Mps  }
+       & { __mutations?: [{ a: A }, ...Mcs] }

+ type Mutate<S, Ms> =
+   Ms extends [] ? S :
+   Ms extends [infer M, ...infer Mr] ? Mutate<Write<S, M>, Mr> :
+   never
+ 
+ type Write<T, U> =
+   Omit<T, keyof U> & U
```

`Mps` happen before because they are come from the parent, `Mcs` happen after because they come from the child.

Note that we are doing `= []` for `Mcs` and `Mps` because previously when there's no `{ __mutation }` found (like in case of `() => ({ count: 0 })`) the compiler would resolve them to their constraints ie `{}` which also happened to be the default. Now the default is `[]` so we need to make it explicit. So technically speaking previously too we should have had `Mc extends {} = {}` but that's almost same as writing `Mc extends {}`.

So now `storeOut` and `storeIn` are `Mutate<Store<unknown>, [{ a: string }, { a: number }]>` except that in case of `storeOut`, `number` gets narrowed to `1`. We can fix that by blocking inference of `A` at the places it isn't supposed to be inferred from...

```diff
  // https://tsplay.dev/Wk5d2N

  declare const withA: 
    < A
    , T
    , Mcs extends {}[] = []
    , Mps extends {}[] = []
    >
      ( a: A
      , initializer:
-         & ( ( store: Mutate<Store<T>, [...Mps, { a: A }]>
+         & ( ( store: Mutate<Store<T>, [...Mps, { a: NoInfer<A> }]>
-             , __mutations: [...Mps, { a: A }]
+             , __mutations: [...Mps, { a: NoInfer<A> }]
              ) => T
            )
          & { __mutations?: Cm }
      ) =>
        & ((store: Store<T>, __mutations: Pm) => T)
-       & { __mutations?: [{ a: A }, ...Mcs] }
+       & { __mutations?: [{ a: NoInfer<A> }, ...Mcs] }

+ type NoInfer<T> =
+   [T][T extends unknown ? 0 : never]
```

So now we're inferring `A` only from the argument, as it should be. And now `number` no longer gets narrowed to `1`.

Also remember that child mutations can also happen before the current one, example...

```js
const withA = (a, f) => store => {
  let state = f(store)
  store.a = a;
  return state;
}

let storeOut = create(
  withA(1,
    withA(""a"",
      storeIn =>
        ({ count: 0 })
    )
  )
)
```

In this case we'd expect `storeOut.a` to be `number` instead of `string` unlike the previous case. Depending on the implementation, the author can type the middleware accordingly, in this case we're first doing the child mutations so the type becomes...

```diff
  // https://tsplay.dev/wg6kbW

- & { __mutations?: [{ a: NoInfer<A> }, ...Mcs] }
+ & { __mutations?: [...Mcs, { a: NoInfer<A> }] }
```

### Subtractive mutations

Although rare but it's important to note that now mutations can make a store no longer extend `Store<T>`, in that case some cases that should compile won't compile, example...

```js
// https://tsplay.dev/WYBpEw

const withReadonly = f => store => {
  let readonlyStore = { ...store };
  delete readonlyStore.set;
  return f(store);
}

let storeOut = create(
  withReadonly(
    withA(""a"",
      storeIn =>
        ({ count: 0 })
    )
  )
)
```

If you scroll at the end of the error message you'd see it says ""'undefined' is not assignable to type '(t: unknown) => void'"" that's because `withA`'s type says it requires `Store<T>` when in fact it doesn't use `set` and only sets a property `a`. Previously, we moved from `(store: Store<T> & Pm) =>` to `(store: Store<T>, __mutation: Pm) => void` because the former didn't work. But now we can go back to that and use `Mutate<Store<T>, Mps>` which would solve our problem and make it compile...

```diff
// https://tsplay.dev/WvYdRm

-       & ((store: Store<T>, __mutations: Mps) => T)
+       & ((store: Mutate<Store<T>, Mps>, __mutations: Mps) => T)
```

But what if `withA` actually requires `set` and want the store to be of type `Store<T>`? In that case we can specify our requirements and then we get the original error back which is now warrant...

```diff
// https://tsplay.dev/WyO7dN

-       & ((store: Mutate<Store<T>, Mps>, __mutations: Mps) => T)
+       & ((store: Mutate<Store<T>, Mps> & Store<T>, __mutations: Mps) => T)
```

It's important to only specify only what we require in the implementation, for example if `withA` only cared about `get` it should specify only that would then make our code compile again as it should...

```diff
// https://tsplay.dev/W4y1ew

-       & ((store: Mutate<Store<T>, Mps> & Store<T>, __mutations: Mps) => T)
+       & ((store: Mutate<Store<T>, Mps> & Pick<Store<T>, ""get"">, __mutations: Mps) => T)
```

## Dependent mutations

At any point if our mutation has a `T` on a covariant position, it no longer compiles. Basically if the middleware (mutation) ""gives"" or ""returns"" the state it means `T` is on a covariant position (like in case of `persist`, `onHydrate` and `onFinishHydration` ""give"" the state), it won't work. Here's a simple example...

```js
// https://tsplay.dev/mx6dKw

const withSerialized = f => store => {
  store.getSerialized = () => serialize(store.get())
  // Edit: I realized later this is an stupid example
  // but I'm too lazy to edit it. We'll just pretend
  // `serialize` is an identity function.
  // Perhaps a more realistic but yet simple example
  // would be `getNormalised` or something where the
  // it returns `Normalized</* covariant */ T>`.
  // The realest example is ofc `persist` as I
  // mentioned above.

  return f(store)
}

let storeOut = create(
  withSerialized(
    withA(""a"",
      storeIn =>
        ({ count: 0 })
    )
  )
)
```

If you scroll to the end of the huge error you'd find something like `WithSerialized<unknown> is not assignable to WithSerialized<never>`. The thing for some reason typescript (this could be a bug) resolves `T` to `never` instead of `unknown` assuming it to be contravariant.

I can make it compile [by making all signatures bivariant](https://tsplay.dev/wQen7w) but still `storeIn` would have `WithSerialized<never>` instead of `WithSerialized<unknown>` so that doesn't work. It'd work if `T` is already concrete either [via user explicitly typing it](https://tsplay.dev/WYBxEw) or [via a helper](https://tsplay.dev/N53KZW). These solutions could work but let's actually solve the problem.

### Higher kinded mutations

One thing is clear that we can't have `T` directly on the mutations, that is to say we can't have `{ a: A, t: T }` as a mutation so instead we'll use an emulated higher kinded type `(T, A) => { a: A, t: T }` and inject `T` (and an optional payload like `A` in this case)...

```diff
  // https://tsplay.dev/N9poJw

+ interface StoreMutations<T, A> {}
+ type StoreMutationIdentifier = keyof StoreMutations<unknown, unknown>

  declare const withSerialized:
    < T
-   , Mcs extends {}[] = []
+   , Mcs extends [StoreMutationIdentifier, unknown][] = []
-   , Mps extends {}[] = []
+   , Mps extends [StoreMutationIdentifier, unknown][] = []
    >
      ( initializer:
-         & ( ( store: Mutate<Store<T>, [...Mps, WithSerialized<T>]>
+         & ( ( store: Mutate<Store<T>, [...Mps, [""WithSerialized"", never]]>
-             , __mutations: [...Mps, WithSerialized<T>]
+             , __mutations: [...Mps, [""WithSerialized"", never]]
              ) => T
            )
          & { __mutations?: Mcs }
      ) =>
        & ((store: Mutate<Store<T>, Mps> __mutations: Mps) => T)
-       & { __mutations?: [WithSerialized<T>, ...Mcs] }
+       & { __mutations?: [[""WithSerialized"", never], ...Mcs] }
  
+ interface StoreMutations<T, A>
+   { WithSerialized: { getSerialized: () => T }
+   }
  
  declare const withA: 
    < A
    , T
-   , Mcs extends {}[] = []
+   , Mcs extends [StoreMutationIdentifier, unknown][] = []
-   , Mps extends {}[] = []
+   , Mps extends [StoreMutationIdentifier, unknown][] = []
    >
      ( a: A
      , initializer:
-         & ( ( store: Mutate<Store<T>, [...Mps, { a: NoInfer<A> }]>
+         & ( ( store: Mutate<Store<T>, [...Mps, [""WithA"", NoInfer<A>]]>
-             , __mutations: [...Mps, { a: NoInfer<A> }]
+             , __mutations: [...Mps, [""WithA"", NoInfer<A>]]
              ) => T
            )
          & { __mutations?: Mcs }
      ) =>
        & ((store: Mutate<Store<T>, Mps>, __mutations: Mps) => T)
-       & { __mutations?: [{ a: NoInfer<A> }, ...Mcs] }
+       & { __mutations?: [[""WithA"", NoInfer<A>], ...Mcs] }
      
+ interface StoreMutations<T, A>
+   { WithA: { a: A }
+   }
  
- type Mutate<S, Ms> =
+ type Mutate<S, Ms, T = S extends { get: () => infer T } ? T : never> =
    Ms extends [] ? S :
-   Ms extends [infer M, ...infer Mr]
+   Ms extends [[infer I, infer A], ...infer Mr]   
      ? Mutate<
          Overwrite<
            S,
-           M
+           StoreMutations<T, A>[I & StoreMutationIdentifier]
          >,
          Mr
        > :
    never
```

So instead of passing around mutations `M` we pass ""functions"" `(T, A) => M` that take `T` and some optional payload. So writing...

```ts
type M<A> = [""WithFoo"", A]

interface StoreMutations<T, A>
  { WithFoo: { t: T, a: A }
  }
```

...is in spirit same as writing a higher kinded type...

```ts
type M<A> = T -> { t: T, a: A }
```

So `StoreMutations` is a collection of ""mutation creators"". And now as you can see in the diff `M` becomes `StoreMutations<T, A>[I & StoreMutationIdentifier]`[^2]. Writing `StoreMutations<T, A>[I]` is in spirit writing `storeMutations[i](t, a)` which would return `m`.

`StoreMutations` is also a ""global"" collection so it can be augmented anywhere and new mutations can be added. It works across files thanks to module augmentation and declaration merging, so in reality adding a mutation would look like this...

```ts
// @file node_modules/zustand/index.ts
export interface StoreMutations<T, A> {}

// @file node_modules/zustand-with-serialized/index.ts
declare module ""zustand"" {
  interface StoreMutations<T, A>
    { WithSerialized: { getSerialized: () => T }
    }
}
```

### Higher kinded mutators

Now that we are using higher kinded types, we can simplify things a bit and instead of `newStore = overwrite(oldStore, storeMutations[mi](tFromOldStore, a))` just simply do `newStore = storeMutators[mi](oldStore, a)`.

```diff
  // https://tsplay.dev/NrGk2m

- interface StoreMutations<T, A>
-   { WithSerialized: { getSerialized: () => T }
-   }

+ interface StoreMutators<S, A>
+   { WithSerialized:
+       S extends { get: () => infer T }
+         ? Write<S, { getSerialized: () => T }>
+         : never
+   }

- interface StoreMutations<T, A>
-   { WithA: { a: A }
-   }

+ interface StoreMutators<S, A>
+   { WithA: Write<S, { a: A }>
+   }
  
- type Mutate<S, Ms, T = S extends { get: () => infer T } ? T : never> =
+ type Mutate<S, Ms> =
    Ms extends [] ? S :
    Ms extends [[infer Mi, infer A], ...infer Mr]   
      ? Mutate<
-         Write<
-           S,
-           StoreMutations<T, A>[Mi & StoreMutationIdentifier]
-         >,
+         StoreMutators<S, A>[Mi & StoreMutatorIdentifier],
          Mr
        > :
    never
```

## Zustand-adapted version

[Here](https://tsplay.dev/mMVDVW)'s a version that is compatible with zustand's api (same as in #662), uses unique symbols for identifiers, a reusable `StoreInitializer`, etc and an example middleware.

## To-dos

This is still sort of incomplete here are some things left to figure out...

### Caveats

It doesn't compile if you don't write all middlewares in place because it relies on contextual inference, meaning this doesn't compile...

```js
// https://tsplay.dev/w6X96m

let foo = withB(""b"", () => ({ count: 0 }))
let store = create(withA(""a"", foo))
```

... but this does ...

```js
// https://tsplay.dev/WPxDZW

let store = create(withA(""a"", withB(""b"", () => ({ count: 0 }))))
```

I recently noticed this caveat so I haven't really worked on it. Maybe I could make it at least compile will a little less accuracy in types.

### Other

- Migration plan? What changes do users need to make?
- `createWithState`? Probably a good idea.
- If we'll be having `createWithState` do we still need higher kinded types? Maybe, maybe not.
- Is this pipeable? Can we make a custom pipe that works?
- ...

## Action point

I'd like to know if this seems like a good idea or not, if yes then I'll continue with the to-dos. If no then how far should we go wrt to types?

Thanks for reading all this! Hopefully I've not made much mistakes. Feel free to ask questions

[^1]: Note that the diffs through out the document are just gists, they are not exact it excludes some obvious changes elsewhere (like in `create`) and also renames variables, changes formatting etc. The diff is minimal enough to get the crux of what changed. Go to the playground link to see the full change

[^2]: The `& StoreMutationIdentifier` is to just satisfy the compiler that `I` indeed is a key of `StoreMutations` (as `X & Y` will always be a subtype of `Y`). `I & StoreMutationIdentifier` is same as `I` because `I` already is a subtype of `StoreMutationIdentifier`, eg `""WithSerialized"" & (""WithSerialized"" | ""WithA"")` is `""WithSerialized""`.
",,
1077063575,709, state update on an unmounted component warning,"custom creator
```ts
const setImmerState =
    <T extends State>(set: SetState<T>): ZImmerSetState<T> =>
    (partial, replace) => {
        const nextState =
            typeof partial === 'function'
                ? produce(partial as (state: Draft<T>) => T)
                : (partial as T);
        return set(nextState, replace);
    };

const ImmerMiddleware =
    <
        T extends State,
        CustomSetState extends SetState<T>,
        CustomGetState extends GetState<T>,
        CustomStoreApi extends StoreApi<T>,
    >(
        config: ZImmberStateCreator<T, ZImmerSetState<T>, CustomGetState, ZImmerStoreApi<T>>,
    ): ZImmberStateCreator<T, CustomSetState, CustomGetState, CustomStoreApi> =>
    (set, get, api) => {
        return config(setImmerState(set), get, { ...api, setState: setImmerState(api.setState) });
    };

export function createImmer(createState: any) {
    const store = create(ImmerMiddleware(createState));
    store.setState = setImmerState(store.setState);
    return store;
}
```
my hooks
```typescript
const useRouterStore = createImmer<RouterStore>(() => ({
    signal: {
        shouldChange: false,
        canGenerate: false,
        generated: false,
    },
    routes: [],
    renders: [],
    names: {},
    config: getDefaultState(),
}));

export const useSetupRouter = <T extends Record<string, any>>(config: RouterConfig<T>) => {
    const [userChanged, setUserChanged] = useSafeState<boolean>(false);
    const { getAuthRequest } = useRequest();
    const { token, setuped: AuthSetuped } = useAuth();
    const { requested, user } = useUser();
    const { routerConfig, shouldChange, canGenerate, routes } = useRouterStore(
        (state) => ({
            routerConfig: state.config,
            routes: state.routes,
            shouldChange: state.signal.shouldChange,
            canGenerate: state.signal.canGenerate,
        }),
        shallow,
    );
    const { auth, basePath, server, render } = routerConfig;
    const userRef = useRef<User | null>(user);
    useEffect(() => {
        setUserChanged(!dequal(userRef.current, user));
    }, [user]);
    useEffect(() => {
        if (config) {
            useRouterStore.setState((state) => {
                state.config = merge(state.config, config, {
                    arrayMerge: (_d, s, _o) => s,
                }) as any;
                state.signal.shouldChange = true;
            }, true);
        }
    }, [config]);
    useEffect(() => {
        useRouterStore.setState((state) => {
            state.signal.shouldChange = true;
        });
    }, [userChanged, requested, token, AuthSetuped]);
    useAsyncEffect(async () => {
        if (!shouldChange) return;
        useRouterStore.setState((state) => {
            state.signal.shouldChange = false;
            state.signal.canGenerate = false;
        });
        if (!auth.enabled) {
            useRouterStore.setState((state) => {
                state.routes = [...state.config.routes.constants, ...state.config.routes.dynamic];
                state.signal.canGenerate = true;
            });
            return;
        }
        if (user) {
            if (!userChanged) return;
            useRouterStore.setState((state) => {
                state.routes = filteAccessRoutes(user, state.config.routes.constants, auth, {
                    basePath,
                });
            });
            const request = getAuthRequest();
            if (!server) {
                useRouterStore.setState((state) => {
                    state.routes = filteAccessRoutes(
                        user,
                        [...state.routes, ...state.config.routes.dynamic],
                        auth,
                        {
                            basePath,
                        },
                    );
                    state.signal.canGenerate = true;
                });
            } else if (request && server) {
                try {
                    const { data } = await request.get<RouteOption[]>(server);
                    if (isArray(data)) {
                        useRouterStore.setState((state) => {
                            state.routes = [...state.routes, ...data];
                            state.signal.canGenerate = true;
                        });
                    }
                } catch (error) {
                    console.log(error);
                }
            }
        } else if (requested || (!token && AuthSetuped)) {
            useRouterStore.setState((state) => {
                state.routes = [
                    ...filteWhiteList(state.config.routes.constants, auth, {
                        basePath,
                    }),
                    ...filteWhiteList(state.config.routes.dynamic, auth, {
                        basePath,
                    }),
                ];
                state.signal.canGenerate = true;
            });
        }
    }, [shouldChange]);
    useDeepCompareEffect(() => {
        if (canGenerate) {
            const { nameMaps, routes: renders } = factoryRoutes(routes, {
                basePath,
                render,
            });
            useRouterStore.setState((state) => {
                state.names = nameMaps;
                state.renders = renders;
                if (state.config.auth.enabled && !user && state.config.auth.redirect === 'login') {
                    state.renders.push({
                        path: '*',
                        element: <AuthRedirect loginPath={auth.login_path} />,
                    });
                }
                state.signal.shouldChange = false;
                state.signal.generated = true;
                state.signal.canGenerate = false;
            });
        }
    }, [canGenerate]);
};
export const useRouter = <T extends Record<string, any> = Record<string, any>>() => {
    const { config, routes, generated, names, renders } = useRouterStore(
        (state) => ({
            config: state.config,
            names: state.names,
            renders: state.renders,
            routes: state.routes,
            generated: state.signal.generated,
        }),
        shallow,
    );
    const addRoutes = useCallback((items: RouteOption<T>[]) => {
        useRouterStore.setState((state) => {
            state.config.routes.dynamic = [...state.config.routes.dynamic, ...items];
            state.signal.shouldChange = true;
        });
    }, []);
    const setRoutes = useCallback((items: RouteOption<T>[]) => {
        useRouterStore.setState((state) => {
            state.config.routes.dynamic = [...items];
            state.signal.shouldChange = true;
        });
    }, []);
    return {
        generated,
        names,
        config,
        routes,
        renders,
        addRoutes,
        setRoutes,
    };
};

```
and provider
```tsx
export const RoutesList: FC<{ routes: RouteObject[] }> = ({ routes }) => useRoutes(routes);
export const RouterInit: FC = () => {
    const {
        config: { basePath: basename, hash, window },
        renders,
    } = useRouter();
    return hash ? (
        <HashRouter {...{ window, basename }}>
            <RoutesList routes={renders} />
        </HashRouter>
    ) : (
        <BrowserRouter {...{ window, basename }}>
            <RoutesList routes={renders} />
        </BrowserRouter>
    );
};
export const RouterWrapper: FC = () => {
    const { generated } = useRouter();
    useEffect(() => {
        console.log(`generated: ${generated}`);
    }, [generated]);
    return generated ? <RouterInit /> : <div>加载中{`${generated}`}</div>;
};
export const Router = <T extends Record<string, any>>({ config }: { config: RouterConfig<T> }) => {
    useSetupRouter<T>(config);
    useSetupMenu();
    return <RouterWrapper />;
};
```
error

```
""react_devtools_backend.js:2540 Warning: Can't perform a React state update on an unmounted component.
 This is a no-op, but it indicates a memory leak in your application. 
To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.""
```
",,
1071518310,694,ReferenceError when using devtools middleware,"Hi, I'm getting `ReferenceError: Cannot access 'useStore' before initialization` when using zustand(3.6.6) with devtools middleware in a Nextjs project created using create-next-app.

Steps to reproduce:
1. `npx create-next-app zustand-test`
2. `cd zustand-test`
3. `npm i zustand`
4. Replace `/pages/index.js` with [index.js] and add `store.js` with [store.js]
5. `npm run dev` or `npm run build`

[index.js]
```js
import { useStore } from '../store';

const Home = () => {
  const value = useStore(s => s.value);
  return <div>{value}</div>;
};

export default Home;
```
[store.js]
```js
import create from 'zustand';
import { devtools } from 'zustand/middleware';

const createStore = () => ({
  value: 10,
});

export const useStore = create(devtools(createStore));
```
![ReferenceError](https://user-images.githubusercontent.com/34903858/144757541-dbbb47a8-eac1-4972-a00a-059ef3d55939.png)

",,
1068077725,686,"Error with subscribeWithSelector, persist and string literals","I'm running into errors trying to use `subscribeWithSelector`, `persist`, and string literals. 

``` ts
import create, { GetState, SetState } from 'zustand';
import { persist, StoreApiWithSubscribeWithSelector, subscribeWithSelector } from 'zustand/middleware';

interface BearState {
	// Setting the type to string is fine
	// species: string;  
	
	// However using a string literal throws a type error
	species: 'brown' | 'grizzly' | 'teddy'; 
}


export const useBearStore = create<
	BearState,
	SetState<BearState>,
	GetState<BearState>,
	StoreApiWithSubscribeWithSelector<BearState>
>(
	subscribeWithSelector(
		persist(
			() => ({
				species: 'teddy',
			}),
			{
				name: 'bear-store',
			}
		)
	)
);
```

I get the error logged below. I also tried changing the order of `persist` and `subscribeWithSelector`  which gives an almost identical error.

```
Argument of type '(set: SetState<BearState>, get: GetState<BearState>, api: Omit<StoreApi<{ species: string; }> & { persist: { setOptions: (options: Partial<...>) => void; ... 4 more ...; onFinishHydration: (fn: PersistListener<...>) => () => void; }; }, ""subscribe""> & Omit<...> & { ...; }) => { ...; }' is not assignable to parameter of type 'StoreApiWithSubscribeWithSelector<BearState> | StateCreator<BearState, SetState<BearState>, GetState<BearState>, StoreApiWithSubscribeWithSelector<...>>'.
  Type '(set: SetState<BearState>, get: GetState<BearState>, api: Omit<StoreApi<{ species: string; }> & { persist: { setOptions: (options: Partial<...>) => void; ... 4 more ...; onFinishHydration: (fn: PersistListener<...>) => () => void; }; }, ""subscribe""> & Omit<...> & { ...; }) => { ...; }' is not assignable to type 'StateCreator<BearState, SetState<BearState>, GetState<BearState>, StoreApiWithSubscribeWithSelector<BearState>>'.
    Types of parameters 'api' and 'api' are incompatible.
      Type 'StoreApiWithSubscribeWithSelector<BearState>' is not assignable to type 'Omit<StoreApi<{ species: string; }> & { persist: { setOptions: (options: Partial<PersistOptions<{ species: string; }, Partial<{ species: string; }>>>) => void; ... 4 more ...; onFinishHydration: (fn: PersistListener<...>) => () => void; }; }, ""subscribe""> & Omit<...> & { ...; }'.
        Property 'persist' is missing in type 'StoreApiWithSubscribeWithSelector<BearState>' but required in type 'Omit<StoreApi<{ species: string; }> & { persist: { setOptions: (options: Partial<PersistOptions<{ species: string; }, Partial<{ species: string; }>>>) => void; ... 4 more ...; onFinishHydration: (fn: PersistListener<...>) => () => void; }; }, ""subscribe"">'.ts(2345)
```

If I change the type to `species: string`, the error goes away. 

Keeping the string literal but getting rid of the store type also works:

``` ts
export const useBearStore = create(
	persist(
		subscribeWithSelector(() => ({
			species: 'teddy',
		})),
		{
			name: 'test-store',
		}
	)
);
```

Presumably I've lost the ability to infer types by doing that, however. ",,
1068058803,685,Is it possible to set the default comparison function to shallow? ,"I recently updated to Zustand 3.6.5. The changed order of `.subscribe` and the need to use `subscribeWithSelector` came as a bit of a surprise but once I worked everything out it's worth it for the improved types. 

However, I now have to `import shallow from 'zustand/shallow'` all over my app. So far there's nowhere that I _don't_ want to use shallow comparison. Is there any way to set the default comparison function on the store itself? Or if not, could this feature be added?  
",,
1066715073,683,How do I persist a subset of slices?,"**Code**

```
export const useStore = create<StoreState>(persist(
    // Define the slices that we want to persist across page loads.
    (set, get) => ({
        ...createAuthSlice(set, get), // <-- to be stored in session
        ...createUserSlice(set, get),
        ...createPreferenceSlice(set, get),
    }),
    {
        // Configure persist middleware
        name: ""store"", // Name of persistent storage
        getStorage: () => sessionStorage, // Use the browser's session storage
        partialize: (state) => ({ auth: state.user }),
    }
))
```

I am trying to persist only the user attribute in the auth slice in session, but I keep getting the following error.

`Type '(state: { user: IUser; getAccessToken: any; forgotPassword: any; forgotPasswordSubmit: any; signUp: any; signIn: any; logOut: any; verifyUser: any; }) => { auth: IUser; }' is not assignable to type '(state: { user: IUser; getAccessToken: any; forgotPassword: any; forgotPasswordSubmit: any; signUp: any; signIn: any; logOut: any; verifyUser: any; }) => DeepPartial<{ user: IUser; getAccessToken: any; ... 5 more ...; verifyUser: any; }>'.
  Type '{ auth: IUser; }' has no properties in common with type 'DeepPartial<{ user: IUser; getAccessToken: any; forgotPassword: any; forgotPasswordSubmit: any; signUp: any; signIn: any; logOut: any; verifyUser: any; }>'.ts(2322)
middleware.d.ts(135, 5): The expected type comes from property 'partialize' which is declared here on type 'PersistOptions<{ user: IUser; getAccessToken: any; forgotPassword: any; forgotPasswordSubmit: any; signUp: any; signIn: any; logOut: any; verifyUser: any; }, Partial<{ user: IUser; getAccessToken: any; ... 5 more ...; verifyUser: any; }>>'
(property) partialize?: ((state: AuthSlice) => DeepPartial<AuthSlice>) | undefined`

I would appreciate any help anyone can give me.
",,
1065927484,680,Compatibility with Electron Redux Dev Tools,"Hello, I'm using Zustand v3.6.5 with electron v13.1.9 as well as the popular electron-forge v6.0.0 and it works well. Electron also supports redux dev tools via [electron-devtools-installer](https://github.com/MarshallOfSound/electron-devtools-installer) v3.2.0, which works well with vanilla redux. However, when I try to get my Zustand store to work with redux dev tools via the `devtools` middleware, I get the following error:

`SyntaxError: Unexpected token (32:10)` in `/node_modules/zustand/esm/middleware.js`.

Here is how I use the middleware:

```typescript
export const useGameStore = create<GameState>(devtools(store));
```

The third line in this try-catch block includes the supposed syntax error the console complains about:

```javascript
try {
    extension = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;
} catch {
}
```

I checked in the electron developer tools console and `window.__REDUX_DEVTOOLS_EXTENSION__` is indeed defined.

Does anyone have any ideas why this might occur and how I can resolve this error? It's been puzzling me for a while.",,
1065850741,679,[Question] Proper way to abstract zustand store values in a custom hook,"I'm trying to abstract some global state management into a custom hook.
My use case if to expose the zustand state of a library so it can be used in React components.


The issue I'm encountering with my current approach (vs. using  `useStore` directly) is that the components using my hook have unnecessary re-renders when one of the values change.  

This is my current basic approach:

```javascript
import React from ""react"";
import { useStore } from ""../store"";
import shallow from ""zustand/shallow"";

const selector = (state) => ({
  apples: state.apples,
  addApple: state.addApple,
  removeApple: state.removeApple,
  oranges: state.oranges,
  //...
});

const useFruitState = () => {
  const { apples, oranges, addApple, removeApple } = useStore(
    selector,
    shallow
  );

  return {
    apples,
    oranges,
    addApple,
    removeApple,
  };
};

export default useFruitState;
```

```javascript
function Component() {
  const { apples, oranges, addApple, removeApple } = useFruitState();
  ...
}
```",,
1056835831,670,Typescript/React: Cannot find name 'set'.,"I'm a junior developer and am not sure if this is an issue with Zustand, Typescript, or NPM.

When i try to use the example code on the README.md, I get the following error message in VS Code.

`Cannot find name 'set'. Did you mean 'Set'?ts(2552)
lib.es2015.collection.d.ts(71, 13): 'Set' is declared here.`

I have:

- `npm install zustand --save-dev`
- `npm install @types/node --save-dev`
- Updated tsconfig.json to include `ES6` in lib.

I appreciate any help you can offer. Thank you.",,
1054903864,665,Upgrading to Nextjs12 breaks build (module resolution issue),"Pardon me for my ignorance if I have missed something obvious:
**Note: This worked just fine before Next12**

Today I bumped up NextJS from 11 to 12 and since then, this is what I get while building my app.

![screenshot-localhost_3000-2021 11 16-19_14_03](https://user-images.githubusercontent.com/19551058/141996686-52841b7f-ff0a-40cc-8f90-b3d59a09b9bf.png)

My configurations are as follows:

**package.json**
```
{
  ""name"": ""plantation-gamma"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""export"": ""next export"",
    ""pre-deploy"": ""mv out/404/index.html out/404.html && rm -rf out/404"",
    ""ssg"": ""npm run build && npm run export && npm run pre-deploy"",
    ""deploy"": ""firebase deploy"",
    ""start"": ""next start"",
    ""lint"": ""eslint --fix ."",
    ""format"": ""prettier --write './**/*.{js,jsx,ts,tsx,css,md,json}' --config ./.prettierrc""
  },
  ""dependencies"": {
    ""@headlessui/react"": ""^1.0.0"",
    ""classname"": ""0.0.0"",
    ""firebase"": ""^9.4.1"",
    ""fuzzy-search"": ""^3.2.1"",
    ""got"": ""^11.8.2"",
    ""lqip-modern"": ""^1.2.0"",
    ""motion"": ""^10.3.1"",
    ""next"": ""^12.0.4"",
    ""notion-client"": ""^4.9.3"",
    ""notion-types"": ""^4.8.2"",
    ""notion-utils"": ""^4.8.6"",
    ""p-map"": ""^4.0.0"",
    ""prism-react-renderer"": ""^1.2.0"",
    ""query-string"": ""^7.0.0"",
    ""react"": ""17.0.2"",
    ""react-custom-scrollbars-2"": ""^4.4.0"",
    ""react-dom"": ""^17.0.2"",
    ""react-hotkeys"": ""^2.0.0-pre9"",
    ""react-icons"": ""^4.2.0"",
    ""react-intersection-observer"": ""^8.32.0"",
    ""react-katex"": ""^2.0.2"",
    ""react-notion-x"": ""^4.11.0"",
    ""react-toastify"": ""^7.0.4"",
    ""use-sound"": ""^4.0.1"",
    ""zustand"": ""^3.6.5""
  },
  ""devDependencies"": {
    ""@svgr/webpack"": ""^5.5.0"",
    ""@types/node"": ""^14.14.41"",
    ""@types/react"": ""^17.0.3"",
    ""@types/react-dom"": ""^17.0.9"",
    ""@typescript-eslint/eslint-plugin"": ""^4.22.0"",
    ""@typescript-eslint/parser"": ""^4.22.0"",
    ""autoprefixer"": ""^10.2.5"",
    ""eslint"": ""^7.24.0"",
    ""eslint-config-airbnb-typescript"": ""^12.3.1"",
    ""eslint-config-next"": ""^11.0.0"",
    ""eslint-config-prettier"": ""^8.2.0"",
    ""eslint-plugin-import"": ""^2.25.2"",
    ""eslint-plugin-jsx-a11y"": ""^6.4.1"",
    ""eslint-plugin-prettier"": ""^3.4.0"",
    ""eslint-plugin-react"": ""^7.23.2"",
    ""eslint-plugin-react-hooks"": ""^1.7.0"",
    ""postcss"": ""^8.2.10"",
    ""prettier"": ""^2.2.1"",
    ""tailwindcss"": ""^2.1.1"",
    ""typescript"": ""^4.4.4""
  }
}
```

**tsconfig.json**
```
{
  ""compilerOptions"": {
    ""target"": ""ESNEXT"",
    ""lib"": [
      ""DOM"",
      ""DOM.Iterable"",
      ""ESNext""
    ],
    ""allowJs"": true,
    ""skipLibCheck"": true,
    ""strict"": false,
    ""forceConsistentCasingInFileNames"": true,
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""module"": ""esnext"",
    ""moduleResolution"": ""node"",
    ""resolveJsonModule"": true,
    ""isolatedModules"": true,
    ""jsx"": ""preserve"",
    ""incremental"": true,
    ""baseUrl"": ""."",
    ""paths"": {
      ""@/assets/*"": [
        ""assets/*""
      ],
      ""@/components/*"": [
        ""components/*""
      ],
      ""@/configs/*"": [
        ""configs/*""
      ],
      ""@/hooks/*"": [
        ""hooks/*""
      ],
      ""@/libs/*"": [
        ""libs/*""
      ],
      ""@/pages/*"": [
        ""pages/*""
      ],
      ""@/styles/*"": [
        ""styles/*""
      ],
      ""@/constants/*"": [
        ""constants/*""
      ],
      ""@/store/*"": [
        ""store/*""
      ]
    },
  },
  ""include"": [
    ""custom.d.ts"",
    ""**/*.ts"",
    ""**/*.tsx"",
    ""configs/*.js"",
    ""tailwind.config.js""
  ],
  ""exclude"": [
    ""node_modules"",
    ""next-env.d.ts""
  ]
}
```

**next.config.js**
```
const nextConfig = {
  trailingSlash: true,
  swcMinify: true,
  experimental: {
    urlImports: ['https://cdn.skypack.dev']
  },
  eslint: {
    ignoreDuringBuilds: true
  },
  webpack: (config, options) => {
    const fileLoaderRule = config.module.rules.find((rule) => rule.test && rule.test.test('.svg'));
    fileLoaderRule.exclude = /\.svg$/;

    /**
     * Loading svg as react components
     */
    config.module.rules.push({
      loader: '@svgr/webpack',
      options: {
        prettier: false,
        svgo: true,
        svgoConfig: {
          plugins: [{ removeViewBox: false }]
        },
        titleProp: true
      },
      test: /\.svg$/
    });

    /**
     * Loading audio files
     */
     config.module.rules.push({
      test: /\.(mp3)$/,
      type: ""asset/resource"",
      generator: {
        filename: ""static/chunks/[path][name].[hash][ext]"",
      },
    });

    return config;
  }
};

module.exports = nextConfig;
```",,
1052023108,656,Typescript issues with set function when creating store,"I'm using the basic example to create a store from the documentation and I'm getting the Typescript issues as seen in the screenshot below. These include `object is of type 'unknown'.` and `Parameter 'state' implicitly has an 'any' type.`. Can somebody please assist?

Zustand version: 3.6.5
Typescript version: 4.4.4

![image](https://user-images.githubusercontent.com/5741857/141482033-835ef794-aab3-474a-b7c0-b8717ca21b47.png)

![image](https://user-images.githubusercontent.com/5741857/141482093-54d871f9-cb34-4968-afbb-efb3fb964271.png)
",,
1049522433,650,TypeScript type conflict with persist middleware,"I am unable to get the `persist` middleware working with TypeScript if I define state properties with multiple types or with the `boolean` type.

zustand version: 3.6.4
TypeScript version: 4.1.3

Example code:
```
import create, { GetState, SetState } from ""zustand"";
import { persist, StoreApiWithPersist } from ""zustand/middleware"";

type AuthStore = {
  token: string | undefined;
  authenticated: boolean;
  authenticate: (username: string, password: string) => Promise<void>;
}

const useAuthStore = create<AuthStore, SetState<AuthStore>, GetState<AuthStore>, StoreApiWithPersist<AuthStore>>(
  persist(
    (set) => ({
      token: undefined,
      authenticated: false,
      authenticate: async (username, password) => {
        set({authenticated: true})
      },
    }),
    { name: ""auth-store"" }
  )
);

export default useAuthStore;
```

`persist` function gives the following errors:
```
 Type 'string | undefined' is not assignable to type 'undefined'.
          Type 'string' is not assignable to type 'undefined'.ts(2345)

 The types of 'authenticated' are incompatible between these types.
        Type 'boolean' is not assignable to type 'false'.ts(2345)
```

Everything works as expected if I just define `token` and `authenticated` as `any` type.",,
1045732322,642,[Bug] New subscribe documentation doesn't work,"Hi Zustand

Thanks for an awesome library!

I'm running into an issue with the new subscribeWithSelector in the new zustand version

**Zustand Version**
3.6.4

**Problem**
According to your documentation i should be able to use subscribe with the new subscribeWithSelector, but I keep getting the error that I should use the middleware.

My Store:
`export type TControlsStore = {
  publicBargainingAgreement: string;
};`

`const store = (set: NamedSet<TControlsStore>, get: GetState<TControlsStore>) => ({
  publicBargainingAgreement: '',
});`

`const useControlsStore = create<TControlsStore>(devtools(subscribeWithSelector(store)));`

My subscription:
`useControlsStore.subscribe(state => state, console.log(""my log""))`

**Steps to reproduce**
Install Zustand 3.6.4 and add subscribe according to the documentation and see that you get the error.

![image](https://user-images.githubusercontent.com/59334469/140504515-4690d8ef-f437-4f14-b165-0d067b8989e1.png)
![image](https://user-images.githubusercontent.com/59334469/140504545-fade1c32-f93d-4d04-a709-f1c040810087.png)


-----

Am I missing something from the documentation? To me it looks exactly the same and I can seem to find where the error is?",,
1045722894,640,`createContext` doesn't work with `@react-three/fiber`,"I wanted to expose the `Canvas` state, so I used `createContext` and wrapped `Canvas` in the returned Provider, like so:

```tsx
// store.tsx

import create from ""zustand"";
import createContext from ""zustand/context"";

const { Provider, useStore } = createContext();

export function StoreProvider({ children, initialState }) {
  return (
    <Provider createStore={() => create(() => ({ ...initialState }))}>
      {children}
    </Provider>
  );
}

export { useStore };
```

```tsx
// App.tsx

function App() {
  const someState = useStore(state => state.someState)

  return (
    <Canvas>
      <Content />
    </Canvas>
  );
}

function Wrapper() {
  return (
    <StoreProvider initialState={{}}>
      <App />
    </StoreProvider>
  );
}

export default Wrapper;
```

```tsx
// Content.tsx

export function Content() {
  const someOtherState = useStore(state => state.someOtherState)

  return <mesh />;
}

```

This throws an error similar to:

```
Uncaught Error: Seems like you have not used zustand provider as an ancestor.
    at useStore (context.js:25)
    at Content (Content.tsx? [sm]:22)
```

My understanding is that Zustand works out of the box with multiple renderers. Am I missing something?

Thank you!",,
1045382275,638,Persist Middleware Typescript Error,"Hello,

I am getting this error bellow when setting my typescript tsconfig strict mode to `true`.

`Argument of type '(set: SetState<{ session: SessionData; user: UserData | null; }>, get: GetState<{ session: SessionData; user: UserData | null; }>, api: StoreApi<...> & { ...; }) => { ...; }' is not assignable to parameter of type 'StoreApi<{ session: SessionData; user: UserData | null; }> | StateCreator<{ session: SessionData; user: UserData | null; }, SetState<{ session: SessionData; user: UserData | null; }>, GetState<...>, StoreApi<...>>'.
  Type '(set: SetState<{ session: SessionData; user: UserData | null; }>, get: GetState<{ session: SessionData; user: UserData | null; }>, api: StoreApi<...> & { ...; }) => { ...; }' is not assignable to type 'StateCreator<{ session: SessionData; user: UserData | null; }, SetState<{ session: SessionData; user: UserData | null; }>, GetState<{ session: SessionData; user: UserData | null; }>, StoreApi<...>>'.
    Types of parameters 'api' and 'api' are incompatible.
      Type 'StoreApi<{ session: SessionData; user: UserData | null; }>' is not assignable to type 'StoreApi<{ session: {}; user: null; }> & { persist: { setOptions: (options: Partial<PersistOptions<{ session: {}; user: null; }, Partial<{ session: {}; user: null; }>>>) => void; clearStorage: () => void; rehydrate: () => Promise<...>; hasHydrated: () => boolean; onHydrate: (fn: (state: { ...; }) => void) => void; }...'.
        Type 'StoreApi<{ session: SessionData; user: UserData | null; }>' is not assignable to type 'StoreApi<{ session: {}; user: null; }>'.
          Types of property 'setState' are incompatible.
            Type 'SetState<{ session: SessionData; user: UserData | null; }>' is not assignable to type 'SetState<{ session: {}; user: null; }>'.
              Type '{ session: SessionData; user: UserData | null; }' is not assignable to type '{ session: {}; user: null; }'.ts(2345)`

I have created a minimum repo [here](https://codesandbox.io/s/typescript-forked-xijc8?file=/src/index.ts).

Thank you in advance.",,
1043066618,632,[TypeScript] v3.6.3 multiple middlewares breaks type check on stores with objects,"As per the test example here: https://github.com/pmndrs/zustand/blob/9f47fdc9276c96db99b70ee763e3990b2ec533a7/tests/middlewareTypes.test.tsx#L440-L476

If one of the items stored is an object, type checking reports an error. (Sorry this must be the 5th question/issue about TS being a pain!)

**Minimal example:**

```typescript
type ObjectState = {
  count: 0,
  obj: {
    prop: string;
  };
  inc: () => void;
};

const useStore = create<
  ObjectState,
  SetState<ObjectState>,
  GetState<ObjectState>,
  StoreApiWithSubscribeWithSelector<ObjectState> & StoreApiWithPersist<ObjectState>
>(
  subscribeWithSelector(
    persist(
      (set, get) => ({
        count: 0,
        inc: () => set({ count: get().count + 1 }, false),
      }),
      { name: ""count"" }
    )
  ),
  { name: ""prefix"" }
);
```",,
1042993679,631,[Question] [Typescript] StoreApiWithPersist with union type trying to update to 3.6.3,"I'm attempting to update some code to 3.6.3 (from 3.6).

Some state properties I have are union types:  `number | null`.
Using the test case as an example, I cannot get this to validate, any advice on how to get this compiling?

```ts
type CounterState = {
    count: number | null;
};

const useStore = create<
   CounterState, 
   SetState<CounterState>, 
   GetState<CounterState>, 
   StoreApiWithPersist<CounterState>>(
    persist(
        (set, get) => ({
            count: 1,
        }),
        { name: 'prefix' },
    ),
);
```

The error received on persist:

Argument of type '(set: SetState<CounterState>, get: GetState<CounterState>, api: StoreApiWithPersist<{ count: number; inc: () => void; }>) => { ...; }' is not assignable to parameter of type 'StoreApiWithPersist<CounterState> | StateCreator<CounterState, SetState<CounterState>, GetState<CounterState>, StoreApiWithPersist<...>>'.
  Type '(set: SetState<CounterState>, get: GetState<CounterState>, api: StoreApiWithPersist<{ count: number; inc: () => void; }>) => { ...; }' is not assignable to type 'StateCreator<CounterState, SetState<CounterState>, GetState<CounterState>, StoreApiWithPersist<CounterState>>'.
    Types of parameters 'api' and 'api' are incompatible.
      Type 'StoreApiWithPersist<CounterState>' is not assignable to type 'StoreApiWithPersist<{ count: number; inc: () => void; }>'.
        Type 'StoreApiWithPersist<CounterState>' is not assignable to type 'StoreApi<{ count: number; inc: () => void; }>'.
          Types of property 'setState' are incompatible.
            Type 'SetState<CounterState>' is not assignable to type 'SetState<{ count: number; inc: () => void; }>'.
              Type 'number | null' is not assignable to type 'number'.
                Type 'null' is not assignable to type 'number'.ts(2345)


Changing  `StoreApiWithPersist<CounterState>`  to `StoreApiWithPersist<any>` bypasses the warning
",,
1042326077,628,[Question] [TypeScript] Best way to decouple set() function,"Hello! I wish to be able to dispatch a function instead of using setters and getters. But how is it better to deal with its type?

```typescript
interface MyStore {
  bears: number;
  honey: number;
  dispatch: (fn: HandlerFn | Partial<MyStore>) => void;
}

// Expected dispatch handler type to be something like:
type HandlerFn = (state: MyStore) => Partial<MyStore>;

export const useStore = create<MyStore>((set) => ({
  bears: 1,
  honey: 3,
  dispatch: (fn: HandlerFn | Partial<MyStore>) => set(fn)
}));

export const incBears = (state: MyStore) => ({
  bears: state.bears + 1,
  honey: state.honey + 3
});

export const incJustHoney = (state: MyStore) => ({
  honey: state.honey + 1
});

export const lotsOfBears = { bears: 999 };
```
example usage `<button onClick={() => dispatch(incBears)}>` . 

I expect my handler type to be as `HandlerFn` to return `Partial` store (or just `Partial` store in case of an object). 
However `Partial` doesn't match with the `set` interface (also I tried to compose anything nice out of zustand types)

The error is:
```
(parameter) fn: HandlerFn
Argument of type 'HandlerFn' is not assignable to parameter of type 'PartialState<MyStore, keyof MyStore, keyof MyStore, keyof MyStore, keyof MyStore>'.
  Type 'HandlerFn' is not assignable to type '(state: MyStore) => MyStore | Pick<MyStore, keyof MyStore>'.
    Type 'Partial<MyStore>' is not assignable to type 'MyStore | Pick<MyStore, keyof MyStore>'.
      Type 'Partial<MyStore>' is not assignable to type 'Pick<MyStore, keyof MyStore>'.
        Types of property 'bears' are incompatible.
          Type 'number | undefined' is not assignable to type 'number'.
            Type 'undefined' is not assignable to type 'number'.ts(2345)
```

Basically, if I just want to proxy the `set` function,  what would be the best way to annotate handler function?

I think I could have specified the handler types as for example `(state: MyStore) => Pick<MyStore, ""bears"", ""honey"">`, however, I don't always know which keys my function return


See full example here https://codesandbox.io/s/hopeful-cohen-xy33j?file=/src/store.ts

",,
1042097841,626,Issue with TypeScript and useStoreApi,"Hello !

I have an issue with typescript and the useStoreApi hook:

```
export type CustomStoreApi = StoreApi<IState> & StoreApiWithSubscribeWithSelector<IState>;

const zustandContext = createContext<IState, UseBoundStore<IState, CustomStoreApi>>();

export const StoreProvider = zustandContext.Provider;

export const useStore = zustandContext.useStore;
export const useStoreApi = zustandContext.useStoreApi;
```

When I try to use my hook `useStoreApi` even if I properly typed the type above, I have this error :

![Screenshot 2021-11-02 at 10 54 05](https://user-images.githubusercontent.com/1364225/139824940-b51382ae-9be0-47a3-965a-873796820235.png)

We can see that type is properly set

![Screenshot 2021-11-02 at 10 59 03](https://user-images.githubusercontent.com/1364225/139825750-24a136a5-ed64-4ff8-a387-60eb92ee4e9d.png)

Could you help me please ? thanks !
",,
1040790898,623,Listen change in zustand slice,"In Mobx, there is a feature that runs side effects when there are some changes on data.
```
reaction(
      () => this.token,
      async (token) => {
        token ? await authStorage.setToken(token) : await authStorage.removeToken();
      }
    );
```

I have a zustand slice like below. Is there any way to listen to a change of token then update the storage?
```
type State = {
  token: AuthToken | null;
  setToken: (token?: AuthToken) => void;
  restoreToken: (token?: AuthToken) => void;
  logout: () => void;
};

const updateStorage = async (token?: AuthToken) => {
  token ? await authStorage.setToken(token) : await authStorage.removeToken();
};

const createAuthSlice = (set: SetState<State>, get: GetState<State>) => ({
  setToken: (token?: AuthToken) => {
    if (!token) return;
    set((s) => void (s.token = token));
  },
  restoreToken: async () => {
    const token = await authStorage.getToken();
    if (!token) return;
    get().setToken(token);
  },
  logout: () => set((s) => void (s.token = null)),
});

export default createAuthSlice;
```",,
1038589956,616,subscribeWithSelector break types with Typescript,"Hello,

I have issue with the new middleware `subscribeWithSelector`

![Screenshot 2021-10-28 at 16 27 38](https://user-images.githubusercontent.com/1364225/139276590-5bc340e6-a626-4f1b-8c94-8b898c20901f.png)

I dont't understand why...

Previously I used ramda `pipe` function to combine my differents middlware in a more clean way, but the same error...

More generaly, Zustand lack of typescript examples / documentation, I'm often struggled with Type error using zustand

Could you help me ? Thanks !",,
1037895349,615,Using thunk when dispatching action,"First thank you for this amazing library, I am in love with the API syntax as I find it simple and lightweight. I am currently migrating from a context + reducer + memo approach to Zustand in my company. My codebase use a redux/flux style with the classic: reducers, selectors, action creators. I read the doc and created some slice stores with their corresponding dispatch as recommended.

I am wondering if I am doing it right though as my action creators are returning either an action (object with a type & payload) or a thunk (a function with dispatch as an argument). In order to handle the thunk I did the following:

```typescript
type Thunk = (dispatch: Dispatch) => void;
export const createSlice = (set: SetState<State>, get: GetState<State>) => ({
  isBooting: true,
  appDispatch: (action: Action | Thunk) => {
    if (typeof action === ""function"") {
      const dispatch = get().appDispatch;
      return action(dispatch);
    }
    return set((state: State) => reducer(state, action));
  }
});
``` 

An action creator:

```typescript
export const boot = () => (dispatch: Dispatch) => {
  dispatch({ type: BOOT_START });

  const cookie = Storage.restore<boolean>(COOKIE_KEY, false);
  const uuid = Storage.restore<string | null>(UUID_KEY, uuidv4());
  Storage.persist(UUID_KEY, uuid);
  client.Session.setDevice(uuid);

  dispatch({ type: BOOT_SUCCESS, payload: cookie });
};
```

Is it a problem to get `appDispatch` this way in order to handle a thunk ? Is it possible to use a middleware instead ?
I am not using the redux middleware by the way as I had trouble typing the store. I've seen people passing the `dispatch` directly to the action creator and I did it in the past but I want to be consistent with my actual codebase.
",,
1035177072,612,Use existing Hooks to populate state typescript how to,"I have hooks that provide data already, since hooks can be used only inside another hook or inside a react component, I've created a custom hook to make use of the existing hooks and get data, that data, in turn, can be used to populate state and the state is returned from that custom hook. 

I'm using state slicing and creating a store from the slice returned from the custom hook.

The state is getting updated but I don't see any changes in UI. I don't know where I'm doing wrong or is there an existing solution to achieve this ? Please help

I've put together a contrived example on code sandbox here

https://codesandbox.io/s/youthful-tdd-05z8c?file=/src/useStoreHook.ts

you can check the console for all the logs of updates

```ts
import create, {
  GetState,
  SetState,
  StateCreator,
  StoreApi,
  UseStore
} from ""zustand"";
import { devtools } from ""zustand/middleware"";
import { v4 as uuidv4 } from ""uuid"";
import { useEffect, useState } from ""react"";

export type TTodo = {
  userId: number;
  id: number | string;
  completed: boolean;
  title: string;
};

export type TState = {
  todos: TTodo[];
  addTodo: () => void;
  removeTodo: ({ id }: { id: string | number }) => void;
};

const fetchTodos = async () => {
  const todos = await (
    await fetch(""https://jsonplaceholder.typicode.com/users/1/todos"")
  ).json();
  return todos;
};

// Existing custom hook which can be used to populate store data
const useTodo = () => {
  const [todos, setTodos] = useState<any[]>([]);

  useEffect(() => {
    async function fetchData() {
      const data = await fetchTodos();
      setTodos(data);
    }
    fetchData();
  }, []);

  return todos;
};

const useCreateBaseSlice = () => {
  const todos = useTodo();

  const slice: StateCreator<TState> = (set, get) => ({
    todos: Array.isArray(todos) ? todos : [],

    addTodo() {
      const item = {
        id: uuidv4(),
        userId: Math.floor(Math.random() * (1000 - 1) + 1),
        title: ""Todo Text"",
        completed: false
      };
      console.log(`adding todo ${JSON.stringify(item, null, 2)}`);
      set((state) => {
        state.todos = [item, ...state.todos];
        console.log(get().todos);
      });
    },

    removeTodo({ id }) {
      set((state) => {
        const excludedTodos = state.todos.filter((todo) => todo.id !== id);
        state.todos = [...excludedTodos];
      });
    }
  });

  return slice;
};

const useCreateStore = (): UseStore<TState> => {
  const baseSlice = useCreateBaseSlice();

  return create<TState>(
    devtools((set, get, api) => ({
      ...baseSlice(
        set as SetState<TState>,
        get as GetState<TState>,
        api as StoreApi<TState>
      )
    }))
  );
};

export default useCreateStore;

```


",,
1034734415,611,set function typescript type to have third parameter,"If I'm not mistaken, the `set` function accepts a third parameter that reflects in the devtools panel when the given `set` function is called. Now in the typescript type it only has two parameters: `partial` and `replace`.

![image](https://user-images.githubusercontent.com/37542420/138645286-7fc1cc10-0cb7-4e62-bb0b-fa0356131f21.png)
",,
1034299126,609,immer as middleware and use devtools typescript,"This is a contrived example but the code works when using immer as middleware and I don't get any errors on vscode

```ts
import { Draft, produce } from 'immer';
import create, { GetState, SetState, State, StateCreator, } from 'zustand';
import { devtools } from 'zustand/middleware'
type Todo = { id: string; status: string; title: string }
type TState = { todos: Todo[], add(payload: Todo): void };

const sliceTodo = (set: SetState<TState>, get: GetState<TState>): TState => ({
   todos: [],
   add(payload) { set(state => { state.todos.push(payload) }) }
});

const immer = <T extends State>
   (config: StateCreator<T>): StateCreator<T> =>
   (set, get, api) =>
      config((partial, replace) => {
         const nextState = typeof partial === 'function'
            ? produce(partial as (state: Draft<T>) => T)
            : partial as T
         return set(nextState, replace)
      },
         get,
         api
      )

const useStore = create<TState>(immer((set, get) => ({ ...sliceTodo(set, get) })))

export default useStore
```

![image](https://user-images.githubusercontent.com/506491/138576379-e773c2ed-ad39-4189-a85d-a48ba3386ffd.png)


but when I use devtools middleware then I get errors

```ts
const useStore = create<TState>(
   devtools(
      immer((set, get) =>
         ({ ...sliceTodo(set, get) })
      ))
)
```

One thing I love about zustand is the redux devtools middleware, please someone help fix this issue, thx.


![image](https://user-images.githubusercontent.com/506491/138576265-d4b3e8f6-a54b-4a37-a970-2d5811a2551f.png)


Code with squiggly typescript errors
![image](https://user-images.githubusercontent.com/506491/138576392-2887e4b1-28a1-46be-ae63-184a6f5dee93.png)


when devtools removed it's ok
![image](https://user-images.githubusercontent.com/506491/138576286-01bfdd08-3e5c-4532-b7bf-315798f6a114.png)


extra information from vscode screenshot

![image](https://user-images.githubusercontent.com/506491/138594624-1bc56cd3-84cf-4c21-af0e-776fbd288b5f.png)

![image](https://user-images.githubusercontent.com/506491/138594652-3a6d9015-3e90-4f85-a524-e12a1d16c836.png)








",,
1033663334,607,`subscribeWithSelector` breaks Next.js SSR,"```js
const useStore = create(subscribeWithSelector(() => ...))
```

`useStore` fails to initialize on node, then can't be used in **server rendered components** (can't import uninitialized code)
 
`zustand@3.5.7`
`next@11.1.1`",,
1032899260,605,How to getState data in async function? ,"I'm firing `useStore.getState().queryUser()` that will run API query to get required data and store in `user` state, during that time i don't want the `username` to be undefined or null to be passed as return in `getToken`. So the only solution i have found for now is to use `await` in `useStore.getState().queryUser()` but `.ts` is saying `await' has no effect on the type of this expression.` so I'm trying to figure out if there is a better way? 

```tsx
const getUsername = async () => {
  await useStore.getState().queryUser()

  const { username } = useStore.getState().user

  console.log('🚀 ~ t1', username)

  return username
}

export default getUsername
```",,
1026746389,589,[Help needed] Split state with immer middleware,"Hi,

I'm trying to follow the best practices in zustand as suggested here: https://github.com/pmndrs/zustand/wiki/Splitting-the-store-into-separate-slices

But I'm not sure how to do this when using immer as a middleware.

This is what I have right now

This is my state: 
```ts
import { GetState, SetState } from 'zustand'
import { TechnologyField, TechnologyToDelete } from '@models'

export type TechnologiesState = {
  selectedTechnologies: {
    programmingLanguages: TechnologyField[]
    frameworks: TechnologyField[]
  }
  awaitingToBeProcessed: {
    programmingLanguages: number[]
    frameworks: number[]
  }
  toBeDeleted: {
    programmingLanguages: TechnologyToDelete[]
    frameworks: TechnologyToDelete[]
  }
}

export const createTechnologiesState = (
  set: SetState<TechnologiesState>,
  get: GetState<TechnologiesState>
): TechnologiesState => ({
  selectedTechnologies: {
    programmingLanguages: [],
    frameworks: [],
  },
  ...,
})
```

And then I have actions
```ts
import { SelectedTechnology, TechnologyField } from '@models'
import { TechnologyKeys } from '@modules'
import { getMaxYearsExperience } from '@utils'
import { GetState, SetState } from 'zustand'
import { TechnologiesState } from '@stores'

export type TechnologiesActions = {
  initializeTechnologies: (
    programmingLanguages: TechnologyField[],
    frameworks: TechnologyField[]
  ) => void
  addTechnology: (key: TechnologyKeys) => void
  ...
}

export const createTechnologiesActions = (
  set: SetState<TechnologiesState>,
  get: GetState<TechnologiesState>
): TechnologiesActions => ({
  addTechnology: (key: TechnologyKeys) => {
    set((draft) => {
      draft.selectedTechnologies[key].push({
        value: '',
        label: '',
        releaseYear: '',
        yearsOfExperience: '',
        warningInput: false,
      })

      return draft
    })
  },
  ...
})
```

And finally I want to create the store with these slices

```ts
import create, { GetState, SetState, State, StateCreator } from 'zustand'
import produce, { Draft } from 'immer'
import { mountStoreDevtool } from 'simple-zustand-devtools'
import {
  TechnologiesState,
  TechnologiesActions,
  createTechnologiesState,
  createTechnologiesActions,
} from '@stores'

const log =
  <T extends State>(config: StateCreator<T>): StateCreator<T> =>
  (set, get, api) =>
    config(
      (partial) => {
        console.log('State Before', get())
        set(partial)
        console.log('State After', get())
      },
      get,
      api
    )

const immer =
  <T extends State>(config: StateCreator<T>): StateCreator<T> =>
  (set, get, api) =>
    config(
      (partial, replace) => {
        const nextState =
          typeof partial === 'function'
            ? produce(partial as (state: Draft<T>) => T)
            : (partial as T)
        return set(nextState, replace)
      },
      get,
      api
    )

type UseTechnologies = TechnologiesState & TechnologiesActions

const immerConfig = (
  set: SetState<UseTechnologies>,
  get: GetState<UseTechnologies>
): UseTechnologies => ({
  ...createTechnologiesState(set, get),
  ...createTechnologiesActions(set, get),
})



export const useTechnologiesStore = create<UseTechnologies>(
  process.env.NODE_ENV === 'development' ? log(immer(immerConfig)) : immer(immerConfig)
)

if (process.env.NODE_ENV === 'development' && typeof window !== 'undefined') {
  mountStoreDevtool('TechnologiesStore', useTechnologiesStore)
}
```

However, when I try this I get this error:
![image](https://user-images.githubusercontent.com/8176422/137383246-97bec43d-c272-4d82-aa5f-9775b0437763.png)
",,
1021732181,585,zustand seems not work well with redux devtools,"As described in the [doc](https://github.com/pmndrs/zustand#redux-devtools)
```js
import { devtools } from 'zustand/middleware'

// Usage with a plain action store, it will log actions as ""setState""
const useStore = create(devtools(store))
```
But when I actually tried，`Jump` to Action did't work. 
After a little debug, I found that the bug seemed to be here. `message.state` should replace the `newState`, instead of assigning it to the `DEVTOOLS ` property.
https://github.com/pmndrs/zustand/blob/d9780c78e54f08f699a36b60727968c2c3895f0f/src/middleware.ts#L126-L132
And the above seems to be related to #560, so @Aslemammad Could you please give some suggestions？:)
",,
1020498938,583,Different behaviour of LocalStorage and AsyncStorage,"In my app, I'm using @react-native-async-storage/async-storage because I plan to support React Native.
But because React Native is not expected to be supported soon, I decided to switch back to LocalStorage
and my app stopped working. If I will add setTimeout to `state.dispatchStoreRehydrated();`, it works.
It's probably because LocalStorage is sync while AsyncStorage isn't.

```ts
onRehydrateStorage: () => (state) => {
  if (state)
    // Fix for LocalStorage. With AsyncStorage, setTimeout
    // is not required.
    setTimeout(() => {
      state.dispatchStoreRehydrated();
    }, 0);
},
```
 ",,
1012682196,579,calling set within middleware,"I'm trying to hook zustand up to our persistent database at the moment. I'm trying to create a middleware that sets up a listener to changes in our database and then makes the changes in zustand. The issue I'm running into is that these changes don't seem to actually make it into my store. Here is my middleware:

```
export const myMiddleware = (config) => (set, get, api) => {
    databaseDocument.$.subscribe((rawData) => {
      set(initialDocument)

      console.log('get within subscription', get())
    })

    return config(
      set,
      get,
      api,
    )
  }
```

I find that if I log `get()` (see above) within my subscription I see the correct thing, but if I try and access my store I don't find my data. Is this expected? What am I missing :)",,
1010573258,576,"Error: Package subpath './shallow' is not defined by ""exports""","I get the below error on a new nextjs project. The component is a copy and paste from the example in the readme. My package.json shares the same three.js dependencies. Any ideas?

``` 1 of 1 unhandled error
Server Error
Error: Package subpath './shallow' is not defined by ""exports"" in .../node_modules/zustand/package.json

This error happened while generating the page. Any console logs will be displayed in the terminal window.
Call Stack
applyExports
internal/modules/cjs/loader.js (491:9)
resolveExports
internal/modules/cjs/loader.js (507:23)
Function.Module._findPath
internal/modules/cjs/loader.js (635:31)
Function.Module._resolveFilename
internal/modules/cjs/loader.js (1007:27)
Function.mod._resolveFilename
.../node_modules/next/dist/build/webpack/require-hook.js (96:28)
Function.Module._load
internal/modules/cjs/loader.js (890:27)
Module.require
internal/modules/cjs/loader.js (1080:19)
require
internal/modules/cjs/helpers.js (72:18)
Object.<anonymous>
.../node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js (8:15)
Module._compile
internal/modules/cjs/loader.js (1176:30)",,
1010072254,573,[Help needed] Typescript - SetState,"Hi bros.

total typescript noob here.
im trying to convert one ""small"" function to typescript as a poc, but im failing too hard.
JS (working):  https://github.com/YeonV/LedFx-Frontend-v2/blob/main/src/utils/apiProxy.js
TS (noob try1): https://pastebin.com/cRXYDKTa
TS (noob try2): https://pastebin.com/sedA43Q3

resulting in a :
![image](https://user-images.githubusercontent.com/28861537/135143723-7c9db927-d5c9-4c41-bdfd-f3b96479b101.png)

im only passing zustand's `set`  from the calling components. 
sorry for this noobness

Any help would be awesome <3

Gratefully
Blade",,
1008956174,570,[Questions] [Help Wanted] Zustand + React,"Hi bros!
First of all thanks for this amazing project!!!
I created a new test-project using zustand, and it exploded into a full big project:
https://github.com/YeonV/LedFx-Frontend-v2/blob/main/src/utils/apiStore.jsx

It works super well!

Questions:

1. Do you have any recommendations for me to my code? (optimizations, best-practices,...)

> my next steps would be slicing and maybe add types?

2. is it possible to make the functions CTRL-clickable to ""jump to definition""? (without bloating the code) so one can jump from the component direcly to the set-function-definition for example.
3. Shared state between Zustand and Electron is possible? (is there an example anywhere?)

Thank you very much
Gratefully

Blade",,
1007113600,567,Can't update state using setState function,"Sorry guys in advance if this is just me being stupid. But i'm having trouble updating state when i want to pass params.

In `Comp1` when i hover mouse on it i want the state to change to true. Also i want to ensure that by doing so this will not cause the `Comp2` component to re-render. 

My understanding was that if i do like so `useStoreOnHover.setState({ onComp1: true })` it should work but it does not :( 

I have also tried with `const onComp1Set = useStoreOnHover((s) => s.onComp1Set)` but still same :( 

The only way i was able to get it working is by `const { onComp1Set } = useStoreOnHover()` but I'm trying to avoid these type of de-structuring because it also triggers re-renders to other components. 

Live example: https://codesandbox.io/s/winter-grass-qxrv8

```tsx
import create, { GetState, SetState } from ""zustand"";

type typeStoreOnHover = {
  onComp1: boolean;
  onComp1Set: (val: boolean) => void;

  onComp2: boolean;
};

export const useStoreOnHover = create<typeStoreOnHover>(
  (set: SetState<typeStoreOnHover>, get: GetState<typeStoreOnHover>) => {
    return {
      onComp1: false,
      onComp1Set: (val) => set({ onComp1: val }),

      onComp2: false
    };
  }
);

const Comp1 = () => {
  const onComp1 = useStoreOnHover.getState().onComp1;
  // const onComp1Set = useStoreOnHover((s) => s.onComp1Set);

  console.log(""Comp 1"", onComp1);
  return (
    <div
      onMouseEnter={() => {
        // onComp1Set(true);
        useStoreOnHover.setState({ onComp1: true });
      }}
    >
      Comp 1 {onComp1 ? ""True"" : ""False""}
    </div>
  );
};

const Comp2 = () => {
  const onComp2 = useStoreOnHover((s) => s.onComp2);

  console.log(""Comp 2"", onComp2);

  return <div>Comp 2 </div>;
};

export default function App() {
  return (
    <>
      <Comp1 />
      <Comp2 />
    </>
  );
}
```",,
1005684763,564,Next.js SSR  - initialZustandState removes actions from client-side state,"Actions are deleted from client side ?
I followed your example but using TS and State Slices...

Any direction on why this could happen?


`
import { useLayoutEffect } from 'react'

import create, { SetState, GetState, UseStore } from 'zustand'
import createContext from 'zustand/context'

import { devtools, redux } from 'zustand/middleware'

import createSidebarSlice, { SidebarState } from './SidebarSlice';
import createLocationSlice, { LocationState } from './LocationSlice';
import createNewsFiltersSlice, { NewsFiltersState } from './NewsFiltersSlice';

const zustandContext = createContext()
export const Provider = zustandContext.Provider
// An example of how to get types

/** @type {import('zustand/index').UseStore<typeof initialState>} */



export type Store =
    SidebarState &
    LocationState &
    NewsFiltersState

let store: UseStore<Store>;

export const useStore: UseStore<Store | any> = zustandContext.useStore

export const initializeStore = (preloadedState: any = {}) => {
    const store = (set: SetState<Store>, get: GetState<Store>) => ({
        ...createSidebarSlice(set, get),
        ...createLocationSlice(set, get),
        ...createNewsFiltersSlice(set, get, preloadedState.newsfilters),
    });
    return create<Store>(
        process.env.NODE_ENV === 'development' ? devtools(store) : store
    )
}

export function useCreateStore(initialState: any) {
    // For SSR & SSG, always use a new store.
    if (typeof window === 'undefined') {
      return () => initializeStore(initialState)
    }
  
    // For CSR, always re-use same store.
    store = store ?? initializeStore(initialState)
    // And if initialState changes, then merge states in the next render cycle.
    //
    // eslint complaining ""React Hooks must be called in the exact same order in every component render""
    // is ignorable as this code runs in same order in a given environment
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useLayoutEffect(() => {
      if (initialState && store) {
          console.info(""Store"")
        store.setState({
          ...store.getState(),
          ...initialState,
        })
      }
    }, [initialState])
  
    return () => store
  }

// const useStore = create<Store>(
//     process.env.NODE_ENV === 'development' ? devtools(store) : store
// )


export default useStore


`
",,
1000170019,562,Persisted state gets thrown away if any state is set in useEffect,"I'm having a strange bug where my persisted state is getting overridden.

I'm using Next.js, Zustand with the persist middleware, and localForage using async IndexedDB. I have default values set in my store, but when my app first runs I want to use some different default values in a `useEffect` depending on whether the user is using a mobile device or not.

According to my mental model of Zustand, what should happen is that the `useEffect` runs before or after the persisted state is loaded. If it runs before, the persisted state should get merged in with priority. If it runs after, the persisted state should be merged in with the properties in `useEffect` having priority. What I'd actually like to happen is for the `useEffect` to get run before, but it doesn't matter for the purposes of this issue.

Instead, what seems to be happening is that **all of my persisted properties get thrown away**, and I get the default values along with the values I set in the `useEffect`. This doesn't make sense to me, and it seems like a bug. My persisted properties should always stay persisted if I haven't explicitly overridden them, which in this case I haven't -- all I've overridden are some other properties.

If I comment out the `useEffect`, then it works as you would expect: the persisted state stays persisted.

Hopefully this makes sense. If you'd like to take a look at my code to get a better idea of what I'm talking about, the store is [here](https://github.com/churichard/notabase/blob/97d39f7f8780c07d5ed9f297820e9f533d0edb61/lib/store.ts) and the code that runs in the `useEffect` is [here](https://github.com/churichard/notabase/blob/97d39f7f8780c07d5ed9f297820e9f533d0edb61/components/AppLayout.tsx#L172-L177).

**Edit:**
Minimal reproducible case: https://github.com/churichard/zustand-persist-bug

Click the button to increase the number of bears (which is stored in IndexedDB). Once you refresh the page, the bears resets to 0.

Comment out the `useEffect` to see it work fine and for the number of bears persist.",,
994313829,559,"""TypeError: create is not a function"" when using with jest configured for ESM","Consider the following setup:

`package.json`:
```js
{
  ""name"": ""repro"",
  ""version"": ""1.0.0"",
  ""type"": ""module"",
  ""main"": ""index.js"",
  ""dependencies"": {
    ""jest"": ""27.1.1"",
    ""react"": ""17.0.2"",
    ""zustand"": ""3.5.10""
  }
}
```

`index.js`:
```js
import create from 'zustand'

export const useStore = create(set => ({
    foo: 0,
}))
```

`repro.test.js`:
```js
import { useStore } from "".""

test(""repro"", () => {
    console.log(useStore.getState())
});
```

Then, when running `node --experimental-vm-modules node_modules/.bin/jest` I get:

```
    TypeError: create is not a function

      3 | console.log(create)
      4 |
    > 5 | export const useStore = create(set => ({
        |                         ^
      6 |     foo: 0,
      7 | }))
      8 |

      at index.js:5:25
      at TestScheduler.scheduleTests (node_modules/@jest/core/build/TestScheduler.js:333:13)
      at runJest (node_modules/@jest/core/build/runJest.js:387:19)
      at _run10000 (node_modules/@jest/core/build/cli/index.js:408:7)

  console.log
    { default: [Function: create] }
```

It seems that the import is not picking the esm bundle?",,
990620050,555,Missing type inference when calling store.subscribe with a selector,"Type inference breaks when using `store.subscribe` with a selector.

```js
import createStore from ""zustand/vanilla"";

const store = createStore(() => ({
  hello: ""world""
}));

store.subscribe((state) => {
  // 👍 state type is inferred here
  console.log(state.hello);
});

store.subscribe(
  (state) => {
    // 💥 state type ""unknown"" here
    console.log(state.hello);
  },
  ({ hello }) => ({ hello })
);
```

Here's a [Codesandbox](https://codesandbox.io/s/thirsty-kirch-yy5mh).

Is this a known limitation?",,
986158524,551,recommend way to deep merge state inside set function,"```js
import create from 'zustand';

const useStore = create(set => ({
  test: { name: 'lili', age: 10 },
  update: () => set({ test: { age: 11 }})
})
```

the expected result state is  ` test: { name: 'lili', age: 11} `。
",,
982152045,548,[Question] is it possible to access the data outside the component with a separate store mechanism including the middleware inside?,"is it possible to access the data outside the component with a separate store mechanism including the middleware inside?
_example:_ 
```js
// useStore.js
import create from 'zustand'
import { persist, devtools } from ""zustand/middleware""

const createBearSlice = (set, get) => ({
   eatFish: () => set((prev) => ({ fishes: prev.fishes > 1 ? prev.fishes - 1 : 0}))
})


const createAuthSlice = (set, get) => ({
   token: """"
})

export const useStore = create(devtools((set, get) => ({
    ...createBearSlice(set, get),
    ...createAuthSlice(set, get)
})))

```

and then i call ```useStore``` in other file(not component), ```useStore?.getState()?.token``` the value is  ```undefined```
```js
// http.ts
import axios from 'axios';
import { useStore } from 'stores/useStore';

const store = useStore?.getState()?.token

console.log(store); // undefined


// Init Axios
const axiosInstance = axios.create();

const requestHandler = <T>(request: T): T => request;

const errorHandler = async (error: any) => return Promise.reject({ ...error });

const successHandler = (response: any): any => response.data;

// Add interceptors
axiosInstance.interceptors.request.use((request) => requestHandler(request));

axiosInstance.interceptors.response.use(
  (response) => successHandler(response),
  (error) => errorHandler(error),
);

export default axiosInstance;
```

I'am using CRA + typescript...
any input about that case?",,
982000074,547,how to use to share state across components!,"Obvious question, but I haven't got this from the docs.

State manager is to share state across components. 

in the [example code](https://github.com/pmndrs/zustand/blob/main/examples/src/App.js) and docs, `useStore` is just a global variable, and all components are in the same file.

when I put the store into a separate file and import into a couple of places

it still seems to call the update fns a little boilerplate is needed, like this. I have to first define constants for those anon funcs?

```
  const setWallet = useStore(state => state.setWallet);
  const setBalance = useStore(state => state.setBalance);
  useEffect(() => {
     // doesnt' work
    /// useStore((state) => { state.setWallet(localWallet) })

    setWallet(localWallet)
    setBalance(balance)
  }, [address, balance]);
```

the first method gives an error like:

```
./src/App.jsx
  Line 240:5:  React Hook ""useStore"" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function  react-hooks/rules-of-hooks
```

is there a quicker pattern or more concise way?
For ref I have the store defined as this

```
// Store.js
import create from 'zustand'

// state and store
const useStore = create(set => ({
    letters: [],
    wallet: null,
    balance: 0,
    name: '',
    setWallet: (wallet) => set({ wallet }),
    setBalance: (balance) => set({ balance }),
    setName: (name) => set({ name }),
}))

export default useStore
```

",,
979446174,542,How to use zustand with webpack 4?,"From recent release notes: ""Note for old bundlers like webpack 4: Unlike previous versions, the bundler will pick cjs build by default. If you need module build, it should be explicit. Free free to open an issue for questions and discussions.""

Create React App still uses Webpack 4, so my build is broken with new version. Getting this error message:

`Can't import the named export 'createContext' from non EcmaScript module (only default export is available)`

Please don't say eject.",,
976418442,541,Redux Action Creators with TypeScript,"Hi, thanks for creating and maintaining this project!

Repo: https://github.com/chrislicodes/react-state-management/tree/with-ZustandReduxDevTools

I like the idea of using action creators that I can then call in the components directly, so I created some actions:

```ts

interface FetchPokemonAction {
  type: ActionType.FETCH_POKEMON;
}

interface FetchPokemonSuccessAction {
  type: ActionType.FETCH_POKEMON_SUCCESS;
  payload: IPokemon[];
}

interface FetchPokemonErrorAction {
  type: ActionType.FETCH_POKEMON_ERROR;
  payload: string;
}

export type Action =
  | FetchPokemonAction
  | FetchPokemonSuccessAction
  | FetchPokemonErrorAction
```

A reducer:

```ts

export interface PokemonStoreData {
  pokemon: IPokemon[] | [];
  loading: boolean;
  error: string | null;
  dispatch?: (action: Action) => void; //how to type this better?
}

export const initialState = {
  pokemon: [],
  loading: false,
  error: null,
};

export const pokemonReducer = (state: PokemonStoreData, action: Action) => {
  switch (action.type) {
    case ActionType.FETCH_POKEMON:
      return {
        ...state,
        loading: true,
        error: null,
      };

    case ActionType.FETCH_POKEMON_SUCCESS:
      return {
        ...state,
        loading: false,
        error: null,
        pokemon: action.payload,
      };

    case ActionType.FETCH_POKEMON_ERROR:
      return {
        ...state,
        loading: false,
        error: action.payload,
        pokemon: [],
      };

    default:
      return state;
  }
};
```

Initialize the store:

```ts
import create from ""zustand"";
import { devtools, redux } from ""zustand/middleware"";
import { pokemonReducer, initialState } from ""./reducer"";

export const usePokemonStore = create(
  devtools(redux(pokemonReducer, initialState))
);
```
And now I could use action creators like this:

```ts
type Dispatch = (action: Action) => void; //wrong

export const fetchPokemon = async (dispatch: Dispatch, limit = 50) => {
  dispatch({
    type: ActionType.FETCH_POKEMON,
  });

  try {
    const pokemonList = await axios.get(
      `https://pokeapi.co/api/v2/pokemon?limit=${limit}`
    );

    const fetchURLs = pokemonList.data.results.map(
      (pokemon: any) => pokemon.url
    );

    const fullPokemonData: IPokemon[] = await Promise.all(
      fetchURLs.map(async (url: string) => {
        const data = await axios.get(url);
        return data.data;
      })
    );

    dispatch({
      type: ActionType.FETCH_POKEMON_SUCCESS,
      payload: fullPokemonData,
    });
  } catch (err) {
    dispatch({
      type: ActionType.FETCH_POKEMON_ERROR,
      payload: err.message,
    });
  }
};
```

But by using it this way, I have to grab the dispatch function from the store in every component and pass it to my action creators. The Redux Middleware attaches the same reference of the dispatch function to the API, so I could grab dispatch from there and pass it to my action creators, or? 

But it also seems like accessing the API using '[useStore, api] = create()' is not the right way to go anymore.

```ts
 // For backward compatibility (No TS types for this)
  useStore[Symbol.iterator] = function () {
    console.warn(
      '[useStore, api] = create() is deprecated and will be removed in v4'
    )
``` 
Is there a way to make this work better?

(I am also not sure how to type that correctly, but it seems #212 is also related to that).",,
972365783,539,Reduce type definition when using Typescript ,"Is there anyway we can avoid defining the type of create function's return value (especially functions) when using typescript to reduce the number of codes we need to write? Can zustand infer the types automatically?

<img width=""619"" alt=""截屏2021-08-17 下午2 58 15"" src=""https://user-images.githubusercontent.com/89065116/129678986-8eab8836-a4fa-4364-8858-670d59b8098c.png"">




",,
971488760,536,Persist middleware and localstorage,"I use zustand middleware persist with my store. and here's the code for the store.

```
type UserStore = {
  userData: User | null;
  setUserData: (user: User) => void;
  removeUserData: () => void;
};

export const useUserData = create<UserStore>(
  persist(
    (set) => ({
      userData: null,

      setUserData: (user: User) => {
        set(() => ({
          userData: user,
        }));
      },

      removeUserData: () => {
        set(() => ({
          userData: null,
        }));
      },
    }),
    {
      name: ""userStore"",
    }
  )
);
```

The problem is after I've logged out the current user, if i check the localStorage, the user is still persisted at the localStorage (browser). The only thing i can get rid of the current user is by `localStorage.setItem(""userStore"", JSON.stringyfy(null))`

Is there a workaround with this or am i just doing it wrong? Thanks.",,
971244823,535,zustand forms - steps needed to Garbage Collect zustand store,"I'm using zustands with a passive form generator. A summarized version looks like

```
const createFormStore = () => createStore(....);

function Form(initialState, onFieldAsync, onFormAsync) {
 const formStoreRef = useRef(createFormStore());
 ...
 useEffect(() => {
  formStoreRef.current.setForm(initialData);
  return () => {
   // destroy form
  };
 }, [intialData]);
 return (
  <form ...>
   <FormContext.Provider value={formStoreRef.current.formStore)>
   ...
   </FormContext>
  </form>
 )
}
```

It works. However, I'm not sure if the older forms were Garbage Collected. Do I have to take any steps to get it Garbage Collected (ie destroy zustand store)?
",,
970947783,534,Zustand 3.5.8 broke next.js with webpack 5.,"I'm using next.js with zustand for state management.

I'm not sure what's in the `3.5.8` version of this package. But when I upgraded from 3.5.7 to 3.5.8 every single page I have is broken in development / hot reloading mode.

I'm getting a completely unrelated error that makes it look like it's a problem with my component imports.

```
Server Error
Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.

This error happened while generating the page. Any console logs will be displayed in the terminal window.
```

^ Red herring.

Note: If I make a production build everything works as expected and there are no errors. The errors only occur when I run `next` in development / hot reloading mode with webpack 5.

After spending hours trying to fix what looked to be random new problems with circular dependencies that was introduced by upgrading zustand somehow. I made it to a component where the only thing that was wrong with it, or broke it was importing `useStore` from zustand...

At that point I realized it wasn't so much a component issue. But something introduced by Zustand.

I checked the release note of the latest version and it says:

```
#507 fix(build): Improved ESM support for most used bundlers with fallbacks for older bundlers
```

And suddenly it all makes sense. I'm no expert in bundlers, but this ""improved ESM support""  to zustand must have caused a change in how next.js handles my files, and broken not just the zustand useStore I have, but also created circular dependencies issues.

It definitely does not seem to be compatible with 3.5.7 for me.

My next.config.js file is pretty simple:

```
const withAntdLess = require('next-plugin-antd-less')
const { withPlausibleProxy } = require('next-plausible')

module.exports = withPlausibleProxy()(
  withAntdLess({
    modifyVars: { '@primary-color': '#3366ff' },
    lessVarsFilePathAppendToEndOfContent: false,
    cssLoaderOptions: {},

    webpack(config) {
      return config
    },
  })
)
```

And here is my `.babelrc`

```
module.exports = {
  presets: [['next/babel']],
  plugins: [['import', { libraryName: 'antd', style: true }]],
}
```

I'm using `""next"": ""11.1.0"",` with webpack 5 enabled.

I hope you can help figure out either what went wrong with Zustand in this patch update. Or if I need to make some changes to my project to support future versions of zustand. (I love this state management library, it's amazing!)

For now the only change I made to get it to work again was downgrading to 3.5.7",,
963893860,529,State value doesn't seem to persist for a Select element (dropdown),"Hi

I have a very simple example (in Next JS) that doesn't seem to work, where I have created a basic store:

```javascript
interface IAppState {
    team: ETeam | undefined;
    layout: ""List"" | ""Field"";
    setTeam: (t: ETeam) => void;
    setLayout: (s: ""List"" | ""Field"") => void;
}

export const useStore = create<IAppState>(persist(
    (set) => ({
        team: undefined,
        layout: ""List"",
        setTeam: (t) => set({team: t}),
        setLayout: (s) => set({layout: s}),
    }),
    {
        name: ""my-team-list"",
        getStorage: () => localStorage,
    }
))
```

Then I'm using it as follows (simplified)

```javascript
export const Main = () => {
    const { team, setTeam } = useStore(state => state);

    return {
        <h1>{team}</h1> // returns persisted state correctly

        <select value={team} onChange={(opt) => setTeam(opt => opt.target.value as ETeam)}>
            <option value={ETeam.Bulldogs}>Bulldogs</option>
            <option value={ETeam.Broncos}>Broncos</option>
            <option value={ETeam.Cowboys}>Cowboys</option>            
            // etc
        <select>
    }
}
```

In the H1 element, the value is correct - in the select it always defaults back to the first option of the select - regardless of the value in localStorage.

Have I missed something?

Appreciate any help!
",,
963182857,528,How to use zustand with react-query?,"I'm trying to use react query and zustand and I'm always getting an ""Invalid hook call. Hooks can only be called inside of the body of a function component"" error.

suppose you want to remove this context and use zustand instead:

```
const useLoginMutation = () => {
  return useMutation({
    mutationFn: login,
  });
};

export const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const login = useLoginMutation().mutateAsync

  return (
    <AuthContext.Provider
      value={{
        login
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};
```
Because AuthProvider is a component I can call hooks in it. but in a zustand store, I can't do it. This is the answer that I came up with and gives me the error mentioned earlier.

```
export const useAuthStore = create(() => ({
  login: useLoginMutation().mutateAsync,
}));
```

How should I handle this situation?",,
958104951,520,[Question] Separate state from actions,"Hi,
I'm trying to migrate from `redux` / `redux-saga` to `zustand` (which I find a lot simpler in term of all the boilerplate i can remove).
I'm trying to keep the **state** separated from the **actions** to have a similar API to what I had before in my code and tests.

For instance, I would like `set` and `get` to not know about the different action functions.
So far I created a custom hook that looks like this, using the vanilla API, and would like to know what pitfalls I should avoid or if I'm completely in the wrong by doing this.

```ts
export interface IUserState {
    user?: { username: string }
}


export const initialState = (): IUserState => ({
    user: undefined
})

export const useUserStore = function (
    initState: IUserState | undefined = undefined
) {
    const store = create<IUserState>(() => initState ?? initialState())

    const loadUser = useCallback(async () => {
        const { resp } = await Requests.get(USER_URLS.user)
        const user = resp ? convertUser(resp.user) : undefined
        if (user)
            store.setState({ user })
    }, [store])


    return { store, loadUser}
}
```

Then I can write my tests as follows (using `@testing-library/react-hooks`):

```ts
describe('Load user', () => {
    const mock: UserGET<typeof USER_URLS.user> = D.user

    it('Works as expected on success', async () => {
        const { result } = renderHook(() => useUserStore())
        jest.spyOn(Requests, 'get').mockReturnValueOnce(
            new Promise((res) => res({ resp: mock }))
        )
        await act(async () => {
            await result.current.loadUser()
        })
        expect(result.current.store.getState()).toEqual({
            ...initialState(),
            user: convertUser(D.user.user)
        })
    })
```",,
954956714,513,Set Persist API storage `name` with variable,"Hey folks, thanks for providing this great module. 🤙

I was wondering on how to set the name of the persistent storage dynamically through a variable.

Something like:

```js
export const useActiveComposition = create<ActiveCompositionState>(persist(
  (set) => ({
    activeCompositionId: null,
    setActiveCompositionId: (composition: Composition) => set({ activeCompositionId: composition ? composition.id : null })
  }),
  {
    name: `melo-active-composition-${useProject.getState().project?.id}`,
    getStorage: () => localStorage,
  }
));
```

But unfortunately, this returns undefined because the hook gets initialized at a time where the value isn't ready. 

How would I approach this problem, and access another stores data or a variable in general to provide it here in a persistent store as a name? Can I pass a variable when calling the hook?

Thanks in advance! 🙏",,
954072913,511,Inital state set proposal,"Hi. I really like zustand, but using it with next js is a big problem. Due to the fact that there is no way to set the initial state from the component itself, in 90% of cases you have to use useState.  I will give an example of how I would like what the api would look like.
```
const useCounter = create(set => ({
    incrementCounter: () => set(state => ({ count: state.count + 1 }))
}));
```
```
//nextjs page
export default Page({ data }) {
    const count = useCounter(state => state.count, { count: data.count }); //second argument provides initial state
    return <div><span>{count}</span><IncrementButton /></div>;
}

  function IncrementButton() {
    const incrementCounter = useCount(state => state.incrementCounter);
    return <button onClick={incrementCounter}>Increment</button>;
  }

  export function getServerSideProps() {
    return {
      props: {
        data: {
          count: // fetch(""https://externalapi.com"")...
        }
      }
    }
  }
```
In my opinion, the internal implementation of the hook should look like this(pseudocode)
```
function useCounter(selector, initialState) {
    ...
    for(const key in initialState){
       if(!(key in actualState) {
        setState({...actualState, [key]: initialState[key]);
       }
    }
  ...
  }
```
That is, if several hooks have an initialState, then it will be applied only from the hook that will be called first. If such a field is already in the state, then we will not change anything. Of course, you can use useEffect to achieve what you want, but I would like it to work with SSR as useState. I hope I clearly explained my idea.
P.S. I saw an example in the nextjs repository and in my opinion it cannot be used normally and I would like to have another way.",,
951331506,508,[Question] Creating slices using Typescript,"Hi

Sorry if this has been asked already. [I looked at the Wiki on how to split up my store into separate slices](https://github.com/pmndrs/zustand/wiki/Splitting-the-store-into-separate-slices), but how can I go about this using Typescript?",,
950279195,504,[Question] Combine/pipe middlewares without ramda?,"Is it possible to do something like this without ramda in typescript?

`export const createStore = pipe(devtools, log, immer, create);`

 I am using Nextjs and have been getting errors I can't figure out right now. Was just hoping there was an alternative as it is bugging me that I have to include the middlewares in each store creation.",,
949315065,501,[Question] How to get useEffect to only update on store changes when the change is from another component/own component,"Hi, I am trying to update a component in real time with data that is to be displayed into a table without refreshing the page when there are changes in the state of the store after retrieving the data once in the component. 

However, the page is constantly re-rendered instead of re-rendering when there are changes to the store

Here is my store ,

```javascript
  const baseUrl = ""http://localhost:4000/app/reservation"";

  export const useStore = create((set) => ({
  reservations: [],
  getReservations: async () => {
    const response = await axios.get(baseUrl);
    set({ reservations: await response.data });
  },
  addReservation: (reservation) => {
    set((state) => ({ reservations: [...state.reservations, reservation] }));
  },
  removeReservation: (id) => {
    set((state) => ({
      reservations: state.reservations.filter(
        (reservation) => id !== reservation._id
      ),
    }));
  },
}));
```

Here is the component where I use the store,
```javascript
  const getAllReservation = useStore((state) => state.getReservations);
  const reservations = useStore((state) => state.reservations);
  const reservationsRef = useRef(useStore.getState().reservations);

  useEffect(() => {
    getAllReservation();
    useStore.subscribe(
      (reservations) => (reservationsRef.current = reservations),
      (state) => state.reservations
    );
  }, [reservations, getAllReservation]);
```

I have another component, different from the one above which calls `addReservation` from the store.

I have tried the code below but it does not re-render the page on changes but constantly re-renders the page
``` javascript
useEffect(() => {
    getAllReservation();
  }, [reservations, getAllReservation]);
```

I have tried the code below but it requires me to refresh the page in order to show the updated changes. when i call `addReservation`
```
  useEffect(() => {
    getAllReservation();
  }, []);
```

Thank you for your help.
",,
948938098,500,Zustand updates the wrong object,"Hi,
i have a store that looks like this:

```
export const useStore = create(set => ({
    articlesToPick: null, //will be set to a list of articles 
    articlePicked: null,

  // other functions...  

    minus: () => {
        set(state => {
            const articlePicked = state.articlePicked
            if (articlePicked.Qta_Pos > 0) {
                articlePicked.Qta_Pos = articlePicked.Qta_Pos - 1
            }
            return ({ articlePicked: articlePicked })
        })
    },
    plus: () => {
        set(state => {
            const articlePicked = state.articlePicked
            articlePicked.Qta_Pos = articlePicked.Qta_Pos + 1
            return ({ articlePicked: articlePicked })
        })
    }
}))
```
The `articlesToPick `contains a list of objects, when the user selects one, `articlePicked` will be set to this object.

Now when i call the plus or minus function to change the `articlePicked`, the coresponding object in `articlesToPick` will be changed aswell.

How can I prevent this?",,
948758899,499,Add dependency on selector in useIsomorphicLayoutEffect call in index.ts?,"Hi,

I am currently working on a function that creates multiple instances of a zustand store.

So far I have come up with this piece of typescript (using zustand@3.5.7):

```typescript
type Stores<T extends State> = { [storeIndex: string]: UseStore<T> }
const multiStores = new WeakMap<StoreApi<any> | StateCreator<any, SetState<any>>, Stores<any>>()

const getOrCreateStoreHook = <T extends State>(
  storeIndex: string,
  createState: StoreApi<T> | StateCreator<T, SetState<T>>
): UseStore<T> => {
  if (!multiStores.has(createState)) multiStores.set(createState, {} as Stores<T>)
  const ms = multiStores.get(createState) as Stores<T>
  if (!ms[storeIndex]) return (ms[storeIndex] = createHook(createState))
  return ms[storeIndex]
}

export const createMultiStore = <T extends State>(createState: StoreApi<T> | StateCreator<T, SetState<T>>) => {
  function useMultiStore<U>(
    storeIndex: string,
    selector: StateSelector<{ state: string }, U>,
    equalityFn?: EqualityChecker<U> | undefined
  ): U
  function useMultiStore(storeIndex: string): T
  function useMultiStore<U>(
    storeIndex: string,
    selector?: StateSelector<{ state: string }, U>,
    equalityFn?: EqualityChecker<U> | undefined
  ) {
    const useStore = getOrCreateStoreHook(storeIndex, createState)
    return useStore(selector || (useStore.getState as any), equalityFn) as U | T
  }
  return Object.assign(useMultiStore, {
    getApi: (storeIndex: string) => (multiStores.get(createState) as Stores<T>)[storeIndex] as UseStore<T>,
  })
}
```

and I use it like this (in a contrived example):
```typescript
type CounterState = { state: { count: number }; inc(): void; dec(): void; reset(): void }

const useCounterStore = createMultiStore<CounterState>((set, get, api) => ({
  state: { count: 0 },
  inc: () => set((store) => ({ state: { count: store.state.count + 1 } })),
  dec: () => set((store) => ({ state: { count: store.state.count - 1 } })),
  reset: () => set({ state: { count: 0 } }),
}))

const MultiStore = ({ storeName }: { storeName: string }) => {
  const { state: state1, inc, dec, reset } = useCounterStore(storeName)
  return (
    <div>
      <h1>{storeName}</h1>
      <h2>Hook State: {state1.count}</h2>
      <h3>Manual getState(): {useCounterStore.getApi(storeName)?.getState().state.count}</h3>
      <button onClick={dec}>DECREASE</button>
      <button onClick={inc}>INCREASE</button>
      <button onClick={reset}>RESET</button>
    </div>
  )
}
const Tests = () => {
  const [storeName, setStoreName] = useState('store1')
  const handleStoreSwitch = () => {
    storeName === 'store1' ? setStoreName('store2') : setStoreName('store1')
  }
  return (
    <div style={{ textAlign: 'center' }}>
      <h2>Test Zustand Multi-Store</h2>
      <button onClick={handleStoreSwitch}>SWITCH STORE</button>
      <MultiStore storeName={storeName} />
    </div>
  )
}
```
Regretfully this doesn't work. When I switch between stores only the first store gets updated. 
The only way I see how to make this work is by making a small change to zustand. 

If I change the empty dependency list of the useIsomorphicLayoutEffect called in the create function inside index.ts 

```typescript
    const stateBeforeSubscriptionRef = useRef(state)
    useIsomorphicLayoutEffect(() => {

    /*...*/

    }, [])
```

to include selector

```typescript
    }, [selector])
```

then everything works for me.
So my question is, if this is a change you would consider? I don't know if this dependency screws up something else. But it does work wonders for my code. :) ",,
947946271,497,Split store into multiple files ,"Hello, thanks for Zustand, magnificient library simple and efficient for React state management.

I would like to be able to use a single store with create but split it into multiple files like combineReducers in Redux. 
Because in a big project, i may have a lot of data and functions for different components that will interact with each other in the same store. The js file will be very big and difficult to maintain.

It would be cool to be able to import data and functions (with get and set state) inside the main store from different js files.
Regards,
Getzel",,
945370141,496,Just passing `localForage`  to getStorage() in persist middleware would create issues in testing.,"I found [this suggestion](https://github.com/pmndrs/zustand/issues/394#issuecomment-846461472
) about how to use `localforage` as a custom store:

Store:
````
const useBrowsingHistory = create<State>(
  persist(
    (set, get) => ({
      list: get()?.list || [],
      create: (newItem) =>
        set(() => {
           const list = get()?.list
           return { list: [...list, newItem] }
        }),
    }),
    {
      name: ""key"",
      getStorage: () => localForage,
    }
  )
);
````
However, it'd create some issues with testing because of async/await stuff:

test:
````
describe(""useBrowsingHistory"", () => {
  it(`test create`, async () => {

    const listHook = renderHook(() =>
      useBrowsingHistory((state) => state.list)
    );
    const createHook = renderHook(() =>
      useBrowsingHistory((state) => state.create)
    );
    await act(async () => {
      await createHook.result.current(newData);
    });
    expect(listHook.result.current.length).toBe(1);

  });
}
````
It would not pass the test:

````
Error: expect(received).toBe(expected)
Expected: 1
Received: 0
````

But if I define a custom store like this, the test would pass: 

````
const customStorage = {
  getItem: async (name: string): Promise<string | null> => {
    return (await localForage.getItem(name)) || null;
  },
  setItem: async (name: string, value: string): Promise<void> => {
    await localForage.setItem(name, value);
  },
};


const useBrowsingHistory = create<State>(
  persist(
   {....},
    {
      name: ""key"",
      getStorage: () => customStorage,
    }
  )
);

````

However, I'd get this warning:

````
Persist middleware: unable to update browsingHistory, the given storage is currently unavailable
````
though it may not be as big of an issue.


",,
943798021,495,Issue exporting useStore from createContext,"I'm working on a component that has multiple child components. I'm using zustand to manage the state of the component, but since I want to keep each instance of the parent component separate, I'm using the provided React context solution.

However, contrary to the examples, I need to access my `useStore` function inside my child components that live in different files. What I did was to `export const { Provider, useStore } = createContext<State>();` from a `useStore.ts` file and set the `Provider` with the appropriate `createStore` on the parent and import `useStore` to my child components where I need to access the store.

The issue is that I get the following error when I export `useStore` this way: `Exported variable 'useStore' has or is using name 'UseStoreData' from external module "".../node_modules/zustand/context"" but cannot be named.`

Is it simple an issue because `UseStoreData` is not an exported interface? Is there a better way to approach this?

Thanks",,
942045312,493,next js example has typescript error,"[this code](https://github.com/vercel/next.js/blob/canary/examples/with-zustand/lib/store.js) guide to set type of `useStore` to `UseStore<typeof initialState>` with this hint :
  ```typescript
const zustandContext = createContext()
export const Provider = zustandContext.Provider
// An example of how to get types
/** @type {import('zustand/index').UseStore<typeof initialState>} */
export const useStore = zustandContext.useStore
```
but it's throw this error 
```
Type 'UseStoreData<object>' is missing the following properties from type 'UseStore<{ blogFirstPage: BlogFirstPage; }>': setState, getState, subscribe, destroyts(2739)
```
and this chunk of code :
```typescript
    useLayoutEffect(() => {
      if (initialState && store) {
        store.setState({
          ...store.getState(),
          ...initialState,
        })
      }
    }, [initialState])
```
throw this error :
```
This condition will always return true since this function is always defined. Did you mean to call it instead?
```
we should call store on condition 
```typescript
    useLayoutEffect(() => {
      if (initialState && store()) {
        store.setState({
          ...store.getState(),
          ...initialState,
        })
      }
    }, [initialState])
```
",,
941355660,489,How to integrate with other hooks,"Since zustand store is actually a hook,
I assume it could integrate with existing hooks easily

say if I'm using react-query(as an example) for api requests,
can I do something like below:

```js
const useStore = create(set => ({
  someAsyncAction: async () => {
    const { mutateAsync } = useMutation(...);
    await mutateAsync();
  }
}));
```

and if I want to use that hook across different store actions,
how can I do that?
the code below does not work, I know I'm not doing it right,
but it describes what I'm considering basically

```js
const useStore = create(set => {
  const { mutateAsync } = useMutation(...);

  return {
    someAsyncAction: async () => {
      await mutateAsync();

      ... other stuff
    },
    anOtherActionWithTheSameMutation: async () => {
      await mutateAsync();

      ... other stuff
    }
  }
});
```",,
939816606,485,How to dispatch actions in Components,"As I am learning zustand, I really like it. It is simple, lightweight and super fast.
So I am trying a new project and I have a question.

How can i fetch actions via UI?

This is my orderStore file
```
const orderState = create((set, get) => ({
  orders: [],
  getOrders: async (orders) => {
    try {
      set({ orders });
      return get().orders;
    } catch (error) {
      throw error?.response.data || ""An Error Occured"";
    }
  },
}));

export default orderState;
```
And I want to call this action in Component ( .tsx )
How can i do that?
If I call within useEffect it say Hooks Error.

```
const getOrders = orderState((state) => state.getOrders);
```
Please Help Me.

",,
939584560,481,createContext's useStore type are not complete?,"Seems like types of `useStore` are not really consistent with the usual `useStore` hook created by `create` function. Due to the fact there is only one call signature it doesn't infer the store's types correctly. Example below:

```ts
const {Provider, useStore} = createContext<SlideshowStore>();
const store = useStore(); // store is of `unknown` type
```

I have worked around it like this:

```ts
const {Provider, useStore, useStoreApi: getStoreApi} = createContext<SlideshowStore>();
const useSlideShow: UseStore<SlideshowStore> = Object.assign(useStore, getStoreApi());
```

Is this an oversight or was this done on purpose? If this is something that could be improved I am willing to work on this and submit a PR.",,
937873219,478,persist with sync storage,"Hi,

I'm using react-native-mmkv as a replacement to asyncstorage,

react-native-mmkv is a sync library, but when using it in the persist middlewar, it doesn't rehydrate.

This is what I had to write to get it to work
```
export const storage: StateStorage = {
  getItem: async (key: string): Promise<string | null> => {
    const reply = MMKV.getString(key)
    return Promise.resolve(reply ?? null)
  },
  setItem: async (key: string, value: string): Promise<void> => {
    MMKV.set(key, value)
    Promise.resolve()
  },
}
```

but ideally, it should work synchronously

```
export const storage: StateStorage = {
    getItem: (key: string): string | null => {
      const reply = MMKV.getString(key)
      return reply ?? null
    },
    setItem: (key: string, value: string): void => {
      MMKV.set(key, value)
    },
  }
}

```


I've read a bit about the issue here and I was wondering it https://github.com/pmndrs/zustand/pull/455 fixes the issue, or maybe I should look elsewhere for a fix ?",,
933702246,473,TypeScript having issues with inferring the type of Provider,"Here's my `store.ts` file:
```typescript
import create, { UseStore } from 'zustand';
import createContext from 'zustand/context';

export const { Provider, useStore } = createContext();
export const createStore = (): UseStore<TodosState> => // ...
```
TypeScript is reporting an error when exporting Provider: `
The inferred type of 'Provider' cannot be named without a reference to '.pnpm/@types+react@17.0.11/node_modules/@types/react'. This is likely not portable. A type annotation is necessary.` Where can I find a ""clean"" type annotation? The generated type annotations I was able to find from opening the type definition for Provider aren't very pretty.",,
932952141,472,How do Toggle using Zustand,"I have created the following store using Zustand:  

```
import create from ""zustand""

const useStore = create((set) => ({
  show: false,
  toggleShow: () => set((state) => ({ show: !state.show })),
}))
```

I assumed that this would be the correct way to toggle the value of `show`.  However, typescript is not happy -- it has a red squiggly line underneath the `show` in `!state.show` with the following error message:

```
Property 'show' does not exist on type 'object'.ts(2339)
any
```

Any idea why I am getting that error message and how I can properly set up a toggle function using Zustand?

Thanks.",,
930982103,467,Await store function from function in same store,"I would like to compose a store function using another (async) function

```js
const useContactsStore = create((set, get) => ({
  contacts: [],
  fetchContacts: async () => {
    const contacts = await Contacts.getAll();
    set({ contacts });
  },
  setupContacts: async () => {
    (...)
    const { fetchContacts, contacts } = get();
    await fetchContacts();
    console.log('contacts from other function: ', contacts);
    console.log('contacts inline: ', await Contacts.getAll());
```

In this example, the first log returns an empty array while the second succeeds and returns the request result. 

I understand `fetchContacts` doesn't seem to return a Promise.

How would you go about this? ",,
930905495,465,persist middleware deserialize typings incorrect.,"I am trying to use a custom `deserialize` function in order to avoid crashes/mismatches between runtime and typescript types. However, the typings of `persist` seem to be incorrect, as TypeScript complains that the setter function attached to the state is not returned from the `deserialize` function:

https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAYygUwIY2XAZlCI4BEAXgK4DOMqAdgCYEDcAUKJLHAN5xjJRnAVwAvtlz5i5SrQD0IYDRoAbZAHdUKBs3DR4AKjioycAFJkIVEXkJYwAWhhkpC4ACMpJsxpbaO2BRGUANHByyFQwwDAAnkIWYtZ2Dk6uWCRUCOEeTF5segZwAKKxVrb2ji5S+REAFjyeWjn6hsAQRQTNCRqMCGYCACoQANahALKhJPkAHmDUNMg0AMqUGMMQswpwALzBEAB0UdwAFOyMcMFk-UNUAHIQGAAiyGRIwGAZVJPTtHMAXNs7zhAIEpqAETmcLiMxh8Zj8-gCgWgqKDBABKJhdHrwAAKPD4FDmADVUAoSJgtgAeXq9SLcODICYYWhNXbU7jk6iRAB8nIOFHQyBWa1+VJpyBRm05YOae1FRzBpwAbrjmlRftKqCQQM4eKDTqc+RhfgaBatkApdUI0YxGPtMBCqKMNdCvgslia1qyyX9PQB5LDksG2iBYOD2x3jKYw138wVmxic9G20ODSFOyMuxb8zbJy7h52zaPLU0KT1wABkHDBZGQMAAkucU9dbsgHk8oC83vnYQd+F2aL94cCqOKNpy4AqIHImPqa-Ww1D0wXfj2yH2B4ChyOxxOp4xBOjulQBLMsKgSAoYPO058C5mi0K4AAlNA0MwKSKUxt5xdzO-us2emOGxgscergo2Nz3I8zyvCqa5wDAUCkhapz8FeEY3rCiHIWC+7WoeAjkMg6F9n+2ZIGgGCfrmC6YYWyA8mC3C8PwMAHPKcC8jWW6caBYFwDsgknmeF4kT+9GxuaHEznWDaXJBLbQe2sFmPBK72gprYwZ24lbtJerVmxnBoRBzZacpOl0ZaKEGbOcmphhUbLiZNHXlGen8bZRnga5jkutZHGojZfFgVQqAgMgvwEDAX60VGf4EDZpxSFIcDKJgszVu2xLAEQmAwDU47EqSwTmKgcBkKgWCYKo0TfCi+mZTwwA5XlvxYH4yjsZ5pzuFQOzTLwyBJXq+Q7AgVSoMAVAAOoHDiLH4jQRIksgBxiXRf6SSiOyzN0swoiNpxjVgQI0N1PWnAcPFypdYFKixZi-AADEd-HGr8nCCbtyCnuel6xW5GZupJQhvacQX6WBIRhBEkRQ3ADWeYdgVgg1aJAA

I guess the correct solution would be to have a helper type that recursively removes function properties from the state type.",,
930777106,464,Is it possible to use zustand with immer AND record patches? ,"First, thanks for this lean and quite functional state management lib, I really like it. A killer feature for me is the ability to implement undo/redo functionality and I like the the ergonomic of `immer`. 
- https://immerjs.github.io/immer/patches ? 


Here is a little snippet, that is currently not working for me - commented out `(patches, inversePatches) => `  block. 

Any suggestions of how to make `produce` records patches and work with `zustand`? 


```typescript
import produce from 'immer'
import { default as create, StateCreator } from 'zustand/vanilla'

interface Store {
  people: string[]
  addPerson: (person: string) => void
  set: (fn: (state: Store) => void) => void
}

const addPerson = (person: string) => {
  return produce((state: Store) => {
    state.people.push(person)
  })
}

const store: StateCreator<Store> = (set) => ({
  people: ['Jon Doe', 'Jane Doe'],
  set: (fn: any) => set(produce(fn)),
  addPerson: (person: string) => set(addPerson(person)),
})

const vanillaStore = create<Store>(store)
vanillaStore.getState().addPerson('me')
console.log(vanillaStore.getState().people)

// ************* with patches ************** //
// DOCS: https://immerjs.github.io/immer/patches
import { enablePatches } from 'immer'
enablePatches()
let changes: any[] = []
let inverseChanges: any[] = []

const addPersonWithPatches = (person: string) => {
  return produce(
    // {},
    (state: Store) => {
      state.people.push(person)
    }
    // (patches, inversePatches) => {
    //   changes.push(...patches)
    //   inverseChanges.push(...inversePatches)
    // }
  )
}

const storeWithPatches: StateCreator<Store> = (set) => ({
  people: ['Jon Doe', 'Jane Doe'],
  set: (fn: any) => set(produce(fn)),
  addPerson: (person: string) => set(addPersonWithPatches(person)),
})

const vanillaStoreWithPatches = create<Store>(storeWithPatches)
vanillaStoreWithPatches.getState().addPerson('me')
vanillaStoreWithPatches.getState().addPerson('you')
console.log(vanillaStoreWithPatches.getState().people)
console.log(changes)
console.log(inverseChanges)
```

Thanks and have a great weekend!",,
929782637,461,IE 11 not working with > v3.5.2,"Hey team,

Looks like the generator jazz that was removed in https://github.com/pmndrs/zustand/releases/tag/v3.5.3 and then added back in https://github.com/pmndrs/zustand/releases/tag/v3.5.4 has stopped IE11 working

I've currently got it set in my webpack config like so:
```javascript
// Zustand in IE land, need to specify that we're using the cjs and not esm
// https://github.com/pmndrs/zustand/issues/354#issuecomment-816534766
{
  resolve: {
    alias: {
      zustand: path.resolve(__dirname, ""node_modules/zustand/index.js""),
    },
  },
};
````

And this works in 3.5.2 but not for any of the later versions.

Worth mentioning that I could be missing some key detail in how I'm meant to use this library with IE11 support

Thanks ❤️ ",,
928929899,458,zustand persist with indexedDB bug,"Before explain the problem, here is library that I used to reproduce the bug.
- react@17.0.2
- react-dom@17.0.2
- idb-keyval@5.0.6
- zustand@3.5.4

And this code for creating the state
```javascript
import create from ""zustand"";
import { persist } from ""zustand/middleware"";
import { get, set } from ""idb-keyval"";

export const IDBStorage = {
  getItem: async (name) => {
    // Exit early on server
    if (typeof indexedDB === ""undefined"") {
      return null;
    }

    const value = await get(name);

    console.log(""load indexeddb called"");
    return value || null;
  },
  setItem: async (name, value) => {
    // Exit early on server
    if (typeof indexedDB === ""undefined"") {
      return;
    }
    set(name, value);
  },
};

export default create(
  persist(
    (set, get) => ({
      products: [],
      clear: () => {
        console.log(""clear called !"");
        set({
          products: [],
        });
      },
      loadProducts: async () => {
        console.log(""load called 1"");
        const response = await fetch(
          ""https://hub.dummyapis.com/products?noofRecords=10&idStarts=1001&currency=usd""
        );
        const products = await response.json();
        const current_products = get().products;

        console.log(""load called 2"", products);

        // In actual scenario, there is pagination mechanism
        // but, since I call `clear` method first, the `current_products` should be empty
        set({
          products: [...current_products, ...products],
        });
      },
    }),
    {
      name: ""app_products"",
      getStorage: () => IDBStorage,
    }
  )
);
```
and this the react component code
```jsx
import ""./App.css"";
import useAppStore from ""./store"";
import { useEffect } from ""react"";
import shallow from ""zustand/shallow"";

function App() {
  const [products, clear, loadProducts] = useAppStore(
    (state) => [state.products, state.clear, state.loadProducts],
    shallow
  );

  useEffect(() => {
    clear();
    loadProducts();
  }, [clear, loadProducts]);

  return (
    <div className=""App"">
      <header className=""App-header"">
        {products.map((product) => (
          <li key={product.id}>{product.name}</li>
        ))}
      </header>
    </div>
  );
}

export default App;
```
You can clone the project at [nothing628/react-zustand-test](https://github.com/nothing628/react-zustand-test)
First, this code just doing clear product list and then load new product list from API. So at first time running the application, zustand don't have any data to `rehydrate` and application running correctly.

But, at second time user reload the webpage, this is happen
![686090ae-1d69-43e1-bdbd-136e3832f771](https://user-images.githubusercontent.com/15797914/123218574-18ea8c80-d4f6-11eb-95b3-5a17a9bc8dc9.png)
![Screenshot from 2021-06-24 14-12-12](https://user-images.githubusercontent.com/15797914/123219170-cbbaea80-d4f6-11eb-9658-0ef45ceb1a5f.png)

I think rehydrate procedure should be called first before any method in the store called. Please help me to check if this is bug or not.

Note : Sorry if there are spelling mistakes in my writing. I hope you understand what I mean",,
928856043,457,zustand persist - actions inside nested object are undefined on rehydration,"Hi all - I use the pattern of wrapping all my actions in an 'actions' object. I wanted to use persistence for an easter egg state, but I noticed that when I would toggle the easter egg, refresh the page and try again I would get errors with the toggle being undefined.

Is this desired behavior? Moving the actions to a flat object and not in my 'actions' object solved the issue, I only did the actions object because I believe I saw it elsewhere. Are there other shortcomings of using that pattern?

```ts
interface EasterEggState {
    active: boolean;
    actions: {
        set: (value: boolean) => void;
        toggle: () => void;
    };
}

export const useEasterEgg = create<EasterEggState>(
    persist(
        (set, get) => ({
            active: false,
            actions: {
                set: (value) => set({ active: value }),
                toggle: () => set({ active: !get().active }),
            },
        }),
        {
            name: 'app.easteregg',
            version: 1,
        },
    ),
);
```

![image](https://user-images.githubusercontent.com/27971797/123206123-c15e0980-d480-11eb-96e7-377b72fdb3be.png)
",,
928191956,454,Zustand module bundling problems,"Hey, I am building private modules for an application, which are shared through workspaces.
 When using the build library in my ejected react-app i run into difficulties.
 Something with the default export of zustand's create method is not working with my rollup/create-react-app configurations.
 I have no clue if this error is produced by zustand or rollup or CRA/webpack. 
Any help is appreciated.

The error:

![image](https://user-images.githubusercontent.com/15143394/123092908-46b6cf00-d42b-11eb-89a6-962766df3005.png)

The typescript source file which must be bundled (lib/src/stores.ts):

```typescript
import { KitaModel } from ""../utils/apiModels"";
import create from ""zustand"";

export class Kita {...}
export interface KitaStore {...}
export const useKitaStore = create<KitaStore>((set) => ({...}));
```

The resulting type declarations (lib/dist/stores.d.ts):

```typescript
import { KitaModel } from ""../utils/apiModels"";

export declare class Kita {...}
export interface KitaStore {...}
export declare const useKitaStore: import(""zustand"").UseStore<KitaStore>;
```

The rollup config (lib/rollup.config.js):

```typescript
import pkg from './package.json';
import resolve from '@rollup/plugin-node-resolve';
import { terser } from 'rollup-plugin-terser';
import typescript from 'rollup-plugin-typescript2';

export default {
	preserveSymlinks: true,
	input: 'src/index.ts',
	output: [{
		format: 'esm',
		file: pkg.module,
		sourcemap: false,
	}, {
		format: 'cjs',
		file: pkg.main,
		sourcemap: false,
	},
	{
		name: pkg['umd:name'] || pkg.name,
		format: 'umd',
		file: pkg.unpkg,
		sourcemap: false,
		plugins: [
			terser()
		],
	}],
	external: [
		...require('module').builtinModules,
		...Object.keys(pkg.dependencies || {}),
		...Object.keys(pkg.peerDependencies || {}),
	],
	plugins: [
		resolve(),
		typescript()
	]
}
```

The ts config (lib/tsconfig.json)

```typescript
{
  ""compilerOptions"": {
    /* Basic Options */
    ""target"": ""es6"",                                /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', 'ES2021', or 'ESNEXT'. */
    ""module"": ""es6"",                           /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */                          /* Report errors in .js files. */
    ""jsx"": ""react"",                           /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */
    ""declaration"": true,                         /* Generates corresponding '.d.ts' file. */
    ""sourceMap"": true,                           /* Generates corresponding '.map' file. */
    ""outDir"": ""./dist"",                              /* Redirect output structure to the directory. */
    ""rootDir"": ""./"",                             /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    /* Strict Type-Checking Options */
    ""strict"": true,                                 /* Enable all strict type-checking options. */
    ""noImplicitAny"": true,                       /* Raise error on expressions and declarations with an implied 'any' type. */
    ""alwaysStrict"": true,                        /* Parse in strict mode and emit ""use strict"" for each source file. */
    /* Module Resolution Options */
    ""moduleResolution"": ""node"",                  /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    ""baseUrl"": ""./"",                             /* Base directory to resolve non-absolute module names. */
    ""esModuleInterop"": true,                        /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    /* Advanced Options */
    ""skipLibCheck"": true,                           /* Skip type checking of declaration files. */
    ""forceConsistentCasingInFileNames"": true        /* Disallow inconsistently-cased references to the same file. */
  },
  ""include"": [""src/*"", ""@types/*""],
  ""exclude"": [""node_modules""]
}
```
The package.json (lib/package.json)

```typescript
{
  ""version"": ""1.0.0"",
  ""description"": ""private shared utility library"",
  ""module"": ""dist/index.mjs"",
  ""unpkg"": ""dist/index.min.js"",
  ""main"": ""dist/index.js"",
  ""types"": ""dist/index.d.ts"",
  ""files"": [
    ""dist""
  ],
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" && exit 1"",
    ""build"": ""npx rollup -c""
  },
  ""exports"": {
    ""."": {
      ""import"": ""./dist/index.mjs"",
      ""require"": ""./dist/index.js""
    },
    ""./package.json"": ""./package.json""
  },
  ""keywords"": [],
  ""license"": ""ISC"",
  ""dependencies"": {
    ""@types/node"": ""^15.12.4"",
    ""axios"": ""^0.21.1"",
    ""typescript"": ""^4.3.4"",
    ""zustand"": ""^3.5.4""
  },
  ""devDependencies"": {
    ""@rollup/plugin-node-resolve"": ""8.1.0"",
    ""rollup"": ""2.21.0"",
    ""rollup-plugin-terser"": ""6.1.0"",
    ""rollup-plugin-typescript2"": ""0.27.1""
  }
}
```

The imports/exports in my dist bundle (lib/dist/index.m.js):

````typescript
...
import create from 'zustand';
...
export { ..., useKitaStore };
```


",,
920024567,434,[v3.5.2] Type error when using devtools and persist in TypeScript,"## Test code

```tsx
import create from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface TestState {
  t1: string;
  t2: number;
  setT1: (t: string) => void;
  [key: string]: any;
}

const useTest = create<TestState>(
  devtools(
    persist(
      (set) => ({
        t1: null,
        t2: null,
        setT1: (n) => {
          set({
            t1: n,
          });
        },
      }),
      {
        name: 'zustand-state-test',
        getStorage: () => localStorage,
      },
    ),
  ),
);

export default useTest;
```

## What happens?

`zustand: 3.4.2` no type error

`zustand: 3.5.2` show some type error

persist use SetState, but devtools use NamedSet.

## Screenshot

<img width=""977"" alt=""zustand-type-error"" src=""https://user-images.githubusercontent.com/9999765/121844220-38bfca80-cd16-11eb-81e1-851258a30add.png"">


## CodeSandbox

https://codesandbox.io/s/elegant-flower-s0e9c?file=/src/App.tsx",,
912699204,414,Test improvements,"Working on #403 exposed a couple of potential improvements for the tests. I'm creating this issue to align which ones should actually be done, and how the changes should be grouped into PRs.

- [x] Reduce the usage of `any` in test files (#417)
  - Came up [here](https://github.com/pmndrs/zustand/pull/403#discussion_r642656923)
  - Would mean to add quite some type definitions to test files. Too much boilerplate? But types are nice, so I'm in favour of doing it.

- [x] Remove unnecessary mocks of `console.error` (#420)
  - Came up [here](https://github.com/pmndrs/zustand/pull/403#discussion_r642655833)
  - I guess the mocks are in for cases like [this one](https://github.com/pmndrs/zustand/blob/master/tests/persistSync.test.tsx#L146). Still can be removed where not used.

- [ ] ~~Rename [persistSync.test.tsx](https://github.com/pmndrs/zustand/blob/master/tests/persistSync.test.tsx) to `.ts` as it doesn't contain any JSX.~~

- [x] Rename [persist.test.tsx](https://github.com/pmndrs/zustand/blob/master/tests/persist.test.tsx) to `persistAsync.test.tsx` to be consistent. (#416)

- [x] Wrap tests in [persist.test.tsx](https://github.com/pmndrs/zustand/blob/master/tests/persist.test.tsx) into a `describe()` block to be consistent with [persistSync.test.tsx] (#416)(https://github.com/pmndrs/zustand/blob/master/tests/persistSync.test.tsx)
  - or should this be done with all test files?

- [x] [persist.test.tsx](https://github.com/pmndrs/zustand/blob/master/tests/persist.test.tsx): Make sure that `onRehydrateStorage` was not called with an error (#423)
  - I noticed that the tests will not fail on errors occurring during state initialisation as the error is only passed to `onRehydrateStorage`. Therefore each test needs to verify that `onRehydrateStorage` was called with `undefined`.
  - I already added this check to `persistSync.test.tsx` (see [example](https://github.com/pmndrs/zustand/blob/master/tests/persistSync.test.tsx#L129))

- [x] persist tests: Use `jest.fn()` to mock `onRehydrateStorage` instead of hand-crafting a spy (#423)
  - See [here](https://github.com/pmndrs/zustand/blob/master/tests/persistSync.test.tsx#L32) as example
  - No big deal, but my guess is that it would simplify the code, and make it more fail-safe

- [x] Add [this](https://github.com/pmndrs/zustand/blob/master/tests/persistSync.test.tsx#L145) test to the `persist.test.tsx` as well. (#430)

- [x] Add some structure to [basic.test.tsx](https://github.com/pmndrs/zustand/blob/master/tests/basic.test.tsx) (#424)
  - Right now it's 800 lines of `it()` calls 😅 
  - One way to add a bit of structure would be to have each `subscribe` and type-related tests be grouped under a separate `describe()` call within the same file.
  - ... or break up the file? Would need feedback on that one. 

 - [x] perstist*.test.tsx: Expand it('can persist state') by verifying that the persisted state is actually written to the storage (#431)
   - One of the more important scenarios, right?
 
- [x] split tests for `subscribe()` into multiple it() blocks (#427)

- [x] replace callbacks with spies for `subscribe()` tests (#429)

- [ ] ~~`persistAsync.test.tsx`: Move component `Counter` to top of file~~
  - Tried it, doesn't seem to be worth it.  Will skip.

- [x] Address inconsistency of arguments for `onRehydrateStorage` between sync and async (#437)
  - Follow-up of [this](https://github.com/pmndrs/zustand/pull/430#pullrequestreview-682429685)

- [x] Follow up on #431 (#436)
  - Implement also for async version.

- [ ] Add tests for outer `onRehydrateStorage` callback`
  - At the moment the tests only test the function returned by `onRehydrateStorage` which is called after rehydration, not the one that's called before rehydration.

I guess that all of those deserve separate PRs. So I'd just need to know which ones you want to be done, then I'd get going.",,
911348087,411,TypeScript being able to setState by key,"I have this state below with a bunch of properties. I want `setValue`  function to set a value based on a provided key there won't be a need for a bunch setState methods.

But I am getting the error below 

`
Argument of type '{ [x: string]: ValueOf<PersonStore>; }' is not assignable to parameter of type 'PartialState<SeriesFormStoreTypes, ""setValue"" | keyof State | ""setInitialState"">'.
` 

```
type ValueOf<T> = T[keyof T]

type PersonStore = {
    firstName: string
    lastName: string
    age: number
    height: number
    setValue: (key: keyof State, value: ValueOf<PersonStore>) => void
}

export const PersonFormStore = create<PersonStore>(
  (set: SetState<PersonStore>) => ({
    firstName: """",
    lastName: """",
    age 0,
    height: 0,
    setValue: (key, value) => set({ [key]: value }),
  })
```

Any idea of how I can add a function like described above and fix the type error?

> `PersonStore` needs to extend `State` and your `keyof State` should be `keyof PersonStore`:
> 
> ```ts
> type PersonStore = {
>   firstName: string;
>   lastName: string;
>   age: number;
>   height: number;
>   setValue: <K extends keyof Omit<PersonStore, ""setValue"">>(key: K, value: PersonStore[K]) => void;
> } & State;
> ```
> 
> In the above snippet, I've also omitted `setValue` from the `key` argument since you probably don't want it to be replaced.

I am sorry but the same problem still happens",,
910872117,409,Having trouble getting deserialize to work,"Sorry for the noob question, I don't know if there's a better forum for these types of issues

I'm trying to persist my accessToken to localstorage. It works great. But when reloading the page, the deserialize function doesn't seem to hydrate the store state at all.

Here's my store
```
// > auth.ts
const useAuthStore = create<AuthStoreState>(
  devtools(
    persist(
      (set) => ({
        accessToken: '',
        setAccessToken: (accessToken) => set((_state) => ({ accessToken })),
      }),
      {
        name: 'AccessToken',
        serialize: ({ state }) => JSON.stringify(state.accessToken),
        deserialize: (accessToken: string) => JSON.parse(`{ ""accessToken"": ""${accessToken}"" }`), 
        // --> logging the JSON.parse statement gives { accessToken: ""sometokenvalue"" }
      }
    )
  )
);

// > in index.jsx
const { accessToken } = useAuthStore(); // --> <empty string>
```

Any ideas what's going wrong here?
",,
902227599,400,[Feature request] What about auto-generating selectors for a store?,"Keep writing these selectors, 

```typescript
export interface IAuthStore {
  isAuth: boolean
  logout: () => Promise<void>
}

export const useAuthStore = createStore<IAuthStore>(
  set => ({
    isAuth: false,
    logout: async () => {},
  }),
)

useAuthStore.selectors =  {
  isAuth: (state: IAuthStore) => state.isAuth,
  logout: (state: IAuthStore) => state.logout,
}
```

I am wondering can we have this feature built-in?

which means, after `export const useAuthStore = createStore<IAuthStore>(......)`

We can just use it like:

```typescript
// isAuth will have a correct type
const isAuth = useAuthStore(useAuthStore.selectors.isAuth)
```

`useAuthStore.selectors` here is generated by `create` function from `zustand`

Should be a great feature :)
",,
900241876,399,set() not working after promise resolution,"Hello,

Just started using `zustand`, I ran into an issue : In the factory passed to `create`, I use promises to connect to the [MIDI api](https://www.w3.org/TR/webmidi/#midiaccess-interface), and call `set` from there. An example might speak clearer : 

```typescript
export const useMidi = create<MidiState>(set => {
  navigator.requestMIDIAccess &&
    navigator
      .requestMIDIAccess()
      .then(access => {
        const registerInputs = () => {
          set({
            inputs: [
              new KeyboardInput(),
              new ClickInput(),
              ...[...access.inputs.values()].map(input => new PortInput(input))
            ]
          });
        };
        registerInputs();
        access.onstatechange = registerInputs;
      })
      .catch(() => set({ error: true }));

  return {
    error: !navigator.requestMIDIAccess,
    inputs: []
  };
});
```

I know **for sure** thanks to some `console.log`s that the promise is successfully resolved, so `set` is called.
But when using the store : 

```typescript
export default function Inputs() {
  const { inputs } = useMidi();
  return (
    <Table>
      ...
    </Table>
```

`inputs` just never updates and is always an empty array. What am I doing wrong ?

**EDIT**: Just found the source of the bug, it had nothing to do with `zustand`. Sorry for that.",,
894214528,393,v3.3.3 broke some TS types ,"## Summary

v3.3.3 introduces a breaking change for Typescript users that use `set` with callback with multiple return statements. See repro.

Please advice how to type this properly after v3.3.3.

## Workaround

I don't know.

## Minimal Repro

```ts
import create from ""zustand/vanilla"";
import { combine } from ""zustand/middleware"";

const TestStore = create(combine({
    locked: false,
    amount: 0
  }, (set) => ({
    setAmount: (newAmount: number) => {
      // Works until 3.3.2, TS-errors on 3.3.3 and later (up to current 3.5.1). Note multiple returns.
      set(({ locked }) => {
        //^^^^^^^^^^^^^^^^^
        // Argument of type '({ locked }: { locked: boolean; amount: number; }) => { amount?: undefined; } | { amount: number; }' is not assignable to parameter of type 'PartialState<{ locked: boolean; amount: number; }, ""amount"">'.
        // Type '({ locked }: { locked: boolean; amount: number; }) => { amount?: undefined; } | { amount: number; }' is not assignable to type '(state: { locked: boolean; amount: number; }) => { locked: boolean; amount: number; } | Pick<{ locked: boolean; amount: number; }, ""amount"">'.
        //   Type '{ amount?: undefined; } | { amount: number; }' is not assignable to type '{ locked: boolean; amount: number; } | Pick<{ locked: boolean; amount: number; }, ""amount"">'.
        //     Type '{ amount?: undefined; }' is not assignable to type '{ locked: boolean; amount: number; } | Pick<{ locked: boolean; amount: number; }, ""amount"">'.
        //       Type '{ amount?: undefined; }' is not assignable to type 'Pick<{ locked: boolean; amount: number; }, ""amount"">'.
        //         Types of property 'amount' are incompatible.
        //           Type 'undefined' is not assignable to type 'number'.ts(2345)
        if (locked) return {};
        
        return {
          amount: newAmount
        };
      });
    },
    setAmountForced: (newAmount: number) => {
      // Works always. Note single return.
      set(({ locked }) => {
        return {
          amount: newAmount
        };
      });
    }
  })
));
```",,
893731704,392,"Multiple groups of checkboxes, optimize rerendering","Hello, 

i have a complex structure of checkboxes
https://monosnap.com/file/y43SLkgElIVGD00QBimnF4hZdS9nzP

group of items with select all for each group

so, for now, on select any checkbox, all existing  checkboxes are rerendered

my checkbox component

`export default function TableCheckbox({row}) {
  const SelectedItems = useStore(state => state.SelectedItems)
  const SelectedItemsChange = useStore(state => state.SelectedItemsChange)

  let checked = SelectedItems.includes(row.uuid)
  return (
      <div style={{lineHeight: '46px'}}>
        <Checkbox
            value={row.uuid}
            checked={checked}
            onChange={() => {
              SelectedItemsChange([row.uuid])
            }}
            inline
        >
          {Math.random()}
        </Checkbox>
      </div>
  )
}`

my state
`      SelectedItems: [],
      SelectedItemsChange: (uuids) => {

        let selected = get().SelectedItems;
        uuids.map((uuid) =>
            selected.indexOf(uuid) === -1 ? selected.push(uuid) : selected.splice(uuid, 1)
        );

        set(state => ({
          SelectedItems: [...selected],
        }))
      },
`

any advice, about how can i optimize it?

thanks in advance",,
872155245,374,persist middleware: Rehydrate on demand,"Looking at the code of the persist middleware, it seems that loading from storage / rehydration only happens on initialization. It would be nice if it was possible to also rehydrate on demand, eg. if you are using localStorage and you want to react to changes made to storage in another tab (like authentication, or anything really) via [`window.addEventListener(""storage"")`.](https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event)

Looking at the code, I think the best way to implement this would be as part of PersistOptions, something like `update?: (rehydrate: () => Promise<void>) => void` where `rehydrate` is naturally the [rehydration function](https://github.com/pmndrs/zustand/blob/master/src/middleware.ts#L261-L290) and the user can configure how they call it inside the listener function (by eg. adding a window event listener for the storage event).",,
864833944,370,Wrong Example on README.md,"Wrong code example on Persist middleware section.

### Current:
```javascript
import create from ""zustand""
import { persist } from ""zustand/middleware""

export const useStore = create(persist(
  (set, get) => ({
    fishes: 0,
    addAFish: () => set({ fish: get().fish + 1 })
  }),
  {
    name: ""food-storage"", // unique name
    getStorage: () => sessionStorage, // (optional) by default the 'localStorage' is used
  }
))
```
👆️  
`addAFish: () => set({ fish: get().fish + 1 })`  
Should be updated to:  
`addAFish: () => set({ fishes: get().fishes + 1 })`",,
858177561,364,Object/Array pick triggers rerenders with r3f,"Batch state picking triggers rerendering when using zustand with r3f (!):

`const { nuts, honey } = useStore(state => ({ nuts: state.nuts, honey: state.honey }))`
`const [nuts, honey] = useStore(state => [state.nuts, state.honey])`

Simple picking, works fine:

`const nuts = useStore(s => s.nuts)`
`const honey = useStore(s => s.honey )`

log appear as batch output in console:

![shot](https://user-images.githubusercontent.com/56654837/114763295-efc5b700-9d62-11eb-99f8-c8205771fed1.png)

tracked with [https://github.com/welldone-software/why-did-you-render](url)

possibly object/array state selectors ref are not handled stable and forceUpdate displays its incrementing value as shown
[https://github.com/pmndrs/zustand/blob/2adf4ee47768e90e556355b8e1168fe3281c3408/src/index.ts#L43](url)
",,
857192391,363,"[jest] Still throwing ""not wrapped in act(...)"" errors","Follow up on https://github.com/pmndrs/zustand/issues/272#issuecomment-809660791.

After updating my test runner to `jest-circus` and wrapping each `resetFn` in `act(...)` I thought I got rid of this error, but it came up again after another state update that is done inside a `useEffect` on mount. This one reads a json file from the filesystem and stores it in a zustand store:

```ts
    refreshGallery: async () => {
      const galleryData = await api.readGallery();
      set((draft) => {
        draft.gallery = galleryData;
      });
    },
```
Which basically does the following (Electron app):
```ts
  ipcHandle('readGallery', async () => {
    const dbPath = path.join(app.getPath('userData'), 'media', 'database.json');
    const db = await fs.readFile(dbPath, 'utf-8');
    const data = JSON.parse(db);
    return data;
  });
```

The (newly) failing test is 
```tsx
test('sidebar exists', () => {
  render(<App />);
  expect(screen.getByTitle('nav.camera')).toBeInTheDocument();
});
```

I've managed to fix the `wrapped in act(...)` error by basically wrapping the entire test in `async`:
```tsx
test('sidebar exists', async () => {
  await act(async () => {
    render(<App />);
  });
  expect(screen.getByTitle('nav.camera')).toBeInTheDocument();
});
```

Could this be a `zustand` issue, or is it something `jest`-related?",,
855901347,358,Deserialize option of PersistOptions has an incorrect type,"Option `deserialize` has the following definition in PersistOptions type:
`deserialize?: (str: string) => StorageValue<S> | Promise<S>;`
Because of that asynchronous version demands to return Store value itself and not the object that incapsulates state and version of the state. While code that uses this option always expects `StorageValue<S>` to be returned out of deserialize method, for both sync and async versions.
I think the type should be defined like this:
`deserialize?: (str: string) => StorageValue<S> | Promise<StorageValue<S>>;`",,
854144528,354,Syntax error on IE11 when v3.4.1 is bundled by webpack,"I have just updated from version 3.3 to 3.4 and noticed that `index.cjs.js` is missing.
`index.cjs.js` worked on IE11, but syntax error occurs version 3.4 `index.js`

Our project has to continue to support IE11..
After version 3.4, is the only way to support it to transpile `index.js` by itself?",,
845474468,347,SSR useLayoutEffect warning,"I'm using Deno and Aleph and when adding in the Zustand library, I get the following warning:

```
Warning: useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. 
This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. 
To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. 
See https://reactjs.org/link/uselayouteffect-ssr for common fixes.
```

I'm calling out to Zustand here: https://github.com/aadamsx/aleph-error3/blob/master/lib/useStore.ts

And when rendering the component I get the error here: https://github.com/aadamsx/aleph-error3/blob/master/components/People.tsx

This thread traces the problem and possible solutions: https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85

And here is where I raised the issue in Aleph: https://github.com/alephjs/aleph.js/issues/221#issuecomment-809024724

Is there any way Zustand can get around this warning for SSRs use cases?",,
844354988,345,How to persist state ,"Hi I have my store setup like this :

```
import create from 'zustand';

export const useStore = create((set) => ({
    filters: {searchQuery: 'hello', evaluationMonth : null},
    setFilters: (e) => set((state) => ({filters : {evaluationMonth : 'New Month'}}),true),
}))

```

When i call setFilters it updates evaluationMonth as expected, but it wipes out everything else (searchQuery). How do i persist the old state? I tried adding the second argument 'true', but this didnt work.",,
844309009,344,State slicing best practices,"Hi,
reading the docs, under ""Selecting multiple state slices"" I read this:

> If you want to construct a single object with multiple state-picks inside, similar to redux's mapStateToProps, you can tell zustand that you want the object to be diffed shallowly by passing an alternative equality function.

```
import shallow from 'zustand/shallow'

// Object pick, re-renders the component when either state.nuts or state.honey change
const { nuts, honey } = useStore(state => ({ nuts: state.nuts, honey: state.honey }), shallow)

// Array pick, re-renders the component when either state.nuts or state.honey change
const [nuts, honey] = useStore(state => [state.nuts, state.honey], shallow)

// Mapped picks, re-renders the component when state.treats changes in order, count or keys
const treats = useStore(state => Object.keys(state.treats), shallow)
```

> You can, but bear in mind that it will cause the component to update on every state change!

`const state = useStore()`

Could I do

`const { nuts } = useStore()`

and get just the nuts slice and have component updates only on the change of nuts and not honey?
I don't understand why in the examples you always use this syntax

`const currentBear = useCredentialsStore(state => state.currentBear)`

instead of

`const {currentBear} = useCredentialsStore()`

Am I missing something or it would have the same result?
Thank you for clarifying.

marco",,
838670208,342,Typing a store via an interface by extending `State` silently breaks when using `getState()` syntax,"Example:

Consider the following example, as described in the docs (https://github.com/pmndrs/zustand#typescript):
```tsx
type BearState = {
  bears: number;
  increase: (by: number) => void;
};

const useStore = create<BearState>((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by }))
}));
```

Calling the following line will throw a typescript error:
```ts
useStore.getState().iDoNotExist;
// Property 'iDoNotExist' does not exist on type 'BearState'.ts(2339)
```

However if using an interface, it will silently fail:
```tsx
interface BearState extends State {
  bears: number;
  increase: (by: number) => void;
}
```
and `useStore.getState().iDoNotExist` will resolve to `unknown`

Demo:
https://codesandbox.io/s/zustand-interface-856gt?file=/src/App.tsx",,
837029829,338,Update the Immer middleware Typescript example,"When updating to V9, the example shown in the docs will throw the following type error...

```
Conversion of type 'void extends ValidRecipeReturnTypePossiblyPromise<Draft<T>> ? (base: Immutable<Draft<T>>) => Draft<T> : never' to type '(state: T) => T' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.ts(2352)
```

With V9, it is possible now to pass the state generic directly to produce.

Before V9
```ts
import { State, StateCreator } from 'zustand'
import produce, { Draft } from 'immer'

const immer = <T extends State>(
  config: StateCreator<T, (fn: (draft: Draft<T>) => void) => void>
): StateCreator<T> => (set, get, api) =>
  config((fn) => set(produce(fn) as (state: T) => T), get, api)
```

After V9
```diff
import { State, StateCreator } from 'zustand'
import produce, { Draft } from 'immer'

const immer = <T extends State>(
  config: StateCreator<T, (fn: (draft: Draft<T>) => void) => void>
): StateCreator<T> => (set, get, api) =>
- config((fn) => set(produce(fn) as (state: T) => T), get, api)
+ config((fn) => set(produce<T>(fn)), get, api)
```",,
836287805,335,Is possible call useContext into useStore ?,"Hi everybody, i hope you can help me with the following question:

Recently I am using zustand in a project that handles states with ""Context"", my stores with zustand I'm saving it in separated file, for example  I have a file ""useDocuments.js"" that contains:
`
const useDocuments = create((set, get) => ({
    loading: false,
    documents: [],
    filters: {}
}));
export default useDocuments;
`
Now, I want initialize the 'filters' field with values like (userId, companyId) , but this values are stored in a ""context"", how could call useContext for fetch this values.

Thank you for your support.


",,
836128191,334,Importing in a `type=module` project fails,"First: thanks for the simplified version of state management. So glad I found it, so sad it took me so long ;).

I created a small project, where the `package.json` sets it to be a ESM project, by `type=module`.
See https://codeberg.org/wolframkriesing/bug-exploration-zustand-and-esm/src/branch/main/package.json#L4

I ran into two issues, that are somehow related to #201 but I am not sure exactly what's the root cause.

## The Problem(s)
I wanted to get zustand to be testable with mocha in an ESM setup. But I ran into:
1) When using `type=module` and importing `zustand/vanilla` mocha says
   there is no such file. No idea what that might be.
   This is the JS file and the error it throws:
   https://codeberg.org/wolframkriesing/bug-exploration-zustand-and-esm/src/branch/main/src/vanilla.test.js
2) When importing `zustand/vanilla.js` the default export is somehow broken. A change of 
   `exports.default = create;`  
   to   
   `module.exports = create;`  
   in `zustand/vanilla.js` would fix it.
   This sounds like a packager problem in zustand?
   https://codeberg.org/wolframkriesing/bug-exploration-zustand-and-esm/src/branch/main/src/vanilla-js.test.js
   
Is the ESM setup just not there yet, and not recommended? I had hoped to go there gradually.
How do others solve this issue?   ",,
834840948,332,[Question] How to have the previous state in a setter,"Imagine I'm doing this:

```js
const timelineActive = useUiStore((state) => state.timelineActive)
const setTimelineActive = useUiStore((state) => state.setTimelineActive)

const handleClickTimelineButton = () => {
    setTimelineActive(!timelineActive)
  }
```

with

```js
import create from ""zustand""

const useUiStore = create((set) => ({
  timelineActive: true,
  setTimelineActive: (value) => set(() => ({ timelineActive: value })),
}))

export default useUiStore
```

I would like to know if there's a way to do something like this:


```js
const setTimelineActive = useUiStore((state) => state.setTimelineActive)

const handleClickTimelineButton = () => {
    setTimelineActive(prevState => !prevState.timelineActive)
  }
```

Thank you!",,
834451968,331,useStore.subscribe hook does not correctly infer type from selector,"Demonstrated in this codesandbox: https://codesandbox.io/s/angry-pare-zndc9?file=/src/App.tsx:321-339

When using useStore.subscribe, the argument to the listener function is getting inferred as unknown, even though it should be using the return type from the selector function.",,
821377916,323,Browser support?,I see you're [targeting esnext](https://github.com/pmndrs/zustand/blob/master/tsconfig.json#L3); have you documented supported browsers anywhere and/or given thought to targeting es5 instead for IE11 support? Thanks!,,
817149561,317,weak type safety in setState due to usage of Partial,"reproduction: https://codesandbox.io/s/romantic-moon-xxkzd?file=/src/App.tsx

in this example, our `dec` function sets `count` to `undefined`, even though this is not allowed (it has to be a number). If we try to set it to a string, this will correctly type-error.

`setState` takes a `Partial<State>`, as defined here: https://github.com/pmndrs/zustand/blob/58c286e6cb9d6fc6dfe0142113b12aada0894ec8/src/vanilla.ts#L17-L20

but `Partial` not only lets you omit keys, it also adds lets you explicitly set every key to `undefined`, which is quite dangerous since those partial objects are then usually spread over the existing state, thus setting the value to `undefined` at runtime.

[Here](https://www.typescriptlang.org/play?#code/C4TwDgpgBAysCGxoF4oG8oGMD2BXAdkgE4BcU+uAtgEYREC+AUIzvgM7BQeIRkAK8IsACW8ADYAeODwB8UVBhwFiZAgBMIAM2H4IaqPSA) is a minimal typescript playground repro, so TS is fine with these two lines:

```
type State = { counter: number}
const state: Partial<State> = { counter: undefined }
```

`this.setState` in class-based React components does not have this problem, because they are not using `Partial`, but rather picking the keys manually:

```
setState<K extends keyof S>(
            state: ((prevState: Readonly<S>, props: Readonly<P>) => (Pick<S, K> | S | null)) | (Pick<S, K> | S | null),
```

not sure if we could tweak the types here to do something similar?",,
812572230,311,State Update when not necessary,"
```js
import create from ""zustand/vanilla"";

const useStore = create(() => ({ name: 'foo', bar: true }))
let stateUnsubscribe = useStore.subscribe(() => console.log(`state has changed`))
 
const nameUnsubscribe = useStore.subscribe(
  () => console.log(`name has changed`),
  (state) => state.name
)
const barUnsubscribe = useStore.subscribe(
  () => console.log(`bar has changed`),
  (state) => state.fur
)

useStore.setState({ name: 'foo' })
useStore.setState({ bar: true }) 

// state has changed
// state has changed
```

state callback is being called although the state values haven't **really** changed",,
806299870,304,Separating / merging state using immer middleware + TS,"I'd ideally want to use zustand with immer and TS and to be able to extract the actions from the values.
How would one combine these two patterns?
https://github.com/pmndrs/zustand/issues/211#issuecomment-710782706:
```ts
import create from 'zustand'

const createActions = (set) => ({
  setTitle: (title) => set({ title }),
  toggle: () => set(prev => ({ done: !prev.done })),
})

const useStore = create((set) => ({
  title: 'foo',
  done: false,
  ...createActions(set),
}))
```
https://github.com/pmndrs/zustand/pull/169#issuecomment-687770407:
```ts
const immer = <T extends State>(
  config: StateCreator<T, (fn: (state: T) => void) => void>
): StateCreator<T> => (set, get, api) =>
  config((fn) => set(produce(fn) as (state: T) => T), get, api);

const useStore = create<{
  bees: boolean;
  setBees: (b: boolean) => void;
}>(
  immer((set) => ({
    bees: false,
    setBees: (input) =>
      set((state) => {
        state.bees = input;
      })
  }))
);
```
",,
805522422,302,"Zombie child, yet again","There still seems to be the issue of zombie child. It requires some special criteria to reproduce:

1) The state needs to have initial value
2) The delete action, needs to be async called in regards to the event handler (Ex.: wrap the action call inside a setTimeout)
3) This is reproducible only on the elements that were present in the initial state.

Note, that the same scenario is not reproducible while using redux with hooks.

Repo to reproduce: https://github.com/ratoi-crysty/zustand-zombie-child",,
801944183,296,Devtools Bug,"Hello, when I try to import 'devtools' from 'zustand/middleware' as it is declared in docs, I receive errors.

![image](https://user-images.githubusercontent.com/63511519/107005691-26021b80-67a1-11eb-8626-6f64a67022cc.png)

![image](https://user-images.githubusercontent.com/63511519/107005720-2d292980-67a1-11eb-8133-df62e9d7ff1f.png)

My Packages:
    ""react"": ""^17.0.0"",
    ""react-dom"": ""^17.0.0"",
    ""zustand"": ""^3.3.1""",,
796780946,291,clunky combine store usage,"I've followed the recommended way to combine stores in #228. It's clunky to work with as inside the stores you have to set state as if you're setting from the root of the state, this makes everything overly verbose. I imagine in many cases sub-stores won't touch other stores state and having one root store would mainly be for simplifying co-dependent state queries outside of the stores.

Take a root store made up of sub-stores like this:
```
const useStore = create((set, get, api) => ({
  users: { ...createUsersStore(set, get, api) },
  restrictedUsers: { ...createRestrictedUsersStore(set, get, api) }
}));
```

Inside the sub-stores, it'd be intuitive to set state like this:
```
const createUsersStore = (set, get, api) => ({
  data: [],
  setUsers: users => set({data: users})
})
```

Example:
```
// expected state after calling useStore.getState().users.setUsers(['user1', 'user2']) :
{
  users: {
    data: ['user1', 'user2']
  },
  restrictedUsers: {...}
}

// instead, it looks like this:
{
  data: ['user1', 'user2'],
  users: {
    data: []
  },
  restrictedUsers: {...}
}
```

To fix this issue, you need to prepend all `set` object params with the sub-store key, and spread the current values:
```
const createUsersStore = (set, get, api) => ({
  data: [],
  setUsers: users => set({users: {...get().users, data: users}})
})
```

This feels like unnecessary ceremony. Immer could be a solution, but I like to have my async logic contained in store _actions_; Immer doesn't like async. The solution I've come to is a helper like this:
```
const _setIn = (set, get, propName) => setObjArg => set({ [propName]: { ...get()[propName], ...setObjArg } });
```

This helper can then be passed down into the stores
```
const useStore = create((set, get, api) => {
  const setIn = curry(_setIn)(set, get);
  return {
    users: { ...createUsersStore(set, get, api, setIn(""users"")) },
    restrictedUsers: {...createRestrictedUsersStore(set, get, api, setIn(""restrictedUsers""))}
  };
});
```

How setting now looks, and works intuitively:
```
const createUsersStore = (set, get, api, setIn) => ({
  data: [],
  setUsers: users => setIn({data: users})
})
```

This works well, but only supports `set(obj)`; no support for `set(state => ...)`. Is there an alternative solution (or modification to mine) that matches this, and ideally doesn't limit the api of `set`. I feel a solution to this should be documented as in real world apps it's quite common to have co-dependent stores, and having one global store simplifies the application logic for these co-dependencies (imo).

Zustand is fantastic, I want to harness the full power of it without introducing ridiculous ceremony like Redux.",,
788519393,283,Not available storage fails silently,"Hello there 👋 , 

First of all, I really really like zustand as a state management tool and I'm a big fan of it. 
I just noticed one small thing. When using the `persist` middleware to add the state to the `localStorage` or `sessionStorage` and the application doesn't allow to access it for example when used in an SSR application, the error or the fact that is not available is not notified to the user or the developer.

This means it fails silently and when you are not checking the storage yourself you might expect it being saved, but it's not. 

I think by adding some `warning` or information within the console here in the `middleware.ts` file like this could save some debugging time: 
```
try {
  storage = getStorage()
} catch (e) {
 console.warn(""You try to persist your state, but the storage is currently not available in your application"")
}
```


",,
787512113,282,How to consume specific data from store A in store B? ,"I have two stores: a userStore with user's info, and a membershipStatus store, that allows me to track the membership status of the user. 

I would like to make something like this:

```javascript
const userStore = create(() => ({
  username: ""Joe"",
  todo: [""eat"", ""sleep"", ""repeat""],
  membershipValidUntil: ""2021-01-16T17:04:22.930Z""
}));

const isPremium = (membershipValidUntil) => {
  if (!membershipValidUntil) return false;
  return new Date() < membershipValidUntil;
};
const membershipStatus = create(() => ({
  isConnected: !!userStore?.username,
  isPremium: isPremium(userStore.membershipValidUntil)
}));

export default function App() {
  const { isConnected, isPremium } = membershipStatus();
  const { username } = userStore();
  return (
    <div>
      {isConnected && <h1>Hello {username}</h1>}
      {isPremium && <h1>private space</h1>}
    </div>
  );
}
```
The membershipStatus() store is undefined. How to consume the userStore and obtain the isConnected & isPremium info?

Thanks, awesome lib!",,
781802547,277,Question about memoize selector for many components,"Hello,

```ts
type AppStore = {
  settings: Partial<GlobalStoryblok>
  page: Partial<PageStoryblok>
  drawerVariant: DrawerProps['variant']
}

export const useAppStore = create<AppStore>(() => ({
  settings: {},
  page: {},
  drawerVariant: 'temporary'
}))

// memoize the selectors for component-reuse
export const settingsSelector = (state: AppStore) => state.settings
export const pageSelector = (state: AppStore) => state.page
export const pageSettingsSelector = (state: AppStore) => ({
  settings: state.settings,
  page: state.page
})

// sample component
function Component(){
  const settings = useAppStore(settingsSelector)
}
```

Is this the recommended way of using Zustand with TypeScript? I am migrating away from `react-hooks-global-state` and several React context approaches to keep the code more clean. The selectors are re-used over many files in the codebase. Thanks for feedback!
",,
780562491,271,[Proposal] 🚀 Testing utilities for zustand,"## Background

`zustand` is an amazing package that doesn't depend on React Context providers at all. The stores live ""outside"" of React and can be accessed from everywhere, even outside of React components. 

Because of this, when testing React components via a testing library, the states of the stores don't reset across tests. That means that the code of one test may affect the outcome of another test. It also means that within a test suite (i.e. `describe` block), test order matters, since a test might modify the state of a store that another test may be depending upon.

There's currently no official way of resetting store state before/after each test. A custom solution would include manually extracting the `initialState` of a store and using it to force-set a store's state before each test run:


```js
const initialStoreState = useStore.getState();

describe('Suite', () => {
  
  beforeEach(() => {
    useStore.setState(initialStoreState, true);
  });

  ... // tests

});
```

This can quickly become tedious since:

1. You have to manually do that for each test suite/file
2. You have to do that for each and every store in your app or remember the exact stores your tests will be using

An alternative solution involves ""mocking"" zustand and automatically resetting all stores after each test by keeping track of all stores in the app. This involves creating a `__mocks__/zustand.js` file and putting the following code in there:

```jsx
import actualCreate from 'zustand';

// a variable to hold reset functions for all stores declared in the app
const storeResetFns = new Set();

// when creating a store, we get its initial state, create a reset function and add it in the set
const create = createState => {
  const store = actualCreate(createState);
  const initialState = store.getState();
  storeResetFns.add(() => store.setState(initialState, true));
  return store;
};

// Reset all stores after each test run
afterEach(() => {
  storeResetFns.forEach(resetFn => resetFn());
});
```

This has the benefits of:

1. Not having to modify your source code or tests in any shape or form
2. Not having to do anything for each new store you create

## Goal

Have an officially supported way of testing zustand, while limiting the developer's effort to achieve that

## Proposal

We create a separate package named `zustand/testing` which will contain a polished & safe version of the snippet above. From there there are 2 options:

### Option 1 - Automatic mocking

This option automatically mocks `zustand`'s default export, without the developer needing to create any mock files.

Whenever `process.env.NODE_ENV` has a value of `test` (which currently stands true for all major test runners), `zustand` will silently replace the default `create` function with a ""mocked"" version of `create` (available via `zustand/testing`) that will enable the reset functionality portrayed above.

In order to be backwards compatible & avoid any breaking changes, this can be controlled by an additional additional ENV variable named `ZUSTAND_SKIP_AUTO_RESET` which will default to `true` in the current major version and to `false` in the next one. 

### Option 2 - Manual mocking

This option requires developers to explicitly opt-in to the mocking behavior. Specifically, developers will have to import `zustand/testing` within their [setup](https://jestjs.io/docs/en/configuration#setupfilesafterenv-array) file in order to have the mocking capability enabled.

This removes the need for `process.env.NODE_ENV` and `process.env.ZUSTAND_SKIP_AUTO_RESET`, but requires an explicit opt-in.

## Related Links

https://github.com/pmndrs/zustand/issues/242

",,
778118443,268,"Zustand, Next.js, localStorage","Excuse me, in fact this is not an issue, this is a beginner's question.

I'm using Zustand with Next.js, and trying to set an initial value from localStorage in const useStore.

E.g. if exist in local storage - set it from local storage, if not - let it be integer 1.

Tried your example from Github:
```
import create from ""zustand""
import { persist } from ""zustand/middleware""

export const useStore = create(persist(
  (set, get) => ({
    fish: 0,
    addAFish: () => set({ fish: get().fish + 1 })
  }),
  {
    name: ""food-storage"", // unique name
    storage: sessionStorage, // (optional) default is 'localStorage'
  }
))
```

[Tried RobbyUitbeijerse solution](https://github.com/pmndrs/zustand/issues/245#issue-749551108).

I'm receiving an error:
```
error - ReferenceError: localStorage is not defined
(or window is not defined) in 2nd case...
at /home/nnnn/nnnn/node_modules/zustand/middleware.js:104:45
```

It's obviously SSR related and I'll be very gratefull for any hint.

Everything I need is to set above mentioned 'fish' (or bears from main example) from local storage (if such key exist in local storage) or to set some default value if such key does not exist in local storage.",754464667,"Hey, the current example on the readme doesn't work for ssr since `sessionStorage` is not defined on the server. This is discussed in #248 (I'll draft a pr soon to fix this).

> Tried RobbyUitbeijerse solution.

It works on my side. Can you share your code?"
778118443,268,"Zustand, Next.js, localStorage","Excuse me, in fact this is not an issue, this is a beginner's question.

I'm using Zustand with Next.js, and trying to set an initial value from localStorage in const useStore.

E.g. if exist in local storage - set it from local storage, if not - let it be integer 1.

Tried your example from Github:
```
import create from ""zustand""
import { persist } from ""zustand/middleware""

export const useStore = create(persist(
  (set, get) => ({
    fish: 0,
    addAFish: () => set({ fish: get().fish + 1 })
  }),
  {
    name: ""food-storage"", // unique name
    storage: sessionStorage, // (optional) default is 'localStorage'
  }
))
```

[Tried RobbyUitbeijerse solution](https://github.com/pmndrs/zustand/issues/245#issue-749551108).

I'm receiving an error:
```
error - ReferenceError: localStorage is not defined
(or window is not defined) in 2nd case...
at /home/nnnn/nnnn/node_modules/zustand/middleware.js:104:45
```

It's obviously SSR related and I'll be very gratefull for any hint.

Everything I need is to set above mentioned 'fish' (or bears from main example) from local storage (if such key exist in local storage) or to set some default value if such key does not exist in local storage.",754465362,"Closing this for now, I'll reopen if it turns out to be a bug."
776500836,267,Persist middleware api,"Follow up of https://github.com/pmndrs/zustand/pull/248#issuecomment-752130586. The idea is to make an api to interact with `persist`.

#### Change the options
```js
useMyStore.persist.setOptions({
  getStorage: () => sessionStorage,
})
```
This `setOptions` could be useful to, for example, choose a storage at runtime if the use check a box or something. It could also be used to change the name of the storage as needed here: https://github.com/pmndrs/zustand/pull/248#issuecomment-752130586

#### Clear storage data
```js
useMyStore.persist.clearStorage()
```

#### On demand rehydration (see #374)
```js
useMyStore.persist.rehydrate()
```",830024822,"So while I imagine the implementation here shouldn't be too complicated by simply extending the api along the lines of this:

```typescript
type PersistApi = {
  persist: {
    setOptions: () => void;
    clearStorage: () => void;
    rehydrate: () => Promise<void>;
  };
};

export const persist = <S extends State>(
  config: StateCreator<S>,
  options: PersistOptions<S>
) => (set: SetState<S>, get: GetState<S>, api: StoreApi<S> & PersistApi): S => {

  /* ... */

  const rehydrate = async () => { /* the existing rehydrate function */ }

  api.persist = {
    setOptions: () => { /* implementation */ },
    clearStorage: () => { /* implementation */ },
    rehydrate,
  };

  /* ... */
};
```

One issue I see here is the TypeScript story for middleware API extensions. How do we make it so that this doesn't result in red squigglies?

```typescript
type State = {
  fishes: number;
  addAFish: () => void;
}

export const useStore = create<State>(
  persist(
    (set, get) => ({
      fishes: 0,
      addAFish: () => set({ fishes: get().fishes + 1 }),
    }),
    {
      name: ""food-storage"", // unique name
      getStorage: () => sessionStorage, // (optional) by default the 'localStorage' is used
    }
  )
);

useStore.persist.clearStorage();
//       ^^^^^^^
// TypeScript Error: Property 'persist' does not exist on type 'UseStore<State>'
```

Ideally, I imagine this would have some sort of automatic typing solution where middleware can augment the return type, but this would definitely require a somewhat involved effort around the codebase to make it work. But initially zustand could just provide a quick way to make it work along the lines of this:

```diff
- export default function create<TState extends State>(
+ export default function create<TState extends State, TMiddlewareApi = {}>(
  createState: StateCreator<TState> | StoreApi<TState>
- ): UseStore<TState> { /* ... */ }
+ ): UseStore<TState> & TMiddlewareApi { /* ... */ }
```

And then you could do this:

```typescript
import { persist, PersistApi } from ""zustand/middleware"";

export const useStore = create<State, PersistApi>(/* ... */);
// useStore is now of type UseStore<State> & PersistApi

useStore.persist.clearStorage();
// no more TypeScript error here
```

Sure, having to manually type your middleware APIs like this wouldn't be ideal, but it would work and would even support multiple middleware easily (as you could just do `create<State, FooApi & BarApi & BazApi>`).

Thoughts?"
776500836,267,Persist middleware api,"Follow up of https://github.com/pmndrs/zustand/pull/248#issuecomment-752130586. The idea is to make an api to interact with `persist`.

#### Change the options
```js
useMyStore.persist.setOptions({
  getStorage: () => sessionStorage,
})
```
This `setOptions` could be useful to, for example, choose a storage at runtime if the use check a box or something. It could also be used to change the name of the storage as needed here: https://github.com/pmndrs/zustand/pull/248#issuecomment-752130586

#### Clear storage data
```js
useMyStore.persist.clearStorage()
```

#### On demand rehydration (see #374)
```js
useMyStore.persist.rehydrate()
```",830131788,"Middleware API extensions are definitely a hairy problem for typing. In which case, if there's no motivation to investigate an ""automatic"" typing solution at this time, I think it would be a good idea to move forward with the manual typing solution I proposed above where the middleware API definitions are exported and the consumer must pass them in as a second type parameter to `create`. After all, this problem ultimately doesn't really affect JS usage and if someone eventually does come up with a better type solution for TypeScript I imagine it shouldn't be a major code change for existing consumers of middleware API typings (just removal of an additional type parameter), so having the functionality available would definitely be an improvement over not having it even if the TypeScript story isn't perfect."
776500836,267,Persist middleware api,"Follow up of https://github.com/pmndrs/zustand/pull/248#issuecomment-752130586. The idea is to make an api to interact with `persist`.

#### Change the options
```js
useMyStore.persist.setOptions({
  getStorage: () => sessionStorage,
})
```
This `setOptions` could be useful to, for example, choose a storage at runtime if the use check a box or something. It could also be used to change the name of the storage as needed here: https://github.com/pmndrs/zustand/pull/248#issuecomment-752130586

#### Clear storage data
```js
useMyStore.persist.clearStorage()
```

#### On demand rehydration (see #374)
```js
useMyStore.persist.rehydrate()
```",830451699,"Would manual typing the same as type assertion, technically?

```ts
export const useStore = create<State, PersistApi>(/* ... */);
// the above is equivalent to the below
export const useStore = create<State>(/* ... */) as UseStore<State> & PersistApi;
```

I'm a bit worried because the former looks type-safe, which is not true with ""manual"" typing, and it can cause runtime error. In other words, it's just _hiding_ the type assertion in the library, which doesn't sound right.

Maybe it's like type correctness vs. developer experience. What do you think?"
776500836,267,Persist middleware api,"Follow up of https://github.com/pmndrs/zustand/pull/248#issuecomment-752130586. The idea is to make an api to interact with `persist`.

#### Change the options
```js
useMyStore.persist.setOptions({
  getStorage: () => sessionStorage,
})
```
This `setOptions` could be useful to, for example, choose a storage at runtime if the use check a box or something. It could also be used to change the name of the storage as needed here: https://github.com/pmndrs/zustand/pull/248#issuecomment-752130586

#### Clear storage data
```js
useMyStore.persist.clearStorage()
```

#### On demand rehydration (see #374)
```js
useMyStore.persist.rehydrate()
```",830576885,"You're right - the proposed approach is essentially just a type assertion. The benefit of doing it as a type parameter is that you don't need to import the UseStore type manually, but considering how you'd be importing the Middleware API types anyway it wouldn't be a big stretch to do so anyway, in which case the suggested approach might as well be ""use type assertion like this if you're using middleware with API extensions"". In which case the main thing needed to make things work would be to a) define and export middleware API types from the relevant modules and b) document the necessary type assertion for `create` in the readme."
770303684,264,persist middleware fails after two refreshes,"I'm scratching my head on this one — the persist middleware seems to work fine. I can set state properties and they follow me around the app. When I refresh, all my data is there. But when I refresh *again*, the state resets to its initial state. Any idea why this happens?",747647995,"Sure:
```tsx
import React, { ReactNode } from ""react"";
import create, { State }  from 'zustand';
import { persist } from 'zustand/middleware';
import produce from 'immer';
import { BackgroundConfig, RemoteContentPolicy } from ""~/types/local-update"";

export interface LocalState extends State {
  hideAvatars: boolean;
  hideNicknames: boolean;
  remoteContentPolicy: RemoteContentPolicy;
  dark: boolean;
  background: BackgroundConfig;
  omniboxShown: boolean;
  suspendedFocus?: HTMLElement;
  toggleOmnibox: () => void;
  set: (fn: (state: LocalState) => void) => void
};

const useLocalState = create<LocalState>(persist((set, get) => ({
  dark: false,
  background: undefined,
  hideAvatars: false,
  hideNicknames: false,
  remoteContentPolicy: {
    imageShown: true,
    audioShown: true,
    videoShown: true,
    oembedShown: true,
  },
  omniboxShown: false,
  suspendedFocus: undefined,
  toggleOmnibox: () => set(produce(state => {
    state.omniboxShown = !state.omniboxShown;
    if (state.suspendedFocus) {
      state.suspendedFocus.focus();
      state.suspendedFocus = undefined;
    } else {
      state.suspendedFocus = document.activeElement;
      state.suspendedFocus.blur();
    }
  })),
  set: fn => set(produce(fn))
}), {
  name: 'localReducer'
}));

function withLocalState<P, S extends keyof LocalState>(Component: any, stateMemberKeys?: S[]) {
  return React.forwardRef((props: Omit<P, S>, ref) => {
    const localState = stateMemberKeys ? useLocalState(
      state => stateMemberKeys.reduce(
        (object, key) => ({ ...object, [key]: state[key] }), {}
      )
    ): useLocalState();
    return <Component ref={ref} {...localState} {...props} />
  });
}

export { useLocalState as default, withLocalState };
```"
765042461,262,Intellisense-style autocomplete doesn't work for zustand/middleware,"from: https://github.com/pmndrs/zustand/pull/248#issuecomment-740303328

This is an issue to track the titled issue.
(I hope this will be resolved when TypeScript supports ""exports"" in package.json.)",889849006,"Closing this as this is not actionable now. Let's re-open it when things change.
If anyone is interested, feel free to investigate it."
765042461,262,Intellisense-style autocomplete doesn't work for zustand/middleware,"from: https://github.com/pmndrs/zustand/pull/248#issuecomment-740303328

This is an issue to track the titled issue.
(I hope this will be resolved when TypeScript supports ""exports"" in package.json.)",1646103830,"@dai-shi apologies for bumping a really old issue but I've noticed a small bug that _might_ be related and wasn't sure if I should open a new issue or if I'm doing something incorrectly.

I have an older project I wrote in JS and is just a little too tedious to port entirely to TS, and I noticed that the intellisense doesn't seem to work when `set` and `get` (or only `set`) arguments are used when creating the store.

For example:
Creating this store:
![Screenshot 2023-07-21 at 2 38 01 PM](https://github.com/pmndrs/zustand/assets/58572875/730825b1-5414-4427-8fa4-f4f6312c4c60)
Results in this intellisense:
![Screenshot 2023-07-21 at 2 37 49 PM](https://github.com/pmndrs/zustand/assets/58572875/64f39851-8763-4875-bf4d-59156b8ec88b)

But creating this store:
![Screenshot 2023-07-21 at 2 38 12 PM](https://github.com/pmndrs/zustand/assets/58572875/10ed1d13-eeec-4688-aa1c-71ef1d383b8d)
Results in no intellisense:
![Screenshot 2023-07-21 at 2 38 27 PM](https://github.com/pmndrs/zustand/assets/58572875/8199c41f-105f-43c4-8725-1ad2edb620c8)

The results are the same for each scenario when wrapping the store with the `persist` middleware.

Version:
`""zustand"": ""^4.3.9""`

Zustand is imported like so (if it's helpful to know)
```js
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
```

Any suggestions? 

Thank you for this wonderful lib! 🙏 "
765042461,262,Intellisense-style autocomplete doesn't work for zustand/middleware,"from: https://github.com/pmndrs/zustand/pull/248#issuecomment-740303328

This is an issue to track the titled issue.
(I hope this will be resolved when TypeScript supports ""exports"" in package.json.)",1646294552,"Can you please open a new discussion (not a new issue)?

I'm not sure if there's anything we can do, but let's discuss there. "
757757334,253,How do i define a set of actions in typescript?,"Lets say i have the following code in js.

    const [useStore, api] = create((set, get) => {
    return {
        actions: {
            action1() {
            },
            action2(myInteger) {
            },
            action2(myboolean) {
            },
        }
    }})

How do i define the type for the store, so that one of the types is a composite of many other actions?
",739334101,"Nevermind..

    onMouseEvents: {
        onMouseDown: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
        onMouseMove: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
        onMouseUp: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
    }

this works"
754316357,250,Accessing other store actions from action,"Quick question: is there a better way to access other stores action methods from within current store action method than calling `useOtherStore.getState().setSomething()`? Thanks

i.e.
```
export const useAppStore = create((set, get) => {
   appState: ""active"",
   setRoute: (route) => {
      // import logout action from auth store
      const logout = useAuthStore.getState().logout;
      // ...or call it directly: useAuthStore.getState().logout()
      
      // set new app state
      set({
         appState: ""inactive""
      })

      // call logout
      logout()
   }
})
```",736488001,"No, I don't think so. Or, create a combined store?"
754316357,250,Accessing other store actions from action,"Quick question: is there a better way to access other stores action methods from within current store action method than calling `useOtherStore.getState().setSomething()`? Thanks

i.e.
```
export const useAppStore = create((set, get) => {
   appState: ""active"",
   setRoute: (route) => {
      // import logout action from auth store
      const logout = useAuthStore.getState().logout;
      // ...or call it directly: useAuthStore.getState().logout()
      
      // set new app state
      set({
         appState: ""inactive""
      })

      // call logout
      logout()
   }
})
```",743960163,Closing as resolved.
746665690,244,Updating state doesn't trigger a component rerender,"👋 So I have set up a simple store, keeping track of an array of objects, and I have one action that edits just one of those objects based on an ID parameter.
```js
// Format of the list of objects
list: [
  {
    id: '123',
    // other data
  },
  // other objects
],
editItem: (id, newItem) => set(state => {
  return {
    list: state.list.map(item => {
      if (item.id == id) {
        return newItem;
      }
      return item;
    }),
  };
}),
// more actions
```

I have a component that is using this `list`, which reflects the data in just one of the objects, and so I'm using the following code to get that inside my component function:
```js
// 'id' is passed through my navigation
const items = useStore(state => state.list);
const item = items.find(i => i.id == id);
```

I'm displaying a property from my `item` in that component, but my problem occurs when I call that `editItem` action from another screen, my original component doesn't rerender. I'm sure that Zustand is updating the state correctly, because a `subscribe` listener on my `items` array gets called every time it updates.

Any help would be very appreciated; not sure if I'm just missing something or if this is an issue with Zustand.",808978364,"@onygami You need to update state immutably. Here's the fix:
https://codesandbox.io/s/inspiring-mountain-z93fi?file=/src/useTodos.ts"
743965164,242,Reset zustand state between tests,"I like how simple zustand is, however I need to be able to run tests in isolation. Currently tests will fail because the state of the previous test is affecting the next test. 

A solution would be a possibility to reset all stores to the initial state or a way to use a Provider to get a new instance of Zustand for every test.

I tried resetting modules in Jest, but that doesn't play well with testing-library. Currently I just added a reset action to my store.

Or is there a better way to test?

I'm using React, Jest and react-testing-library",755220624,"I actually found a pretty nice automatic way of performing store cleanups in a very transparent way (at least in React) without any change in your source or test code. 

I've mocked `zustand` by adding the following code in a `__mocks__/zustand.ts` file:

```ts
import actualCreate from 'zustand';

const stores = new Set<Function>();

const create: typeof actualCreate = createState => {
  const store = actualCreate(createState);
  const initialState = store.getState();
  stores.add(() => store.setState(initialState, true));

  return store;
};

afterEach(() => {
  stores.forEach(resetFn => resetFn());
});

export default create;

```

The idea is to mock the store creation in order keep a list of all the stores that have been created within the app, get their first/original state and then use it reset them in a jest `afterEach`hook (can also work with any other teardown hook of any test runner)


@dai-shi I'd be willing to clean it up a bit & make it part of `zustand` itself (as something optional), if you think that it might be helpful. Alternatively, it could also be added as part of a recipe.

"
739372466,238,store.setState() api method doesn't trigger persistance,"I'm trying to use persistance middleware in React, however I'm doing store updates from outside a react component by calling `useStore.setState({ property: value })`. This function call sets the state and appears in Redux devtools without persisting the update in `localStorage`.",724546986,"I'm not sure. We'll definitely need to modify some bits in `vanilla.ts -> create()`. An option would be to modify the store's internal api object via the middleware (same thing as `set`) and then use it in `create()`. But I'm not sure how this could be done, I'll check later in the day."
739372466,238,store.setState() api method doesn't trigger persistance,"I'm trying to use persistance middleware in React, however I'm doing store updates from outside a react component by calling `useStore.setState({ property: value })`. This function call sets the state and appears in Redux devtools without persisting the update in `localStorage`.",743753283,"@dai-shi  no, I'm using `store.setState` . This is how I define the store

```typescript
export const _accountDataStore = create(
  persist<TAccountDataStore>(
    (set, get) => ({
      accountData: get()?.accountData || null,
      setAccountData: (data) => set({accountData: data}),
      removeAccountData: () => set({accountData: null}),
    }),
    {
      name: 'sharpmenu-account', // unique name
      storage: AsyncStorage, // (optional) default is 'localStorage'
    },
  ),
);

```

I set store for temporary purpose by using `_accountDataStore.setState({accountData: {foo:'bar'}})`, and it's persist."
738210854,235,Migrating from Context (questions),"Zustand looks amazing but I need some help figuring out how to migrate from Context to Zustand in my hobby project.
I have Auth & User Provider via Context right now. How would I best switch from Context to Zustand? I'm using React Native.

```
<AuthProvider>
        <UserProvider>
              <BottomTabProvider>{children}</BottomTabProvider>
        </UserProvider>
</AuthProvider>
```

UserProvider has a useEffect for making a API request to download user object if Auth is true;

```
useEffect(() => {
    const getUser = async () => {
      try {
        const res = await axios.get(url, {
          withCredentials: true,
        });
        setUser({
          firstName: res.data.name.first,
        });
        setLoading(false);
      } catch (err) {}
    };
    if (auth) {
      getUser();
    }
  }, [auth, url]);
```",,
737305016,232,Devtools not working,"My store

```
import { devtools } from 'zustand/middleware'
const useStore = create<IState>(
  devtools(set => ({
    appConfig: {},
    filters: {
      dispatch: args => set(state => filtersReducer(state, args)),
      data: null,
      status: null,
      error: null,
    },
  }))
)

```

i get TypeError: api.devtools.subscribe is not a function

![image](https://user-images.githubusercontent.com/35596657/98302268-00078800-1fb4-11eb-8a7e-8cc21fc8d374.png)


api.devtools.subscribe

runnning  ""zustand"": ""^3.1.3""",,
733939701,226,Infinite Re render on calling a store method,"On calling a store method the component is being re rendered
'''
import React from 'react';
import useFSStore from '../hooks/useFS';

const MKDIR: React.FC<{args:string[]}> = ({ args }:{args :string[]}) => {
  const { fs, mkdir } = useFSStore();
  return (<div>..</div>);
};

MKDIR.whyDidYouRender = true;

export default MKDIR;
'''
",,
733559611,221,Update state in a function,"This should be easy, so I'm probably missing something.
I know how to update the state using the useStore hook inside a React component, but how do I update the store inside a functional component?

```
export function handleDeepLink(event) {
  const setUser = useStore((state) => state.setUser); << // Not allowed
```
",,
729869753,216,Enable NamedSet when using devtools and combine,"When using devtools with combine, combine's `set` is not of type `NamedSet` so typescript does not permit to give a third parameter to `set` function. Is there a way to work around it?

![image](https://user-images.githubusercontent.com/27731641/97222903-c95c9100-17ad-11eb-8a7b-6f743270dcaa.png)

maybe exporting interface from `middleware.ts:31`, I can force it to use.",,
726936633,213,Type error when using interface instead of type in Typescript,"Typescript is throwing error when I use interface instead of type. Take this example:

```ts
export interface DashboardSummary {
  added: number
  updated: number
  active: number
  invite: number
}

const initialState: DashboardSummary = {
  invite: 0,
  active: 0,
  added: 0,
  updated: 0,
}

const useDashboardStore = create(
  combine(initialState, set => ({ // error on `initialState`
    fetch: async () => {
      const res = await axios.get<DashboardSummary>('/api/user/dashboard')

      if (res.status === 200) {
        set(res.data) // error on `res.data`
      }
    },
  }))
)
```

On hover `initialState`, typescript says:
```
Argument of type 'DashboardSummary' is not assignable to parameter of type 'Record<string | number | symbol, unknown>'.
  Index signature is missing in type 'DashboardSummary'.ts(2345)
```

Is it possible to fix it?",,
725200127,212,Typescript version for zustand redux middleware with dispatch ,"Can you give example of your zustand and redux calling dispatch action like this link below using typescript? I believe there's a dispatch on zustand middleware don't know how to use it.

[Codesandbox link](https://codesandbox.io/s/zustand-immer-redux-f05t3?file=/src/createStore.js:131-138)",,
723511468,210,React Native fast refresh problems,"Hi !

I'm using Zustand v3 with React Native and everything works great. 
Troubles comes when I hit save and app is fast-refreshed: my store is emptied and no update is trigger anymore after that. The only way to make this work again is to reload the whole app.
This weird behavior **appears only when I hit save on my useStore file (which create store with create())**

I'm doing something like this:
```javascript
// App.js
const App = () => {
  const getLists = useStore((state) => state.getLists);
  const lists = useStore((state) => state.lists);
  useEffect(() => {
    getLists();
  }, []);
 
  console.log(lists);
  ...
}
```
the getLists method:
```javascript
  // useStore.js
  getLists: async () => {
      const lists = await getLists();
      set({ lists });
  },
```
the addList method:
```javascript
  // useStore.js
  addList: (list) => {
      const lists = [...get().lists];
      lists.push(list);
      set({ lists });
  },
```

So if I save my useStore.js, fast refresh comes in, and then if I try to add with my addList method, console.log is not called because the component is not rendered any more (but I think it should because I updated lists).
I confirm that this experiment works when I'm not using fast refresh of when I'm not saving useStore.js (console log is called so App is re-rendered).

Let me know if you need more information or a RN repo to reproduce this !

Thanks for this nice library btw 😃",,
722293123,208,store.subscribe TS error,"Hey, I know that there were two issues with this problem reported some time ago and both were closed as solved but they are not. Here is reproduction and comments explaining what's wrong:

```ts
import create from ""zustand"";

type Mode = ""FIRST"" | ""SECOND"" | ""THIRD"";

export type State = {
  mode: Mode | null;
  name: string;
};

export const useStore = create<State>(() => ({
  mode: null,
  name: ""name""
}));

useStore.subscribe(
  (mode: State[""mode""]) => {
    // When I try to provide type manually then
    // the selector function gives me an error
    console.log(mode);
  },
  (state) => state.mode
);

useStore.subscribe(
  (mode) => {
    // The `mode` variable is `unknown` here and
    // I don't get any benefit of type system
    console.log(mode);
  },
  (state) => state.mode
);

useStore.subscribe<State[""mode""]>(
  (mode) => {
    // This works but that could be done automatically.
    console.log(mode);
  },
  (state) => state.mode
);
```

Source: https://codesandbox.io/s/sad-shamir-9ezqu?file=/src/index.ts

Any plants to solve this issue?",,
710839041,200,@babel/runtime dependency while consuming Zustand with Typescript,"When importing Zustand in a typescript (node CLI) project, I'm getting this error:

```
Error: Cannot find module '@babel/runtime/regenerator'
Require stack:
- /Users/me/projects/project/node_modules/zustand/index.cjs.js
```

There seem to be an `index.js` and an `index.cjs.js`, with Typescript importing the latter. The index.cjs.js requires @babel/runtime. My Node version is 12.x and my tsconfig looks like this:
```
{
    ""compilerOptions"": {
        ""lib"": [""es2019"", ""es2020.promise"", ""es2020.bigint"", ""es2020.string""],
        ""module"": ""commonjs"",
        ""target"": ""es2019"",
        ""strict"": true,
        ""esModuleInterop"": true,
        ""skipLibCheck"": true,
        ""forceConsistentCasingInFileNames"": true,
        ""jsx"": ""react""
    }
}
```

I rather not change my tsconfig or Node version, unless there is a compelling reason. Is it correct that for my case I need to install `@babel/runtime` as a dependency? I would expect not to, since `tsc` should probably take care of everything?

Thanks!",,
700249153,191,Add example for TypeScript inferred types with Immer,"I would like to add a TypeScript example which combines `combine` and `immer` usages so that everything is typed, automatically inferred and is intended for use with `immer`. Typing is inferred in state actions as well as when using it in the components.
1. Here, `withImmer` should be the innermost `middleware` and other `middleware`s can be added on top of it such as `devools`. 
2. The 2nd parameter of `set` function (`replace`) is omitted here, since it doesn't make sense with Immer because the entire object (original/proxied) is returned.
3. It should be noted that using `shallow` in `useStore(..., shallow)` is also not needed because if the object is not modified, Immer returns the original object and strict equality `===` will hold.
4. In the current version of `immer` example, explicit type casting is used because currying is used for the `producer` syntax. I have explicitly used the original form of producer with 2 arguments so that no casting is required.

```ts
const withImmer = <PrimaryState extends State, SecondaryState extends State>(
  initialState: PrimaryState,
  createState: (
    set: (fn: (draftState: PrimaryState) => void) => void,
    get: GetState<PrimaryState>,
    api: StoreApi<PrimaryState>
  ) => SecondaryState
): StateCreator<PrimaryState & SecondaryState> =>
  (set, get, api) =>
    Object.assign(
      {},
      initialState,
      createState(
        fn => set(baseState => produce(baseState, fn)),
        get as GetState<PrimaryState>,
        api as StoreApi<PrimaryState>
      )
    );
```

Usage:
```ts
const initialState = {data: {count: 0, other: true}};
const useStore = create(withImmer(initialState, set => ({
    incBy: (by: number) => set(state => {
      state.data.count += by;
    }),
    invertOther: () => set(state => {
      state.data.other = !state.data.other;
    }),
  }))
);

const [count, incBy, invertOther] = useStore(state => [state.data.count, state.incBy, state.invertOther]);
console.log(count); // 0
incBy(10);
console.log(count); // 10
```

Please let me know your thoughts on the same.",,
698412289,187,merging state,"I'm trying to do something relatively simple - update a state object and merge the values with the existing state object.

```
export const useStore = create((set) => ({
  user: undefined,
  setUser: (user: any) => set((state) => ({ ...state.user, ...user })),
}
```
and then I do:

```
const setUser = useStore((state) => state.setUser);
const stateUser = useStore((state) => state.user);

setUser({
  id: 'xyz',
  phoneNumber: '55555555',
  emailVerified: false,
});
```

Then later on...

```
setUser({
  firstName: 'Sam',
  lastName: 'Samual',
});
```

I expect the user to be:

```
{
  id: 'xyz',
  phoneNumber: '55555555',
  emailVerified: false,
  firstName: 'Sam',
  lastName: 'Samual',
}
```

But I'm getting **undefined**.

Changing the store definition to this: 

```
export const [useStore, api] = create((set) => ({
  user: undefined,
  setUser: (user: any) => set((state) => ({ user })),
}
```

Then I get the User record, but not merged since it overrides the User in state.

What am I doing wrong?",,
695804581,183,"MyStore does not satisfy the constraint 'Record<string | number | symbol, unknown>'.","The following code runs fine on `3.0.0`:

```ts
import create from 'zustand';

type PlayState = 'playing' | 'paused' | 'stopped';

export interface PlayerStore {
  playState: PlayState;
  showOutline: boolean;
  setPlayState: (state: PlayState) => void;
}

export const usePlayerStore = create<PlayerStore>((set) => ({
  playState: 'paused',
  showOutline: false,
  setPlayState: (playState) => set(() => ({ playState })),
}));
```

But breaks on `3.1.0`, with the following error message, by tsc:

```
PlayerStore does not satisfy the constraint 'Record<string | number | symbol, unknown>'.
```",,
695391520,182,SSR Example (SSR data is shared),"I'm using Next.js and have a separate file `state.js` that has something like this:

```javascript
export const useSessionStore = create(combine({
  session: {},
}, set => ({
  setSession: (session) => set({ session }),
})))
```

And then calling `setSession()` on the server (for example in `_app.js`) after a successful login. When reading `session` on the server + client, it seems to work fine. So far so good.

The problem is: the `session` seems to be saved in Node.js memory and shared with everyone(?). When you login on one browser, the same session data is returned when you load the page on another browser. So I'm assuming when I set session on the server, it persists on Node.js side and returns the same session for all clients.

What am I doing wrong, or is zustand not meant for this?",,
694600794,180,Parent-child update order,"I'm encountering a race condition between parent and children updates using zustand. Let me describe the problem:

I have a PrivateRoute component that redirects when my zustand currentUser state is falsy:
```jsx
const PrivateRoute = ({ component: RouteComponent, ...rest }) => {
  const currentUser = useAuth((state) => state.currentUser);

  const render = useCallback(
    (routeProps) => {
      if (currentUser) {
        return <RouteComponent {...routeProps} />;
      }

      // redirect to login if current user is null
      return <Redirect to=""/login"" />;
    },
    [currentUser]
  );

  return <Route {...rest} render={render} />;
};
```

I have a route protected by this PrivateRoute component like so:
```jsx
export default function Home() {
  const currentUser = useAuth((state) => state.currentUser);
  // render something using currentUser
}
```

And then I have something like this:
```jsx
<Router>
  <PrivateRoute component={Home} />
</Router>
```

I use firebase for handling auth in my app. Zustand allows me to update the state outside a react component w/c I super love:
```jsx
auth.onAuthStateChanged(async (user) => {
  if (user) {
    useAuth.setState({ currentUser: res.data });
  } else {
    // logged out
    useAuth.setState({ currentUser: null });
  }
});
```

This works well initially. But for some reason, the second time the auth state updates (i.e. a second logout), the `Home` component updates before its parent `PrivateComponent` does:
```jsx
export default function Home() {
  const currentUser = useAuth((state) => state.currentUser);
  // this errors out because currentUser turns to null and I don't check its value because
  // I expect PrivateComponent to redirect first before getting here.
}
```

I solved this by passing `currentUser` instead from the `PrivateComponent`:
```jsx
...
  const render = useCallback(
    (routeProps) => {
      if (currentUser) {
        return <RouteComponent currentUser={currentUser} {...routeProps} />;
      }
...

export default function Home({ currentUser }) {
  // PrivateComponent redirects before anything happens here
}
```

This is fine but I'm just wondering if this behavior is expected and why it seems to happen only on the second batch of auth updates.",,
694372647,178,Namespacing / slicing application state alike Redux' combineReducers,"Hey!

I just came across this library, and am quite enthusiastic already 🥳

I've ditched Redux in the past, only to have returned to adding it back later because of a need for a common-sense global application state instance when using various somewhat-interdependent contexts didn't work out better than Redux in the first place.

One think I really dislike about Redux, is the ergonomic pain of having to differentiate between synchronous and asynchronous (or otherwise indirect) operations. This always feels like a ""fake"" or accidental technically-contrained version of a private/public layered approach. Often, the set of ordinary actions end up kind of like a private store api, and the async actions (or otherwise indirect thunks) end up like the public api.

Zustand seems to nicely eliminate this distinction from it ergonomics, retaining the same general approach but without the ""bureaucratic fuss"" let's say.

```jsx
const useStore = create((set, get, api) => {
  // set up the state layout
  const initialState = { ... };
  // some internal helpers
  const privateFn = (...) => { ... get() ... set(...) ... };
  // the public api
  const publicFn = (...) => { ... get() ... privateFn(...) ... };
  return {
    ...initialState,
    publicFn,
    ...
  };
});
```

I'm tempted to look into replacing Redux for Zustand in my (medium-scale, web & native) app, but would first need to concoct/add a few tools to be able to transition from what we have now. Up top on that list is the ability to divide the top-level state into somewhat independent ""slices"", e.g. `combineReducers` in Redux.

Here's a little attempt I made at something that would look similar, but maybe be a bit more flexible than a drop-in `combineCreators` (which was my first idea):

https://codesandbox.io/s/zustand-combinecreators-ojew5?file=/src/App.tsx

```tsx
const useStore = create((get, set, api) => {
  const counterSlice = namespace(""counter"", createCounter)(get, set,  api);
  ...
  const crossSliceOperation = (...) => { ... };

  return {
    counter: counterSlice,
    crossSliceOperation,
    ...
  };
});
```

(Also, typing all of this is not super trivial, and probably requires some overloading of `SetState` etc.)

What are your thoughts?",,
690140565,173,typing problem storeApi outside of react with immer middleware,"@kurosh-z Hey, I fixed it recently. Please check the example in #169. If it doesn't work, would you please file a new issue?

_Originally posted by @dai-shi in https://github.com/react-spring/zustand/issues/75#issuecomment-684075606_


Hi , 
 #169  actually solved the typing problem inside of react. But if you use the setState api outside of react, typescript requires you to return the state.

```typescript
// outside of react
useStore.setState((state) => {
  state.bb.b1 = true;
});
```
<img width=""761"" alt=""Screen Shot 2020-09-01 at 3 21 31 PM"" src=""https://user-images.githubusercontent.com/32224317/91856407-d609b080-ec66-11ea-8ea0-2023568b37d0.png"">



codeSandbox :

https://codesandbox.io/s/pedantic-flower-immerzustand-forked-ptso7?file=/src/App.tsx


",,
689388307,171,devtools don't always log,"devtools log fine as long as you call `set` (inside the `create` function). However, if you use the `useStore.setState` function to set some state, devtools doesn't log it.

Here is a minimal reproduceable example:

https://codesandbox.io/s/beautiful-ellis-17s7g

The `increase` function logs fine, the `setToFive` function does not.

Judging from the code, I think it is because `namedSet` is kept locally here:

https://github.com/react-spring/zustand/blob/a6417ce460a31cec94adc4a32c55d1abc98a00ba/src/middleware.ts#L54-L63

Currently, the middleware can only return the initialState, but since we want to wrap the setState function, we would somehow need to return / expose that function as well. What do you think?",,
688749045,170,Store is returning undefined,"So I am trying to use Zustand version 3.0.2 and I've been following the README but it does not seem to be working. Every time I attempt to use a store it returns undefined. I know the actual store works because when I console log it's contents in the file where it's created I can see the values. I am using TypeScript in a React Native application but I don't think that'd cause any issues.
```
const userPersist = persist<UserStore>(
  (set: SetState<UserStore>, get: GetState<UserStore>) =>
    set({
      user: initialUser,
      setUser: (newUser: User) =>
        set({
          user: newUser,
        }),
      updateUser: (fieldsToUpdate: User) =>
        set({
          user: {...get().user, ...fieldsToUpdate},
        }),
      resetUser: () =>
        set({
          user: initialUser,
        }),
    }),
  ""user"",
);

const useStore = create(userPersist);
```
initialUser is an object with values so that should not be returning undefined. I keep trying to access the store like this in a React component but it returns undefined for everything.
```
const {user, resetUser} = useUserStore(
    (state: UserStore) => ({
      user: state.user,
      resetUser: state.resetUser,
    }),
    shallow,
 );
console.log(user); // undefined
console.log(resetUser); undefined
```
Even trying it with just getting one value returns undefined.
```
  const user = useUserStore((state) => state.user);
  console.log(user); // undefined
```",,
685715421,168,React Hook does not update on state update,"Hey there,
I have been using zustand.js so far but there is a case where the html does not update when the state changes. My Code:


NotesList.js:
``` js
import React, { Component, useState } from 'react';

import {useNotes} from '../store.js';

const NotesList = () => {
    let notes = useNotes(state => state.data.notes);
    let changeCurrentNote = useNotes(state => state.changeCurrentNote);


  //  let uuidNote = useNotes(state => state.data.notes.uuid.title);
    const selectNote = (e) => {
        let note_id = e.target.id.split('-')[1];
        changeCurrentNote(note_id);
    }

    return(
    <div className=""notes"">
       {
       Object.entries(notes).map((note, key) => { // note[0] = id, note[1].content, note[1].title etc
           return (<div id={'note-' + note[0]} key={note[0]} onClick={selectNote}>{note[1].title}</div>)
       })
    }

    </div>
    )
}
export default NotesList
```

A part of store.js:
```js
const [useNotes] = create((set, get) => ({
    data: {
        notes: {
            uuid: {
                content: ""Just a Note."",
                title: ""A Note here..."",
                tags: [""Abc""]
            },
        }
  }
}
export {useNotes}
```


However, if I add `let uuidNote = useNotes(state => state.data.notes.uuid.title);` in the Hook the specific title does update (other titles don't), is there a way to fix that / am I doing someting wrong?


Edit: it works if I use the following `save()` function (inside `create()` )`

```js
save: () => {
   
            let oldState = get().data.notes;
 
            
            let currentNote = get().data.currentNote;

            oldState[currentNote.id].title = currentNote.title;
            oldState[currentNote.id].content = currentNote.content;
            oldState[currentNote.id].tags = currentNote.tags;

            set(state => {
                state.data.notes = null // it does not work if I remove this line
            });
            set(state => {
                state.data.notes = oldState
            })
}
```",,
682807615,162,How to use zustand in a non-singleton way,"In current documentation, store instance is created when the module is executed. **All component instances will bind to the same store instance(singleton pattern).** Zustand is similar to redux in this way.

But sometimes this is not what I want. Sometimes I want **each `ComponentA` instance has its own `StoreA` instance**. In other words, `ComponentA instance lifetime === StoreA instance lifetime`. `ComponentA` can share its `StoreA` instance to its children.
This pattern is very suitable when the data lifetime should be same with component instance lifetime.

Is there a standard way to do this?",,
680612303,158,Possible to translate a useReducer to Zustand?,"I have a reducer:

```jsx
const reducer = (state, action) => {

  switch (action.change) {
    case 'ROOT' :
      return {
        ...state,
        root: action.value
      }
    case 'QUALITY' :
      return {
        ...state,
        quality: action.value
      }
    case 'EXTENSION' :
      return {
        ...state,
        extension: action.value
      }
    case 'CHORD' :
      return {
        ...state,
        quality: action.value.split(`-`)[0],
        extension: action.value.split(`-`)[1]
      }
    case 'RESET' :
      return { 
        ...state,
        root: '',
        quality: '',
        extension: ''
      }
    default :
      return state
  }
}
```

...which is used in a react component utilizing the `useReducer` hook, like so:

```jsx
const [{ root, quality, extension }, dispatch] = useReducer(
    reducer,
    {
      root: ( props.root || '' ),
      quality: ( props.quality || '' ),
      extension: ( props.extension || '' )
    }
  )

  const handleRootChange = event =>
    dispatch({ change: 'ROOT', value: event.target.value })

  const handleQualityChange = event =>
    dispatch({ change: 'QUALITY', value: event.target.value })

  const handleExtensionChange = event =>
    dispatch({ change: 'EXTENSION', value: event.target.value })

  const handleChordChange = event => {
    dispatch({ change: 'CHORD', value: event.target.value })
  }

  const handleReset = event =>
    dispatch({ change: 'RESET'})

  const notes = `${root}-${quality}-${extension}`
```

...soooo, can something like this be achieved using Zustand in a simper way?",,
680609768,156,Typescript error: Cannot find module 'zustand/shallow',"Hi thanks for making zustand, 
After upgrading to 3.0 the import for zustand/shallow seems to work but shows a type error
`Cannot find module 'zustand/shallow' or its corresponding type declarations.`
https://codesandbox.io/s/thirsty-dew-kru3z?file=/src/App.tsx",,
680349307,151,Remove actions from store for simpler API,"I am realizing I should have shared this idea earlier... now v3 is released so it's a bit late... or is it?

The premise of this idea is that it's always felt a bit odd to keep the actions themselves inside the store. I _guess_ a dev might want to change the actions dynamically but I'd venture to say this is not happening in 99% of use cases.

So... I was playing with an idea of how I might be able to use zustand in a more casual way. I wanted to be able to easily lift my state from a local `useState` to a ""global"" zustand store. I [tweeted about it here](https://twitter.com/kindberg/status/1293752005169762304). Within that tweet there is a [codesandbox with a playground](https://codesandbox.io/s/easy-global-and-context-state-lifting-tgvb0?file=/src/App.js:960-1228) exploring this idea.

The core idea of the playground is something like this:
```js
// `globalState` uses zustand behind the scenes
const [useName, setName] = globalState('Tim')  // Store a simple literal
const [usePet, setPet] = globalState({ type: 'Cat', name: 'Nacho')  // Or store an object

const App = () => {
  const name = useName()
  const pet = usePet()  // could use a selector here if you want
  return (
    <div>
      // Call the setters from anywhere!
      <button onClick={() => setName('Bob')}>Change Name</button>
      <button onClick={() => setPet({ name: 'Beanie' })}>Change Pet Name</button>
    </div>
  )
}
```

So what did I learn from the idea?

That zustand stores are really about the data inside and subscribing to that data. The actions do not feel like they belong inside, they are just overhead. All that is really needed is exposing the set and get functions.

I realize this is all possible with v3 and you might be tempted to close this because of that reason, but I'm wondering if this mental shift should be more baked into the docs, or code, or both?

This is what I imagine it looking like (using the readme example). FWIW I love how v3 hangs additional methods on the hook, I also came to this conclusion recently.
```js
import create from 'zustand'

const useCount = create(0) // Just provide the state, no actions

// Now, if you want create bespoke actions using the exposed useCount.set
// Side note: I think it should be called useCount.get() to get the state, just shorter and more elegant
const increase = () => useCount.set(state => ({ count: state.count + 1 })),
const reset = () => useCount.set({ count: 0 })

function Counter() {
  const count = useCount()
  return <h1>{count}</h1>
}

function Controls() {
  return <button onClick={increase}>up</button>
}
```

As you can see this simplifies the API greatly! Thoughts??",,
678720361,140,Setting initial state and updating in an interval,"Sorry for the newb question here. I'm trying to store the current time with Zustand and update it every second without re-rendering the app.

Currently I have:

```
...
import create from 'zustand';

const [useStore] = create((set) => ({
  currentDateTime: undefined,
  setCurrentDateTime: () => set((state) => ({ currentDateTime: new Date() })),
}));

export default function App() {
  const { currentDateTime, setCurrentDateTime } = useStore();
  useEffect(() => {
    const secondsTimer = setInterval(() => {
      setCurrentDateTime();
    }, 1000);
    return () => clearInterval(secondsTimer);
  }, [setCurrentDateTime]);

  console.log('Setting the time');
  ...
```

I am seeing the console log every second, which means it is re-rendering.
What am I doing wrong here?",,
673831741,132,Using getter to calculate computed values,"Hey!

Is it ok to use the getter to return a computed value in a function? Since using it in a value doesn't work?

Example:

```typescript
const [useAuth] = create((set, get) => ({
    user: {username: undefined, authLevel: 0},
    // isSignedIn: !!get().user.username // doesn't work because it's executed before the store is created, so get() returns undefined right?
    isSignedIn: () => !!get().user.username // should work, just call isSignedIn() instead of using as a value, in the components?
})}
```

Also, I feel like computed values are a cool features for state management libraries to have out of the box, are there planes to add it? Do you guys need help with it somehow?",,
671620946,131,How to set type for devtools in TypeScript?,"I'm trying like this:
```ts
type TStore = {
  count: number;
  inc(): any;
  dec(): any;
};

const [useStore] = create<TStore>(
  devtools((set: SetState<TStore>) => ({
    count: 1,
    inc: () =>
      set(state => {
        count: ++state.count;
      }),
    dec: () =>
      set(state => {
        count: --state.count;
      }),
  }))
);
```
But I got error:
```
Argument of type '(state: TStore) => void' is not assignable to parameter of type 'PartialState<TStore>'.
  Type '(state: TStore) => void' is not assignable to type '(state: TStore) => Partial<TStore>'.
    Type 'void' is not assignable to type 'Partial<TStore>'.
```",,
658773737,127,"In order to be iterable, non-array objects must have a [Symbol.iterator]() method.","if devtools are not used, application will crash after build

```js
export default function creator(...args) {
  // if (process.env.NODE_ENV === 'development') {
  //   return create(devtools(...args));
  //  }
  
  create(...args); 
}
```

![image](https://user-images.githubusercontent.com/34636376/87742448-53917280-c819-11ea-948f-a3cf353218d5.png)
",,
651032366,124,What am i doing wrong here,"Can someone pls explain why i see continual `rerendering` here? Devtools tells me it's the `useAStore()` hook but it only picks the `addLines` action 🤔

This is a minimal example of a pattern i'm trying to form - the ability to combine actions from multiple stores into ""composed actions"" inside a hook and then use the same 2 store's state values directly from components. (I want to use the composed actions from a higher component)

Repro repo (yarn dev to run): https://github.com/elmpp/ink-zustand-poc

```
const React = require(""react"");
const { Box, Text } = require(""ink"");
const { useEffect } = require(""react"");
const create = require('zustand').default;

module.exports = () => {
	const {addLines} = useAStore()

	useEffect(() => {
		// increment()
    const increment = (timer) => {
			addLines([`${Math.random}`])
    }
    const timer = setInterval(() => {
      increment(timer)
    }, 2000)
    return () => clearInterval(timer)
	}, [addLines])

	console.log('rerendering');

	return (
		<Box>
			<Sub />
		</Box>
	);
};

const Sub = () => {
	const {lines} = useStore(state => ({lines: state.lines}))

	return (
		<Box>
			{lines.map(line => <Text>{line}</Text>)}
		</Box>
	);
}


const [useStore] = create((set, get) => ({
	lines: ['first'],
	addLines: lines => set(state => state.lines.concat(lines)),
}))

const useAStore = () => {
	const {addLines} = useStore(state => ({addLines: state.addLines}))
	return {addLines}
}
```

",,
646776727,123,Selectors defined outside of a render function do not always return the associated store value,"I'm having a problem where store values output via a custom hook do not all have the values from the current store. Some have values from the previous store. Here's a brief explanation, I've also pasted more complete code at the end. Appreciate your help!

The crux of the issue is that if I have my selectors in an object useStore(selectors.blah), values from the store are incorrect. If I do this useStore(state => state.blah) there's no problem. More info:

I've grouped my selectors like this (living in a module with the store):

```
export const selectors = {
  status: (state) => state.status,
  profile: (state) => state.profile,
};
```

And use them like this in a custom hook in a separate module

```
  const status = useStore(selectors.status);
  const profile = useStore(selectors.profile);

```

A login and a logout button change store status and profile together from

```
{ status: statusType.LOGGED_OUT, groups: [], profile: null }
```

to

```
{
      status: statusType.LOGGED_IN,
      profile: {
        familyName: 'bob',
      },
    }
```

The values output in the custom hook are not what I was expecting. status has the current value of the store (statusType.LOGGED_IN), profile has the previous value of the store (null). Odd!

If instead I do this in the custom hook

```
  const status = useStore((state) => state.status);
  const profile = useStore(state => state.profile);
```

All is well. status and profile values have the current values of the store on every render

Here's some more complete code:

------

Custom hook

```
import { useStore, selectors, mutators, statusType } from './store';

export function useCustom() {
  const status = useStore(selectors.status);
  const profile = useStore(selectors.profile);

  const login = useStore(mutators.login);
  const logout = useStore(mutators.logout);

  // these do not match the current version of the store on every render
  console.log('profile', profile); // null
  console.log('status', status); // statusType.LOGGED_IN

  switch (status) {
    case statusType.LOGGED_IN:
      return {
        status: statusType.LOGGED_IN,
        isLoggedIn: true,
        profile,
        logout,
      };
    case statusType.LOGGED_OUT:
      return {
        status: statusType.LOGGED_OUT,
        isLoggedIn: false,
        profile,
        login,
      };
    default:
      return {};
  }
}

```
store

```
import create from 'zustand';

export const statusType = {
  LOADING: 'loading',
  LOGGED_IN: 'logged_in',
  LOGGED_OUT: 'logged_out',
};

export const [useStore, store] = create((set) => ({
  status: statusType.LOADING,
  profile: null,
  login: async () => {
    set({
      status: statusType.LOGGED_IN,
      profile: {
        familyName: 'bob',
      },
    });
  },
  logout: async () => {
    set({ status: statusType.LOGGED_OUT, groups: [], profile: null });
  },
}));

if (typeof window !== 'undefined') {
  init();
}

async function init() {
  store.setState({
    status: statusType.LOGGED_IN,
    profile: {
      familyName: 'bob',
    },
  });
}

export const selectors = {
  status: (state) => state.status,
  profile: (state) => state.profile,
};

export const mutators = {
  login: (state) => state.login,
  logout: (state) => state.logout,
};

```",,
646581845,121,synchronous access to state values impossible?,"I want to do this:

```
export const [useMyLiteralStore] = create((set: (state:{}) => void) => ({
  literals: '',
  setLiterals: (newLiterals: string) => set((state:{}) => ({ literals: newLiterals })),
}));

const MyReactComp: React.FC<Props> = (Props) => {

  const setLiterals = useMyLiteralStore((state: any) => state.setLiterals);
  const myliterals = useMyLiteralStore((state: any) => state.literals);

  useEffect(() => {
    setLiterals('myTestValue');
console.error(""myliterals "", myliterals); //not 'myTestValue' <------- I WANT THIS TO ACTUALLY BE 'myTestValue'
  }, []);
```

is there a way to achieve what I want? I want to have access to myliterals, after setting it, in a synchronous way like shown above.

What I certainly _dont_ want to do, is hand around my global state in function arguments to side step the problem.",,
645835970,119,Doesn't work in IE11 (even when using core-js),"the error is:
>Syntax error

![image](https://user-images.githubusercontent.com/2072058/85792786-acc62480-b6f9-11ea-988b-0c629c1de9c9.png)


I have 

```
import 'core-js';
```
at the top of my file",,
644174799,118,Framework-agnostic store,"Hi.

Just recently I ran into this library and I really like the API. One thing I noticed is that the implementation is tied to React. While this is not necessarily a bad thing, but, with a few tweaks, you could widen the usage of the library to realms beyond.

I tinkered around with the code and made it work like this:

```TypeScript
export default function create<TState extends State>(
  createState: StateCreator<TState>
): [UseStore<TState>, StoreApi<TState>] {
  const store = createStore<TState>(createState);
  const storeHook = useStore<TState>(store);

  return [storeHook, store];
}
```

Based on this, there were no breaking changes to the current API (just had to expose `createListener: CreateListener<T>` and `listen: Subscribe<T>` on the `StoreApi` interface). Now, if a given user wants to use Zustand without React, they could use the `createStore` function.

I'm not sure if this interests the maintainers, but I could open a PR if it is:
https://github.com/react-spring/zustand/compare/master...olavoasantos:feat-fw-agnostic-store",,
642410191,116,get() is undefined during store creation,"I've got a simple store I added below. Idea here is to have platform and action that gets it. I also added computed / helper booleans like `isAndroid`. For some reason whenever I use one of these booleans I see an error `can not get platform of undefined`. This is fixed by changing those helper booleans to `get().platform`. But I don't understand why get is undefined. Should it not already include an initial store?  Perhaps it is only undefined when store is being created?

```ts
import create from 'zustand';

interface PlatformStore {
  platform: 'web' | 'ios' | 'android' | 'electron';
  isAndroid: boolean;
  isIos: boolean;
  isWeb: boolean;
  getPlatform: () => Promise<void>;
}

const [usePlatformStore] = create<PlatformStore>((set, get) => ({
  platform: 'web',

  isAndroid: get().platform === 'android',

  isIos: get().platform === 'ios',

  isWeb: get().platform === 'web',

  async getPlatform() { /* gets platform and uses set() to add it to the store */ }
));
```",,
637025704,114,Typescript problem with StateListener,"Hey!

I use this block of code:

```js
  export interface NetWorkInfo {
    isInternetOn: boolean;
    type: NetInfoStateType;
    isConnectionExpensive: boolean;
    cellularType: NetInfoCellularGeneration | 'null';
  };

  ...

  useEffect(() => {
    const unsubIsInternetOn = apiApp.subscribe<NetWorkInfo>(
      networkInfo => {
        const { isInternetOn } = networkInfo;
        setIsInternetOn(isInternetOn);
      },
      appState => appState.state.networkInfo
    );

    return () => {
      unsubIsInternetOn();
    };
  }, []);
```

And TS is never happy about the first param of subscribe: 
`Property 'isInternetOn' does not exist on type 'NetWorkInfo | null'.`

Because of the `null` [here](https://github.com/react-spring/zustand/blob/d8f8c5f752465065959b3e6782774b316881f72a/src/index.ts#L13).

Is there a reason why the param1 of StateListener should be null ?

Thanks!",,
611184285,109,Warning: Can't perform a React state update on an unmounted component. [BUG@Zustand 2.2+],"Hello, I've been using zustand to try out new React applications, however, I'm getting this warning from React when I change my state by using the API.setState:

`Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.
    in Login (at app.tsx:39)`

This is the code:

```js
import React from 'react'
import create from 'zustand'
import shallow from 'zustand/shallow'

const [useAuthStore, authStoreApi] = create(() => ({
  authenticated: false,
  password: ''
}))
const setPassword = (password) => authStoreApi.setState({ password })
const authenticate = async () => {
  await new Promise((resolve) => setTimeout(resolve, 1000))
  authStoreApi.setState({ authenticated: true })
}

const Login = () => {
  const [authenticated, password] = useAuthStore(
    (store) => [store.authenticated, store.password],
    shallow
  )
  return (
    <div>
      <span>authenticated: {authenticated ? 'yes' : 'no'}</span>
      <input value={password} onChange={(e) => setPassword(e.target.value)} />
      <button type=""button"" onClick={authenticate}>
        authenticate
      </button>
    </div>
  )
}
const Home = () => <div>Welcome!</div>

export const App = () => {
  const authenticated = useAuthStore((store) => store.authenticated)
  return (
    <div>
      {authenticated && <Home />}
      {!authenticated && <Login />}
    </div>
  )
}
```

It works when I fetch singular props, e.g. `const password = useAuthStore(store => store.password)`, or when I use array-selector with one entity AND use the shallow-comparator. But using multiple state picks with or without the shallow-comparator leaves me with this React-error.

Did anyone have any similar issue?

React version: 16.13.1
Zustand version: 2.2.3

**EDIT**: It seems to work using Zustand 2.1.4

Thanks",,
608147461,108,Correct approach to get derived values from state,"Hello,

In my store, I have several methods that calculates same derived values from state. I am looking for an optimized way to achive that.

Right now, I can do this:

```
getDerivedValue: () => {
  return get().listA[get().indexB].value;
}
...
get().getDerivedValue();
```

But I prefer something like this:

```
get derivedValue () {
  return get().listA[get().indexB].value;
}
...
get().derivedValue;
```

Unfortunately, using getter gives only the inital state, returning value doesn't update with state changes. My computations are not that expensive, but it would be much better to access the value as it was a variable then calling it as a function. My concern is a bit aesthetic but anyway, it would be nice to have something like Mobx's [computed property](https://mobx.js.org/refguide/computed-decorator.html). Is there a workaround for using getter or could you provide an alternative to achieve this?

Thank you.",,
595646003,98,Typescript typing trouble for immer proxy,"I'm a TS user trying to properly type an immer middleware, but I'm failing miserably:

Vanilla:
```javascript
// Turn the set method into an immer proxy
const immer = config => (set, get, api) => config(fn => set(produce(fn)), get, api)
```
TS:
```typescript
function immerConverter<T>(config: StateCreator<T>): StateCreator<T> {
  return (set: SetState<T>, get, api) =>
    config(fn => set(produce(fn)), get, api);
}
```
Leading to the following error:
```
Error:(46, 30) TS2345: Argument of type 'PartialState<T>' is not assignable to parameter of type '(...args: any[]) => any'.
  Type 'Partial<T>' is not assignable to type '(...args: any[]) => any'.
    Type 'Partial<T>' provides no match for the signature '(...args: any[]): any'.
```

Any ideas?",,
587374131,96,type error when using with immer,"now the signature of set accepts: `export declare type PartialState<T extends State> = Partial<T> | ((state: T) => Partial<T>);` but with immer it requires `(state: T) => void`, or it cannot pass the type checking.

The complete type should be: `export declare type PartialState<T extends State> = Partial<T> | ((state: T) => Partial<T>) | ((state:T) => void);`",,
581107506,95,[Types] Strictly typed store allows invalid values,"I might be missing something, but shouldn't following disallow `invalidA` and `invalidB` values to be used in a store? As it is at the moment I don't get any error about them.

```ts
import create from 'zustand';

interface Store {
  count: number;
  increase: () => void;
}

const [useStore] = create<Store>(set => ({
  count: 0,
  invalidA: 0,
  increase: () => set(state => ({ count: state.count + 1 })),
  invalidB: () => set({ count: 0 })
}));

export default useStore;
```",,
577516583,93,Component cann't get newstate.,"When I use it like this, component cann't get newstate.
```
const fooSelector = useCallback(state => state.foo, [])
const foo = useStore(fooSelector)
```
I think it's because of this line of code: https://github.com/react-spring/zustand/blob/master/src/index.ts#L132
```
    if (
      subscriber.selector !== selector ||
      subscriber.equalityFn !== equalityFn ||
      subscriber.errored
    ) {
      // Using local variables to avoid mutations in the render phase.
      newStateSlice = selector(state)
      hasNewStateSlice = !equalityFn(subscriber.currentSlice, newStateSlice)
    }
```
`usecallback` caused the selector not to be updated. So even if the state is updated, it doesn't compare the new state with the old state.So components and data are not updated.
",,
569047264,92,[devtools] get name of caller in middleware,"Hi!

I've been working on a port to zustand which contains a substantial analytics middleware. In the meantime, I learned a few things - is my understanding correct here?

1. the `devtools` middleware requires `name` as a second parameter to all of your `set` functions, which it then sends to redux devtools.
2. the `devtools` middleware doesn't continue passing those `name`s along, it just drops them
3. in order to use the names elsewhere, I must put the devtools middleware _last_.
4. each middleware prior must also be sure to pass `name` along.


If I'm understanding this correctly, I'm curious as to if there might be a better way to pass the name of the `set` function which has caused this middleware to be fired.

For (__ugly__) example:

```ts
function caller(): string {
  return new Error().stack
    .match(/at (\S+)/g)[3]
    .slice(3)
    .replace('Object.', '');
}

export const middleware = store => (set, get, api) =>
  store(
    (getPayload: any) => {
      const name = caller();
      const payload = getPayload();
      const state = get();

      switch(name) {
        case 'onReady': {
          sendAnalyticEvent(payload);
        }
        default: {}
      }
      return set(getPayload);
    },
    get,
    api,
  );

```


Is there any path to a _sane_ API for this which would solve a couple of problems?

1. no need to pass ""name"" as a 2nd setter param for redux devtools
2. access to the name of the caller from any middleware

Thanks! Great work on zustand.",,
566855310,89,Batch setState,"Hello!

I'm reviewing this store library, testing out some quirks and stuff. It seems really great, but I would suggest adding some type of batch update when updating multiple stores, if it doesn't already exist.

```js
// actions
export const action = () => {
  modalStoreApi.setState({ show: false });
  usersStoreApi.setState({ users: [ ...usersStoreApi.getState().users, 'new user' ] })
}

// component
export const Component = () => {
  const show = useModalStore(store => store.show)
  const users = useUsersStore(store => store.users)

  return show && <span>User 1: {users[0]}</span>
})
```

So in this case, the component will re-render twice, so what would be cool would be something like this, similar to how redux-thunk does it:

```js
// actions
export const action = () => {
  batch(() => {
    modalStoreApi.setState({ show: false });
    usersStoreApi.setState({ users: [ ...usersStoreApi.getState().users, 'new user' ] })
  })
}
```

Not the greatest example perhaps, but I know this is needed at times, when you're separating your stores, and combining them at places using selectors and so on.

What do you think?

Thanks",,
558346807,87,"const { value, setValue } = useStore(), value: any / setValue: any?","Hi, so I have simple store defined like this:

```javascript
import create from 'zustand';

const [useStore] = create(set => ({
  value: 'char', // <- I'd like this to be an enum (e.g. 'char' | 'num')
  setValue: (e: MouseEvent, newValue: string) => set(state => ({ value: newValue })),
}));

export { useStore };
```
Then when I use the store in some component, lets say:

```javascript
const { value, setValue } = useStore(); // <- ts says const value: any, const setValue: any

return (
  <Button onClick={e => setType(e, 'num')} />
)
```

How can I ensure that `setType()` is called only with correct string `'char' | 'num'`?

Anyway I am new to the typescript and React so bear with me please.
I also tried useContext from React itself but your api is just so easy to use, so I want to thank you for this library and your work as well, keep it up! ",,
544646338,83,Immer + Typescript - produce state type is missing,"I'm trying to use immer to simplify the process of updating nested state. However, the `state` object is converted to `any` within the produce function. Am I doing something wrong?

Example: 

```
interface State {
  papers: {name: string; id: string}[];
}

const stateAndActions = (set: NamedSetState<State>, get: GetState<State>) => {
  return {
    ...initialState,
   updatePaper: (id: string, name: string) => set(produce(state => {<do something here>})),
  }
}
```

p.s. I just switched from redux to zustand and I love it!",,
516937727,77,[devtools] doesn't log actions since v2,"When updating from 1.0.7 to 2.2.1, I lose the tracking of all actions in the Redux devtools:

## 2.2.1
![image](https://user-images.githubusercontent.com/2037851/68097209-a2e47c80-fef0-11e9-9495-0830ef579b87.png)

## 1.0.7
![image](https://user-images.githubusercontent.com/2037851/68097276-1b4b3d80-fef1-11e9-89db-4f67f84c5867.png)

The app works just fine and the store updates correctly when using the app, it just doesn't log out the commits any more.

Using it like:

```ts
import create, { StateCreator } from 'zustand'
import { devtools } from 'zustand/middleware'

export const DefaultStoreState: DefaultStateGetters = {
  lastDataUpdate: new Date(),
  loading: false,
  showDrawer: false,
  message: null,
  ...
}

const store: StateCreator<DefaultState> = (set, get) => ({
  ...DefaultStoreState,
  ...
})

export const [useStore, Store] = create<DefaultState>(devtools(store, 'WACHS App Store'))
```

Any pointers would be appreciated. Let me know if you need more detail and I will update this post.

Cheers & thanks
Patrik",,
516564115,75,Middleware in TypeScript,"Hi, I'd like to use `zustand` with TypeScript. Any chance you can write the example middlewares (`log` and `immer`) with TypeScript so I can follow and imitate?

I'd really appreciate it. Thank you. @JeremyRH @drcmda.",,
512577796,71,zustand 3 milestones,"Let's collect some,

- [ ] Concurrent React, are we ready for it?
- [ ] Simpler API?

currently

```jsx
const [useStore, api] = create(set => ({ set, count: 0 }))

const count = useStore(state => state.count)

const count = api.getState().count
const unsub = api.subscribe(count => console.log(count), state => state.count)
api.setState({ count: 1 })
```

why not

```jsx
const useStore = create(set => ({ set, count: 0 }))

const count = useStore(state => state.count)

const count = useStore.getState().count
const unsub = useStore.subscribe(count => console.log(count), state => state.count)
useStore.setState({ count: 1 })
```

vanilla users wouldn't name it ""useStore""

```jsx
const api = create(set => ({ set, count: 0 }))
const count = api.getState().count
```

it would mean we're now api compatible with redux without doing much.

with a little bit of hacking it could also be made backwards compatible by giving it a iterable property. i've done this before with three-fibers useModel which returned an array once, but then i decided a single value is leaner.

@JeremyRH ",,
506546836,67,subscribe type error since version 2.x,"Hi,

I upgraded this morning zustand from version `1.0.7` to version `2.1.0` and I have a typescript compilation error.
First I had to change the syntax with the new `subscribe` API. Before I has this:

```typescript
import create from 'zustand';

interface State {
  time: number;
  setTime: (time: number) => void;
}

export const [useTranscriptTimeSelector, useTranscriptTimeSelectorApi] = create<
  State
>(set => ({
  setTime: time => set({ time }),
  time: 0,
}));

useTranscriptTimeSelectorApi.subscribe(
    time => (player.currentTime = time as number),
    {
      selector: state => state.time,
    },
  );
```

Now with the new syntax I have:

```typescript
import create from 'zustand';

interface State {
  time: number;
  setTime: (time: number) => void;
}

export const [useTranscriptTimeSelector, useTranscriptTimeSelectorApi] = create<
  State
>(set => ({
  setTime: time => set({ time }),
  time: 0,
}));

  useTranscriptTimeSelectorApi.subscribe(
    time => player.currentTime = time,
    state => state.time,
  );
```

And I have this error message:

```
error TS7006: Parameter 'time' implicitly has an 'any' type.

      time => player.currentTime = time,
       ~~~~
```

If I refer to the readme, my syntax is good.

Thank you for your help.",,
502074861,64,zombie children again ,"![Screenshot 2019-10-03 at 16 19 32](https://user-images.githubusercontent.com/2223602/66135060-a1761a80-e5f9-11e9-9bb3-4dbb71d50e63.png)



example

```jsx
const [useStore, api] = create(set => ({
  sketch: { type: ""sketch"", children: [""1""] },
  ""1"": { type: ""line"", children: [""2"", ""3""] },
  ""2"": { type: ""point"", pos: [0, 0, 0] },
  ""3"": { type: ""point"", pos: [10, 0, 0] },
  delete() {
    console.log(""------ setState ------"")
    set(state => ({
      ...state,
      ""1"": { ...state[""1""], children: [""3""] },
      ""2"": undefined
    }))
  }
}))

function Point({ id }) {
  console.log(""    Point renders"", id)
  const { pos } = useStore(state => state[id])
  return pos.join("" "")
}

function Line({ id }) {
  console.log(""  Line renders"", id)
  const ids = useStore(state => state[id].children)
  return ids.map(id => <Point key={id} id={id} />)
}

function Sketch() {
  console.log(""Sketch renders"")
  const ids = useStore(state => state.sketch.children)
  return ids.map(id => <Line key={id} id={id} />)
}

function App() {
  useEffect(() => void setTimeout(() => api.getState().delete(), 2000), [])
  return <Sketch />
}
```

live demo: https://codesandbox.io/s/crazy-frog-49vrj

### what happens 

    Sketch
      Line
        Point pos=[0,0,0]
        Point pos=[10,0,0]

The delete() method removed the first point and takes it out of its parents children collection. React normally renders hierarchical, so it should be fine. But for some weird reason each listener in zustand immediately goes to the components render function. It actually calls a useReducer/forceUpdate, which then triggers reacts dispatchAction > scheduleWork > requestWork > performSyncWork ... > render

```jsx
const setState: SetState<TState> = partial => {
    const partialState =
      typeof partial === 'function' ? partial(state) : partial
    if (partialState !== state) {
      state = Object.assign({}, state, partialState)

      //<--- the next line causes synchroneous render passes for each listener called
      listeners.forEach(listener => listener())
    }
  }
```

I've tried to wrap it into batchedpdates and that seemed to fix it, now React renders in hierarchical order again, **after** the listeners have been triggered:

```jsx
      unstable_batchedUpdates(() => {
        listeners.forEach(listener => listener())
      })
```

Is there any explanation for this? And what can we do to fix it?

@JeremyRH ",,
501747397,63,Only render updated items in an array,"I have an array of items in Zustand store, and if I update one, all items in the array rerender.

I have a simple example here where a store has a list of colors rendered to divs. When you click on a div it updates the items in the stored array. However, all items rerender when one is changed. Is there a way to set up Zustand so only one object rerenders when it item changes in an array?

https://codesandbox.io/s/polished-framework-59eys
```jsx
import React from ""react"";
import ReactDOM from ""react-dom"";
import produce from ""immer"";
import create from ""zustand"";

export const immer = config => set => {
  return Object.entries(config()).reduce(
    (acc, [key, value]) => ({
      ...acc,
      [key]:
        typeof value === ""function""
          ? (...args) => set(produce(draft => void config(draft)[key](...args)))
          : value
    }),
    {}
  );
};

const store = state => ({
  divs: [""red"", ""red"", ""red""],
  updateColor: (color, index) => {
    state.divs[index] = color;
  }
});

const [useStore] = create(immer(store));

const App = () => {
  const { divs } = useStore();
  return (
    <div className=""App"">
      {divs.map((d, i) => (
        <DivEl color={d} index={i} />
      ))}
    </div>
  );
};

const DivEl = ({ color, index }) => {
  const { updateColor } = useStore();
  return (
    <div
      onClick={() => updateColor(color === ""red"" ? ""blue"" : ""red"", index)}
      style={{
        width: ""100px"",
        height: ""100px"",
        background: color,
        margin: ""1em""
      }}
    />
  );
};

const rootElement = document.getElementById(""root"");
ReactDOM.render(<App />, rootElement);
```",,
482677922,55,ReferenceError when using devtools middleware,"Hi, I'm getting a `ReferenceError: Cannot access 'state' before initialization` when using zustand(1.0.4) with the devtools middleware in a create-react-app based setup. The error is only present in development mode.

To reproduce:
1. `npx create-react-app test-zustand && cd test-zustand`
2. `yarn`
3. `yarn add zustand`
4. Replace App.js with [TestApp]
3. `yarn start`

[TestApp]:
```
import React from ""react"";
import ""./App.css"";
import create from ""zustand"";
import { devtools } from ""zustand/middleware"";

const [useStore] = create(
  devtools(set => ({
    count: 1,
    inc: () => set(state => ({ count: state.count + 1 })),
    dec: () => set(state => ({ count: state.count - 1 }))
  }))
);

function App() {
  const count = useStore(state => state.count);
  const inc = useStore(state => state.inc);
  return (
    <div className=""App"">
      <header className=""App-header"">
        <p>Count: {count}</p>
        <button onClick={inc}>Inc</button>
      </header>
    </div>
  );
}

export default App;
```

Screenshot:
![Screenshot from 2019-08-20 09-44-37](https://user-images.githubusercontent.com/16530091/63323718-28fc1880-c32f-11e9-8e67-930bb9ec6f6a.png)
",,
482336263,54,Typescript automatic typings,"Hello,

Is there a technical limitation that would explain why there are no automatic typings of the store ? ",,
471155601,50,Subscribe<T> type error,"The following type is throwing errors in TS and I think it's specifically the `U | void` passed to `StateListener`. TS cannot infer the shape of the state passed to the listener fn.

https://github.com/react-spring/zustand/blob/f936e3d9df0e3a18e2504e62828b23f6e9937fe3/src/index.ts#L23-L25

![image](https://user-images.githubusercontent.com/3819093/61643786-8f7b1180-ac71-11e9-9e51-bed88cbc279c.png)

Seems like converting `U | void` into `U` fixes it but we have to explicitely pass the generic when called. I was wondering why we'd need `void` in this case.

```diff
export declare type Subscribe<T extends State> = <U>(
-  listener: StateListener<U | void>,
+  listener: StateListener<U>,
  options?: SubscribeOptions<T, U>
) => () => void;
```

```ts
const [, api] = create<State>(() => ({});
api.subscribe<State>(s => {}) // This passes type checking
```

I have created a reproducible example: https://codesandbox.io/s/adoring-brook-264gb
",,
467422128,46,zustand/shallow and zustand/middleware are not transpiled to cjs,"I'm getting errors because zustand/middleware.js and zustand/shallow.js have non-supported syntax in them. 

There is a .cjs.js file for each but then I have to import from 'zustand/middleware.cjs' which feels a bit weird, but it's a successful workaround.

It seems with additional non-main entries like these, they do not have the convenience of specifying `main` and `module` in the package.json like the main entry has. So the safest bet would probably be to have their `.js` file be the lowest common demoninator, commonjs.

I'm not sure these two entries need to be exported as anything but commonjs.",,
463837582,45,SetState & GetState Typescript declaration in create function arguments (bis),"I opened an issue #32 a few weeks ago. The https://github.com/react-spring/zustand/pull/35 pull request was supposed to fix the problem, but as far as I can see, it doesn't.",,
462361079,44,Discussion: Accessing store from another store,"Is it good or bad to have stores talk to each other? If it's ok, what would be good/bad ways of going about it? E.g. Here's one idea, if stores do use other stores, they could use the exposed API instead of the hook. _I'm making this use-case up, so it might be unrealistic._
```js
// UsersStore.js
export const [useUsersStore, usersStore] = create(...)

// CommentsStore.js
import { usersStore } from './UsersStore.js'

export const [useCommentsStore, commentsStore] = create(set => ({
  async loadUserComments(userId) {
    // Note: I'm accessing the other store here
    const commentIds = usersStore.getState().users[userId].commentIds
    set({ comments: await fetch(`/comments`, { ids: commentIds }) })
  }
}))
```

Or would it be better to force components to compose stores together like this?
```js
// UsersStore.js
export const [useUsersStore] = create(...)

// CommentsStore.js
export const [useCommentsStore] = create(set => ({
  comments: [],
  async loadComments(commentIds) {
    set({ comments: await fetch(`/comments`, { ids: commentIds }) })
  }
}))

// Component.jsx
function UserComments({ id }) {
  // Note: I'm doing all the wiring together in the component instead
  const commentIds = useUsersStore(state => state.users[id].commentIds)
  const comments = useCommentsStore(state => state.comments)
  const loadComments = useCommentsStore(state => state.loadComments)

  useEffect(() => {
    loadComments(commentIds)
  }, [commentIds])
}
```

Maybe, if you really want to encapsulate the logic, you could create a custom hook to wire them together? We could export an additional non-zustand custom hook that joins two (or more) zustand stores together to provide composited functionality.

Would this even work? I think I like this...
```js
// Not sure what file I'd put this in ¯\_(ツ)_/¯
export const useUserComments = (userId) => {
  const commentIds = useUsersStore(state => state.users[id].commentIds)
  const comments = useCommentsStore(state => state.comments)
  const loadComments = useCommentsStore(state => state.loadComments)

  useEffect(() => {
    loadComments(commentIds)
  }, [commentIds])

  return comments
}

// Component.jsx
function UserComments({ id }) {
  const comments = useUserComments(id)
}
```",,
462361062,43,Discussion: Multiple stores in one component,"When using multiple stores in a component, it seems I have to change the style of which I consume a store. Store conventions can cause some headaches when using multiple stores in a component—conventions like: always having an `actions` key, or multiple stores may have a `loaded` key.

This shows the problem:
```js
const Component = () => {
  // This is my preferred way of using zustand
  const { users, loaded, actions } = useUsersStore()
  // But now this code will break because of duplicate variable declarations
  const { comments, loaded, actions } = useCommentsStore()
}
```

So my only idea is to do this:
```js
const Component = () => {
  const usersStore = useUsersStore()
  const commentsStore = useCommentsStore()

  // Then work with it as a domain object, which is kind of nice actually.
  if (usersStore.loaded) { ... }
  return <div>{ commentsStore.comments }</div>
}
```

However, things get a bit more complicate if I want to use selectors. Atomic selectors are promoted in the docs because they are showing simple use-cases, but those might be cumbersome here because I'd have to ""namespace"" each clashing variable, like so:

```js
const Component = () => {
  const usersActions = useUsersStore(state => state.actions)
  const usersLoaded = useUsersStore(state => state.loaded)
  const comments = useCommentsStore(state => state.comments)
  const commentsActions = useCommentsStore(state => state.actions)
  const commentsLoaded = useCommentsStore(state => state.loaded)

  // Then work with it as a domain object, which is kind of nice actually.
  if (usersLoaded) { ... }
  return <div>{ comments }</div>
}
```
Maybe that's not so bad. Thoughts?

I'd prefer the domain objects though with a nice selection API, maybe something that uses lodash `pick` and `get` under the hood.

```js
const Component = () => {
  const usersStore = useUsersStore(['users', 'loaded', 'actions'])
  const commentsStore = useCommentsStore(['comments', 'loaded', 'actions'])

  // Then I just use the domain objects as shown before
}
```

The string shorthand would even be a very nice API for atomic selections...
```js
const Component = () => {
  const usersActions = useUsersStore('actions')
  const usersLoaded = useUsersStore('loaded')
  const comments = useCommentsStore('comments')
  const commentsActions = useCommentsStore('actions')
  const commentsLoaded = useCommentsStore('loaded')
}
```

It could support lodash `get` style deep selections too...
```js
const Component = () => {
  const loadAllUsers = useUsersStore('actions.loadAll')
}
```

If the core lib didn't support this, would this be possible to add via a middleware?",,
462360136,42,Discussion: Storing hooks in the state,"Is it good or bad to have hooks in your store state? It's a neat idea because you could move things like useEffect into there. My gut says ""DO NOT DO THIS"", but I wanted to share the thought. E.g.
```js
export const [useCommentsStore] = create((set, get) => ({
  comments: [],
  async useLoadComments(commentIds) {
    useEffect(() => {
      const commentIds = usersStore.getState().users[userId].commentIds
      set({ comments: await fetch(`/comments`, { ids: commentIds }) })
    }, [commentIds])
  }
}))
```
Then in a component:
```js
const Component = ({ commentIds }) => {
  const { comments, useLoadComments } = useCommentsStore()
  useLoadComments(commentIds)
  return <div>{ comments }</div>
}
```

However, I think it might be better to not couple the store to react via hooks usage. Just use hooks in the component instead like normal:
```js
const Component = ({ commentIds }) => {
  const { comments, loadComments } = useCommentsStore()
  useEffect(() => {
    loadComments(commentIds)
  }, [commentIds])
  return <div>{ comments }</div>
}
```",,
459518019,36,How can zustand distinguish between atomics and objects?,"So this is something that @dm385 found by accidentally mutating a state object: https://codesandbox.io/s/strange-dew-4gv6k

```jsx
const [useStore] = create((set, get) => ({
  nested: { a: { a: 1  } }
  actions: {
    inc: () => {
      const nested = { ...get().nested }
      nested.a.a = nested.a.a + 1
      set({ nested })

function Test() {
  const nested = useState(state => state.nested)
```

Curiously the useStore hook doesn't fire when inc() is called. It mutates state, and if that weren't the case it would work, but the nested object *is* being exchanged here, so i was wondering why the hook didn't respond:

We distinguish between two selects, atomics and objects:

```jsx
// Object pick
const { number, string } = useStore(state => ({ number: state.number, string: state.string }))
// Atomic picks
const number = useStore(state => state.number)
const string = useStore(state => state.string)
```

I've never thought about this before, but it actually goes into the objects we return *every time* to make a shallow equal test, if they're self-made, like above, or if we select them right from state:

```jsx
// Doesn't do plain reference equality here, it will check each object prop for ref equality instead
const object = useStore(state => state.object)
```

The outcome is the same of course, if an object gets changed, even deeply, some prop is going to be different due to reducing. So at least we're safe, if users don't mutate it works, but can this lead to performance problems? For instance if a hash map object has 100.000 props it will have to go through them... : S

In Redux the hook does only a strict equality check by default, see: https://react-redux.js.org/api/hooks#equality-comparisons-and-updates Is this something we should do? And since we can't change the call signature since the 2nd arg is already given to dependencies, would this make sense?

```jsx
useStore(selector, deps)
useStore.shallow(selector, deps)
api.subscribe(selector, callback)
api.subscribe.shallow(selector, callback)
```

@JeremyRH ",,
455285423,32,SetState & GetState Typescript declaration in create function arguments,"The `create` function typescript definition has a generic parameter that helps to define the final state that will be used : `TState extends State`. This state has to extend `State` (`Record<string, any>`) which is relevant for  a state.

Unfortunately both `set` and `get` parameters types don't use this generic parameter and instead are bound to `State` as we can see :
```  createState: (set: SetState<State>, get: GetState<State>, api: any) => TState```

It is not very anoying for the `set` parameter, but it is really a pity that when one uses the `get` method, the definition does not simply type the return to `TState` instead of the very neutral `State`.

Is it just a mistake ? Or is there a reason not to have used `TState` in `set: SetState<State>` and `get: GetState<State>` ? (I must admit that I would expect `set: SetState<TState>` and `get: GetState<TState>` instead).

I've created a (trivial) pull request : https://github.com/react-spring/zustand/pull/31",,
451918600,28,Doesn't work on IE-10 and IE-11,"Would it be possible to support IE-10 and IE-11 by generating target files(via tsconfig) for IE-10,11 as well as modern browsers? 

Currently it gives syntax error in Internet Explorer.",,
449630379,23,"Feature request: api.subscribe(callback, /*selector*/)","We need a way to bind components to the store without causing updates (for rapid micro updates that would cause lots of render requests). See: https://twitter.com/0xca0a/status/1133329007800397824

In theory this can be done using subscribe, but it can't select state. My suggestion would be an optional second arg:

```jsx
const [, api] = create(set => ({
  a: 1,
  b: 2,
  set
}))
const unsub = api.subscribe(state => console.log(state), state => state.b)
api.getState().set(state => ({ ...state, b: 3 }))

// console would say: 3
```

Now components could receive transient updates and also disconnect on unmount via useEffect:

```jsx
function Person({ id }) {
  useEffect(() =>
    api.subscribe(state => /*do something*/, state => state.persons[id]),
    [id]
  )
```

@JeremyRH what's your opinion? And if you're fine with it, could you help getting this in? I'm still learning TS and i'm getting some typing issues, i had to set the internal listeners array to ""StateListener-any"" but it looked good so far:

```jsx
  const listeners: Set<StateListener<any>> = new Set()

  const setState = (partialState: PartialState<State>) => {
    state = Object.assign(
      {},
      state,
      typeof partialState === 'function' ? partialState(state) : partialState
    )
    listeners.forEach(listener => listener(state))
  }

  const getState = () => state

  function subscribe<U>(
    callback: StateListener<U>,
    selector?: StateSelector<State, U>
  ) {
    let listener = callback
    if (selector) {
      let stateSlice = selector(state)
      listener = () => {
        const selectedSlice = selector(state)
        if (!shallowEqual(stateSlice, (stateSlice = selectedSlice)))
          callback(stateSlice)
      }
    }
    listeners.add(listener)
    return () => void listeners.delete(listener)
  }
```",,
446613548,21,Improve Typescript support and only make the first generic type required.,"As soon as you start messing with the first generic, you are quickly hit by the second and third required generics. This could probably be improved by giving those default types.

Also exporting some of the types and an interface for the store api would be a nice addition. This way we can create functions that require the store api as a parameter for example.

I've already tried implementing some of these, but sadly broke the auto-generation of the `State` generic, so no auto-completion for `set` and `get` and so on, which probably isn't so nice for none typescript users.

https://github.com/Luxizzle/zustand/commit/b095e8cd63ea56854ae8cd61dc28faa604049ac8",,
439852663,17,Asynchronous SetState,"Hi 👋 

I was playing with immer and it looks like they have support for [asynchronous producers](https://github.com/immerjs/immer#async-producers).

Then I was looking at a way to have side effects in producers and update the draft accordingly to update zustand's store but `set` doesn't like Promises.
So, I was wondering if having `set` being able to resolve promises and update the state from the resolved value would be something interesting for zustand.

~I was able to make it work but I wonder if there were any drawbacks since I have to explicitely `get()` the state at the moment of producing the next state. Is it similar to how `set` receives the current state?~

EDIT: After a few tests I've noticed that calling `setState` multiple times one after the other, doesn't quite work since they are called synchronously so the `draft` being passed in to both is of the shape of what `get()` returns, as soon as the async producer resolves it doesn't have the previous state update so it overrides it completely. To solve this, we'd have to use the state `set` gets.

Reproduction: https://codesandbox.io/s/x3rnq036xp — You can see in the console that after the second update, the state has only 2 items instead of 3.

```diff
import produce from ""immer"";
import create from ""zustand"";

const fetchThing = () => Promise.resolve(""thing"");

const [, api] = create(set => {
-  const setState = fn => set(produce(fn));
+  const setState = async fn => {
+    set(await produce(get(), fn));
+  };
  return {
    things: [],
    addThing() {
+	  setState(draft => {
+        draft.things.push('first thing');
+      });
	  
+	  // This will override the entire ""things"" slice whenever it resolves.
      setState(async draft => {
        draft.things.push(await fetchThing());
      });
    }
  };
});

api.subscribe(console.log);
api.getState().addThing();
```

Thank you! I'm happy to contribute if people are interested in updating the behaviour of `set`.",,
435326276,15,Does not trigger rerender,"I intended to use zustand as singleton hook for history, as so:

```js
import { createBrowserHistory } from 'history'
import delegate from 'delegate-it'
import create from 'zustand'

// global-ish history tracker
export const [ useHistory ] = create(set => {
  let history = createBrowserHistory()

  const unlisten = history.listen((location, action) => {
    // NOTE: passing history object as-is does not trigger rerendering
    set(history)
  })

  let delegation = delegate('a', 'click', e => {
    e.preventDefault()
    history.push(e.delegateTarget.getAttribute('href'))
  });
  return history
})
```
The problem is that passing unchanged state object to `set` does not trigger rerendering, as noted in the commentary. For that purpose we have to create a clone as
```js
set({...history})
```
Is that planned behavior? That isn't what expected.
Thanks",,
433767321,10,Infinite recursion in selector,"Now these awesome storage hooks as side-effect solve the task of singleton-hook, like [hookleton](https://ghub.io/hookleton), so that makes them useful for eg. history/routing.

Would be super-cool also to incorporate ""use-effect""-purpose into the standard selector function as
```js
let [query, setQuery] = useState({ param1, param2 })
let { value, error, loading } = useZustandStore(state => ({
value: state.fetch(query),
...state
}, [...query])


// ... in zustand-store
fetch = async (query) => {
set({loading: true, error: null, success: null})
// ..await something
set({loading: false, success, error})
return success
}
```
Now that selector creates nasty recusion, making that method of querying data useless.
What would be the right solution here? That is not elegant to put fetching logic in a separate `useEffect(fetchingLogic, [...query])`.",,
431848632,3,Typescript definitions,"Hi! Love the library, really fits my workflow, thank you!
I wrote some basic type-defs to help along, maybe you'll find them useful:

```typescript
type ZustandCreate<T> = (set) => T;
type ZustandUse<T> = (store: T) => Partial<T>;
declare module ""zustand"" {
  function create<T>(fn: ZustandCreate<T>): ZustandUse<T>[];
  export = create;
}
```",,
